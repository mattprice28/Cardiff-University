/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Sat Oct 10 03:10:34 CEST 2015 ----! */


package jogamp.nativewindow.windows;

import java.nio.*;

import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import jogamp.common.os.MachineDataInfoRuntime;

import com.jogamp.nativewindow.util.Point;
import com.jogamp.nativewindow.NativeWindowException;
import jogamp.nativewindow.NWJNILibLoader;
import jogamp.nativewindow.Debug;

public class BITMAPINFO {

  StructAccessor accessor;

  private static final int mdIdx = MachineDataInfoRuntime.getStatic().ordinal();
  private final MachineDataInfo md;

  private static final int[] BITMAPINFO_size = new int[] { 44 /* ARM_MIPS_32 */, 44 /* X86_32_UNIX */, 44 /* X86_32_MACOS */, 44 /* PPC_32_UNIX */, 44 /* SPARC_32_SUNOS */, 44 /* X86_32_WINDOWS */, 44 /* LP64_UNIX */, 44 /* X86_64_WINDOWS */  };
  private static final int[] bmiHeader_offset = new int[] { 0 /* ARM_MIPS_32 */, 0 /* X86_32_UNIX */, 0 /* X86_32_MACOS */, 0 /* PPC_32_UNIX */, 0 /* SPARC_32_SUNOS */, 0 /* X86_32_WINDOWS */, 0 /* LP64_UNIX */, 0 /* X86_64_WINDOWS */ };
  private static final int[] bmiHeader_size = new int[] { 40 /* ARM_MIPS_32 */, 40 /* X86_32_UNIX */, 40 /* X86_32_MACOS */, 40 /* PPC_32_UNIX */, 40 /* SPARC_32_SUNOS */, 40 /* X86_32_WINDOWS */, 40 /* LP64_UNIX */, 40 /* X86_64_WINDOWS */  };
  private static final int[] bmiColors_offset = new int[] { 40 /* ARM_MIPS_32 */, 40 /* X86_32_UNIX */, 40 /* X86_32_MACOS */, 40 /* PPC_32_UNIX */, 40 /* SPARC_32_SUNOS */, 40 /* X86_32_WINDOWS */, 40 /* LP64_UNIX */, 40 /* X86_64_WINDOWS */ };
  private static final int[] bmiColors_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };

  public static int size() {
    return BITMAPINFO_size[mdIdx];
  }

  public static BITMAPINFO create() {
    return create(Buffers.newDirectByteBuffer(size()));
  }

  public static BITMAPINFO create(java.nio.ByteBuffer buf) {
      return new BITMAPINFO(buf);
  }

  BITMAPINFO(java.nio.ByteBuffer buf) {
    md = MachineDataInfo.StaticConfig.values()[mdIdx].md;
    accessor = new StructAccessor(buf);
  }

  public java.nio.ByteBuffer getBuffer() {
    return accessor.getBuffer();
  }

  /** Getter for native field <code>bmiHeader</code>: CType[(StructType) typedef 'BITMAPINFOHEADER', size [fixed false, lnx64 40], [const[false], struct{tagBITMAPINFOHEADER: 11, }]] */
  public BITMAPINFOHEADER getBmiHeader() {
    return BITMAPINFOHEADER.create( accessor.slice( bmiHeader_offset[mdIdx], bmiHeader_size[mdIdx] ) );
 }

  /** Setter for native field <code>bmiColors</code>: CType[(ArrayType) 'RGBQUAD *', size [fixed false, lnx64 4], [const[false], array*1]], with array length of <code>1</code> */
  public BITMAPINFO setBmiColors(RGBQUAD val) {
    final int elemSize = RGBQUAD.size();
    final ByteBuffer destB = getBuffer();
    if( elemSize > bmiColors_size[mdIdx] ) { throw new IndexOutOfBoundsException("elemSize "+elemSize+" > size "+bmiColors_size[mdIdx]); };
    int bOffset = bmiColors_offset[mdIdx];
    final int bLimes = bOffset + elemSize;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize); };
    final ByteBuffer sourceB = val.getBuffer();
    for(int f=0; f<elemSize; f++) {
      if( bOffset >= bLimes ) { throw new IndexOutOfBoundsException("elem-byte[0]["+f+"]: bOffset "+bOffset+" >= bLimes "+bLimes+", elemSize "+elemSize); };
      destB.put(bOffset++, sourceB.get(f));
    }
    return this;
  }

  /** Getter for native field <code>bmiColors</code>: CType[(ArrayType) 'RGBQUAD *', size [fixed false, lnx64 4], [const[false], array*1]], with array length of <code>1</code> */
  public RGBQUAD getBmiColors() {
    return RGBQUAD.create(accessor.slice(bmiColors_offset[mdIdx], RGBQUAD.size()));
  }
}
