/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:19:09 CEST 2015 ----! */

package jogamp.opengl.gl4;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.opengl.GLES1;
import com.jogamp.opengl.GLES2;
import com.jogamp.opengl.GL2ES1;
import com.jogamp.opengl.GL2ES2;
import com.jogamp.opengl.GL2ES3;
import com.jogamp.opengl.GL3ES3;
import com.jogamp.opengl.GL4ES3;
import com.jogamp.opengl.GL2GL3;
import com.jogamp.opengl.GL2;
import com.jogamp.opengl.GL3;
import com.jogamp.opengl.GL3bc;
import com.jogamp.opengl.GL4;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import java.io.PrintStream;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GL4bcImpl implements GLBase, GL, GL2ES1, GL2ES2, GL2ES3, GL3ES3, GL4ES3, GL2GL3, GL2, GL3, GL3bc, GL4, GL4bc{
  /** Entry point to C language function: <code> void {@native glClearIndex}(GLfloat c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glClearIndex(float c)  {

    final long __addr_ = _pat._addressof_glClearIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearIndex"));
    }
        dispatch_glClearIndex1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearIndex}(GLfloat c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearIndex1(float c, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColor"));
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClear(int mask)  {

    final long __addr_ = _pat._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClear"));
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexMask}(GLuint mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexMask(int mask)  {

    final long __addr_ = _pat._addressof_glIndexMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexMask"));
    }
        dispatch_glIndexMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexMask}(GLuint mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glIndexMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = _pat._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMask"));
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_QCOM_alpha_test</code><br>Alias for: <code>glAlphaFuncQCOM</code>   */
  public void glAlphaFunc(int func, float ref)  {

    final long __addr_ = _pat._addressof_glAlphaFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAlphaFunc"));
    }
        dispatch_glAlphaFunc1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_QCOM_alpha_test</code><br>Alias for: <code>glAlphaFuncQCOM</code>   */
  private native void dispatch_glAlphaFunc1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = _pat._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunc"));
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLogicOp(int opcode)  {

    final long __addr_ = _pat._addressof_glLogicOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLogicOp"));
    }
        dispatch_glLogicOp1(opcode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLogicOp1(int opcode, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glCullFace(int mode)  {

    final long __addr_ = _pat._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullFace"));
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = _pat._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrontFace"));
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPointSize(float size)  {

    final long __addr_ = _pat._addressof_glPointSize;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointSize"));
    }
        dispatch_glPointSize1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPointSize1(float size, long procAddress);

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLineWidth(float width)  {

    final long __addr_ = _pat._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineWidth"));
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLineStipple}(GLint factor, GLushort pattern) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLineStipple(int factor, short pattern)  {

    final long __addr_ = _pat._addressof_glLineStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineStipple"));
    }
        dispatch_glLineStipple1(factor, pattern, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineStipple}(GLint factor, GLushort pattern) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLineStipple1(int factor, short pattern, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonMode}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_NV_polygon_mode</code><br>Alias for: <code>glPolygonModeNV</code>   */
  public void glPolygonMode(int face, int mode)  {

    final long __addr_ = _pat._addressof_glPolygonMode;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonMode"));
    }
        dispatch_glPolygonMode1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonMode}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_NV_polygon_mode</code><br>Alias for: <code>glPolygonModeNV</code>   */
  private native void dispatch_glPolygonMode1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = _pat._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffset"));
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  private native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPolygonStipple(ByteBuffer mask)  {

    checkUnpackPBOUnbound(true);
    final boolean mask_is_direct = Buffers.isDirect(mask);
    final long __addr_ = _pat._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
    }
        dispatch_glPolygonStipple1(mask_is_direct ? mask : Buffers.getArray(mask), mask_is_direct ? Buffers.getDirectBufferByteOffset(mask) : Buffers.getIndirectBufferByteOffset(mask), mask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPolygonStipple1(Object mask, int mask_byte_offset, boolean mask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPolygonStipple(byte[] mask, int mask_offset)  {

    checkUnpackPBOUnbound(true);
    if(mask != null && mask.length <= mask_offset)
      throw new GLException("array offset argument \"mask_offset\" (" + mask_offset + ") equals or exceeds array length (" + mask.length + ")");
    final long __addr_ = _pat._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
    }
        dispatch_glPolygonStipple1(mask, mask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPolygonStipple(long mask_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonStipple"));
    }
        dispatch_glPolygonStipple1(mask_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonStipple}(const GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPolygonStipple1(long mask_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPolygonStipple(ByteBuffer mask)  {

    checkPackPBOUnbound(true);
    final boolean mask_is_direct = Buffers.isDirect(mask);
    final long __addr_ = _pat._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
    }
        dispatch_glGetPolygonStipple1(mask_is_direct ? mask : Buffers.getArray(mask), mask_is_direct ? Buffers.getDirectBufferByteOffset(mask) : Buffers.getIndirectBufferByteOffset(mask), mask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param mask a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPolygonStipple1(Object mask, int mask_byte_offset, boolean mask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPolygonStipple(byte[] mask, int mask_offset)  {

    checkPackPBOUnbound(true);
    if(mask != null && mask.length <= mask_offset)
      throw new GLException("array offset argument \"mask_offset\" (" + mask_offset + ") equals or exceeds array length (" + mask.length + ")");
    final long __addr_ = _pat._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
    }
        dispatch_glGetPolygonStipple1(mask, mask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPolygonStipple(long mask_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPolygonStipple"));
    }
        dispatch_glGetPolygonStipple1(mask_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPolygonStipple}(GLubyte *  mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glGetPolygonStipple1(long mask_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlag}(GLboolean flag) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEdgeFlag(boolean flag)  {

    final long __addr_ = _pat._addressof_glEdgeFlag;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlag"));
    }
        dispatch_glEdgeFlag1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlag}(GLboolean flag) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEdgeFlag1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param flag a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glEdgeFlagv(ByteBuffer flag)  {

    final boolean flag_is_direct = Buffers.isDirect(flag);
    final long __addr_ = _pat._addressof_glEdgeFlagv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagv"));
    }
        dispatch_glEdgeFlagv1(flag_is_direct ? flag : Buffers.getArray(flag), flag_is_direct ? Buffers.getDirectBufferByteOffset(flag) : Buffers.getIndirectBufferByteOffset(flag), flag_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param flag a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glEdgeFlagv1(Object flag, int flag_byte_offset, boolean flag_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagv}(const GLboolean *  flag) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEdgeFlagv(byte[] flag, int flag_offset)  {

    if(flag != null && flag.length <= flag_offset)
      throw new GLException("array offset argument \"flag_offset\" (" + flag_offset + ") equals or exceeds array length (" + flag.length + ")");
    final long __addr_ = _pat._addressof_glEdgeFlagv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagv"));
    }
        dispatch_glEdgeFlagv1(flag, flag_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissor"));
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glClipPlane(int plane, DoubleBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glClipPlane;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlane"));
    }
        dispatch_glClipPlane1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glClipPlane1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlane}(GLenum plane, const GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glClipPlane(int plane, double[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glClipPlane;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlane"));
    }
        dispatch_glClipPlane1(plane, equation, Buffers.SIZEOF_DOUBLE * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetClipPlane(int plane, DoubleBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glGetClipPlane;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlane"));
    }
        dispatch_glGetClipPlane1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param equation a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetClipPlane1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlane}(GLenum plane, GLdouble *  equation) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetClipPlane(int plane, double[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glGetClipPlane;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlane"));
    }
        dispatch_glGetClipPlane1(plane, equation, Buffers.SIZEOF_DOUBLE * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffer}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glDrawBuffer(int mode)  {

    final long __addr_ = _pat._addressof_glDrawBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffer"));
    }
        dispatch_glDrawBuffer1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffer}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDrawBuffer1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_read_buffer</code><br>Alias for: <code>glReadBufferNV</code>   */
  public void glReadBuffer(int mode)  {

    final long __addr_ = _pat._addressof_glReadBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBuffer"));
    }
        dispatch_glReadBuffer1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_read_buffer</code><br>Alias for: <code>glReadBufferNV</code>   */
  private native void dispatch_glReadBuffer1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glEnable(int cap)  {

    final long __addr_ = _pat._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnable"));
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDisable(int cap)  {

    final long __addr_ = _pat._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisable"));
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = _pat._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabled"));
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoublev(int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetDoublev;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublev"));
    }
        dispatch_glGetDoublev1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoublev1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoublev}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetDoublev(int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetDoublev;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublev"));
    }
        dispatch_glGetDoublev1(pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushAttrib}(GLbitfield mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPushAttrib(int mask)  {

    final long __addr_ = _pat._addressof_glPushAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushAttrib"));
    }
        dispatch_glPushAttrib1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushAttrib}(GLbitfield mask) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPushAttrib1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopAttrib}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPopAttrib()  {

    final long __addr_ = _pat._addressof_glPopAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopAttrib"));
    }
        dispatch_glPopAttrib1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopAttrib}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPopAttrib1(long procAddress);

  /** Entry point to C language function: <code> GLint {@native glRenderMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public int glRenderMode(int mode)  {

    final long __addr_ = _pat._addressof_glRenderMode;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderMode"));
    }
        return dispatch_glRenderMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glRenderMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native int dispatch_glRenderMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public int glGetError()  {

    final long __addr_ = _pat._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetError"));
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = _pat._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetString"));
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFinish()  {

    final long __addr_ = _pat._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinish"));
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFlush()  {

    final long __addr_ = _pat._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlush"));
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = _pat._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHint"));
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  private native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepth}(GLclampd depth) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glClearDepth(double depth)  {

    final long __addr_ = _pat._addressof_glClearDepth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepth"));
    }
        dispatch_glClearDepth1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepth}(GLclampd depth) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearDepth1(double depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = _pat._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthFunc"));
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = _pat._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthMask"));
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRange}(GLclampd zNear, GLclampd zFar) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glDepthRange(double zNear, double zFar)  {

    final long __addr_ = _pat._addressof_glDepthRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRange"));
    }
        dispatch_glDepthRange1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRange}(GLclampd zNear, GLclampd zFar) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthRange1(double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearAccum}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glClearAccum(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glClearAccum;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearAccum"));
    }
        dispatch_glClearAccum1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearAccum}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearAccum1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glAccum}(GLenum op, GLfloat value) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glAccum(int op, float value)  {

    final long __addr_ = _pat._addressof_glAccum;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAccum"));
    }
        dispatch_glAccum1(op, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAccum}(GLenum op, GLfloat value) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glAccum1(int op, float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMatrixMode(int mode)  {

    final long __addr_ = _pat._addressof_glMatrixMode;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMode"));
    }
        dispatch_glMatrixMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMatrixMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrtho}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val)  {

    final long __addr_ = _pat._addressof_glOrtho;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glOrtho"));
    }
        dispatch_glOrtho1(left, right, bottom, top, near_val, far_val, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrtho}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glOrtho1(double left, double right, double bottom, double top, double near_val, double far_val, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrustum}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glFrustum(double left, double right, double bottom, double top, double near_val, double far_val)  {

    final long __addr_ = _pat._addressof_glFrustum;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrustum"));
    }
        dispatch_glFrustum1(left, right, bottom, top, near_val, far_val, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustum}(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFrustum1(double left, double right, double bottom, double top, double near_val, double far_val, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewport"));
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPushMatrix()  {

    final long __addr_ = _pat._addressof_glPushMatrix;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushMatrix"));
    }
        dispatch_glPushMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPushMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPopMatrix()  {

    final long __addr_ = _pat._addressof_glPopMatrix;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopMatrix"));
    }
        dispatch_glPopMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPopMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLoadIdentity()  {

    final long __addr_ = _pat._addressof_glLoadIdentity;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadIdentity"));
    }
        dispatch_glLoadIdentity1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLoadIdentity1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glLoadMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixd"));
    }
        dispatch_glLoadMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glLoadMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLoadMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixd"));
    }
        dispatch_glLoadMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
    }
        dispatch_glLoadMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLoadMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
    }
        dispatch_glLoadMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixd"));
    }
        dispatch_glMultMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMultMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixd"));
    }
        dispatch_glMultMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
    }
        dispatch_glMultMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMultMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
    }
        dispatch_glMultMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotated}(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRotated(double angle, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glRotated;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRotated"));
    }
        dispatch_glRotated1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotated}(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRotated1(double angle, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glRotatef(float angle, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glRotatef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRotatef"));
    }
        dispatch_glRotatef1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRotatef1(float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScaled}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glScaled(double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glScaled;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScaled"));
    }
        dispatch_glScaled1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScaled}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScaled1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glScalef(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glScalef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScalef"));
    }
        dispatch_glScalef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScalef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslated}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTranslated(double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glTranslated;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTranslated"));
    }
        dispatch_glTranslated1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslated}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTranslated1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTranslatef(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glTranslatef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTranslatef"));
    }
        dispatch_glTranslatef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTranslatef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsList}(GLuint list) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public boolean glIsList(int list)  {

    final long __addr_ = _pat._addressof_glIsList;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsList"));
    }
        return dispatch_glIsList1(list, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsList}(GLuint list) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native boolean dispatch_glIsList1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteLists}(GLuint list, GLsizei range) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glDeleteLists(int list, int range)  {

    final long __addr_ = _pat._addressof_glDeleteLists;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteLists"));
    }
        dispatch_glDeleteLists1(list, range, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteLists}(GLuint list, GLsizei range) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDeleteLists1(int list, int range, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGenLists}(GLsizei range) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public int glGenLists(int range)  {

    final long __addr_ = _pat._addressof_glGenLists;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenLists"));
    }
        return dispatch_glGenLists1(range, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenLists}(GLsizei range) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native int dispatch_glGenLists1(int range, long procAddress);

  /** Entry point to C language function: <code> void {@native glNewList}(GLuint list, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNewList(int list, int mode)  {

    final long __addr_ = _pat._addressof_glNewList;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNewList"));
    }
        dispatch_glNewList1(list, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNewList}(GLuint list, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNewList1(int list, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndList}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEndList()  {

    final long __addr_ = _pat._addressof_glEndList;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndList"));
    }
        dispatch_glEndList1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndList}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEndList1(long procAddress);

  /** Entry point to C language function: <code> void {@native glCallList}(GLuint list) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glCallList(int list)  {

    final long __addr_ = _pat._addressof_glCallList;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCallList"));
    }
        dispatch_glCallList1(list, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCallList}(GLuint list) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glCallList1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glCallLists}(GLsizei n, GLenum type, const GLvoid *  lists) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param lists a direct or array-backed {@link java.nio.Buffer}   */
  public void glCallLists(int n, int type, Buffer lists)  {

    final boolean lists_is_direct = Buffers.isDirect(lists);
    final long __addr_ = _pat._addressof_glCallLists;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCallLists"));
    }
        dispatch_glCallLists1(n, type, lists_is_direct ? lists : Buffers.getArray(lists), lists_is_direct ? Buffers.getDirectBufferByteOffset(lists) : Buffers.getIndirectBufferByteOffset(lists), lists_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCallLists}(GLsizei n, GLenum type, const GLvoid *  lists) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param lists a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCallLists1(int n, int type, Object lists, int lists_byte_offset, boolean lists_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glListBase}(GLuint base) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glListBase(int base)  {

    final long __addr_ = _pat._addressof_glListBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glListBase"));
    }
        dispatch_glListBase1(base, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glListBase}(GLuint base) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glListBase1(int base, long procAddress);

  /** Entry point to C language function: <code> void {@native glBegin}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glBegin(int mode)  {

    inBeginEndPair = true;
    final long __addr_ = _pat._addressof_glBegin;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBegin"));
    }
        dispatch_glBegin1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBegin}(GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glBegin1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnd}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEnd()  {

    final long __addr_ = _pat._addressof_glEnd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnd"));
    }
        dispatch_glEnd1(__addr_);
    inBeginEndPair = false;
  }

  /** Entry point to C language function: <code> void {@native glEnd}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEnd1(long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2d(double x, double y)  {

    final long __addr_ = _pat._addressof_glVertex2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2d"));
    }
        dispatch_glVertex2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2f(float x, float y)  {

    final long __addr_ = _pat._addressof_glVertex2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2f"));
    }
        dispatch_glVertex2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2i(int x, int y)  {

    final long __addr_ = _pat._addressof_glVertex2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2i"));
    }
        dispatch_glVertex2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2s(short x, short y)  {

    final long __addr_ = _pat._addressof_glVertex2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2s"));
    }
        dispatch_glVertex2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3d(double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glVertex3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3d"));
    }
        dispatch_glVertex3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3f(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glVertex3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3f"));
    }
        dispatch_glVertex3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3i(int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glVertex3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3i"));
    }
        dispatch_glVertex3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3s(short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glVertex3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3s"));
    }
        dispatch_glVertex3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4d(double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glVertex4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4d"));
    }
        dispatch_glVertex4d1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex4d1(double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4f(float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glVertex4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4f"));
    }
        dispatch_glVertex4f1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex4f1(float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4i}(GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4i(int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertex4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4i"));
    }
        dispatch_glVertex4i1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4i}(GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex4i1(int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4s}(GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4s(short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glVertex4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4s"));
    }
        dispatch_glVertex4s1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4s}(GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glVertex4s1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2dv"));
    }
        dispatch_glVertex2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2dv"));
    }
        dispatch_glVertex2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2fv"));
    }
        dispatch_glVertex2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2fv"));
    }
        dispatch_glVertex2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2iv"));
    }
        dispatch_glVertex2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2iv"));
    }
        dispatch_glVertex2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2sv"));
    }
        dispatch_glVertex2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2sv"));
    }
        dispatch_glVertex2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3dv"));
    }
        dispatch_glVertex3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3dv"));
    }
        dispatch_glVertex3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3fv"));
    }
        dispatch_glVertex3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3fv"));
    }
        dispatch_glVertex3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3iv"));
    }
        dispatch_glVertex3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3iv"));
    }
        dispatch_glVertex3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3sv"));
    }
        dispatch_glVertex3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3sv"));
    }
        dispatch_glVertex3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertex4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4dv"));
    }
        dispatch_glVertex4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertex4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4dv"));
    }
        dispatch_glVertex4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertex4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4fv"));
    }
        dispatch_glVertex4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertex4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4fv"));
    }
        dispatch_glVertex4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertex4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4iv"));
    }
        dispatch_glVertex4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertex4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4iv"));
    }
        dispatch_glVertex4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4sv"));
    }
        dispatch_glVertex4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glVertex4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4sv"));
    }
        dispatch_glVertex4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3b}(GLbyte nx, GLbyte ny, GLbyte nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3b(byte nx, byte ny, byte nz)  {

    final long __addr_ = _pat._addressof_glNormal3b;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3b"));
    }
        dispatch_glNormal3b1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3b}(GLbyte nx, GLbyte ny, GLbyte nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3b1(byte nx, byte ny, byte nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3d}(GLdouble nx, GLdouble ny, GLdouble nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3d(double nx, double ny, double nz)  {

    final long __addr_ = _pat._addressof_glNormal3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3d"));
    }
        dispatch_glNormal3d1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3d}(GLdouble nx, GLdouble ny, GLdouble nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3d1(double nx, double ny, double nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3f(float nx, float ny, float nz)  {

    final long __addr_ = _pat._addressof_glNormal3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3f"));
    }
        dispatch_glNormal3f1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3f1(float nx, float ny, float nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3i}(GLint nx, GLint ny, GLint nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3i(int nx, int ny, int nz)  {

    final long __addr_ = _pat._addressof_glNormal3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3i"));
    }
        dispatch_glNormal3i1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3i}(GLint nx, GLint ny, GLint nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3i1(int nx, int ny, int nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3s}(GLshort nx, GLshort ny, GLshort nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3s(short nx, short ny, short nz)  {

    final long __addr_ = _pat._addressof_glNormal3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3s"));
    }
        dispatch_glNormal3s1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3s}(GLshort nx, GLshort ny, GLshort nz) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3s1(short nx, short ny, short nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glNormal3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3bv"));
    }
        dispatch_glNormal3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glNormal3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3bv"));
    }
        dispatch_glNormal3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glNormal3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3dv"));
    }
        dispatch_glNormal3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glNormal3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3dv"));
    }
        dispatch_glNormal3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNormal3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3fv"));
    }
        dispatch_glNormal3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNormal3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3fv"));
    }
        dispatch_glNormal3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNormal3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3iv"));
    }
        dispatch_glNormal3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNormal3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3iv"));
    }
        dispatch_glNormal3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glNormal3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3sv"));
    }
        dispatch_glNormal3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glNormal3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3sv"));
    }
        dispatch_glNormal3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexd}(GLdouble c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexd(double c)  {

    final long __addr_ = _pat._addressof_glIndexd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexd"));
    }
        dispatch_glIndexd1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexd}(GLdouble c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glIndexd1(double c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexf}(GLfloat c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexf(float c)  {

    final long __addr_ = _pat._addressof_glIndexf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexf"));
    }
        dispatch_glIndexf1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexf}(GLfloat c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glIndexf1(float c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexi}(GLint c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexi(int c)  {

    final long __addr_ = _pat._addressof_glIndexi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexi"));
    }
        dispatch_glIndexi1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexi}(GLint c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glIndexi1(int c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexs}(GLshort c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexs(short c)  {

    final long __addr_ = _pat._addressof_glIndexs;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexs"));
    }
        dispatch_glIndexs1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexs}(GLshort c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glIndexs1(short c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glIndexdv(DoubleBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = _pat._addressof_glIndexdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexdv"));
    }
        dispatch_glIndexdv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glIndexdv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexdv}(const GLdouble *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexdv(double[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = _pat._addressof_glIndexdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexdv"));
    }
        dispatch_glIndexdv1(c, Buffers.SIZEOF_DOUBLE * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glIndexfv(FloatBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = _pat._addressof_glIndexfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexfv"));
    }
        dispatch_glIndexfv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glIndexfv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexfv}(const GLfloat *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexfv(float[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = _pat._addressof_glIndexfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexfv"));
    }
        dispatch_glIndexfv1(c, Buffers.SIZEOF_FLOAT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glIndexiv(IntBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = _pat._addressof_glIndexiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexiv"));
    }
        dispatch_glIndexiv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glIndexiv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexiv}(const GLint *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexiv(int[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = _pat._addressof_glIndexiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexiv"));
    }
        dispatch_glIndexiv1(c, Buffers.SIZEOF_INT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glIndexsv(ShortBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = _pat._addressof_glIndexsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexsv"));
    }
        dispatch_glIndexsv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param c a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glIndexsv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexsv}(const GLshort *  c) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glIndexsv(short[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = _pat._addressof_glIndexsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexsv"));
    }
        dispatch_glIndexsv1(c, Buffers.SIZEOF_SHORT * c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3b}(GLbyte red, GLbyte green, GLbyte blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3b(byte red, byte green, byte blue)  {

    final long __addr_ = _pat._addressof_glColor3b;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3b"));
    }
        dispatch_glColor3b1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3b}(GLbyte red, GLbyte green, GLbyte blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3b1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3d}(GLdouble red, GLdouble green, GLdouble blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3d(double red, double green, double blue)  {

    final long __addr_ = _pat._addressof_glColor3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3d"));
    }
        dispatch_glColor3d1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3d}(GLdouble red, GLdouble green, GLdouble blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3d1(double red, double green, double blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3f}(GLfloat red, GLfloat green, GLfloat blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3f(float red, float green, float blue)  {

    final long __addr_ = _pat._addressof_glColor3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3f"));
    }
        dispatch_glColor3f1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3f}(GLfloat red, GLfloat green, GLfloat blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3f1(float red, float green, float blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3i}(GLint red, GLint green, GLint blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3i(int red, int green, int blue)  {

    final long __addr_ = _pat._addressof_glColor3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3i"));
    }
        dispatch_glColor3i1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3i}(GLint red, GLint green, GLint blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3i1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3s}(GLshort red, GLshort green, GLshort blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3s(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glColor3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3s"));
    }
        dispatch_glColor3s1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3s}(GLshort red, GLshort green, GLshort blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3s1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3ub}(GLubyte red, GLubyte green, GLubyte blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3ub(byte red, byte green, byte blue)  {

    final long __addr_ = _pat._addressof_glColor3ub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3ub"));
    }
        dispatch_glColor3ub1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ub}(GLubyte red, GLubyte green, GLubyte blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3ub1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3ui}(GLuint red, GLuint green, GLuint blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3ui(int red, int green, int blue)  {

    final long __addr_ = _pat._addressof_glColor3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3ui"));
    }
        dispatch_glColor3ui1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ui}(GLuint red, GLuint green, GLuint blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3ui1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3us}(GLushort red, GLushort green, GLushort blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3us(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glColor3us;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3us"));
    }
        dispatch_glColor3us1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3us}(GLushort red, GLushort green, GLushort blue) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor3us1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4b}(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4b(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = _pat._addressof_glColor4b;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4b"));
    }
        dispatch_glColor4b1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4b}(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4b1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4d}(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4d(double red, double green, double blue, double alpha)  {

    final long __addr_ = _pat._addressof_glColor4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4d"));
    }
        dispatch_glColor4d1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4d}(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4d1(double red, double green, double blue, double alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColor4f(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glColor4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4f"));
    }
        dispatch_glColor4f1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4f1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4i}(GLint red, GLint green, GLint blue, GLint alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4i(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glColor4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4i"));
    }
        dispatch_glColor4i1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4i}(GLint red, GLint green, GLint blue, GLint alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4i1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4s}(GLshort red, GLshort green, GLshort blue, GLshort alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4s(short red, short green, short blue, short alpha)  {

    final long __addr_ = _pat._addressof_glColor4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4s"));
    }
        dispatch_glColor4s1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4s}(GLshort red, GLshort green, GLshort blue, GLshort alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4s1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColor4ub(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = _pat._addressof_glColor4ub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4ub"));
    }
        dispatch_glColor4ub1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4ub1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ui}(GLuint red, GLuint green, GLuint blue, GLuint alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4ui(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glColor4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4ui"));
    }
        dispatch_glColor4ui1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ui}(GLuint red, GLuint green, GLuint blue, GLuint alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4ui1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4us}(GLushort red, GLushort green, GLushort blue, GLushort alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4us(short red, short green, short blue, short alpha)  {

    final long __addr_ = _pat._addressof_glColor4us;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4us"));
    }
        dispatch_glColor4us1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4us}(GLushort red, GLushort green, GLushort blue, GLushort alpha) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4us1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3bv"));
    }
        dispatch_glColor3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3bv"));
    }
        dispatch_glColor3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glColor3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3dv"));
    }
        dispatch_glColor3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glColor3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3dv"));
    }
        dispatch_glColor3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColor3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3fv"));
    }
        dispatch_glColor3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColor3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3fv"));
    }
        dispatch_glColor3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3iv"));
    }
        dispatch_glColor3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3iv"));
    }
        dispatch_glColor3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3sv"));
    }
        dispatch_glColor3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3sv"));
    }
        dispatch_glColor3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor3ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3ubv"));
    }
        dispatch_glColor3ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor3ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3ubv"));
    }
        dispatch_glColor3ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor3uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3uiv"));
    }
        dispatch_glColor3uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor3uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3uiv"));
    }
        dispatch_glColor3uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3usv"));
    }
        dispatch_glColor3usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor3usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3usv"));
    }
        dispatch_glColor3usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor4bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4bv"));
    }
        dispatch_glColor4bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor4bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4bv"));
    }
        dispatch_glColor4bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glColor4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4dv"));
    }
        dispatch_glColor4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glColor4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4dv"));
    }
        dispatch_glColor4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColor4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4fv"));
    }
        dispatch_glColor4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColor4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4fv"));
    }
        dispatch_glColor4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4iv"));
    }
        dispatch_glColor4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4iv"));
    }
        dispatch_glColor4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4sv"));
    }
        dispatch_glColor4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4sv"));
    }
        dispatch_glColor4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glColor4ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4ubv"));
    }
        dispatch_glColor4ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glColor4ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4ubv"));
    }
        dispatch_glColor4ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColor4uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4uiv"));
    }
        dispatch_glColor4uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColor4uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4uiv"));
    }
        dispatch_glColor4uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4usv"));
    }
        dispatch_glColor4usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColor4usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4usv"));
    }
        dispatch_glColor4usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1d}(GLdouble s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1d(double s)  {

    final long __addr_ = _pat._addressof_glTexCoord1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1d"));
    }
        dispatch_glTexCoord1d1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1d}(GLdouble s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord1d1(double s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1f}(GLfloat s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1f(float s)  {

    final long __addr_ = _pat._addressof_glTexCoord1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1f"));
    }
        dispatch_glTexCoord1f1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1f}(GLfloat s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord1f1(float s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1i}(GLint s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1i(int s)  {

    final long __addr_ = _pat._addressof_glTexCoord1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1i"));
    }
        dispatch_glTexCoord1i1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1i}(GLint s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord1i1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1s}(GLshort s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1s(short s)  {

    final long __addr_ = _pat._addressof_glTexCoord1s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1s"));
    }
        dispatch_glTexCoord1s1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1s}(GLshort s) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord1s1(short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2d}(GLdouble s, GLdouble t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2d(double s, double t)  {

    final long __addr_ = _pat._addressof_glTexCoord2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2d"));
    }
        dispatch_glTexCoord2d1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2d}(GLdouble s, GLdouble t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord2d1(double s, double t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2f}(GLfloat s, GLfloat t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2f(float s, float t)  {

    final long __addr_ = _pat._addressof_glTexCoord2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2f"));
    }
        dispatch_glTexCoord2f1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2f}(GLfloat s, GLfloat t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord2f1(float s, float t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2i}(GLint s, GLint t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2i(int s, int t)  {

    final long __addr_ = _pat._addressof_glTexCoord2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2i"));
    }
        dispatch_glTexCoord2i1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2i}(GLint s, GLint t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord2i1(int s, int t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2s}(GLshort s, GLshort t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2s(short s, short t)  {

    final long __addr_ = _pat._addressof_glTexCoord2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2s"));
    }
        dispatch_glTexCoord2s1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2s}(GLshort s, GLshort t) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord2s1(short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3d}(GLdouble s, GLdouble t, GLdouble r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3d(double s, double t, double r)  {

    final long __addr_ = _pat._addressof_glTexCoord3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3d"));
    }
        dispatch_glTexCoord3d1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3d}(GLdouble s, GLdouble t, GLdouble r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord3d1(double s, double t, double r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3f}(GLfloat s, GLfloat t, GLfloat r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3f(float s, float t, float r)  {

    final long __addr_ = _pat._addressof_glTexCoord3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3f"));
    }
        dispatch_glTexCoord3f1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3f}(GLfloat s, GLfloat t, GLfloat r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord3f1(float s, float t, float r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3i}(GLint s, GLint t, GLint r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3i(int s, int t, int r)  {

    final long __addr_ = _pat._addressof_glTexCoord3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3i"));
    }
        dispatch_glTexCoord3i1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3i}(GLint s, GLint t, GLint r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord3i1(int s, int t, int r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3s}(GLshort s, GLshort t, GLshort r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3s(short s, short t, short r)  {

    final long __addr_ = _pat._addressof_glTexCoord3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3s"));
    }
        dispatch_glTexCoord3s1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3s}(GLshort s, GLshort t, GLshort r) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord3s1(short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4d}(GLdouble s, GLdouble t, GLdouble r, GLdouble q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4d(double s, double t, double r, double q)  {

    final long __addr_ = _pat._addressof_glTexCoord4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4d"));
    }
        dispatch_glTexCoord4d1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4d}(GLdouble s, GLdouble t, GLdouble r, GLdouble q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord4d1(double s, double t, double r, double q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4f}(GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4f(float s, float t, float r, float q)  {

    final long __addr_ = _pat._addressof_glTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4f"));
    }
        dispatch_glTexCoord4f1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4f}(GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord4f1(float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4i}(GLint s, GLint t, GLint r, GLint q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4i(int s, int t, int r, int q)  {

    final long __addr_ = _pat._addressof_glTexCoord4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4i"));
    }
        dispatch_glTexCoord4i1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4i}(GLint s, GLint t, GLint r, GLint q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord4i1(int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4s}(GLshort s, GLshort t, GLshort r, GLshort q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4s(short s, short t, short r, short q)  {

    final long __addr_ = _pat._addressof_glTexCoord4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4s"));
    }
        dispatch_glTexCoord4s1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4s}(GLshort s, GLshort t, GLshort r, GLshort q) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexCoord4s1(short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord1dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1dv"));
    }
        dispatch_glTexCoord1dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord1dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1dv"));
    }
        dispatch_glTexCoord1dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord1fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1fv"));
    }
        dispatch_glTexCoord1fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord1fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1fv"));
    }
        dispatch_glTexCoord1fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord1iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1iv"));
    }
        dispatch_glTexCoord1iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord1iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1iv"));
    }
        dispatch_glTexCoord1iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord1sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1sv"));
    }
        dispatch_glTexCoord1sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord1sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord1sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1sv"));
    }
        dispatch_glTexCoord1sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2dv"));
    }
        dispatch_glTexCoord2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2dv"));
    }
        dispatch_glTexCoord2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2fv"));
    }
        dispatch_glTexCoord2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2fv"));
    }
        dispatch_glTexCoord2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2iv"));
    }
        dispatch_glTexCoord2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2iv"));
    }
        dispatch_glTexCoord2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2sv"));
    }
        dispatch_glTexCoord2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2sv"));
    }
        dispatch_glTexCoord2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3dv"));
    }
        dispatch_glTexCoord3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3dv"));
    }
        dispatch_glTexCoord3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3fv"));
    }
        dispatch_glTexCoord3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3fv"));
    }
        dispatch_glTexCoord3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3iv"));
    }
        dispatch_glTexCoord3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3iv"));
    }
        dispatch_glTexCoord3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3sv"));
    }
        dispatch_glTexCoord3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3sv"));
    }
        dispatch_glTexCoord3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexCoord4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4dv"));
    }
        dispatch_glTexCoord4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexCoord4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4dv"));
    }
        dispatch_glTexCoord4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexCoord4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4fv"));
    }
        dispatch_glTexCoord4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexCoord4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4fv"));
    }
        dispatch_glTexCoord4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoord4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4iv"));
    }
        dispatch_glTexCoord4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoord4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4iv"));
    }
        dispatch_glTexCoord4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4sv"));
    }
        dispatch_glTexCoord4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexCoord4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4sv"));
    }
        dispatch_glTexCoord4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2d(double x, double y)  {

    final long __addr_ = _pat._addressof_glRasterPos2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2d"));
    }
        dispatch_glRasterPos2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2f(float x, float y)  {

    final long __addr_ = _pat._addressof_glRasterPos2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2f"));
    }
        dispatch_glRasterPos2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2i(int x, int y)  {

    final long __addr_ = _pat._addressof_glRasterPos2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2i"));
    }
        dispatch_glRasterPos2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2s(short x, short y)  {

    final long __addr_ = _pat._addressof_glRasterPos2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2s"));
    }
        dispatch_glRasterPos2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3d(double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glRasterPos3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3d"));
    }
        dispatch_glRasterPos3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3f(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glRasterPos3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3f"));
    }
        dispatch_glRasterPos3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3i(int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glRasterPos3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3i"));
    }
        dispatch_glRasterPos3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3s(short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glRasterPos3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3s"));
    }
        dispatch_glRasterPos3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4d(double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glRasterPos4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4d"));
    }
        dispatch_glRasterPos4d1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4d}(GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos4d1(double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4f(float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glRasterPos4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4f"));
    }
        dispatch_glRasterPos4f1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4f}(GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos4f1(float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4i}(GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4i(int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glRasterPos4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4i"));
    }
        dispatch_glRasterPos4i1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4i}(GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos4i1(int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4s}(GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4s(short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glRasterPos4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4s"));
    }
        dispatch_glRasterPos4s1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4s}(GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRasterPos4s1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2dv"));
    }
        dispatch_glRasterPos2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2dv"));
    }
        dispatch_glRasterPos2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2fv"));
    }
        dispatch_glRasterPos2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2fv"));
    }
        dispatch_glRasterPos2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2iv"));
    }
        dispatch_glRasterPos2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2iv"));
    }
        dispatch_glRasterPos2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2sv"));
    }
        dispatch_glRasterPos2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos2sv"));
    }
        dispatch_glRasterPos2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3dv"));
    }
        dispatch_glRasterPos3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3dv"));
    }
        dispatch_glRasterPos3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3fv"));
    }
        dispatch_glRasterPos3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3fv"));
    }
        dispatch_glRasterPos3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3iv"));
    }
        dispatch_glRasterPos3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3iv"));
    }
        dispatch_glRasterPos3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3sv"));
    }
        dispatch_glRasterPos3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos3sv"));
    }
        dispatch_glRasterPos3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRasterPos4dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4dv"));
    }
        dispatch_glRasterPos4dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRasterPos4dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4dv"));
    }
        dispatch_glRasterPos4dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRasterPos4fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4fv"));
    }
        dispatch_glRasterPos4fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRasterPos4fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4fv"));
    }
        dispatch_glRasterPos4fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRasterPos4iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4iv"));
    }
        dispatch_glRasterPos4iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRasterPos4iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4iv"));
    }
        dispatch_glRasterPos4iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRasterPos4sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glRasterPos4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4sv"));
    }
        dispatch_glRasterPos4sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRasterPos4sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterPos4sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRasterPos4sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glRasterPos4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterPos4sv"));
    }
        dispatch_glRasterPos4sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectd}(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectd(double x1, double y1, double x2, double y2)  {

    final long __addr_ = _pat._addressof_glRectd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectd"));
    }
        dispatch_glRectd1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectd}(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRectd1(double x1, double y1, double x2, double y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectf}(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectf(float x1, float y1, float x2, float y2)  {

    final long __addr_ = _pat._addressof_glRectf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectf"));
    }
        dispatch_glRectf1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectf}(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRectf1(float x1, float y1, float x2, float y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRecti}(GLint x1, GLint y1, GLint x2, GLint y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRecti(int x1, int y1, int x2, int y2)  {

    final long __addr_ = _pat._addressof_glRecti;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRecti"));
    }
        dispatch_glRecti1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRecti}(GLint x1, GLint y1, GLint x2, GLint y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRecti1(int x1, int y1, int x2, int y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRects}(GLshort x1, GLshort y1, GLshort x2, GLshort y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRects(short x1, short y1, short x2, short y2)  {

    final long __addr_ = _pat._addressof_glRects;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRects"));
    }
        dispatch_glRects1(x1, y1, x2, y2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRects}(GLshort x1, GLshort y1, GLshort x2, GLshort y2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRects1(short x1, short y1, short x2, short y2, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.DoubleBuffer}
      @param v2 a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glRectdv(DoubleBuffer v1, DoubleBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = _pat._addressof_glRectdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectdv"));
    }
        dispatch_glRectdv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.DoubleBuffer}
      @param v2 a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glRectdv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectdv}(const GLdouble *  v1, const GLdouble *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectdv(double[] v1, int v1_offset, double[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = _pat._addressof_glRectdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectdv"));
    }
        dispatch_glRectdv1(v1, Buffers.SIZEOF_DOUBLE * v1_offset, false, v2, Buffers.SIZEOF_DOUBLE * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param v2 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glRectfv(FloatBuffer v1, FloatBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = _pat._addressof_glRectfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectfv"));
    }
        dispatch_glRectfv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.FloatBuffer}
      @param v2 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glRectfv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectfv}(const GLfloat *  v1, const GLfloat *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectfv(float[] v1, int v1_offset, float[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = _pat._addressof_glRectfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectfv"));
    }
        dispatch_glRectfv1(v1, Buffers.SIZEOF_FLOAT * v1_offset, false, v2, Buffers.SIZEOF_FLOAT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.IntBuffer}
      @param v2 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glRectiv(IntBuffer v1, IntBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = _pat._addressof_glRectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectiv"));
    }
        dispatch_glRectiv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.IntBuffer}
      @param v2 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glRectiv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectiv}(const GLint *  v1, const GLint *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectiv(int[] v1, int v1_offset, int[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = _pat._addressof_glRectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectiv"));
    }
        dispatch_glRectiv1(v1, Buffers.SIZEOF_INT * v1_offset, false, v2, Buffers.SIZEOF_INT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.ShortBuffer}
      @param v2 a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glRectsv(ShortBuffer v1, ShortBuffer v2)  {

    final boolean v1_is_direct = Buffers.isDirect(v1);
    final boolean v2_is_direct = Buffers.isDirect(v2);
    final long __addr_ = _pat._addressof_glRectsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectsv"));
    }
        dispatch_glRectsv1(v1_is_direct ? v1 : Buffers.getArray(v1), v1_is_direct ? Buffers.getDirectBufferByteOffset(v1) : Buffers.getIndirectBufferByteOffset(v1), v1_is_direct, v2_is_direct ? v2 : Buffers.getArray(v2), v2_is_direct ? Buffers.getDirectBufferByteOffset(v2) : Buffers.getIndirectBufferByteOffset(v2), v2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v1 a direct or array-backed {@link java.nio.ShortBuffer}
      @param v2 a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glRectsv1(Object v1, int v1_byte_offset, boolean v1_is_direct, Object v2, int v2_byte_offset, boolean v2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glRectsv}(const GLshort *  v1, const GLshort *  v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glRectsv(short[] v1, int v1_offset, short[] v2, int v2_offset)  {

    if(v1 != null && v1.length <= v1_offset)
      throw new GLException("array offset argument \"v1_offset\" (" + v1_offset + ") equals or exceeds array length (" + v1.length + ")");
    if(v2 != null && v2.length <= v2_offset)
      throw new GLException("array offset argument \"v2_offset\" (" + v2_offset + ") equals or exceeds array length (" + v2.length + ")");
    final long __addr_ = _pat._addressof_glRectsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRectsv"));
    }
        dispatch_glRectsv1(v1, Buffers.SIZEOF_SHORT * v1_offset, false, v2, Buffers.SIZEOF_SHORT * v2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glShadeModel(int mode)  {

    final long __addr_ = _pat._addressof_glShadeModel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShadeModel"));
    }
        dispatch_glShadeModel1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glShadeModel1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightf(int light, int pname, float param)  {

    final long __addr_ = _pat._addressof_glLightf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightf"));
    }
        dispatch_glLightf1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLightf1(int light, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLighti}(GLenum light, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLighti(int light, int pname, int param)  {

    final long __addr_ = _pat._addressof_glLighti;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLighti"));
    }
        dispatch_glLighti1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLighti}(GLenum light, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLighti1(int light, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
    }
        dispatch_glLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
    }
        dispatch_glLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightiv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightiv"));
    }
        dispatch_glLightiv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightiv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightiv}(GLenum light, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLightiv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightiv"));
    }
        dispatch_glLightiv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
    }
        dispatch_glGetLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
    }
        dispatch_glGetLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLightiv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetLightiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightiv"));
    }
        dispatch_glGetLightiv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLightiv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightiv}(GLenum light, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetLightiv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetLightiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightiv"));
    }
        dispatch_glGetLightiv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightModelf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glLightModelf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelf"));
    }
        dispatch_glLightModelf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLightModelf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModeli}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLightModeli(int pname, int param)  {

    final long __addr_ = _pat._addressof_glLightModeli;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModeli"));
    }
        dispatch_glLightModeli1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeli}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLightModeli1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightModelfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
    }
        dispatch_glLightModelfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightModelfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightModelfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
    }
        dispatch_glLightModelfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightModeliv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightModeliv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModeliv"));
    }
        dispatch_glLightModeliv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightModeliv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModeliv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLightModeliv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightModeliv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModeliv"));
    }
        dispatch_glLightModeliv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMaterialf(int face, int pname, float param)  {

    final long __addr_ = _pat._addressof_glMaterialf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialf"));
    }
        dispatch_glMaterialf1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMaterialf1(int face, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMateriali}(GLenum face, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMateriali(int face, int pname, int param)  {

    final long __addr_ = _pat._addressof_glMateriali;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMateriali"));
    }
        dispatch_glMateriali1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMateriali}(GLenum face, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMateriali1(int face, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
    }
        dispatch_glMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
    }
        dispatch_glMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMaterialiv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMaterialiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialiv"));
    }
        dispatch_glMaterialiv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMaterialiv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialiv}(GLenum face, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMaterialiv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMaterialiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialiv"));
    }
        dispatch_glMaterialiv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
    }
        dispatch_glGetMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
    }
        dispatch_glGetMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMaterialiv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMaterialiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialiv"));
    }
        dispatch_glGetMaterialiv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMaterialiv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialiv}(GLenum face, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetMaterialiv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMaterialiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialiv"));
    }
        dispatch_glGetMaterialiv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaterial}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glColorMaterial(int face, int mode)  {

    final long __addr_ = _pat._addressof_glColorMaterial;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaterial"));
    }
        dispatch_glColorMaterial1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaterial}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColorMaterial1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelZoom}(GLfloat xfactor, GLfloat yfactor) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelZoom(float xfactor, float yfactor)  {

    final long __addr_ = _pat._addressof_glPixelZoom;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelZoom"));
    }
        dispatch_glPixelZoom1(xfactor, yfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelZoom}(GLfloat xfactor, GLfloat yfactor) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelZoom1(float xfactor, float yfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStoref}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelStoref(int pname, float param)  {

    final long __addr_ = _pat._addressof_glPixelStoref;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelStoref"));
    }
        dispatch_glPixelStoref1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStoref}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelStoref1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPixelStorei(int pname, int param)  {

    glStateTracker.setInt(pname, param);
    final long __addr_ = _pat._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelStorei"));
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransferf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelTransferf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glPixelTransferf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransferf"));
    }
        dispatch_glPixelTransferf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransferf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelTransferf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransferi}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelTransferi(int pname, int param)  {

    final long __addr_ = _pat._addressof_glPixelTransferi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransferi"));
    }
        dispatch_glPixelTransferi1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransferi}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelTransferi1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPixelMapfv(int map, int mapsize, FloatBuffer values)  {

    checkUnpackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
    }
        dispatch_glPixelMapfv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPixelMapfv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapfv(int map, int mapsize, float[] values, int values_offset)  {

    checkUnpackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
    }
        dispatch_glPixelMapfv1(map, mapsize, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapfv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapfv"));
    }
        dispatch_glPixelMapfv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapfv}(GLenum map, GLint mapsize, const GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelMapfv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPixelMapuiv(int map, int mapsize, IntBuffer values)  {

    checkUnpackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
    }
        dispatch_glPixelMapuiv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPixelMapuiv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapuiv(int map, int mapsize, int[] values, int values_offset)  {

    checkUnpackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
    }
        dispatch_glPixelMapuiv1(map, mapsize, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapuiv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapuiv"));
    }
        dispatch_glPixelMapuiv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapuiv}(GLenum map, GLint mapsize, const GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelMapuiv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glPixelMapusv(int map, int mapsize, ShortBuffer values)  {

    checkUnpackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
    }
        dispatch_glPixelMapusv1(map, mapsize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glPixelMapusv1(int map, int mapsize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapusv(int map, int mapsize, short[] values, int values_offset)  {

    checkUnpackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
    }
        dispatch_glPixelMapusv1(map, mapsize, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPixelMapusv(int map, int mapsize, long values_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelMapusv"));
    }
        dispatch_glPixelMapusv1(map, mapsize, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelMapusv}(GLenum map, GLint mapsize, const GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelMapusv1(int map, int mapsize, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetPixelMapfv(int map, FloatBuffer values)  {

    checkPackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
    }
        dispatch_glGetPixelMapfv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetPixelMapfv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapfv(int map, float[] values, int values_offset)  {

    checkPackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
    }
        dispatch_glGetPixelMapfv1(map, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapfv(int map, long values_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapfv"));
    }
        dispatch_glGetPixelMapfv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapfv}(GLenum map, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glGetPixelMapfv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPixelMapuiv(int map, IntBuffer values)  {

    checkPackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
    }
        dispatch_glGetPixelMapuiv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPixelMapuiv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapuiv(int map, int[] values, int values_offset)  {

    checkPackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
    }
        dispatch_glGetPixelMapuiv1(map, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapuiv(int map, long values_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapuiv"));
    }
        dispatch_glGetPixelMapuiv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapuiv}(GLenum map, GLuint *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glGetPixelMapuiv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glGetPixelMapusv(int map, ShortBuffer values)  {

    checkPackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
    }
        dispatch_glGetPixelMapusv1(map, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glGetPixelMapusv1(int map, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapusv(int map, short[] values, int values_offset)  {

    checkPackPBOUnbound(true);
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
    }
        dispatch_glGetPixelMapusv1(map, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetPixelMapusv(int map, long values_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelMapusv"));
    }
        dispatch_glGetPixelMapusv1(map, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelMapusv}(GLenum map, GLushort *  values) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glGetPixelMapusv1(int map, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param bitmap a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, ByteBuffer bitmap)  {

    checkUnpackPBOUnbound(true);
    final boolean bitmap_is_direct = Buffers.isDirect(bitmap);
    final long __addr_ = _pat._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap_is_direct ? bitmap : Buffers.getArray(bitmap), bitmap_is_direct ? Buffers.getDirectBufferByteOffset(bitmap) : Buffers.getIndirectBufferByteOffset(bitmap), bitmap_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param bitmap a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glBitmap1(int width, int height, float xorig, float yorig, float xmove, float ymove, Object bitmap, int bitmap_byte_offset, boolean bitmap_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap, int bitmap_offset)  {

    checkUnpackPBOUnbound(true);
    if(bitmap != null && bitmap.length <= bitmap_offset)
      throw new GLException("array offset argument \"bitmap_offset\" (" + bitmap_offset + ") equals or exceeds array length (" + bitmap.length + ")");
    final long __addr_ = _pat._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap, bitmap_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, long bitmap_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glBitmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBitmap"));
    }
        dispatch_glBitmap1(width, height, xorig, yorig, xmove, ymove, bitmap_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBitmap}(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *  bitmap) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glBitmap1(int width, int height, float xorig, float yorig, float xmove, float ymove, long bitmap_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawPixels(int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glDrawPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawPixels"));
    }
        dispatch_glDrawPixels1(width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawPixels1(int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glDrawPixels(int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glDrawPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawPixels"));
    }
        dispatch_glDrawPixels1(width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawPixels}(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDrawPixels1(int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glCopyPixels(int x, int y, int width, int height, int type)  {

    final long __addr_ = _pat._addressof_glCopyPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyPixels"));
    }
        dispatch_glCopyPixels1(x, y, width, height, type, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glCopyPixels1(int x, int y, int width, int height, int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = _pat._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFunc"));
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = _pat._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMask"));
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = _pat._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOp"));
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearStencil(int s)  {

    final long __addr_ = _pat._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearStencil"));
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGend}(GLenum coord, GLenum pname, GLdouble param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexGend(int coord, int pname, double param)  {

    final long __addr_ = _pat._addressof_glTexGend;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGend"));
    }
        dispatch_glTexGend1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGend}(GLenum coord, GLenum pname, GLdouble param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexGend1(int coord, int pname, double param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfOES</code>   */
  public void glTexGenf(int coord, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexGenf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenf"));
    }
        dispatch_glTexGenf1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfOES</code>   */
  private native void dispatch_glTexGenf1(int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGeniOES</code>   */
  public void glTexGeni(int coord, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexGeni;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeni"));
    }
        dispatch_glTexGeni1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGeniOES</code>   */
  private native void dispatch_glTexGeni1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glTexGendv(int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGendv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGendv"));
    }
        dispatch_glTexGendv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glTexGendv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGendv}(GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexGendv(int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGendv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGendv"));
    }
        dispatch_glTexGendv1(coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
    }
        dispatch_glTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>   */
  public void glTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
    }
        dispatch_glTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
    }
        dispatch_glTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>   */
  public void glTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
    }
        dispatch_glTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetTexGendv(int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGendv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGendv"));
    }
        dispatch_glGetTexGendv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetTexGendv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGendv}(GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexGendv(int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGendv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGendv"));
    }
        dispatch_glGetTexGendv1(coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
    }
        dispatch_glGetTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>   */
  public void glGetTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
    }
        dispatch_glGetTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
    }
        dispatch_glGetTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>   */
  public void glGetTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
    }
        dispatch_glGetTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvf(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexEnvf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvf"));
    }
        dispatch_glTexEnvf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexEnvf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvi(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexEnvi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvi"));
    }
        dispatch_glTexEnvi1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexEnvi1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
    }
        dispatch_glTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
    }
        dispatch_glTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
    }
        dispatch_glTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
    }
        dispatch_glTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
    }
        dispatch_glGetTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
    }
        dispatch_glGetTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
    }
        dispatch_glGetTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
    }
        dispatch_glGetTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterf"));
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteri"));
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexLevelParameterfv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexLevelParameteriv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage1D"));
    }
        dispatch_glTexImage1D1(target, level, internalFormat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage1D1(int target, int level, int internalFormat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage1D"));
    }
        dispatch_glTexImage1D1(target, level, internalFormat, width, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage1D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexImage1D1(int target, int level, int internalFormat, int width, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalFormat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalFormat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalFormat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalFormat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTexImage(int target, int level, int format, int type, Buffer pixels)  {

    checkPackPBOUnbound(true);
    int width = 0, height = 0, depth = 1;
    int[] tmp = new int[1];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, tmp, 0);
    width = tmp[0];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, tmp, 0);
    height = tmp[0];
    if (target == GL_TEXTURE_3D) {
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_DEPTH, tmp, 0);
    depth = tmp[0];
    }
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width, height, depth, true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexImage"));
    }
        dispatch_glGetTexImage1(target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTexImage1(int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexImage(int target, int level, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOBound(true);
    int width = 0, height = 0, depth = 1;
    int[] tmp = new int[1];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_WIDTH, tmp, 0);
    width = tmp[0];
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_HEIGHT, tmp, 0);
    height = tmp[0];
    if (target == GL_TEXTURE_3D) {
    glGetTexLevelParameteriv(target, level, GL_TEXTURE_DEPTH, tmp, 0);
    depth = tmp[0];
    }
    final long __addr_ = _pat._addressof_glGetTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexImage"));
    }
        dispatch_glGetTexImage1(target, level, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glGetTexImage1(int target, int level, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMap1d(int target, double u1, double u2, int stride, int order, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMap1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap1d"));
    }
        dispatch_glMap1d1(target, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMap1d1(int target, double u1, double u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1d}(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMap1d(int target, double u1, double u2, int stride, int order, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMap1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap1d"));
    }
        dispatch_glMap1d1(target, u1, u2, stride, order, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMap1f(int target, float u1, float u2, int stride, int order, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMap1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap1f"));
    }
        dispatch_glMap1f1(target, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMap1f1(int target, float u1, float u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap1f}(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMap1f(int target, float u1, float u2, int stride, int order, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMap1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap1f"));
    }
        dispatch_glMap1f1(target, u1, u2, stride, order, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMap2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap2d"));
    }
        dispatch_glMap2d1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMap2d1(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap2d}(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMap2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap2d"));
    }
        dispatch_glMap2d1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMap2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap2f"));
    }
        dispatch_glMap2f1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMap2f1(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMap2f}(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMap2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMap2f"));
    }
        dispatch_glMap2f1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetMapdv(int target, int query, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetMapdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapdv"));
    }
        dispatch_glGetMapdv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetMapdv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapdv}(GLenum target, GLenum query, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetMapdv(int target, int query, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetMapdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapdv"));
    }
        dispatch_glGetMapdv1(target, query, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapfv(int target, int query, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapfv"));
    }
        dispatch_glGetMapfv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapfv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapfv}(GLenum target, GLenum query, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetMapfv(int target, int query, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapfv"));
    }
        dispatch_glGetMapfv1(target, query, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapiv(int target, int query, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetMapiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapiv"));
    }
        dispatch_glGetMapiv1(target, query, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapiv1(int target, int query, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapiv}(GLenum target, GLenum query, GLint *  v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glGetMapiv(int target, int query, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetMapiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapiv"));
    }
        dispatch_glGetMapiv1(target, query, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1d}(GLdouble u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord1d(double u)  {

    final long __addr_ = _pat._addressof_glEvalCoord1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1d"));
    }
        dispatch_glEvalCoord1d1(u, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1d}(GLdouble u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalCoord1d1(double u, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1f}(GLfloat u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord1f(float u)  {

    final long __addr_ = _pat._addressof_glEvalCoord1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1f"));
    }
        dispatch_glEvalCoord1f1(u, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1f}(GLfloat u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalCoord1f1(float u, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glEvalCoord1dv(DoubleBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = _pat._addressof_glEvalCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1dv"));
    }
        dispatch_glEvalCoord1dv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glEvalCoord1dv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord1dv(double[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = _pat._addressof_glEvalCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1dv"));
    }
        dispatch_glEvalCoord1dv1(u, Buffers.SIZEOF_DOUBLE * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glEvalCoord1fv(FloatBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = _pat._addressof_glEvalCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1fv"));
    }
        dispatch_glEvalCoord1fv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glEvalCoord1fv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord1fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord1fv(float[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = _pat._addressof_glEvalCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord1fv"));
    }
        dispatch_glEvalCoord1fv1(u, Buffers.SIZEOF_FLOAT * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2d}(GLdouble u, GLdouble v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord2d(double u, double v)  {

    final long __addr_ = _pat._addressof_glEvalCoord2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2d"));
    }
        dispatch_glEvalCoord2d1(u, v, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2d}(GLdouble u, GLdouble v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalCoord2d1(double u, double v, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2f}(GLfloat u, GLfloat v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord2f(float u, float v)  {

    final long __addr_ = _pat._addressof_glEvalCoord2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2f"));
    }
        dispatch_glEvalCoord2f1(u, v, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2f}(GLfloat u, GLfloat v) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalCoord2f1(float u, float v, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glEvalCoord2dv(DoubleBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = _pat._addressof_glEvalCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2dv"));
    }
        dispatch_glEvalCoord2dv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glEvalCoord2dv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2dv}(const GLdouble *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord2dv(double[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = _pat._addressof_glEvalCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2dv"));
    }
        dispatch_glEvalCoord2dv1(u, Buffers.SIZEOF_DOUBLE * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glEvalCoord2fv(FloatBuffer u)  {

    final boolean u_is_direct = Buffers.isDirect(u);
    final long __addr_ = _pat._addressof_glEvalCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2fv"));
    }
        dispatch_glEvalCoord2fv1(u_is_direct ? u : Buffers.getArray(u), u_is_direct ? Buffers.getDirectBufferByteOffset(u) : Buffers.getIndirectBufferByteOffset(u), u_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param u a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glEvalCoord2fv1(Object u, int u_byte_offset, boolean u_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalCoord2fv}(const GLfloat *  u) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalCoord2fv(float[] u, int u_offset)  {

    if(u != null && u.length <= u_offset)
      throw new GLException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    final long __addr_ = _pat._addressof_glEvalCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalCoord2fv"));
    }
        dispatch_glEvalCoord2fv1(u, Buffers.SIZEOF_FLOAT * u_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid1d}(GLint un, GLdouble u1, GLdouble u2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMapGrid1d(int un, double u1, double u2)  {

    final long __addr_ = _pat._addressof_glMapGrid1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapGrid1d"));
    }
        dispatch_glMapGrid1d1(un, u1, u2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid1d}(GLint un, GLdouble u1, GLdouble u2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMapGrid1d1(int un, double u1, double u2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid1f}(GLint un, GLfloat u1, GLfloat u2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMapGrid1f(int un, float u1, float u2)  {

    final long __addr_ = _pat._addressof_glMapGrid1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapGrid1f"));
    }
        dispatch_glMapGrid1f1(un, u1, u2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid1f}(GLint un, GLfloat u1, GLfloat u2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMapGrid1f1(int un, float u1, float u2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid2d}(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)  {

    final long __addr_ = _pat._addressof_glMapGrid2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapGrid2d"));
    }
        dispatch_glMapGrid2d1(un, u1, u2, vn, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid2d}(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMapGrid2d1(int un, double u1, double u2, int vn, double v1, double v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapGrid2f}(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glMapGrid2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapGrid2f"));
    }
        dispatch_glMapGrid2f1(un, u1, u2, vn, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapGrid2f}(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMapGrid2f1(int un, float u1, float u2, int vn, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalPoint1}(GLint i) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalPoint1(int i)  {

    final long __addr_ = _pat._addressof_glEvalPoint1;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalPoint1"));
    }
        dispatch_glEvalPoint11(i, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalPoint1}(GLint i) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalPoint11(int i, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalPoint2}(GLint i, GLint j) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalPoint2(int i, int j)  {

    final long __addr_ = _pat._addressof_glEvalPoint2;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalPoint2"));
    }
        dispatch_glEvalPoint21(i, j, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalPoint2}(GLint i, GLint j) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalPoint21(int i, int j, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalMesh1}(GLenum mode, GLint i1, GLint i2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalMesh1(int mode, int i1, int i2)  {

    final long __addr_ = _pat._addressof_glEvalMesh1;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalMesh1"));
    }
        dispatch_glEvalMesh11(mode, i1, i2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMesh1}(GLenum mode, GLint i1, GLint i2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalMesh11(int mode, int i1, int i2, long procAddress);

  /** Entry point to C language function: <code> void {@native glEvalMesh2}(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glEvalMesh2(int mode, int i1, int i2, int j1, int j2)  {

    final long __addr_ = _pat._addressof_glEvalMesh2;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalMesh2"));
    }
        dispatch_glEvalMesh21(mode, i1, i2, j1, j2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMesh2}(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEvalMesh21(int mode, int i1, int i2, int j1, int j2, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFogf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glFogf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogf"));
    }
        dispatch_glFogf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFogf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogi}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glFogi(int pname, int param)  {

    final long __addr_ = _pat._addressof_glFogi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogi"));
    }
        dispatch_glFogi1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogi}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFogi1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
    }
        dispatch_glFogfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFogfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
    }
        dispatch_glFogfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFogiv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glFogiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogiv"));
    }
        dispatch_glFogiv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFogiv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogiv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glFogiv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glFogiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogiv"));
    }
        dispatch_glFogiv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFeedbackBuffer}(GLsizei size, GLenum type, GLfloat *  buffer) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param buffer a direct only {@link java.nio.FloatBuffer}   */
  public void glFeedbackBuffer(int size, int type, FloatBuffer buffer)  {

    if (!Buffers.isDirect(buffer))
      throw new GLException("Argument \"buffer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glFeedbackBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFeedbackBuffer"));
    }
        dispatch_glFeedbackBuffer0(size, type, buffer, Buffers.getDirectBufferByteOffset(buffer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFeedbackBuffer}(GLsizei size, GLenum type, GLfloat *  buffer) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param buffer a direct only {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFeedbackBuffer0(int size, int type, Object buffer, int buffer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glPassThrough}(GLfloat token) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPassThrough(float token)  {

    final long __addr_ = _pat._addressof_glPassThrough;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPassThrough"));
    }
        dispatch_glPassThrough1(token, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPassThrough}(GLfloat token) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPassThrough1(float token, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectBuffer}(GLsizei size, GLuint *  buffer) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param buffer a direct only {@link java.nio.IntBuffer}   */
  public void glSelectBuffer(int size, IntBuffer buffer)  {

    if (!Buffers.isDirect(buffer))
      throw new GLException("Argument \"buffer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glSelectBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSelectBuffer"));
    }
        dispatch_glSelectBuffer0(size, buffer, Buffers.getDirectBufferByteOffset(buffer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectBuffer}(GLsizei size, GLuint *  buffer) </code> <br>Part of <code>GL_VERSION_1_0</code><br>
      @param buffer a direct only {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectBuffer0(int size, Object buffer, int buffer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glInitNames}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glInitNames()  {

    final long __addr_ = _pat._addressof_glInitNames;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInitNames"));
    }
        dispatch_glInitNames1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glInitNames}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glInitNames1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadName}(GLuint name) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glLoadName(int name)  {

    final long __addr_ = _pat._addressof_glLoadName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadName"));
    }
        dispatch_glLoadName1(name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadName}(GLuint name) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLoadName1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushName}(GLuint name) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPushName(int name)  {

    final long __addr_ = _pat._addressof_glPushName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushName"));
    }
        dispatch_glPushName1(name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushName}(GLuint name) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPushName1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopName}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  public void glPopName()  {

    final long __addr_ = _pat._addressof_glPopName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopName"));
    }
        dispatch_glPopName1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopName}(void) </code> <br>Part of <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPopName1(long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexub}(GLubyte c) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  public void glIndexub(byte c)  {

    final long __addr_ = _pat._addressof_glIndexub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexub"));
    }
        dispatch_glIndexub1(c, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexub}(GLubyte c) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glIndexub1(byte c, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c) </code> <br>Part of <code>GL_VERSION_1_1</code><br>
      @param c a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glIndexubv(ByteBuffer c)  {

    final boolean c_is_direct = Buffers.isDirect(c);
    final long __addr_ = _pat._addressof_glIndexubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexubv"));
    }
        dispatch_glIndexubv1(c_is_direct ? c : Buffers.getArray(c), c_is_direct ? Buffers.getDirectBufferByteOffset(c) : Buffers.getIndirectBufferByteOffset(c), c_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c) </code> <br>Part of <code>GL_VERSION_1_1</code><br>
      @param c a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glIndexubv1(Object c, int c_byte_offset, boolean c_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexubv}(const GLubyte *  c) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  public void glIndexubv(byte[] c, int c_offset)  {

    if(c != null && c.length <= c_offset)
      throw new GLException("array offset argument \"c_offset\" (" + c_offset + ") equals or exceeds array length (" + c.length + ")");
    final long __addr_ = _pat._addressof_glIndexubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexubv"));
    }
        dispatch_glIndexubv1(c, c_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushClientAttrib}(GLbitfield mask) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  public void glPushClientAttrib(int mask)  {

    final long __addr_ = _pat._addressof_glPushClientAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushClientAttrib"));
    }
        dispatch_glPushClientAttrib1(mask, __addr_);
    bufferStateTracker.clear();
    glStateTracker.pushAttrib(mask);
  }

  /** Entry point to C language function: <code> void {@native glPushClientAttrib}(GLbitfield mask) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glPushClientAttrib1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopClientAttrib}(void) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  public void glPopClientAttrib()  {

    final long __addr_ = _pat._addressof_glPopClientAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopClientAttrib"));
    }
        dispatch_glPopClientAttrib1(__addr_);
    bufferStateTracker.clear();
    glStateTracker.popAttrib();
  }

  /** Entry point to C language function: <code> void {@native glPopClientAttrib}(void) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glPopClientAttrib1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glEnableClientState(int cap)  {

    final long __addr_ = _pat._addressof_glEnableClientState;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableClientState"));
    }
        dispatch_glEnableClientState1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glEnableClientState1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glDisableClientState(int cap)  {

    final long __addr_ = _pat._addressof_glDisableClientState;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableClientState"));
    }
        dispatch_glDisableClientState1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glDisableClientState1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glVertexPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
    }
        dispatch_glVertexPointer0(size, type, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexPointer0(int size, int type, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>   */
  public void glVertexPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
    }
        dispatch_glVertexPointer0(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>   */
  private native void dispatch_glVertexPointer0(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glNormalPointer(int type, int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
    }
        dispatch_glNormalPointer0(type, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glNormalPointer0(int type, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>   */
  public void glNormalPointer(int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
    }
        dispatch_glNormalPointer0(type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>   */
  private native void dispatch_glNormalPointer0(int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glColorPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
    }
        dispatch_glColorPointer0(size, type, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glColorPointer0(int size, int type, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>   */
  public void glColorPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
    }
        dispatch_glColorPointer0(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>   */
  private native void dispatch_glColorPointer0(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glIndexPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glIndexPointer(int type, int stride, Buffer ptr)  {

    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glIndexPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexPointer"));
    }
        dispatch_glIndexPointer0(type, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexPointer}(GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glIndexPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glIndexPointer0(int type, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glTexCoordPointer(int size, int type, int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
    }
        dispatch_glTexCoordPointer0(size, type, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glTexCoordPointer0(int size, int type, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>   */
  public void glTexCoordPointer(int size, int type, int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
    }
        dispatch_glTexCoordPointer0(size, type, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>   */
  private native void dispatch_glTexCoordPointer0(int size, int type, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glEdgeFlagPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glEdgeFlagPointer(int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glEdgeFlagPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagPointer"));
    }
        dispatch_glEdgeFlagPointer0(stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glEdgeFlagPointerEXT</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glEdgeFlagPointer0(int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glEdgeFlagPointerEXT</code>   */
  public void glEdgeFlagPointer(int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glEdgeFlagPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagPointer"));
    }
        dispatch_glEdgeFlagPointer0(stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagPointer}(GLsizei stride, const GLvoid *  ptr) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glEdgeFlagPointerEXT</code>   */
  private native void dispatch_glEdgeFlagPointer0(int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glArrayElement}(GLint i) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glArrayElementEXT</code>   */
  public void glArrayElement(int i)  {

    final long __addr_ = _pat._addressof_glArrayElement;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glArrayElement"));
    }
        dispatch_glArrayElement1(i, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glArrayElement}(GLint i) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glArrayElementEXT</code>   */
  private native void dispatch_glArrayElement1(int i, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = _pat._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArrays"));
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  private native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_1_1</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glInterleavedArrays(int format, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glInterleavedArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInterleavedArrays"));
    }
        dispatch_glInterleavedArrays1(format, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_1_1</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glInterleavedArrays1(int format, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  public void glInterleavedArrays(int format, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glInterleavedArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInterleavedArrays"));
    }
        dispatch_glInterleavedArrays1(format, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInterleavedArrays}(GLenum format, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glInterleavedArrays1(int format, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = _pat._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTexture"));
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  private native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glPrioritizeTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param priorities a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPrioritizeTextures(int n, IntBuffer textures, FloatBuffer priorities)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean priorities_is_direct = Buffers.isDirect(priorities);
    final long __addr_ = _pat._addressof_glPrioritizeTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrioritizeTextures"));
    }
        dispatch_glPrioritizeTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, priorities_is_direct ? priorities : Buffers.getArray(priorities), priorities_is_direct ? Buffers.getDirectBufferByteOffset(priorities) : Buffers.getIndirectBufferByteOffset(priorities), priorities_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glPrioritizeTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param priorities a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPrioritizeTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, Object priorities, int priorities_byte_offset, boolean priorities_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrioritizeTextures}(GLsizei n, const GLuint *  textures, const GLclampf *  priorities) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glPrioritizeTexturesEXT</code>   */
  public void glPrioritizeTextures(int n, int[] textures, int textures_offset, float[] priorities, int priorities_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(priorities != null && priorities.length <= priorities_offset)
      throw new GLException("array offset argument \"priorities_offset\" (" + priorities_offset + ") equals or exceeds array length (" + priorities.length + ")");
    final long __addr_ = _pat._addressof_glPrioritizeTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrioritizeTextures"));
    }
        dispatch_glPrioritizeTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, priorities, Buffers.SIZEOF_FLOAT * priorities_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glAreTexturesResidentEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param residences a direct or array-backed {@link java.nio.ByteBuffer}   */
  public boolean glAreTexturesResident(int n, IntBuffer textures, ByteBuffer residences)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean residences_is_direct = Buffers.isDirect(residences);
    final long __addr_ = _pat._addressof_glAreTexturesResident;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAreTexturesResident"));
    }
        return dispatch_glAreTexturesResident1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, residences_is_direct ? residences : Buffers.getArray(residences), residences_is_direct ? Buffers.getDirectBufferByteOffset(residences) : Buffers.getIndirectBufferByteOffset(residences), residences_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glAreTexturesResidentEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param residences a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_glAreTexturesResident1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, Object residences, int residences_byte_offset, boolean residences_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glAreTexturesResident}(GLsizei n, const GLuint *  textures, GLboolean *  residences) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glAreTexturesResidentEXT</code>   */
  public boolean glAreTexturesResident(int n, int[] textures, int textures_offset, byte[] residences, int residences_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(residences != null && residences.length <= residences_offset)
      throw new GLException("array offset argument \"residences_offset\" (" + residences_offset + ") equals or exceeds array length (" + residences.length + ")");
    final long __addr_ = _pat._addressof_glAreTexturesResident;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAreTexturesResident"));
    }
        return dispatch_glAreTexturesResident1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, residences, residences_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = _pat._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTexture"));
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  private native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage1DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage1D"));
    }
        dispatch_glTexSubImage1D1(target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage1DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage1D1(int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage1DEXT</code>   */
  public void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage1D"));
    }
        dispatch_glTexSubImage1D1(target, level, xoffset, width, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage1DEXT</code>   */
  private native void dispatch_glTexSubImage1D1(int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage1DEXT</code>   */
  public void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = _pat._addressof_glCopyTexImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage1D"));
    }
        dispatch_glCopyTexImage1D1(target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage1DEXT</code>   */
  private native void dispatch_glCopyTexImage1D1(int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = _pat._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage2D"));
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  private native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage1DEXT</code>   */
  public void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage1D"));
    }
        dispatch_glCopyTexSubImage1D1(target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage1DEXT</code>   */
  private native void dispatch_glCopyTexSubImage1D1(int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage2D"));
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  private native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage1D"));
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  private native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2D"));
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  private native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3D"));
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  private native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1DEXT"));
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DEXT"));
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DEXT"));
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glActiveShaderProgramEXT</code>   */
  public void glActiveShaderProgram(int pipeline, int program)  {

    final long __addr_ = _pat._addressof_glActiveShaderProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveShaderProgram"));
    }
        dispatch_glActiveShaderProgram1(pipeline, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glActiveShaderProgramEXT</code>   */
  private native void dispatch_glActiveShaderProgram1(int pipeline, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glBindProgramPipelineEXT</code>   */
  public void glBindProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glBindProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindProgramPipeline"));
    }
        dispatch_glBindProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glBindProgramPipelineEXT</code>   */
  private native void dispatch_glBindProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar *  *  strings) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glCreateShaderProgramvEXT</code>   */
  public int glCreateShaderProgramv(int type, int count, String[] strings)  {

    final long __addr_ = _pat._addressof_glCreateShaderProgramv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShaderProgramv"));
    }
        return dispatch_glCreateShaderProgramv1(type, count, strings, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar *  *  strings) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glCreateShaderProgramvEXT</code>   */
  private native int dispatch_glCreateShaderProgramv1(int type, int count, String[] strings, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = _pat._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>   */
  public void glDeleteProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = _pat._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = _pat._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
    }
        dispatch_glGenProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>   */
  public void glGenProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = _pat._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
    }
        dispatch_glGenProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramPipelineInfoLog1(int pipeline, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramPipelineiv(int pipeline, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramPipelineiv1(int pipeline, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>   */
  public void glGetProgramPipelineiv(int pipeline, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glIsProgramPipelineEXT</code>   */
  public boolean glIsProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glIsProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgramPipeline"));
    }
        return dispatch_glIsProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glIsProgramPipelineEXT</code>   */
  private native boolean dispatch_glIsProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_geometry_shader4</code>, <code>GL_EXT_separate_shader_objects</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glProgramParameteriEXT</code>, <code>glProgramParameteriARB</code>   */
  public void glProgramParameteri(int program, int pname, int value)  {

    final long __addr_ = _pat._addressof_glProgramParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteri"));
    }
        dispatch_glProgramParameteri1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_geometry_shader4</code>, <code>GL_EXT_separate_shader_objects</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glProgramParameteriEXT</code>, <code>glProgramParameteriARB</code>   */
  private native void dispatch_glProgramParameteri1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fEXT</code>   */
  public void glProgramUniform1f(int program, int location, float v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1f"));
    }
        dispatch_glProgramUniform1f1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fEXT</code>   */
  private native void dispatch_glProgramUniform1f1(int program, int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform1fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
    }
        dispatch_glProgramUniform1fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform1fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>   */
  public void glProgramUniform1fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
    }
        dispatch_glProgramUniform1fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1iEXT</code>   */
  public void glProgramUniform1i(int program, int location, int v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i"));
    }
        dispatch_glProgramUniform1i1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1iEXT</code>   */
  private native void dispatch_glProgramUniform1i1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
    }
        dispatch_glProgramUniform1iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>   */
  public void glProgramUniform1iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
    }
        dispatch_glProgramUniform1iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fEXT</code>   */
  public void glProgramUniform2f(int program, int location, float v0, float v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2f"));
    }
        dispatch_glProgramUniform2f1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fEXT</code>   */
  private native void dispatch_glProgramUniform2f1(int program, int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform2fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
    }
        dispatch_glProgramUniform2fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform2fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>   */
  public void glProgramUniform2fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
    }
        dispatch_glProgramUniform2fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2iEXT</code>   */
  public void glProgramUniform2i(int program, int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i"));
    }
        dispatch_glProgramUniform2i1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2iEXT</code>   */
  private native void dispatch_glProgramUniform2i1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
    }
        dispatch_glProgramUniform2iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>   */
  public void glProgramUniform2iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
    }
        dispatch_glProgramUniform2iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fEXT</code>   */
  public void glProgramUniform3f(int program, int location, float v0, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3f"));
    }
        dispatch_glProgramUniform3f1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fEXT</code>   */
  private native void dispatch_glProgramUniform3f1(int program, int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform3fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
    }
        dispatch_glProgramUniform3fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform3fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>   */
  public void glProgramUniform3fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
    }
        dispatch_glProgramUniform3fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3iEXT</code>   */
  public void glProgramUniform3i(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i"));
    }
        dispatch_glProgramUniform3i1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3iEXT</code>   */
  private native void dispatch_glProgramUniform3i1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
    }
        dispatch_glProgramUniform3iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>   */
  public void glProgramUniform3iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
    }
        dispatch_glProgramUniform3iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fEXT</code>   */
  public void glProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4f"));
    }
        dispatch_glProgramUniform4f1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fEXT</code>   */
  private native void dispatch_glProgramUniform4f1(int program, int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform4fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
    }
        dispatch_glProgramUniform4fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform4fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>   */
  public void glProgramUniform4fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
    }
        dispatch_glProgramUniform4fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4iEXT</code>   */
  public void glProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i"));
    }
        dispatch_glProgramUniform4i1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4iEXT</code>   */
  private native void dispatch_glProgramUniform4i1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
    }
        dispatch_glProgramUniform4iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>   */
  public void glProgramUniform4iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
    }
        dispatch_glProgramUniform4iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glUseProgramStagesEXT</code>   */
  public void glUseProgramStages(int pipeline, int stages, int program)  {

    final long __addr_ = _pat._addressof_glUseProgramStages;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgramStages"));
    }
        dispatch_glUseProgramStages1(pipeline, stages, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glUseProgramStagesEXT</code>   */
  private native void dispatch_glUseProgramStages1(int pipeline, int stages, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glValidateProgramPipelineEXT</code>   */
  public void glValidateProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glValidateProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgramPipeline"));
    }
        dispatch_glValidateProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glValidateProgramPipelineEXT</code>   */
  private native void dispatch_glValidateProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uiEXT</code>   */
  public void glProgramUniform1ui(int program, int location, int v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui"));
    }
        dispatch_glProgramUniform1ui1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uiEXT</code>   */
  private native void dispatch_glProgramUniform1ui1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uiEXT</code>   */
  public void glProgramUniform2ui(int program, int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui"));
    }
        dispatch_glProgramUniform2ui1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uiEXT</code>   */
  private native void dispatch_glProgramUniform2ui1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uiEXT</code>   */
  public void glProgramUniform3ui(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui"));
    }
        dispatch_glProgramUniform3ui1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uiEXT</code>   */
  private native void dispatch_glProgramUniform3ui1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uiEXT</code>   */
  public void glProgramUniform4ui(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui"));
    }
        dispatch_glProgramUniform4ui1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uiEXT</code>   */
  private native void dispatch_glProgramUniform4ui1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>   */
  public void glProgramUniform1uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>   */
  public void glProgramUniform2uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>   */
  public void glProgramUniform3uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>   */
  public void glProgramUniform4uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_copy_texture</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCopyTexSubImage3DEXT</code>, <code>glCopyTexSubImage3DOES</code>   */
  public void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage3D"));
    }
        dispatch_glCopyTexSubImage3D1(target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_copy_texture</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCopyTexSubImage3DEXT</code>, <code>glCopyTexSubImage3DOES</code>   */
  private native void dispatch_glCopyTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = _pat._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveTexture"));
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  private native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = _pat._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleCoverage"));
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  private native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage1DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage1D"));
    }
        dispatch_glCompressedTexImage1D1(target, level, internalformat, width, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage1DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage1D1(int target, int level, int internalformat, int width, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage1DARB</code>   */
  public void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage1D"));
    }
        dispatch_glCompressedTexImage1D1(target, level, internalformat, width, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage1D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage1DARB</code>   */
  private native void dispatch_glCompressedTexImage1D1(int target, int level, int internalformat, int width, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage1DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage1D"));
    }
        dispatch_glCompressedTexSubImage1D1(target, level, xoffset, width, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage1DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage1D1(int target, int level, int xoffset, int width, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage1DARB</code>   */
  public void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage1D"));
    }
        dispatch_glCompressedTexSubImage1D1(target, level, xoffset, width, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage1D}(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage1DARB</code>   */
  private native void dispatch_glCompressedTexSubImage1D1(int target, int level, int xoffset, int width, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, void *  img) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glGetCompressedTexImageARB</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTexImage(int target, int level, Buffer img)  {

    checkPackPBOUnbound(true);
    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = _pat._addressof_glGetCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTexImage"));
    }
        dispatch_glGetCompressedTexImage1(target, level, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, void *  img) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glGetCompressedTexImageARB</code>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTexImage1(int target, int level, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, void *  img) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glGetCompressedTexImageARB</code>   */
  public void glGetCompressedTexImage(int target, int level, long img_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTexImage"));
    }
        dispatch_glGetCompressedTexImage1(target, level, img_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTexImage}(GLenum target, GLint level, void *  img) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glGetCompressedTexImageARB</code>   */
  private native void dispatch_glGetCompressedTexImage1(int target, int level, long img_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glClientActiveTextureARB</code>   */
  public void glClientActiveTexture(int texture)  {

    final long __addr_ = _pat._addressof_glClientActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientActiveTexture"));
    }
        dispatch_glClientActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glClientActiveTextureARB</code>   */
  private native void dispatch_glClientActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1d}(GLenum target, GLdouble s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1dARB</code>   */
  public void glMultiTexCoord1d(int target, double s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1d"));
    }
        dispatch_glMultiTexCoord1d1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1d}(GLenum target, GLdouble s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1dARB</code>   */
  private native void dispatch_glMultiTexCoord1d1(int target, double s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord1dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1dv"));
    }
        dispatch_glMultiTexCoord1dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord1dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1dvARB</code>   */
  public void glMultiTexCoord1dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1dv"));
    }
        dispatch_glMultiTexCoord1dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1f}(GLenum target, GLfloat s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1fARB</code>   */
  public void glMultiTexCoord1f(int target, float s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1f"));
    }
        dispatch_glMultiTexCoord1f1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1f}(GLenum target, GLfloat s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1fARB</code>   */
  private native void dispatch_glMultiTexCoord1f1(int target, float s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord1fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1fv"));
    }
        dispatch_glMultiTexCoord1fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord1fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1fvARB</code>   */
  public void glMultiTexCoord1fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1fv"));
    }
        dispatch_glMultiTexCoord1fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1i}(GLenum target, GLint s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1iARB</code>   */
  public void glMultiTexCoord1i(int target, int s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1i"));
    }
        dispatch_glMultiTexCoord1i1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1i}(GLenum target, GLint s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1iARB</code>   */
  private native void dispatch_glMultiTexCoord1i1(int target, int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord1iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1iv"));
    }
        dispatch_glMultiTexCoord1iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord1iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1ivARB</code>   */
  public void glMultiTexCoord1iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1iv"));
    }
        dispatch_glMultiTexCoord1iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1s}(GLenum target, GLshort s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1sARB</code>   */
  public void glMultiTexCoord1s(int target, short s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1s"));
    }
        dispatch_glMultiTexCoord1s1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1s}(GLenum target, GLshort s) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1sARB</code>   */
  private native void dispatch_glMultiTexCoord1s1(int target, short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord1sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1sv"));
    }
        dispatch_glMultiTexCoord1sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord1sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord1svARB</code>   */
  public void glMultiTexCoord1sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1sv"));
    }
        dispatch_glMultiTexCoord1sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2d}(GLenum target, GLdouble s, GLdouble t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2dARB</code>   */
  public void glMultiTexCoord2d(int target, double s, double t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2d"));
    }
        dispatch_glMultiTexCoord2d1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2d}(GLenum target, GLdouble s, GLdouble t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2dARB</code>   */
  private native void dispatch_glMultiTexCoord2d1(int target, double s, double t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord2dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2dv"));
    }
        dispatch_glMultiTexCoord2dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord2dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2dvARB</code>   */
  public void glMultiTexCoord2dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2dv"));
    }
        dispatch_glMultiTexCoord2dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2f}(GLenum target, GLfloat s, GLfloat t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2fARB</code>   */
  public void glMultiTexCoord2f(int target, float s, float t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2f"));
    }
        dispatch_glMultiTexCoord2f1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2f}(GLenum target, GLfloat s, GLfloat t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2fARB</code>   */
  private native void dispatch_glMultiTexCoord2f1(int target, float s, float t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord2fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2fv"));
    }
        dispatch_glMultiTexCoord2fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord2fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2fvARB</code>   */
  public void glMultiTexCoord2fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2fv"));
    }
        dispatch_glMultiTexCoord2fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2i}(GLenum target, GLint s, GLint t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2iARB</code>   */
  public void glMultiTexCoord2i(int target, int s, int t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2i"));
    }
        dispatch_glMultiTexCoord2i1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2i}(GLenum target, GLint s, GLint t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2iARB</code>   */
  private native void dispatch_glMultiTexCoord2i1(int target, int s, int t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord2iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2iv"));
    }
        dispatch_glMultiTexCoord2iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord2iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2ivARB</code>   */
  public void glMultiTexCoord2iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2iv"));
    }
        dispatch_glMultiTexCoord2iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2s}(GLenum target, GLshort s, GLshort t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2sARB</code>   */
  public void glMultiTexCoord2s(int target, short s, short t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2s"));
    }
        dispatch_glMultiTexCoord2s1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2s}(GLenum target, GLshort s, GLshort t) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2sARB</code>   */
  private native void dispatch_glMultiTexCoord2s1(int target, short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord2sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2sv"));
    }
        dispatch_glMultiTexCoord2sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord2sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord2svARB</code>   */
  public void glMultiTexCoord2sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2sv"));
    }
        dispatch_glMultiTexCoord2sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3d}(GLenum target, GLdouble s, GLdouble t, GLdouble r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3dARB</code>   */
  public void glMultiTexCoord3d(int target, double s, double t, double r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3d"));
    }
        dispatch_glMultiTexCoord3d1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3d}(GLenum target, GLdouble s, GLdouble t, GLdouble r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3dARB</code>   */
  private native void dispatch_glMultiTexCoord3d1(int target, double s, double t, double r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord3dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3dv"));
    }
        dispatch_glMultiTexCoord3dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord3dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3dvARB</code>   */
  public void glMultiTexCoord3dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3dv"));
    }
        dispatch_glMultiTexCoord3dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3f}(GLenum target, GLfloat s, GLfloat t, GLfloat r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3fARB</code>   */
  public void glMultiTexCoord3f(int target, float s, float t, float r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3f"));
    }
        dispatch_glMultiTexCoord3f1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3f}(GLenum target, GLfloat s, GLfloat t, GLfloat r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3fARB</code>   */
  private native void dispatch_glMultiTexCoord3f1(int target, float s, float t, float r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord3fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3fv"));
    }
        dispatch_glMultiTexCoord3fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord3fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3fvARB</code>   */
  public void glMultiTexCoord3fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3fv"));
    }
        dispatch_glMultiTexCoord3fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3i}(GLenum target, GLint s, GLint t, GLint r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3iARB</code>   */
  public void glMultiTexCoord3i(int target, int s, int t, int r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3i"));
    }
        dispatch_glMultiTexCoord3i1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3i}(GLenum target, GLint s, GLint t, GLint r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3iARB</code>   */
  private native void dispatch_glMultiTexCoord3i1(int target, int s, int t, int r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord3iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3iv"));
    }
        dispatch_glMultiTexCoord3iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord3iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3ivARB</code>   */
  public void glMultiTexCoord3iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3iv"));
    }
        dispatch_glMultiTexCoord3iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3s}(GLenum target, GLshort s, GLshort t, GLshort r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3sARB</code>   */
  public void glMultiTexCoord3s(int target, short s, short t, short r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3s"));
    }
        dispatch_glMultiTexCoord3s1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3s}(GLenum target, GLshort s, GLshort t, GLshort r) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3sARB</code>   */
  private native void dispatch_glMultiTexCoord3s1(int target, short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord3sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3sv"));
    }
        dispatch_glMultiTexCoord3sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord3sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord3svARB</code>   */
  public void glMultiTexCoord3sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3sv"));
    }
        dispatch_glMultiTexCoord3sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4d}(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4dARB</code>   */
  public void glMultiTexCoord4d(int target, double s, double t, double r, double q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4d"));
    }
        dispatch_glMultiTexCoord4d1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4d}(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4dARB</code>   */
  private native void dispatch_glMultiTexCoord4d1(int target, double s, double t, double r, double q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexCoord4dv(int target, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4dv"));
    }
        dispatch_glMultiTexCoord4dv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexCoord4dv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4dv}(GLenum target, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4dvARB</code>   */
  public void glMultiTexCoord4dv(int target, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4dv"));
    }
        dispatch_glMultiTexCoord4dv1(target, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fARB</code>   */
  public void glMultiTexCoord4f(int target, float s, float t, float r, float q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4f"));
    }
        dispatch_glMultiTexCoord4f1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fARB</code>   */
  private native void dispatch_glMultiTexCoord4f1(int target, float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexCoord4fv(int target, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4fv"));
    }
        dispatch_glMultiTexCoord4fv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexCoord4fv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4fv}(GLenum target, const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fvARB</code>   */
  public void glMultiTexCoord4fv(int target, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4fv"));
    }
        dispatch_glMultiTexCoord4fv1(target, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4i}(GLenum target, GLint s, GLint t, GLint r, GLint q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4iARB</code>   */
  public void glMultiTexCoord4i(int target, int s, int t, int r, int q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4i"));
    }
        dispatch_glMultiTexCoord4i1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4i}(GLenum target, GLint s, GLint t, GLint r, GLint q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4iARB</code>   */
  private native void dispatch_glMultiTexCoord4i1(int target, int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoord4iv(int target, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4iv"));
    }
        dispatch_glMultiTexCoord4iv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoord4iv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4iv}(GLenum target, const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4ivARB</code>   */
  public void glMultiTexCoord4iv(int target, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4iv"));
    }
        dispatch_glMultiTexCoord4iv1(target, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4s}(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4sARB</code>   */
  public void glMultiTexCoord4s(int target, short s, short t, short r, short q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4s"));
    }
        dispatch_glMultiTexCoord4s1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4s}(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4sARB</code>   */
  private native void dispatch_glMultiTexCoord4s1(int target, short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord4sv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4sv"));
    }
        dispatch_glMultiTexCoord4sv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord4sv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4sv}(GLenum target, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4svARB</code>   */
  public void glMultiTexCoord4sv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4sv"));
    }
        dispatch_glMultiTexCoord4sv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixfARB</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadTransposeMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixf"));
    }
        dispatch_glLoadTransposeMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixfARB</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadTransposeMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixfARB</code>   */
  public void glLoadTransposeMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixf"));
    }
        dispatch_glLoadTransposeMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixdARB</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glLoadTransposeMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixd"));
    }
        dispatch_glLoadTransposeMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixdARB</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glLoadTransposeMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glLoadTransposeMatrixdARB</code>   */
  public void glLoadTransposeMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadTransposeMatrixd"));
    }
        dispatch_glLoadTransposeMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixfARB</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultTransposeMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixf"));
    }
        dispatch_glMultTransposeMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixfARB</code>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultTransposeMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixfARB</code>   */
  public void glMultTransposeMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultTransposeMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixf"));
    }
        dispatch_glMultTransposeMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixdARB</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultTransposeMatrixd(DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixd"));
    }
        dispatch_glMultTransposeMatrixd1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixdARB</code>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultTransposeMatrixd1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultTransposeMatrixd}(const GLdouble *  m) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ARB_transpose_matrix</code><br>Alias for: <code>glMultTransposeMatrixdARB</code>   */
  public void glMultTransposeMatrixd(double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultTransposeMatrixd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultTransposeMatrixd"));
    }
        dispatch_glMultTransposeMatrixd1(m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  public void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparate"));
    }
        dispatch_glBlendFuncSeparate1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  private native void dispatch_glBlendFuncSeparate1(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei drawcount) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_multi_draw_arrays</code><br>Alias for: <code>glMultiDrawArraysEXT</code>
      @param first a direct or array-backed {@link java.nio.IntBuffer}
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiDrawArrays(int mode, IntBuffer first, IntBuffer count, int drawcount)  {

    final boolean first_is_direct = Buffers.isDirect(first);
    final boolean count_is_direct = Buffers.isDirect(count);
    final long __addr_ = _pat._addressof_glMultiDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArrays"));
    }
        dispatch_glMultiDrawArrays1(mode, first_is_direct ? first : Buffers.getArray(first), first_is_direct ? Buffers.getDirectBufferByteOffset(first) : Buffers.getIndirectBufferByteOffset(first), first_is_direct, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, drawcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei drawcount) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_multi_draw_arrays</code><br>Alias for: <code>glMultiDrawArraysEXT</code>
      @param first a direct or array-backed {@link java.nio.IntBuffer}
      @param count a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiDrawArrays1(int mode, Object first, int first_byte_offset, boolean first_is_direct, Object count, int count_byte_offset, boolean count_is_direct, int drawcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArrays}(GLenum mode, const GLint *  first, const GLsizei *  count, GLsizei drawcount) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_multi_draw_arrays</code><br>Alias for: <code>glMultiDrawArraysEXT</code>   */
  public void glMultiDrawArrays(int mode, int[] first, int first_offset, int[] count, int count_offset, int drawcount)  {

    if(first != null && first.length <= first_offset)
      throw new GLException("array offset argument \"first_offset\" (" + first_offset + ") equals or exceeds array length (" + first.length + ")");
    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final long __addr_ = _pat._addressof_glMultiDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArrays"));
    }
        dispatch_glMultiDrawArrays1(mode, first, Buffers.SIZEOF_INT * first_offset, false, count, Buffers.SIZEOF_INT * count_offset, false, drawcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElements}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei drawcount) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_multi_draw_arrays</code><br>Alias for: <code>glMultiDrawElementsEXT</code>
      @param count a direct only {@link java.nio.IntBuffer}
      @param indices a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glMultiDrawElements(int mode, IntBuffer count, int type, PointerBuffer indices, int drawcount)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    if (!Buffers.isDirect(indices))
      throw new GLException("Argument \"indices\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glMultiDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElements"));
    }
        dispatch_glMultiDrawElements0(mode, count, Buffers.getDirectBufferByteOffset(count), type, indices != null ? indices.getBuffer() : null, Buffers.getDirectBufferByteOffset(indices), drawcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElements}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei drawcount) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_multi_draw_arrays</code><br>Alias for: <code>glMultiDrawElementsEXT</code>
      @param count a direct only {@link java.nio.IntBuffer}
      @param indices a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glMultiDrawElements0(int mode, Object count, int count_byte_offset, int type, Object indices, int indices_byte_offset, int drawcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code>, <code>GL_SGIS_point_parameters</code><br>Alias for: <code>glPointParameterfEXT</code>, <code>glPointParameterfARB</code>, <code>glPointParameterfSGIS</code>   */
  public void glPointParameterf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glPointParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterf"));
    }
        dispatch_glPointParameterf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code>, <code>GL_SGIS_point_parameters</code><br>Alias for: <code>glPointParameterfEXT</code>, <code>glPointParameterfARB</code>, <code>glPointParameterfSGIS</code>   */
  private native void dispatch_glPointParameterf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPointParameterfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
    }
        dispatch_glPointParameterfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPointParameterfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>   */
  public void glPointParameterfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
    }
        dispatch_glPointParameterfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteri}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_NV_point_sprite</code><br>Alias for: <code>glPointParameteriNV</code>   */
  public void glPointParameteri(int pname, int param)  {

    final long __addr_ = _pat._addressof_glPointParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameteri"));
    }
        dispatch_glPointParameteri1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteri}(GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_NV_point_sprite</code><br>Alias for: <code>glPointParameteriNV</code>   */
  private native void dispatch_glPointParameteri1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_NV_point_sprite</code><br>Alias for: <code>glPointParameterivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPointParameteriv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPointParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameteriv"));
    }
        dispatch_glPointParameteriv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_NV_point_sprite</code><br>Alias for: <code>glPointParameterivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPointParameteriv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameteriv}(GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_NV_point_sprite</code><br>Alias for: <code>glPointParameterivNV</code>   */
  public void glPointParameteriv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPointParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameteriv"));
    }
        dispatch_glPointParameteriv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordf}(GLfloat coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordfEXT</code>   */
  public void glFogCoordf(float coord)  {

    final long __addr_ = _pat._addressof_glFogCoordf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordf"));
    }
        dispatch_glFogCoordf1(coord, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordf}(GLfloat coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordfEXT</code>   */
  private native void dispatch_glFogCoordf1(float coord, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordfvEXT</code>
      @param coord a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogCoordfv(FloatBuffer coord)  {

    final boolean coord_is_direct = Buffers.isDirect(coord);
    final long __addr_ = _pat._addressof_glFogCoordfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordfv"));
    }
        dispatch_glFogCoordfv1(coord_is_direct ? coord : Buffers.getArray(coord), coord_is_direct ? Buffers.getDirectBufferByteOffset(coord) : Buffers.getIndirectBufferByteOffset(coord), coord_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordfvEXT</code>
      @param coord a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogCoordfv1(Object coord, int coord_byte_offset, boolean coord_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordfv}(const GLfloat *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordfvEXT</code>   */
  public void glFogCoordfv(float[] coord, int coord_offset)  {

    if(coord != null && coord.length <= coord_offset)
      throw new GLException("array offset argument \"coord_offset\" (" + coord_offset + ") equals or exceeds array length (" + coord.length + ")");
    final long __addr_ = _pat._addressof_glFogCoordfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordfv"));
    }
        dispatch_glFogCoordfv1(coord, Buffers.SIZEOF_FLOAT * coord_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordd}(GLdouble coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoorddEXT</code>   */
  public void glFogCoordd(double coord)  {

    final long __addr_ = _pat._addressof_glFogCoordd;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordd"));
    }
        dispatch_glFogCoordd1(coord, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordd}(GLdouble coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoorddEXT</code>   */
  private native void dispatch_glFogCoordd1(double coord, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoorddvEXT</code>
      @param coord a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glFogCoorddv(DoubleBuffer coord)  {

    final boolean coord_is_direct = Buffers.isDirect(coord);
    final long __addr_ = _pat._addressof_glFogCoorddv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoorddv"));
    }
        dispatch_glFogCoorddv1(coord_is_direct ? coord : Buffers.getArray(coord), coord_is_direct ? Buffers.getDirectBufferByteOffset(coord) : Buffers.getIndirectBufferByteOffset(coord), coord_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoorddvEXT</code>
      @param coord a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glFogCoorddv1(Object coord, int coord_byte_offset, boolean coord_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoorddv}(const GLdouble *  coord) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoorddvEXT</code>   */
  public void glFogCoorddv(double[] coord, int coord_offset)  {

    if(coord != null && coord.length <= coord_offset)
      throw new GLException("array offset argument \"coord_offset\" (" + coord_offset + ") equals or exceeds array length (" + coord.length + ")");
    final long __addr_ = _pat._addressof_glFogCoorddv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoorddv"));
    }
        dispatch_glFogCoorddv1(coord, Buffers.SIZEOF_DOUBLE * coord_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glFogCoordPointer(int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glFogCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordPointer"));
    }
        dispatch_glFogCoordPointer0(type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glFogCoordPointer0(int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordPointerEXT</code>   */
  public void glFogCoordPointer(int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glFogCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordPointer"));
    }
        dispatch_glFogCoordPointer0(type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordPointer}(GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_fog_coord</code><br>Alias for: <code>glFogCoordPointerEXT</code>   */
  private native void dispatch_glFogCoordPointer0(int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3b}(GLbyte red, GLbyte green, GLbyte blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3bEXT</code>   */
  public void glSecondaryColor3b(byte red, byte green, byte blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3b;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3b"));
    }
        dispatch_glSecondaryColor3b1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3b}(GLbyte red, GLbyte green, GLbyte blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3bEXT</code>   */
  private native void dispatch_glSecondaryColor3b1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3bvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glSecondaryColor3bv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3bv"));
    }
        dispatch_glSecondaryColor3bv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3bvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glSecondaryColor3bv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3bv}(const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3bvEXT</code>   */
  public void glSecondaryColor3bv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3bv"));
    }
        dispatch_glSecondaryColor3bv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3d}(GLdouble red, GLdouble green, GLdouble blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3dEXT</code>   */
  public void glSecondaryColor3d(double red, double green, double blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3d"));
    }
        dispatch_glSecondaryColor3d1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3d}(GLdouble red, GLdouble green, GLdouble blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3dEXT</code>   */
  private native void dispatch_glSecondaryColor3d1(double red, double green, double blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glSecondaryColor3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3dv"));
    }
        dispatch_glSecondaryColor3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glSecondaryColor3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3dvEXT</code>   */
  public void glSecondaryColor3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3dv"));
    }
        dispatch_glSecondaryColor3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3f}(GLfloat red, GLfloat green, GLfloat blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3fEXT</code>   */
  public void glSecondaryColor3f(float red, float green, float blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3f"));
    }
        dispatch_glSecondaryColor3f1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3f}(GLfloat red, GLfloat green, GLfloat blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3fEXT</code>   */
  private native void dispatch_glSecondaryColor3f1(float red, float green, float blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3fvEXT</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSecondaryColor3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3fv"));
    }
        dispatch_glSecondaryColor3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3fvEXT</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSecondaryColor3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3fvEXT</code>   */
  public void glSecondaryColor3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3fv"));
    }
        dispatch_glSecondaryColor3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3i}(GLint red, GLint green, GLint blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3iEXT</code>   */
  public void glSecondaryColor3i(int red, int green, int blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3i"));
    }
        dispatch_glSecondaryColor3i1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3i}(GLint red, GLint green, GLint blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3iEXT</code>   */
  private native void dispatch_glSecondaryColor3i1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColor3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3iv"));
    }
        dispatch_glSecondaryColor3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColor3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ivEXT</code>   */
  public void glSecondaryColor3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3iv"));
    }
        dispatch_glSecondaryColor3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3s}(GLshort red, GLshort green, GLshort blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3sEXT</code>   */
  public void glSecondaryColor3s(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3s"));
    }
        dispatch_glSecondaryColor3s1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3s}(GLshort red, GLshort green, GLshort blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3sEXT</code>   */
  private native void dispatch_glSecondaryColor3s1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3svEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3sv"));
    }
        dispatch_glSecondaryColor3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3svEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3svEXT</code>   */
  public void glSecondaryColor3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3sv"));
    }
        dispatch_glSecondaryColor3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ub}(GLubyte red, GLubyte green, GLubyte blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ubEXT</code>   */
  public void glSecondaryColor3ub(byte red, byte green, byte blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3ub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ub"));
    }
        dispatch_glSecondaryColor3ub1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ub}(GLubyte red, GLubyte green, GLubyte blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ubEXT</code>   */
  private native void dispatch_glSecondaryColor3ub1(byte red, byte green, byte blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ubvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glSecondaryColor3ubv(ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ubv"));
    }
        dispatch_glSecondaryColor3ubv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ubvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glSecondaryColor3ubv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ubv}(const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3ubvEXT</code>   */
  public void glSecondaryColor3ubv(byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ubv"));
    }
        dispatch_glSecondaryColor3ubv1(v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ui}(GLuint red, GLuint green, GLuint blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3uiEXT</code>   */
  public void glSecondaryColor3ui(int red, int green, int blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3ui"));
    }
        dispatch_glSecondaryColor3ui1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3ui}(GLuint red, GLuint green, GLuint blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3uiEXT</code>   */
  private native void dispatch_glSecondaryColor3ui1(int red, int green, int blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColor3uiv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3uiv"));
    }
        dispatch_glSecondaryColor3uiv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColor3uiv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3uiv}(const GLuint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3uivEXT</code>   */
  public void glSecondaryColor3uiv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3uiv"));
    }
        dispatch_glSecondaryColor3uiv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3us}(GLushort red, GLushort green, GLushort blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3usEXT</code>   */
  public void glSecondaryColor3us(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3us;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3us"));
    }
        dispatch_glSecondaryColor3us1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3us}(GLushort red, GLushort green, GLushort blue) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3usEXT</code>   */
  private native void dispatch_glSecondaryColor3us1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3usvEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3usv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3usv"));
    }
        dispatch_glSecondaryColor3usv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3usvEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3usv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3usv}(const GLushort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColor3usvEXT</code>   */
  public void glSecondaryColor3usv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3usv"));
    }
        dispatch_glSecondaryColor3usv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColorPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glSecondaryColorPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glSecondaryColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorPointer"));
    }
        dispatch_glSecondaryColorPointer0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColorPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glSecondaryColorPointer0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColorPointerEXT</code>   */
  public void glSecondaryColorPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glSecondaryColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorPointer"));
    }
        dispatch_glSecondaryColorPointer0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorPointer}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_EXT_secondary_color</code><br>Alias for: <code>glSecondaryColorPointerEXT</code>   */
  private native void dispatch_glSecondaryColorPointer0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2dMESA</code>, <code>glWindowPos2dARB</code>   */
  public void glWindowPos2d(double x, double y)  {

    final long __addr_ = _pat._addressof_glWindowPos2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2d"));
    }
        dispatch_glWindowPos2d1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2d}(GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2dMESA</code>, <code>glWindowPos2dARB</code>   */
  private native void dispatch_glWindowPos2d1(double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2dvMESA</code>, <code>glWindowPos2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWindowPos2dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2dv"));
    }
        dispatch_glWindowPos2dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2dvMESA</code>, <code>glWindowPos2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWindowPos2dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2dvMESA</code>, <code>glWindowPos2dvARB</code>   */
  public void glWindowPos2dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2dv"));
    }
        dispatch_glWindowPos2dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2fARB</code>, <code>glWindowPos2fMESA</code>   */
  public void glWindowPos2f(float x, float y)  {

    final long __addr_ = _pat._addressof_glWindowPos2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2f"));
    }
        dispatch_glWindowPos2f1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2f}(GLfloat x, GLfloat y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2fARB</code>, <code>glWindowPos2fMESA</code>   */
  private native void dispatch_glWindowPos2f1(float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2fvMESA</code>, <code>glWindowPos2fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWindowPos2fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2fv"));
    }
        dispatch_glWindowPos2fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2fvMESA</code>, <code>glWindowPos2fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWindowPos2fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2fvMESA</code>, <code>glWindowPos2fvARB</code>   */
  public void glWindowPos2fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2fv"));
    }
        dispatch_glWindowPos2fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2iMESA</code>, <code>glWindowPos2iARB</code>   */
  public void glWindowPos2i(int x, int y)  {

    final long __addr_ = _pat._addressof_glWindowPos2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2i"));
    }
        dispatch_glWindowPos2i1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2i}(GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2iMESA</code>, <code>glWindowPos2iARB</code>   */
  private native void dispatch_glWindowPos2i1(int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2ivARB</code>, <code>glWindowPos2ivMESA</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWindowPos2iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2iv"));
    }
        dispatch_glWindowPos2iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2ivARB</code>, <code>glWindowPos2ivMESA</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWindowPos2iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2ivARB</code>, <code>glWindowPos2ivMESA</code>   */
  public void glWindowPos2iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2iv"));
    }
        dispatch_glWindowPos2iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2sMESA</code>, <code>glWindowPos2sARB</code>   */
  public void glWindowPos2s(short x, short y)  {

    final long __addr_ = _pat._addressof_glWindowPos2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2s"));
    }
        dispatch_glWindowPos2s1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2s}(GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos2sMESA</code>, <code>glWindowPos2sARB</code>   */
  private native void dispatch_glWindowPos2s1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2svARB</code>, <code>glWindowPos2svMESA</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWindowPos2sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2sv"));
    }
        dispatch_glWindowPos2sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2svARB</code>, <code>glWindowPos2svMESA</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWindowPos2sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos2sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos2svARB</code>, <code>glWindowPos2svMESA</code>   */
  public void glWindowPos2sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos2sv"));
    }
        dispatch_glWindowPos2sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos3dMESA</code>, <code>glWindowPos3dARB</code>   */
  public void glWindowPos3d(double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glWindowPos3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3d"));
    }
        dispatch_glWindowPos3d1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3d}(GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos3dMESA</code>, <code>glWindowPos3dARB</code>   */
  private native void dispatch_glWindowPos3d1(double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3dvARB</code>, <code>glWindowPos3dvMESA</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWindowPos3dv(DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3dv"));
    }
        dispatch_glWindowPos3dv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3dvARB</code>, <code>glWindowPos3dvMESA</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWindowPos3dv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3dv}(const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3dvARB</code>, <code>glWindowPos3dvMESA</code>   */
  public void glWindowPos3dv(double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3dv"));
    }
        dispatch_glWindowPos3dv1(v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3fARB</code>, <code>glWindowPos3fMESA</code>   */
  public void glWindowPos3f(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glWindowPos3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3f"));
    }
        dispatch_glWindowPos3f1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3f}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3fARB</code>, <code>glWindowPos3fMESA</code>   */
  private native void dispatch_glWindowPos3f1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos3fvMESA</code>, <code>glWindowPos3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWindowPos3fv(FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3fv"));
    }
        dispatch_glWindowPos3fv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos3fvMESA</code>, <code>glWindowPos3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWindowPos3fv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3fv}(const GLfloat *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_MESA_window_pos</code>, <code>GL_ARB_window_pos</code><br>Alias for: <code>glWindowPos3fvMESA</code>, <code>glWindowPos3fvARB</code>   */
  public void glWindowPos3fv(float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3fv"));
    }
        dispatch_glWindowPos3fv1(v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3iARB</code>, <code>glWindowPos3iMESA</code>   */
  public void glWindowPos3i(int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glWindowPos3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3i"));
    }
        dispatch_glWindowPos3i1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3i}(GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3iARB</code>, <code>glWindowPos3iMESA</code>   */
  private native void dispatch_glWindowPos3i1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3ivARB</code>, <code>glWindowPos3ivMESA</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWindowPos3iv(IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3iv"));
    }
        dispatch_glWindowPos3iv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3ivARB</code>, <code>glWindowPos3ivMESA</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWindowPos3iv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3iv}(const GLint *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3ivARB</code>, <code>glWindowPos3ivMESA</code>   */
  public void glWindowPos3iv(int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3iv"));
    }
        dispatch_glWindowPos3iv1(v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3sARB</code>, <code>glWindowPos3sMESA</code>   */
  public void glWindowPos3s(short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glWindowPos3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3s"));
    }
        dispatch_glWindowPos3s1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3s}(GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3sARB</code>, <code>glWindowPos3sMESA</code>   */
  private native void dispatch_glWindowPos3s1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3svARB</code>, <code>glWindowPos3svMESA</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWindowPos3sv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glWindowPos3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3sv"));
    }
        dispatch_glWindowPos3sv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3svARB</code>, <code>glWindowPos3svMESA</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWindowPos3sv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWindowPos3sv}(const GLshort *  v) </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ARB_window_pos</code>, <code>GL_MESA_window_pos</code><br>Alias for: <code>glWindowPos3svARB</code>, <code>glWindowPos3svMESA</code>   */
  public void glWindowPos3sv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glWindowPos3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWindowPos3sv"));
    }
        dispatch_glWindowPos3sv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_blend_color</code><br>Alias for: <code>glBlendColorEXT</code>   */
  public void glBlendColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glBlendColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendColor"));
    }
        dispatch_glBlendColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_blend_color</code><br>Alias for: <code>glBlendColorEXT</code>   */
  private native void dispatch_glBlendColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquation"));
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  private native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGenQueriesARB</code>, <code>glGenQueriesEXT</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGenQueriesARB</code>, <code>glGenQueriesEXT</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGenQueriesARB</code>, <code>glGenQueriesEXT</code>   */
  public void glGenQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glDeleteQueriesARB</code>, <code>glDeleteQueriesEXT</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glDeleteQueriesARB</code>, <code>glDeleteQueriesEXT</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glDeleteQueriesARB</code>, <code>glDeleteQueriesEXT</code>   */
  public void glDeleteQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glIsQueryARB</code>, <code>glIsQueryEXT</code>   */
  public boolean glIsQuery(int id)  {

    final long __addr_ = _pat._addressof_glIsQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsQuery"));
    }
        return dispatch_glIsQuery1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glIsQueryARB</code>, <code>glIsQueryEXT</code>   */
  private native boolean dispatch_glIsQuery1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glBeginQueryARB</code>, <code>glBeginQueryEXT</code>   */
  public void glBeginQuery(int target, int id)  {

    final long __addr_ = _pat._addressof_glBeginQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginQuery"));
    }
        dispatch_glBeginQuery1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glBeginQueryARB</code>, <code>glBeginQueryEXT</code>   */
  private native void dispatch_glBeginQuery1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glEndQueryARB</code>, <code>glEndQueryEXT</code>   */
  public void glEndQuery(int target)  {

    final long __addr_ = _pat._addressof_glEndQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndQuery"));
    }
        dispatch_glEndQuery1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glEndQueryARB</code>, <code>glEndQueryEXT</code>   */
  private native void dispatch_glEndQuery1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryivARB</code>, <code>glGetQueryivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryivARB</code>, <code>glGetQueryivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryivARB</code>, <code>glGetQueryivEXT</code>   */
  public void glGetQueryiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
    }
        dispatch_glGetQueryObjectiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>   */
  public void glGetQueryObjectiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
    }
        dispatch_glGetQueryObjectiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectuivARB</code>, <code>glGetQueryObjectuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectuiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectuivARB</code>, <code>glGetQueryObjectuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectuiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectuivARB</code>, <code>glGetQueryObjectuivEXT</code>   */
  public void glGetQueryObjectuiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = _pat._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffer"));
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers);
    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers, buffers_offset);
    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = _pat._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsBuffer"));
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  private native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glBufferDataDelegate(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferData"));
    }
        dispatch_glBufferDataDelegate1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glBufferDataDelegate1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferSubData"));
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferSubDataARB</code>
      @param data a direct only {@link java.nio.Buffer}   */
  public void glGetBufferSubData(int target, long offset, long size, Buffer data)  {

    if (!Buffers.isDirect(data))
      throw new GLException("Argument \"data\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glGetBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferSubData"));
    }
        dispatch_glGetBufferSubData0(target, offset, size, data, Buffers.getDirectBufferByteOffset(data), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferSubDataARB</code>
      @param data a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glGetBufferSubData0(int target, long offset, long size, Object data, int data_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private long glMapBufferDelegate(int target, int access)  {

    final long __addr_ = _pat._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBuffer"));
    }
        return dispatch_glMapBufferDelegate1(target, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private native long dispatch_glMapBufferDelegate1(int target, int access, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private boolean glUnmapBufferDelegate(int target)  {

    final long __addr_ = _pat._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapBuffer"));
    }
        return dispatch_glUnmapBufferDelegate1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private native boolean dispatch_glUnmapBufferDelegate1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparate"));
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  private native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersARB</code>, <code>glDrawBuffersEXT</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffers(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = _pat._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersARB</code>, <code>glDrawBuffersEXT</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffers1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersARB</code>, <code>glDrawBuffersEXT</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>   */
  public void glDrawBuffers(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = _pat._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilOpSeparateATI</code>   */
  public void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass)  {

    final long __addr_ = _pat._addressof_glStencilOpSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOpSeparate"));
    }
        dispatch_glStencilOpSeparate1(face, sfail, dpfail, dppass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilOpSeparateATI</code>   */
  private native void dispatch_glStencilOpSeparate1(int face, int sfail, int dpfail, int dppass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilFuncSeparateATI</code>   */
  public void glStencilFuncSeparate(int face, int func, int ref, int mask)  {

    final long __addr_ = _pat._addressof_glStencilFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFuncSeparate"));
    }
        dispatch_glStencilFuncSeparate1(face, func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilFuncSeparateATI</code>   */
  private native void dispatch_glStencilFuncSeparate1(int face, int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glStencilMaskSeparate(int face, int mask)  {

    final long __addr_ = _pat._addressof_glStencilMaskSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMaskSeparate"));
    }
        dispatch_glStencilMaskSeparate1(face, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glStencilMaskSeparate1(int face, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glAttachShader(int program, int shader)  {

    final long __addr_ = _pat._addressof_glAttachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAttachShader"));
    }
        dispatch_glAttachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glAttachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glBindAttribLocationARB</code>   */
  public void glBindAttribLocation(int program, int index, String name)  {

    final long __addr_ = _pat._addressof_glBindAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindAttribLocation"));
    }
        dispatch_glBindAttribLocation1(program, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glBindAttribLocationARB</code>   */
  private native void dispatch_glBindAttribLocation1(int program, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glCompileShaderARB</code>   */
  public void glCompileShader(int shader)  {

    final long __addr_ = _pat._addressof_glCompileShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShader"));
    }
        dispatch_glCompileShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glCompileShaderARB</code>   */
  private native void dispatch_glCompileShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public int glCreateProgram()  {

    final long __addr_ = _pat._addressof_glCreateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgram"));
    }
        return dispatch_glCreateProgram1(__addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native int dispatch_glCreateProgram1(long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public int glCreateShader(int type)  {

    final long __addr_ = _pat._addressof_glCreateShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShader"));
    }
        return dispatch_glCreateShader1(type, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native int dispatch_glCreateShader1(int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDeleteProgram(int program)  {

    final long __addr_ = _pat._addressof_glDeleteProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgram"));
    }
        dispatch_glDeleteProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDeleteProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDeleteShader(int shader)  {

    final long __addr_ = _pat._addressof_glDeleteShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteShader"));
    }
        dispatch_glDeleteShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDeleteShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDetachShader(int program, int shader)  {

    final long __addr_ = _pat._addressof_glDetachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDetachShader"));
    }
        dispatch_glDetachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDetachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glDisableVertexAttribArrayARB</code>   */
  public void glDisableVertexAttribArray(int index)  {

    final long __addr_ = _pat._addressof_glDisableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArray"));
    }
        dispatch_glDisableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glDisableVertexAttribArrayARB</code>   */
  private native void dispatch_glDisableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glEnableVertexAttribArrayARB</code>   */
  public void glEnableVertexAttribArray(int index)  {

    final long __addr_ = _pat._addressof_glEnableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArray"));
    }
        dispatch_glEnableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glEnableVertexAttribArrayARB</code>   */
  private native void dispatch_glEnableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveAttrib(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveAttrib1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>   */
  public void glGetActiveAttrib(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniform(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniform1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>   */
  public void glGetActiveUniform(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final long __addr_ = _pat._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedShaders1(int program, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetAttachedShaders(int program, int maxCount, int[] count, int count_offset, int[] shaders, int shaders_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final long __addr_ = _pat._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, shaders, Buffers.SIZEOF_INT * shaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetAttribLocationARB</code>   */
  public int glGetAttribLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttribLocation"));
    }
        return dispatch_glGetAttribLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetAttribLocationARB</code>   */
  private native int dispatch_glGetAttribLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>   */
  public void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramInfoLog(int program, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramInfoLog1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetProgramInfoLog(int program, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderInfoLog(int shader, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderInfoLog1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetShaderInfoLog(int shader, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSource(int shader, int bufSize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = _pat._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSource1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>   */
  public void glGetShaderSource(int shader, int bufSize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformLocationARB</code>   */
  public int glGetUniformLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetUniformLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocation"));
    }
        return dispatch_glGetUniformLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformLocationARB</code>   */
  private native int dispatch_glGetUniformLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>   */
  public void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>   */
  public void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribdvARB</code>, <code>glGetVertexAttribdvNV</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribdv(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdv"));
    }
        dispatch_glGetVertexAttribdv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribdvARB</code>, <code>glGetVertexAttribdvNV</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribdv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribdvARB</code>, <code>glGetVertexAttribdvNV</code>   */
  public void glGetVertexAttribdv(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdv"));
    }
        dispatch_glGetVertexAttribdv1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>   */
  public void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>   */
  public void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glIsProgramARB</code>, <code>glIsProgramNV</code>   */
  public boolean glIsProgram(int program)  {

    final long __addr_ = _pat._addressof_glIsProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgram"));
    }
        return dispatch_glIsProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glIsProgramARB</code>, <code>glIsProgramNV</code>   */
  private native boolean dispatch_glIsProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public boolean glIsShader(int shader)  {

    final long __addr_ = _pat._addressof_glIsShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsShader"));
    }
        return dispatch_glIsShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native boolean dispatch_glIsShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glLinkProgramARB</code>   */
  public void glLinkProgram(int program)  {

    final long __addr_ = _pat._addressof_glLinkProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLinkProgram"));
    }
        dispatch_glLinkProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glLinkProgramARB</code>   */
  private native void dispatch_glLinkProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSource(int shader, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSource1(int shader, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>   */
  public void glShaderSource(int shader, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glUseProgram(int program)  {

    final long __addr_ = _pat._addressof_glUseProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgram"));
    }
        dispatch_glUseProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glUseProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fARB</code>   */
  public void glUniform1f(int location, float v0)  {

    final long __addr_ = _pat._addressof_glUniform1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1f"));
    }
        dispatch_glUniform1f1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fARB</code>   */
  private native void dispatch_glUniform1f1(int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fARB</code>   */
  public void glUniform2f(int location, float v0, float v1)  {

    final long __addr_ = _pat._addressof_glUniform2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2f"));
    }
        dispatch_glUniform2f1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fARB</code>   */
  private native void dispatch_glUniform2f1(int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fARB</code>   */
  public void glUniform3f(int location, float v0, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glUniform3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3f"));
    }
        dispatch_glUniform3f1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fARB</code>   */
  private native void dispatch_glUniform3f1(int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fARB</code>   */
  public void glUniform4f(int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = _pat._addressof_glUniform4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4f"));
    }
        dispatch_glUniform4f1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fARB</code>   */
  private native void dispatch_glUniform4f1(int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1iARB</code>   */
  public void glUniform1i(int location, int v0)  {

    final long __addr_ = _pat._addressof_glUniform1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i"));
    }
        dispatch_glUniform1i1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1iARB</code>   */
  private native void dispatch_glUniform1i1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2iARB</code>   */
  public void glUniform2i(int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glUniform2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i"));
    }
        dispatch_glUniform2i1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2iARB</code>   */
  private native void dispatch_glUniform2i1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3iARB</code>   */
  public void glUniform3i(int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glUniform3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i"));
    }
        dispatch_glUniform3i1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3iARB</code>   */
  private native void dispatch_glUniform3i1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4iARB</code>   */
  public void glUniform4i(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glUniform4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i"));
    }
        dispatch_glUniform4i1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4iARB</code>   */
  private native void dispatch_glUniform4i1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>   */
  public void glUniform1fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>   */
  public void glUniform2fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>   */
  public void glUniform3fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>   */
  public void glUniform4fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>   */
  public void glUniform1iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>   */
  public void glUniform2iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>   */
  public void glUniform3iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>   */
  public void glUniform4iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glValidateProgramARB</code>   */
  public void glValidateProgram(int program)  {

    final long __addr_ = _pat._addressof_glValidateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgram"));
    }
        dispatch_glValidateProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glValidateProgramARB</code>   */
  private native void dispatch_glValidateProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1d}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1dNV</code>, <code>glVertexAttrib1dARB</code>   */
  public void glVertexAttrib1d(int index, double x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1d"));
    }
        dispatch_glVertexAttrib1d1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1d}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1dNV</code>, <code>glVertexAttrib1dARB</code>   */
  private native void dispatch_glVertexAttrib1d1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1dvARB</code>, <code>glVertexAttrib1dvNV</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib1dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dv"));
    }
        dispatch_glVertexAttrib1dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1dvARB</code>, <code>glVertexAttrib1dvNV</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib1dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1dvARB</code>, <code>glVertexAttrib1dvNV</code>   */
  public void glVertexAttrib1dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dv"));
    }
        dispatch_glVertexAttrib1dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1fARB</code>, <code>glVertexAttrib1fNV</code>   */
  public void glVertexAttrib1f(int index, float x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1f"));
    }
        dispatch_glVertexAttrib1f1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1fARB</code>, <code>glVertexAttrib1fNV</code>   */
  private native void dispatch_glVertexAttrib1f1(int index, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>   */
  public void glVertexAttrib1fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1s}(GLuint index, GLshort x) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1sNV</code>, <code>glVertexAttrib1sARB</code>   */
  public void glVertexAttrib1s(int index, short x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1s"));
    }
        dispatch_glVertexAttrib1s1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1s}(GLuint index, GLshort x) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1sNV</code>, <code>glVertexAttrib1sARB</code>   */
  private native void dispatch_glVertexAttrib1s1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1svARB</code>, <code>glVertexAttrib1svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sv"));
    }
        dispatch_glVertexAttrib1sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1svARB</code>, <code>glVertexAttrib1svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1svARB</code>, <code>glVertexAttrib1svNV</code>   */
  public void glVertexAttrib1sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sv"));
    }
        dispatch_glVertexAttrib1sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2d}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2dARB</code>, <code>glVertexAttrib2dNV</code>   */
  public void glVertexAttrib2d(int index, double x, double y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2d"));
    }
        dispatch_glVertexAttrib2d1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2d}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2dARB</code>, <code>glVertexAttrib2dNV</code>   */
  private native void dispatch_glVertexAttrib2d1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib2dvNV</code>, <code>glVertexAttrib2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib2dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dv"));
    }
        dispatch_glVertexAttrib2dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib2dvNV</code>, <code>glVertexAttrib2dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib2dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib2dvNV</code>, <code>glVertexAttrib2dvARB</code>   */
  public void glVertexAttrib2dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dv"));
    }
        dispatch_glVertexAttrib2dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fARB</code>, <code>glVertexAttrib2fNV</code>   */
  public void glVertexAttrib2f(int index, float x, float y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2f"));
    }
        dispatch_glVertexAttrib2f1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fARB</code>, <code>glVertexAttrib2fNV</code>   */
  private native void dispatch_glVertexAttrib2f1(int index, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>   */
  public void glVertexAttrib2fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2s}(GLuint index, GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib2sNV</code>, <code>glVertexAttrib2sARB</code>   */
  public void glVertexAttrib2s(int index, short x, short y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2s"));
    }
        dispatch_glVertexAttrib2s1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2s}(GLuint index, GLshort x, GLshort y) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib2sNV</code>, <code>glVertexAttrib2sARB</code>   */
  private native void dispatch_glVertexAttrib2s1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2svARB</code>, <code>glVertexAttrib2svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sv"));
    }
        dispatch_glVertexAttrib2sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2svARB</code>, <code>glVertexAttrib2svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2svARB</code>, <code>glVertexAttrib2svNV</code>   */
  public void glVertexAttrib2sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sv"));
    }
        dispatch_glVertexAttrib2sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3dARB</code>, <code>glVertexAttrib3dNV</code>   */
  public void glVertexAttrib3d(int index, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3d"));
    }
        dispatch_glVertexAttrib3d1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3dARB</code>, <code>glVertexAttrib3dNV</code>   */
  private native void dispatch_glVertexAttrib3d1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3dvNV</code>, <code>glVertexAttrib3dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib3dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dv"));
    }
        dispatch_glVertexAttrib3dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3dvNV</code>, <code>glVertexAttrib3dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib3dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3dvNV</code>, <code>glVertexAttrib3dvARB</code>   */
  public void glVertexAttrib3dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dv"));
    }
        dispatch_glVertexAttrib3dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3fARB</code>, <code>glVertexAttrib3fNV</code>   */
  public void glVertexAttrib3f(int index, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3f"));
    }
        dispatch_glVertexAttrib3f1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3fARB</code>, <code>glVertexAttrib3fNV</code>   */
  private native void dispatch_glVertexAttrib3f1(int index, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>   */
  public void glVertexAttrib3fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3s}(GLuint index, GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3sNV</code>, <code>glVertexAttrib3sARB</code>   */
  public void glVertexAttrib3s(int index, short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3s"));
    }
        dispatch_glVertexAttrib3s1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3s}(GLuint index, GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3sNV</code>, <code>glVertexAttrib3sARB</code>   */
  private native void dispatch_glVertexAttrib3s1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3svARB</code>, <code>glVertexAttrib3svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sv"));
    }
        dispatch_glVertexAttrib3sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3svARB</code>, <code>glVertexAttrib3svNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3svARB</code>, <code>glVertexAttrib3svNV</code>   */
  public void glVertexAttrib3sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sv"));
    }
        dispatch_glVertexAttrib3sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NbvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4Nbv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Nbv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nbv"));
    }
        dispatch_glVertexAttrib4Nbv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NbvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4Nbv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nbv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NbvARB</code>   */
  public void glVertexAttrib4Nbv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Nbv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nbv"));
    }
        dispatch_glVertexAttrib4Nbv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4Niv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Niv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Niv"));
    }
        dispatch_glVertexAttrib4Niv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4Niv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Niv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NivARB</code>   */
  public void glVertexAttrib4Niv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Niv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Niv"));
    }
        dispatch_glVertexAttrib4Niv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NsvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4Nsv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Nsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nsv"));
    }
        dispatch_glVertexAttrib4Nsv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NsvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4Nsv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nsv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NsvARB</code>   */
  public void glVertexAttrib4Nsv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Nsv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nsv"));
    }
        dispatch_glVertexAttrib4Nsv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nub}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NubARB</code>   */
  public void glVertexAttrib4Nub(int index, byte x, byte y, byte z, byte w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4Nub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nub"));
    }
        dispatch_glVertexAttrib4Nub1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nub}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NubARB</code>   */
  private native void dispatch_glVertexAttrib4Nub1(int index, byte x, byte y, byte z, byte w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NubvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4Nubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Nubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nubv"));
    }
        dispatch_glVertexAttrib4Nubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NubvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4Nubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NubvARB</code>   */
  public void glVertexAttrib4Nubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Nubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nubv"));
    }
        dispatch_glVertexAttrib4Nubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NuivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4Nuiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Nuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nuiv"));
    }
        dispatch_glVertexAttrib4Nuiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NuivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4Nuiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nuiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NuivARB</code>   */
  public void glVertexAttrib4Nuiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Nuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nuiv"));
    }
        dispatch_glVertexAttrib4Nuiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NusvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4Nusv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4Nusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nusv"));
    }
        dispatch_glVertexAttrib4Nusv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NusvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4Nusv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4Nusv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4NusvARB</code>   */
  public void glVertexAttrib4Nusv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4Nusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4Nusv"));
    }
        dispatch_glVertexAttrib4Nusv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4bvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4bv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bv"));
    }
        dispatch_glVertexAttrib4bv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4bvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4bv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4bvARB</code>   */
  public void glVertexAttrib4bv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bv"));
    }
        dispatch_glVertexAttrib4bv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4dNV</code>, <code>glVertexAttrib4dARB</code>   */
  public void glVertexAttrib4d(int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4d"));
    }
        dispatch_glVertexAttrib4d1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4dNV</code>, <code>glVertexAttrib4dARB</code>   */
  private native void dispatch_glVertexAttrib4d1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4dvNV</code>, <code>glVertexAttrib4dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib4dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dv"));
    }
        dispatch_glVertexAttrib4dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4dvNV</code>, <code>glVertexAttrib4dvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib4dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4dvNV</code>, <code>glVertexAttrib4dvARB</code>   */
  public void glVertexAttrib4dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dv"));
    }
        dispatch_glVertexAttrib4dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fNV</code>, <code>glVertexAttrib4fARB</code>   */
  public void glVertexAttrib4f(int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4f"));
    }
        dispatch_glVertexAttrib4f1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fNV</code>, <code>glVertexAttrib4fARB</code>   */
  private native void dispatch_glVertexAttrib4f1(int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>   */
  public void glVertexAttrib4fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4iv"));
    }
        dispatch_glVertexAttrib4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ivARB</code>   */
  public void glVertexAttrib4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4iv"));
    }
        dispatch_glVertexAttrib4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4s}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4sNV</code>, <code>glVertexAttrib4sARB</code>   */
  public void glVertexAttrib4s(int index, short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4s;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4s"));
    }
        dispatch_glVertexAttrib4s1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4s}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4sNV</code>, <code>glVertexAttrib4sARB</code>   */
  private native void dispatch_glVertexAttrib4s1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4svNV</code>, <code>glVertexAttrib4svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sv"));
    }
        dispatch_glVertexAttrib4sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4svNV</code>, <code>glVertexAttrib4svARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4svNV</code>, <code>glVertexAttrib4svARB</code>   */
  public void glVertexAttrib4sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sv"));
    }
        dispatch_glVertexAttrib4sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ubvNV</code>, <code>glVertexAttrib4ubvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4ubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubv"));
    }
        dispatch_glVertexAttrib4ubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ubvNV</code>, <code>glVertexAttrib4ubvARB</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4ubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4ubvNV</code>, <code>glVertexAttrib4ubvARB</code>   */
  public void glVertexAttrib4ubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubv"));
    }
        dispatch_glVertexAttrib4ubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4uivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uiv"));
    }
        dispatch_glVertexAttrib4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4uivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4uivARB</code>   */
  public void glVertexAttrib4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uiv"));
    }
        dispatch_glVertexAttrib4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4usvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4usv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usv"));
    }
        dispatch_glVertexAttrib4usv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4usvARB</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4usv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4usvARB</code>   */
  public void glVertexAttrib4usv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usv"));
    }
        dispatch_glVertexAttrib4usv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(index, size, type, normalized, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointer0(int index, int size, int type, boolean normalized, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(index, size, type, normalized, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>   */
  private native void dispatch_glVertexAttribPointer0(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glColorMaskiEXT</code>, <code>glColorMaskiOES</code>   */
  public void glColorMaski(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = _pat._addressof_glColorMaski;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaski"));
    }
        dispatch_glColorMaski1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glColorMaskiEXT</code>, <code>glColorMaskiOES</code>   */
  private native void dispatch_glColorMaski1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleani_v(int target, int index, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
    }
        dispatch_glGetBooleani_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleani_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glGetBooleani_v(int target, int index, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
    }
        dispatch_glGetBooleani_v1(target, index, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_v(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>   */
  public void glGetIntegeri_v(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_viewport_array</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glEnableiNV</code>, <code>glEnableiOES</code>, <code>glEnableiEXT</code>   */
  public void glEnablei(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnablei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnablei"));
    }
        dispatch_glEnablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_viewport_array</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glEnableiNV</code>, <code>glEnableiOES</code>, <code>glEnableiEXT</code>   */
  private native void dispatch_glEnablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glDisableiOES</code>, <code>glDisableiNV</code>, <code>glDisableiEXT</code>   */
  public void glDisablei(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisablei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisablei"));
    }
        dispatch_glDisablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glDisableiOES</code>, <code>glDisableiNV</code>, <code>glDisableiEXT</code>   */
  private native void dispatch_glDisablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glIsEnablediOES</code>, <code>glIsEnablediNV</code>, <code>glIsEnablediEXT</code>   */
  public boolean glIsEnabledi(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnabledi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabledi"));
    }
        return dispatch_glIsEnabledi1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glIsEnablediOES</code>, <code>glIsEnablediNV</code>, <code>glIsEnablediEXT</code>   */
  private native boolean dispatch_glIsEnabledi1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glBeginTransformFeedbackEXT</code>, <code>glBeginTransformFeedbackNV</code>   */
  public void glBeginTransformFeedback(int primitiveMode)  {

    final long __addr_ = _pat._addressof_glBeginTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginTransformFeedback"));
    }
        dispatch_glBeginTransformFeedback1(primitiveMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glBeginTransformFeedbackEXT</code>, <code>glBeginTransformFeedbackNV</code>   */
  private native void dispatch_glBeginTransformFeedback1(int primitiveMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glEndTransformFeedbackNV</code>, <code>glEndTransformFeedbackEXT</code>   */
  public void glEndTransformFeedback()  {

    final long __addr_ = _pat._addressof_glEndTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTransformFeedback"));
    }
        dispatch_glEndTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glEndTransformFeedbackNV</code>, <code>glEndTransformFeedbackEXT</code>   */
  private native void dispatch_glEndTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferRangeNV</code>, <code>glBindBufferRangeEXT</code>   */
  public void glBindBufferRange(int target, int index, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glBindBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferRange"));
    }
        dispatch_glBindBufferRange1(target, index, buffer, offset, size, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferRangeNV</code>, <code>glBindBufferRangeEXT</code>   */
  private native void dispatch_glBindBufferRange1(int target, int index, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferBaseNV</code>, <code>glBindBufferBaseEXT</code>   */
  public void glBindBufferBase(int target, int index, int buffer)  {

    final long __addr_ = _pat._addressof_glBindBufferBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferBase"));
    }
        dispatch_glBindBufferBase1(target, index, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferBaseNV</code>, <code>glBindBufferBaseEXT</code>   */
  private native void dispatch_glBindBufferBase1(int target, int index, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glTransformFeedbackVaryingsEXT</code>, <code>glTransformFeedbackVaryingsNV</code>   */
  public void glTransformFeedbackVaryings(int program, int count, String[] varyings, int bufferMode)  {

    final long __addr_ = _pat._addressof_glTransformFeedbackVaryings;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackVaryings"));
    }
        dispatch_glTransformFeedbackVaryings1(program, count, varyings, bufferMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glTransformFeedbackVaryingsEXT</code>, <code>glTransformFeedbackVaryingsNV</code>   */
  private native void dispatch_glTransformFeedbackVaryings1(int program, int count, String[] varyings, int bufferMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTransformFeedbackVarying1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClampColor}(GLenum target, GLenum clamp) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_ARB_color_buffer_float</code><br>Alias for: <code>glClampColorARB</code>   */
  public void glClampColor(int target, int clamp)  {

    final long __addr_ = _pat._addressof_glClampColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClampColor"));
    }
        dispatch_glClampColor1(target, clamp, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClampColor}(GLenum target, GLenum clamp) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_ARB_color_buffer_float</code><br>Alias for: <code>glClampColorARB</code>   */
  private native void dispatch_glClampColor1(int target, int clamp, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glBeginConditionalRenderNV</code>   */
  public void glBeginConditionalRender(int id, int mode)  {

    final long __addr_ = _pat._addressof_glBeginConditionalRender;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginConditionalRender"));
    }
        dispatch_glBeginConditionalRender1(id, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glBeginConditionalRenderNV</code>   */
  private native void dispatch_glBeginConditionalRender1(int id, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glEndConditionalRenderNV</code>   */
  public void glEndConditionalRender()  {

    final long __addr_ = _pat._addressof_glEndConditionalRender;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndConditionalRender"));
    }
        dispatch_glEndConditionalRender1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glEndConditionalRenderNV</code>   */
  private native void dispatch_glEndConditionalRender1(long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>   */
  public void glGetVertexAttribIiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>   */
  public void glGetVertexAttribIuiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1i}(GLuint index, GLint x) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1iEXT</code>   */
  public void glVertexAttribI1i(int index, int x)  {

    final long __addr_ = _pat._addressof_glVertexAttribI1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1i"));
    }
        dispatch_glVertexAttribI1i1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1i}(GLuint index, GLint x) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1iEXT</code>   */
  private native void dispatch_glVertexAttribI1i1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2i}(GLuint index, GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2iEXT</code>   */
  public void glVertexAttribI2i(int index, int x, int y)  {

    final long __addr_ = _pat._addressof_glVertexAttribI2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2i"));
    }
        dispatch_glVertexAttribI2i1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2i}(GLuint index, GLint x, GLint y) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2iEXT</code>   */
  private native void dispatch_glVertexAttribI2i1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3i}(GLuint index, GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3iEXT</code>   */
  public void glVertexAttribI3i(int index, int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glVertexAttribI3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3i"));
    }
        dispatch_glVertexAttribI3i1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3i}(GLuint index, GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3iEXT</code>   */
  private native void dispatch_glVertexAttribI3i1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4iEXT</code>   */
  public void glVertexAttribI4i(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4i"));
    }
        dispatch_glVertexAttribI4i1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4iEXT</code>   */
  private native void dispatch_glVertexAttribI4i1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ui}(GLuint index, GLuint x) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1uiEXT</code>   */
  public void glVertexAttribI1ui(int index, int x)  {

    final long __addr_ = _pat._addressof_glVertexAttribI1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ui"));
    }
        dispatch_glVertexAttribI1ui1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ui}(GLuint index, GLuint x) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1uiEXT</code>   */
  private native void dispatch_glVertexAttribI1ui1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ui}(GLuint index, GLuint x, GLuint y) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2uiEXT</code>   */
  public void glVertexAttribI2ui(int index, int x, int y)  {

    final long __addr_ = _pat._addressof_glVertexAttribI2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ui"));
    }
        dispatch_glVertexAttribI2ui1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ui}(GLuint index, GLuint x, GLuint y) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2uiEXT</code>   */
  private native void dispatch_glVertexAttribI2ui1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ui}(GLuint index, GLuint x, GLuint y, GLuint z) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3uiEXT</code>   */
  public void glVertexAttribI3ui(int index, int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glVertexAttribI3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ui"));
    }
        dispatch_glVertexAttribI3ui1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ui}(GLuint index, GLuint x, GLuint y, GLuint z) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3uiEXT</code>   */
  private native void dispatch_glVertexAttribI3ui1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uiEXT</code>   */
  public void glVertexAttribI4ui(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ui"));
    }
        dispatch_glVertexAttribI4ui1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uiEXT</code>   */
  private native void dispatch_glVertexAttribI4ui1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iv"));
    }
        dispatch_glVertexAttribI1iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1ivEXT</code>   */
  public void glVertexAttribI1iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iv"));
    }
        dispatch_glVertexAttribI1iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iv"));
    }
        dispatch_glVertexAttribI2iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2ivEXT</code>   */
  public void glVertexAttribI2iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iv"));
    }
        dispatch_glVertexAttribI2iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iv"));
    }
        dispatch_glVertexAttribI3iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3ivEXT</code>   */
  public void glVertexAttribI3iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iv"));
    }
        dispatch_glVertexAttribI3iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>   */
  public void glVertexAttribI4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiv"));
    }
        dispatch_glVertexAttribI1uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI1uivEXT</code>   */
  public void glVertexAttribI1uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiv"));
    }
        dispatch_glVertexAttribI1uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiv"));
    }
        dispatch_glVertexAttribI2uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI2uivEXT</code>   */
  public void glVertexAttribI2uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiv"));
    }
        dispatch_glVertexAttribI2uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiv"));
    }
        dispatch_glVertexAttribI3uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI3uivEXT</code>   */
  public void glVertexAttribI3uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiv"));
    }
        dispatch_glVertexAttribI3uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>   */
  public void glVertexAttribI4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4bvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4bv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bv"));
    }
        dispatch_glVertexAttribI4bv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4bvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4bv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bv}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4bvEXT</code>   */
  public void glVertexAttribI4bv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4bv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bv"));
    }
        dispatch_glVertexAttribI4bv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4svEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4sv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4sv"));
    }
        dispatch_glVertexAttribI4sv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4svEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4sv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4sv}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4svEXT</code>   */
  public void glVertexAttribI4sv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4sv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4sv"));
    }
        dispatch_glVertexAttribI4sv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ubvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4ubv(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubv"));
    }
        dispatch_glVertexAttribI4ubv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ubvEXT</code>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4ubv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubv}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ubvEXT</code>   */
  public void glVertexAttribI4ubv(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4ubv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubv"));
    }
        dispatch_glVertexAttribI4ubv1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4usvEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4usv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usv"));
    }
        dispatch_glVertexAttribI4usv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4usvEXT</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4usv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usv}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4usvEXT</code>   */
  public void glVertexAttribI4usv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4usv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usv"));
    }
        dispatch_glVertexAttribI4usv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformuiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformuiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>   */
  public void glGetUniformuiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocation}(GLuint program, GLuint color, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glBindFragDataLocationEXT</code>   */
  public void glBindFragDataLocation(int program, int color, String name)  {

    final long __addr_ = _pat._addressof_glBindFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocation"));
    }
        dispatch_glBindFragDataLocation1(program, color, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocation}(GLuint program, GLuint color, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glBindFragDataLocationEXT</code>   */
  private native void dispatch_glBindFragDataLocation1(int program, int color, String name, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetFragDataLocationEXT</code>   */
  public int glGetFragDataLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataLocation"));
    }
        return dispatch_glGetFragDataLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetFragDataLocationEXT</code>   */
  private native int dispatch_glGetFragDataLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uiEXT</code>   */
  public void glUniform1ui(int location, int v0)  {

    final long __addr_ = _pat._addressof_glUniform1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui"));
    }
        dispatch_glUniform1ui1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uiEXT</code>   */
  private native void dispatch_glUniform1ui1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uiEXT</code>   */
  public void glUniform2ui(int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glUniform2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui"));
    }
        dispatch_glUniform2ui1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uiEXT</code>   */
  private native void dispatch_glUniform2ui1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uiEXT</code>   */
  public void glUniform3ui(int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glUniform3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui"));
    }
        dispatch_glUniform3ui1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uiEXT</code>   */
  private native void dispatch_glUniform3ui1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uiEXT</code>   */
  public void glUniform4ui(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glUniform4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui"));
    }
        dispatch_glUniform4ui1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uiEXT</code>   */
  private native void dispatch_glUniform4ui1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>   */
  public void glUniform1uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>   */
  public void glUniform2uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>   */
  public void glUniform3uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>   */
  public void glUniform4uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
    }
        dispatch_glTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>   */
  public void glTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
    }
        dispatch_glTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
    }
        dispatch_glTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>   */
  public void glTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
    }
        dispatch_glTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
    }
        dispatch_glGetTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>   */
  public void glGetTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
    }
        dispatch_glGetTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>   */
  public void glGetTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferuiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferuiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferuiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClearBufferfv(int buffer, int drawbuffer, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClearBufferfv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferfv(int buffer, int drawbuffer, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferfi(int buffer, int drawbuffer, float depth, int stencil)  {

    final long __addr_ = _pat._addressof_glClearBufferfi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfi"));
    }
        dispatch_glClearBufferfi1(buffer, drawbuffer, depth, stencil, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  private native void dispatch_glClearBufferfi1(int buffer, int drawbuffer, float depth, int stencil, long procAddress);

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public String glGetStringi(int name, int index)  {

    final long __addr_ = _pat._addressof_glGetStringi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetStringi"));
    }
        return dispatch_glGetStringi1(name, index, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  private native String dispatch_glGetStringi1(int name, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = _pat._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsRenderbuffer"));
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  private native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindRenderbuffer"));
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  private native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorage"));
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  private native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = _pat._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsFramebuffer"));
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  private native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = _pat._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFramebuffer"));
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = _pat._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckFramebufferStatus"));
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  private native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture1D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture1DEXT</code>   */
  public void glFramebufferTexture1D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture1D"));
    }
        dispatch_glFramebufferTexture1D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture1D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture1DEXT</code>   */
  private native void dispatch_glFramebufferTexture1D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2D"));
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  private native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glFramebufferTexture3DEXT</code>, <code>glFramebufferTexture3DOES</code>   */
  public void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture3D"));
    }
        dispatch_glFramebufferTexture3D1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glFramebufferTexture3DEXT</code>, <code>glFramebufferTexture3DOES</code>   */
  private native void dispatch_glFramebufferTexture3D1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferRenderbuffer"));
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  private native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = _pat._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateMipmap"));
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  private native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_framebuffer_blit</code>, <code>GL_EXT_framebuffer_blit</code>, <code>GL_ANGLE_framebuffer_blit</code><br>Alias for: <code>glBlitFramebufferNV</code>, <code>glBlitFramebufferEXT</code>, <code>glBlitFramebufferANGLE</code>   */
  public void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _pat._addressof_glBlitFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebuffer"));
    }
        dispatch_glBlitFramebuffer1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_framebuffer_blit</code>, <code>GL_EXT_framebuffer_blit</code>, <code>GL_ANGLE_framebuffer_blit</code><br>Alias for: <code>glBlitFramebufferNV</code>, <code>glBlitFramebufferEXT</code>, <code>glBlitFramebufferANGLE</code>   */
  private native void dispatch_glBlitFramebuffer1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  public void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisample"));
    }
        dispatch_glRenderbufferStorageMultisample1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  private native void dispatch_glRenderbufferStorageMultisample1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_array</code>, <code>GL_NV_geometry_program4</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureLayerEXT</code>, <code>glFramebufferTextureLayerARB</code>   */
  public void glFramebufferTextureLayer(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureLayer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayer"));
    }
        dispatch_glFramebufferTextureLayer1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_array</code>, <code>GL_NV_geometry_program4</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureLayerEXT</code>, <code>glFramebufferTextureLayerARB</code>   */
  private native void dispatch_glFramebufferTextureLayer1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private long glMapBufferRangeDelegate(int target, long offset, long length, int access)  {

    final long __addr_ = _pat._addressof_glMapBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBufferRange"));
    }
        return dispatch_glMapBufferRangeDelegate1(target, offset, length, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private native long dispatch_glMapBufferRangeDelegate1(int target, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  public void glFlushMappedBufferRange(int target, long offset, long length)  {

    final long __addr_ = _pat._addressof_glFlushMappedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedBufferRange"));
    }
        dispatch_glFlushMappedBufferRange1(target, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  private native void dispatch_glFlushMappedBufferRange1(int target, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glBindVertexArrayAPPLE</code>, <code>glBindVertexArrayOES</code>   */
  public void glBindVertexArray(int array)  {

    final long __addr_ = _pat._addressof_glBindVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArray"));
    }
        dispatch_glBindVertexArray1(array, __addr_);
    bufferStateTracker.setBoundBufferObject(GL2GL3.GL_VERTEX_ARRAY_BINDING, array);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glBindVertexArrayAPPLE</code>, <code>glBindVertexArrayOES</code>   */
  private native void dispatch_glBindVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>   */
  public void glDeleteVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>   */
  public void glGenVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_vertex_array_object</code>, <code>GL_APPLE_vertex_array_object</code><br>Alias for: <code>glIsVertexArrayOES</code>, <code>glIsVertexArrayAPPLE</code>   */
  public boolean glIsVertexArray(int array)  {

    final long __addr_ = _pat._addressof_glIsVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArray"));
    }
        return dispatch_glIsVertexArray1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_vertex_array_object</code>, <code>GL_APPLE_vertex_array_object</code><br>Alias for: <code>glIsVertexArrayOES</code>, <code>glIsVertexArrayAPPLE</code>   */
  private native boolean dispatch_glIsVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_NV_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code><br>Alias for: <code>glDrawArraysInstancedARB</code>, <code>glDrawArraysInstancedEXT</code>, <code>glDrawArraysInstancedNV</code>, <code>glDrawArraysInstancedANGLE</code>   */
  public void glDrawArraysInstanced(int mode, int first, int count, int instancecount)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstanced"));
    }
        dispatch_glDrawArraysInstanced1(mode, first, count, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_NV_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code><br>Alias for: <code>glDrawArraysInstancedARB</code>, <code>glDrawArraysInstancedEXT</code>, <code>glDrawArraysInstancedNV</code>, <code>glDrawArraysInstancedANGLE</code>   */
  private native void dispatch_glDrawArraysInstanced1(int mode, int first, int count, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstanced(int mode, int count, int type, Buffer indices, int instancecount)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>   */
  public void glDrawElementsInstanced(int mode, int count, int type, long indices_buffer_offset, int instancecount)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_buffer_offset, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, long indices_buffer_offset, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBuffer}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_1</code>, <code>GL_OES_texture_buffer</code>, <code>GL_ARB_texture_buffer_object</code>, <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code><br>Alias for: <code>glTexBufferOES</code>, <code>glTexBufferARB</code>, <code>glTexBufferEXT</code>   */
  public void glTexBuffer(int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTexBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBuffer"));
    }
        dispatch_glTexBuffer1(target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBuffer}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_1</code>, <code>GL_OES_texture_buffer</code>, <code>GL_ARB_texture_buffer_object</code>, <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code><br>Alias for: <code>glTexBufferOES</code>, <code>glTexBufferARB</code>, <code>glTexBufferEXT</code>   */
  private native void dispatch_glTexBuffer1(int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndex}(GLuint index) </code> <br>Part of <code>GL_VERSION_3_1</code>, <code>GL_NV_primitive_restart</code><br>Alias for: <code>glPrimitiveRestartIndexNV</code>   */
  public void glPrimitiveRestartIndex(int index)  {

    final long __addr_ = _pat._addressof_glPrimitiveRestartIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartIndex"));
    }
        dispatch_glPrimitiveRestartIndex1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndex}(GLuint index) </code> <br>Part of <code>GL_VERSION_3_1</code>, <code>GL_NV_primitive_restart</code><br>Alias for: <code>glPrimitiveRestartIndexNV</code>   */
  private native void dispatch_glPrimitiveRestartIndex1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_NV_copy_buffer</code><br>Alias for: <code>glCopyBufferSubDataNV</code>   */
  public void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _pat._addressof_glCopyBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyBufferSubData"));
    }
        dispatch_glCopyBufferSubData1(readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_NV_copy_buffer</code><br>Alias for: <code>glCopyBufferSubDataNV</code>   */
  private native void dispatch_glCopyBufferSubData1(int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, IntBuffer uniformIndices)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final long __addr_ = _pat._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformIndices1(int program, int uniformCount, String[] uniformNames, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, int[] uniformIndices, int uniformIndices_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformsiv(int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformsiv1(int program, int uniformCount, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformsiv(int program, int uniformCount, int[] uniformIndices, int uniformIndices_offset, int pname, int[] params, int params_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformName(int program, int uniformIndex, int bufSize, IntBuffer length, ByteBuffer uniformName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformName_is_direct = Buffers.isDirect(uniformName);
    final long __addr_ = _pat._addressof_glGetActiveUniformName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformName"));
    }
        dispatch_glGetActiveUniformName1(program, uniformIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformName_is_direct ? uniformName : Buffers.getArray(uniformName), uniformName_is_direct ? Buffers.getDirectBufferByteOffset(uniformName) : Buffers.getIndirectBufferByteOffset(uniformName), uniformName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformName1(int program, int uniformIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformName, int uniformName_byte_offset, boolean uniformName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformName}(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformName(int program, int uniformIndex, int bufSize, int[] length, int length_offset, byte[] uniformName, int uniformName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformName != null && uniformName.length <= uniformName_offset)
      throw new GLException("array offset argument \"uniformName_offset\" (" + uniformName_offset + ") equals or exceeds array length (" + uniformName.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformName"));
    }
        dispatch_glGetActiveUniformName1(program, uniformIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformName, uniformName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public int glGetUniformBlockIndex(int program, String uniformBlockName)  {

    final long __addr_ = _pat._addressof_glGetUniformBlockIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBlockIndex"));
    }
        return dispatch_glGetUniformBlockIndex1(program, uniformBlockName, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  private native int dispatch_glGetUniformBlockIndex1(int program, String uniformBlockName, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformBlockiv1(int program, int uniformBlockIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, IntBuffer length, ByteBuffer uniformBlockName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformBlockName_is_direct = Buffers.isDirect(uniformBlockName);
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformBlockName_is_direct ? uniformBlockName : Buffers.getArray(uniformBlockName), uniformBlockName_is_direct ? Buffers.getDirectBufferByteOffset(uniformBlockName) : Buffers.getIndirectBufferByteOffset(uniformBlockName), uniformBlockName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformBlockName1(int program, int uniformBlockIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformBlockName, int uniformBlockName_byte_offset, boolean uniformBlockName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, int[] length, int length_offset, byte[] uniformBlockName, int uniformBlockName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformBlockName != null && uniformBlockName.length <= uniformBlockName_offset)
      throw new GLException("array offset argument \"uniformBlockName_offset\" (" + uniformBlockName_offset + ") equals or exceeds array length (" + uniformBlockName.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformBlockName, uniformBlockName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glUniformBlockBinding(int program, int uniformBlockIndex, int uniformBlockBinding)  {

    final long __addr_ = _pat._addressof_glUniformBlockBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformBlockBinding"));
    }
        dispatch_glUniformBlockBinding1(program, uniformBlockIndex, uniformBlockBinding, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  private native void dispatch_glUniformBlockBinding1(int program, int uniformBlockIndex, int uniformBlockBinding, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsBaseVertex(int mode, int count, int type, Buffer indices, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
    }
        dispatch_glDrawElementsBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>   */
  public void glDrawElementsBaseVertex(int mode, int count, int type, long indices_buffer_offset, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
    }
        dispatch_glDrawElementsBaseVertex1(mode, count, type, indices_buffer_offset, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>   */
  private native void dispatch_glDrawElementsBaseVertex1(int mode, int count, int type, long indices_buffer_offset, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, Buffer indices, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
    }
        dispatch_glDrawRangeElementsBaseVertex1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElementsBaseVertex1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>   */
  public void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, long indices_buffer_offset, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
    }
        dispatch_glDrawRangeElementsBaseVertex1(mode, start, end, count, type, indices_buffer_offset, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>   */
  private native void dispatch_glDrawRangeElementsBaseVertex1(int mode, int start, int end, int count, int type, long indices_buffer_offset, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertex(int mode, int count, int type, Buffer indices, int instancecount, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
    }
        dispatch_glDrawElementsInstancedBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>   */
  public void glDrawElementsInstancedBaseVertex(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
    }
        dispatch_glDrawElementsInstancedBaseVertex1(mode, count, type, indices_buffer_offset, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseVertex1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertex}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei drawcount, const GLint *  basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glMultiDrawElementsBaseVertexOES</code>, <code>glMultiDrawElementsBaseVertexEXT</code>
      @param count a direct only {@link java.nio.IntBuffer}
      @param indices a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct only {@link java.nio.IntBuffer}   */
  public void glMultiDrawElementsBaseVertex(int mode, IntBuffer count, int type, PointerBuffer indices, int drawcount, IntBuffer basevertex)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    if (!Buffers.isDirect(indices))
      throw new GLException("Argument \"indices\" is not a direct buffer");
    if (!Buffers.isDirect(basevertex))
      throw new GLException("Argument \"basevertex\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glMultiDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertex"));
    }
        dispatch_glMultiDrawElementsBaseVertex0(mode, count, Buffers.getDirectBufferByteOffset(count), type, indices != null ? indices.getBuffer() : null, Buffers.getDirectBufferByteOffset(indices), drawcount, basevertex, Buffers.getDirectBufferByteOffset(basevertex), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertex}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei drawcount, const GLint *  basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glMultiDrawElementsBaseVertexOES</code>, <code>glMultiDrawElementsBaseVertexEXT</code>
      @param count a direct only {@link java.nio.IntBuffer}
      @param indices a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct only {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiDrawElementsBaseVertex0(int mode, Object count, int count_byte_offset, int type, Object indices, int indices_byte_offset, int drawcount, Object basevertex, int basevertex_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glProvokingVertex}(GLenum mode) </code> <br>Part of <code>GL_ARB_provoking_vertex</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_provoking_vertex</code><br>Alias for: <code>glProvokingVertexEXT</code>   */
  public void glProvokingVertex(int mode)  {

    final long __addr_ = _pat._addressof_glProvokingVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProvokingVertex"));
    }
        dispatch_glProvokingVertex1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProvokingVertex}(GLenum mode) </code> <br>Part of <code>GL_ARB_provoking_vertex</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_provoking_vertex</code><br>Alias for: <code>glProvokingVertexEXT</code>   */
  private native void dispatch_glProvokingVertex1(int mode, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glFenceSyncAPPLE</code>   */
  public long glFenceSync(int condition, int flags)  {

    final long __addr_ = _pat._addressof_glFenceSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFenceSync"));
    }
        return dispatch_glFenceSync1(condition, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glFenceSyncAPPLE</code>   */
  private native long dispatch_glFenceSync1(int condition, int flags, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glIsSyncAPPLE</code>   */
  public boolean glIsSync(long sync)  {

    final long __addr_ = _pat._addressof_glIsSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSync"));
    }
        return dispatch_glIsSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glIsSyncAPPLE</code>   */
  private native boolean dispatch_glIsSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glDeleteSyncAPPLE</code>   */
  public void glDeleteSync(long sync)  {

    final long __addr_ = _pat._addressof_glDeleteSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSync"));
    }
        dispatch_glDeleteSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glDeleteSyncAPPLE</code>   */
  private native void dispatch_glDeleteSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glClientWaitSyncAPPLE</code>   */
  public int glClientWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = _pat._addressof_glClientWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientWaitSync"));
    }
        return dispatch_glClientWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glClientWaitSyncAPPLE</code>   */
  private native int dispatch_glClientWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glWaitSyncAPPLE</code>   */
  public void glWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = _pat._addressof_glWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWaitSync"));
    }
        dispatch_glWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glWaitSyncAPPLE</code>   */
  private native void dispatch_glWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64v(int pname, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64v1(int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>   */
  public void glGetInteger64v(int pname, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSynciv(long sync, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSynciv1(long sync, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>   */
  public void glGetSynciv(long sync, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64i_v(int target, int index, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64i_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glGetInteger64i_v(int target, int index, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameteri64v(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameteri64v1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glGetBufferParameteri64v(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_geometry_shader</code>, <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureOES</code>, <code>glFramebufferTextureEXT</code>, <code>glFramebufferTextureARB</code>   */
  public void glFramebufferTexture(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture"));
    }
        dispatch_glFramebufferTexture1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_geometry_shader</code>, <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureOES</code>, <code>glFramebufferTextureEXT</code>, <code>glFramebufferTextureARB</code>   */
  private native void dispatch_glFramebufferTexture1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glTexImage2DMultisample(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexImage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2DMultisample"));
    }
        dispatch_glTexImage2DMultisample1(target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glTexImage2DMultisample1(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glTexImage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexImage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3DMultisample"));
    }
        dispatch_glTexImage3DMultisample1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glTexImage3DMultisample1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultisamplefv(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = _pat._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
    }
        dispatch_glGetMultisamplefv1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultisamplefv1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>   */
  public void glGetMultisamplefv(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = _pat._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
    }
        dispatch_glGetMultisamplefv1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint maskNumber, GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glSampleMaski(int maskNumber, int mask)  {

    final long __addr_ = _pat._addressof_glSampleMaski;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleMaski"));
    }
        dispatch_glSampleMaski1(maskNumber, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint maskNumber, GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glSampleMaski1(int maskNumber, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexed}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ARB_blend_func_extended</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glBindFragDataLocationIndexedEXT</code>   */
  public void glBindFragDataLocationIndexed(int program, int colorNumber, int index, String name)  {

    final long __addr_ = _pat._addressof_glBindFragDataLocationIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationIndexed"));
    }
        dispatch_glBindFragDataLocationIndexed1(program, colorNumber, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexed}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ARB_blend_func_extended</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glBindFragDataLocationIndexedEXT</code>   */
  private native void dispatch_glBindFragDataLocationIndexed1(int program, int colorNumber, int index, String name, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndex}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ARB_blend_func_extended</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glGetFragDataIndexEXT</code>   */
  public int glGetFragDataIndex(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetFragDataIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataIndex"));
    }
        return dispatch_glGetFragDataIndex1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndex}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ARB_blend_func_extended</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glGetFragDataIndexEXT</code>   */
  private native int dispatch_glGetFragDataIndex1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGenSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glDeleteSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public boolean glIsSampler(int sampler)  {

    final long __addr_ = _pat._addressof_glIsSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSampler"));
    }
        return dispatch_glIsSampler1(sampler, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native boolean dispatch_glIsSampler1(int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glBindSampler(int unit, int sampler)  {

    final long __addr_ = _pat._addressof_glBindSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindSampler"));
    }
        dispatch_glBindSampler1(unit, sampler, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glBindSampler1(int unit, int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameteri(int sampler, int pname, int param)  {

    final long __addr_ = _pat._addressof_glSamplerParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteri"));
    }
        dispatch_glSamplerParameteri1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glSamplerParameteri1(int sampler, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameteriv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameteriv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameteriv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameterf(int sampler, int pname, float param)  {

    final long __addr_ = _pat._addressof_glSamplerParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterf"));
    }
        dispatch_glSamplerParameterf1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glSamplerParameterf1(int sampler, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSamplerParameterfv(int sampler, int pname, FloatBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSamplerParameterfv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameterfv(int sampler, int pname, float[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param, Buffers.SIZEOF_FLOAT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>   */
  public void glSamplerParameterIiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIuiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIuiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>   */
  public void glSamplerParameterIuiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameteriv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameteriv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGetSamplerParameteriv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>   */
  public void glGetSamplerParameterIiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetSamplerParameterfv(int sampler, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetSamplerParameterfv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGetSamplerParameterfv(int sampler, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIuiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glQueryCounterEXT</code>   */
  public void glQueryCounter(int id, int target)  {

    final long __addr_ = _pat._addressof_glQueryCounter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryCounter"));
    }
        dispatch_glQueryCounter1(id, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glQueryCounterEXT</code>   */
  private native void dispatch_glQueryCounter1(int id, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>   */
  public void glGetQueryObjecti64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>   */
  public void glGetQueryObjectui64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_NV_instanced_arrays</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_ARB_instanced_arrays</code>, <code>GL_EXT_instanced_arrays</code><br>Alias for: <code>glVertexAttribDivisorNV</code>, <code>glVertexAttribDivisorANGLE</code>, <code>glVertexAttribDivisorARB</code>, <code>glVertexAttribDivisorEXT</code>   */
  public void glVertexAttribDivisor(int index, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexAttribDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisor"));
    }
        dispatch_glVertexAttribDivisor1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_NV_instanced_arrays</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_ARB_instanced_arrays</code>, <code>GL_EXT_instanced_arrays</code><br>Alias for: <code>glVertexAttribDivisorNV</code>, <code>glVertexAttribDivisorANGLE</code>, <code>glVertexAttribDivisorARB</code>, <code>glVertexAttribDivisorEXT</code>   */
  private native void dispatch_glVertexAttribDivisor1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP1ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = _pat._addressof_glVertexAttribP1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1ui"));
    }
        dispatch_glVertexAttribP1ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP1ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexAttribP1ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP1uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexAttribP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1uiv"));
    }
        dispatch_glVertexAttribP1uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP1uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP1uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP1uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP1uiv"));
    }
        dispatch_glVertexAttribP1uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP2ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = _pat._addressof_glVertexAttribP2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2ui"));
    }
        dispatch_glVertexAttribP2ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexAttribP2ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP2uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexAttribP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2uiv"));
    }
        dispatch_glVertexAttribP2uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP2uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP2uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP2uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP2uiv"));
    }
        dispatch_glVertexAttribP2uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP3ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = _pat._addressof_glVertexAttribP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3ui"));
    }
        dispatch_glVertexAttribP3ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexAttribP3ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP3uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexAttribP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3uiv"));
    }
        dispatch_glVertexAttribP3uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP3uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP3uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP3uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP3uiv"));
    }
        dispatch_glVertexAttribP3uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP4ui(int index, int type, boolean normalized, int value)  {

    final long __addr_ = _pat._addressof_glVertexAttribP4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4ui"));
    }
        dispatch_glVertexAttribP4ui1(index, type, normalized, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4ui}(GLuint index, GLenum type, GLboolean normalized, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexAttribP4ui1(int index, int type, boolean normalized, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribP4uiv(int index, int type, boolean normalized, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexAttribP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4uiv"));
    }
        dispatch_glVertexAttribP4uiv1(index, type, normalized, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribP4uiv1(int index, int type, boolean normalized, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribP4uiv}(GLuint index, GLenum type, GLboolean normalized, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexAttribP4uiv(int index, int type, boolean normalized, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribP4uiv"));
    }
        dispatch_glVertexAttribP4uiv1(index, type, normalized, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP2ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP2ui(int type, int value)  {

    final long __addr_ = _pat._addressof_glVertexP2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP2ui"));
    }
        dispatch_glVertexP2ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP2ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexP2ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP2uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP2uiv"));
    }
        dispatch_glVertexP2uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP2uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP2uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP2uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP2uiv"));
    }
        dispatch_glVertexP2uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP3ui(int type, int value)  {

    final long __addr_ = _pat._addressof_glVertexP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP3ui"));
    }
        dispatch_glVertexP3ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexP3ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP3uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP3uiv"));
    }
        dispatch_glVertexP3uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP3uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP3uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP3uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP3uiv"));
    }
        dispatch_glVertexP3uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP4ui(int type, int value)  {

    final long __addr_ = _pat._addressof_glVertexP4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP4ui"));
    }
        dispatch_glVertexP4ui1(type, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4ui}(GLenum type, GLuint value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glVertexP4ui1(int type, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexP4uiv(int type, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glVertexP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP4uiv"));
    }
        dispatch_glVertexP4uiv1(type, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexP4uiv1(int type, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexP4uiv}(GLenum type, const GLuint *  value) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glVertexP4uiv(int type, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glVertexP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexP4uiv"));
    }
        dispatch_glVertexP4uiv1(type, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP1ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP1ui(int type, int coords)  {

    final long __addr_ = _pat._addressof_glTexCoordP1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1ui"));
    }
        dispatch_glTexCoordP1ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP1ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glTexCoordP1ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP1uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1uiv"));
    }
        dispatch_glTexCoordP1uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP1uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP1uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP1uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP1uiv"));
    }
        dispatch_glTexCoordP1uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP2ui(int type, int coords)  {

    final long __addr_ = _pat._addressof_glTexCoordP2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2ui"));
    }
        dispatch_glTexCoordP2ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glTexCoordP2ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP2uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2uiv"));
    }
        dispatch_glTexCoordP2uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP2uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP2uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP2uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP2uiv"));
    }
        dispatch_glTexCoordP2uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP3ui(int type, int coords)  {

    final long __addr_ = _pat._addressof_glTexCoordP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3ui"));
    }
        dispatch_glTexCoordP3ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glTexCoordP3ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP3uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3uiv"));
    }
        dispatch_glTexCoordP3uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP3uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP3uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP3uiv"));
    }
        dispatch_glTexCoordP3uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP4ui(int type, int coords)  {

    final long __addr_ = _pat._addressof_glTexCoordP4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4ui"));
    }
        dispatch_glTexCoordP4ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glTexCoordP4ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexCoordP4uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4uiv"));
    }
        dispatch_glTexCoordP4uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexCoordP4uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordP4uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glTexCoordP4uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordP4uiv"));
    }
        dispatch_glTexCoordP4uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP1ui(int texture, int type, int coords)  {

    final long __addr_ = _pat._addressof_glMultiTexCoordP1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1ui"));
    }
        dispatch_glMultiTexCoordP1ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glMultiTexCoordP1ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP1uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1uiv"));
    }
        dispatch_glMultiTexCoordP1uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP1uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP1uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP1uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoordP1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP1uiv"));
    }
        dispatch_glMultiTexCoordP1uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP2ui(int texture, int type, int coords)  {

    final long __addr_ = _pat._addressof_glMultiTexCoordP2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2ui"));
    }
        dispatch_glMultiTexCoordP2ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glMultiTexCoordP2ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP2uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2uiv"));
    }
        dispatch_glMultiTexCoordP2uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP2uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP2uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP2uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoordP2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP2uiv"));
    }
        dispatch_glMultiTexCoordP2uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP3ui(int texture, int type, int coords)  {

    final long __addr_ = _pat._addressof_glMultiTexCoordP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3ui"));
    }
        dispatch_glMultiTexCoordP3ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glMultiTexCoordP3ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP3uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3uiv"));
    }
        dispatch_glMultiTexCoordP3uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP3uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP3uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP3uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoordP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP3uiv"));
    }
        dispatch_glMultiTexCoordP3uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP4ui(int texture, int type, int coords)  {

    final long __addr_ = _pat._addressof_glMultiTexCoordP4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4ui"));
    }
        dispatch_glMultiTexCoordP4ui1(texture, type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4ui}(GLenum texture, GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glMultiTexCoordP4ui1(int texture, int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexCoordP4uiv(int texture, int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4uiv"));
    }
        dispatch_glMultiTexCoordP4uiv1(texture, type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexCoordP4uiv1(int texture, int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordP4uiv}(GLenum texture, GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glMultiTexCoordP4uiv(int texture, int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoordP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordP4uiv"));
    }
        dispatch_glMultiTexCoordP4uiv1(texture, type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalP3ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glNormalP3ui(int type, int coords)  {

    final long __addr_ = _pat._addressof_glNormalP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalP3ui"));
    }
        dispatch_glNormalP3ui1(type, coords, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalP3ui}(GLenum type, GLuint coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glNormalP3ui1(int type, int coords, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNormalP3uiv(int type, IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glNormalP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalP3uiv"));
    }
        dispatch_glNormalP3uiv1(type, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNormalP3uiv1(int type, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalP3uiv}(GLenum type, const GLuint *  coords) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glNormalP3uiv(int type, int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glNormalP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalP3uiv"));
    }
        dispatch_glNormalP3uiv1(type, coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP3ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glColorP3ui(int type, int color)  {

    final long __addr_ = _pat._addressof_glColorP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP3ui"));
    }
        dispatch_glColorP3ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP3ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glColorP3ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorP3uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = _pat._addressof_glColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP3uiv"));
    }
        dispatch_glColorP3uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorP3uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glColorP3uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = _pat._addressof_glColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP3uiv"));
    }
        dispatch_glColorP3uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glColorP4ui(int type, int color)  {

    final long __addr_ = _pat._addressof_glColorP4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP4ui"));
    }
        dispatch_glColorP4ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glColorP4ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorP4uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = _pat._addressof_glColorP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP4uiv"));
    }
        dispatch_glColorP4uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorP4uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorP4uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glColorP4uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = _pat._addressof_glColorP4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorP4uiv"));
    }
        dispatch_glColorP4uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glSecondaryColorP3ui(int type, int color)  {

    final long __addr_ = _pat._addressof_glSecondaryColorP3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3ui"));
    }
        dispatch_glSecondaryColorP3ui1(type, color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3ui}(GLenum type, GLuint color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  private native void dispatch_glSecondaryColorP3ui1(int type, int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSecondaryColorP3uiv(int type, IntBuffer color)  {

    final boolean color_is_direct = Buffers.isDirect(color);
    final long __addr_ = _pat._addressof_glSecondaryColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3uiv"));
    }
        dispatch_glSecondaryColorP3uiv1(type, color_is_direct ? color : Buffers.getArray(color), color_is_direct ? Buffers.getDirectBufferByteOffset(color) : Buffers.getIndirectBufferByteOffset(color), color_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>
      @param color a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSecondaryColorP3uiv1(int type, Object color, int color_byte_offset, boolean color_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorP3uiv}(GLenum type, const GLuint *  color) </code> <br>Part of <code>GL_ARB_vertex_type_2_10_10_10_rev</code>, <code>GL_VERSION_3_3</code><br>   */
  public void glSecondaryColorP3uiv(int type, int[] color, int color_offset)  {

    if(color != null && color.length <= color_offset)
      throw new GLException("array offset argument \"color_offset\" (" + color_offset + ") equals or exceeds array length (" + color.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColorP3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorP3uiv"));
    }
        dispatch_glSecondaryColorP3uiv1(type, color, Buffers.SIZEOF_INT * color_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShading}(GLfloat value) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_sample_shading</code>, <code>GL_ARB_sample_shading</code><br>Alias for: <code>glMinSampleShadingOES</code>, <code>glMinSampleShadingARB</code>   */
  public void glMinSampleShading(float value)  {

    final long __addr_ = _pat._addressof_glMinSampleShading;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMinSampleShading"));
    }
        dispatch_glMinSampleShading1(value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShading}(GLfloat value) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_sample_shading</code>, <code>GL_ARB_sample_shading</code><br>Alias for: <code>glMinSampleShadingOES</code>, <code>glMinSampleShadingARB</code>   */
  private native void dispatch_glMinSampleShading1(float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationi}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationiOES</code>, <code>glBlendEquationiARB</code>, <code>glBlendEquationiEXT</code>   */
  public void glBlendEquationi(int buf, int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquationi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationi"));
    }
        dispatch_glBlendEquationi1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationi}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationiOES</code>, <code>glBlendEquationiARB</code>, <code>glBlendEquationiEXT</code>   */
  private native void dispatch_glBlendEquationi1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparatei}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationSeparateiARB</code>, <code>glBlendEquationSeparateiEXT</code>, <code>glBlendEquationSeparateiOES</code>   */
  public void glBlendEquationSeparatei(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparatei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparatei"));
    }
        dispatch_glBlendEquationSeparatei1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparatei}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationSeparateiARB</code>, <code>glBlendEquationSeparateiEXT</code>, <code>glBlendEquationSeparateiOES</code>   */
  private native void dispatch_glBlendEquationSeparatei1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunci}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendFunciARB</code>, <code>glBlendFunciEXT</code>, <code>glBlendFunciOES</code>   */
  public void glBlendFunci(int buf, int src, int dst)  {

    final long __addr_ = _pat._addressof_glBlendFunci;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunci"));
    }
        dispatch_glBlendFunci1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunci}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendFunciARB</code>, <code>glBlendFunciEXT</code>, <code>glBlendFunciOES</code>   */
  private native void dispatch_glBlendFunci1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparatei}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glBlendFuncSeparateiOES</code>, <code>glBlendFuncSeparateiARB</code>, <code>glBlendFuncSeparateiEXT</code>   */
  public void glBlendFuncSeparatei(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparatei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparatei"));
    }
        dispatch_glBlendFuncSeparatei1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparatei}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glBlendFuncSeparateiOES</code>, <code>glBlendFuncSeparateiARB</code>, <code>glBlendFuncSeparateiEXT</code>   */
  private native void dispatch_glBlendFuncSeparatei1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawArraysIndirect(int mode, Buffer indirect)  {

    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(indirect, 1);
    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
    }
        dispatch_glDrawArraysIndirect1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawArraysIndirect1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glDrawArraysIndirect(int mode, long indirect_buffer_offset)  {

    checkIndirectVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
    }
        dispatch_glDrawArraysIndirect1(mode, indirect_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glDrawArraysIndirect1(int mode, long indirect_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsIndirect(int mode, int type, Buffer indirect)  {

    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(indirect, 1);
    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
    }
        dispatch_glDrawElementsIndirect1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsIndirect1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glDrawElementsIndirect(int mode, int type, long indirect_buffer_offset)  {

    checkIndirectVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
    }
        dispatch_glDrawElementsIndirect1(mode, type, indirect_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ARB_draw_indirect</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glDrawElementsIndirect1(int mode, int type, long indirect_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1d}(GLint location, GLdouble x) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform1d(int location, double x)  {

    final long __addr_ = _pat._addressof_glUniform1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1d"));
    }
        dispatch_glUniform1d1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1d}(GLint location, GLdouble x) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glUniform1d1(int location, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2d}(GLint location, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform2d(int location, double x, double y)  {

    final long __addr_ = _pat._addressof_glUniform2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2d"));
    }
        dispatch_glUniform2d1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2d}(GLint location, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glUniform2d1(int location, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3d}(GLint location, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform3d(int location, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glUniform3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3d"));
    }
        dispatch_glUniform3d1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3d}(GLint location, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glUniform3d1(int location, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4d}(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform4d(int location, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glUniform4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4d"));
    }
        dispatch_glUniform4d1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4d}(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glUniform4d1(int location, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform1dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1dv"));
    }
        dispatch_glUniform1dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform1dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform1dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1dv"));
    }
        dispatch_glUniform1dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform2dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2dv"));
    }
        dispatch_glUniform2dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform2dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform2dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2dv"));
    }
        dispatch_glUniform2dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform3dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3dv"));
    }
        dispatch_glUniform3dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform3dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform3dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3dv"));
    }
        dispatch_glUniform3dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniform4dv(int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4dv"));
    }
        dispatch_glUniform4dv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniform4dv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4dv}(GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniform4dv(int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4dv"));
    }
        dispatch_glUniform4dv1(location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2dv"));
    }
        dispatch_glUniformMatrix2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2dv"));
    }
        dispatch_glUniformMatrix2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3dv"));
    }
        dispatch_glUniformMatrix3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3dv"));
    }
        dispatch_glUniformMatrix3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4dv"));
    }
        dispatch_glUniformMatrix4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4dv"));
    }
        dispatch_glUniformMatrix4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2x3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3dv"));
    }
        dispatch_glUniformMatrix2x3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2x3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix2x3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3dv"));
    }
        dispatch_glUniformMatrix2x3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix2x4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4dv"));
    }
        dispatch_glUniformMatrix2x4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix2x4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix2x4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4dv"));
    }
        dispatch_glUniformMatrix2x4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3x2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2dv"));
    }
        dispatch_glUniformMatrix3x2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3x2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix3x2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2dv"));
    }
        dispatch_glUniformMatrix3x2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix3x4dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4dv"));
    }
        dispatch_glUniformMatrix3x4dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix3x4dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix3x4dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4dv"));
    }
        dispatch_glUniformMatrix3x4dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4x2dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2dv"));
    }
        dispatch_glUniformMatrix4x2dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4x2dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix4x2dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2dv"));
    }
        dispatch_glUniformMatrix4x2dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glUniformMatrix4x3dv(int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3dv"));
    }
        dispatch_glUniformMatrix4x3dv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glUniformMatrix4x3dv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3dv}(GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformMatrix4x3dv(int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3dv"));
    }
        dispatch_glUniformMatrix4x3dv1(location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetUniformdv(int program, int location, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformdv"));
    }
        dispatch_glGetUniformdv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetUniformdv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformdv}(GLuint program, GLint location, GLdouble *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_fp64</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetUniformdv(int program, int location, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformdv"));
    }
        dispatch_glGetUniformdv1(program, location, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetSubroutineUniformLocation}(GLuint program, GLenum shadertype, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public int glGetSubroutineUniformLocation(int program, int shadertype, String name)  {

    final long __addr_ = _pat._addressof_glGetSubroutineUniformLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSubroutineUniformLocation"));
    }
        return dispatch_glGetSubroutineUniformLocation1(program, shadertype, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetSubroutineUniformLocation}(GLuint program, GLenum shadertype, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  private native int dispatch_glGetSubroutineUniformLocation1(int program, int shadertype, String name, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetSubroutineIndex}(GLuint program, GLenum shadertype, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public int glGetSubroutineIndex(int program, int shadertype, String name)  {

    final long __addr_ = _pat._addressof_glGetSubroutineIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSubroutineIndex"));
    }
        return dispatch_glGetSubroutineIndex1(program, shadertype, name, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetSubroutineIndex}(GLuint program, GLenum shadertype, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  private native int dispatch_glGetSubroutineIndex1(int program, int shadertype, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveSubroutineUniformiv(int program, int shadertype, int index, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetActiveSubroutineUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformiv"));
    }
        dispatch_glGetActiveSubroutineUniformiv1(program, shadertype, index, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveSubroutineUniformiv1(int program, int shadertype, int index, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformiv}(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetActiveSubroutineUniformiv(int program, int shadertype, int index, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveSubroutineUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformiv"));
    }
        dispatch_glGetActiveSubroutineUniformiv1(program, shadertype, index, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveSubroutineUniformName(int program, int shadertype, int index, int bufsize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveSubroutineUniformName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformName"));
    }
        dispatch_glGetActiveSubroutineUniformName1(program, shadertype, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveSubroutineUniformName1(int program, int shadertype, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineUniformName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetActiveSubroutineUniformName(int program, int shadertype, int index, int bufsize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveSubroutineUniformName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineUniformName"));
    }
        dispatch_glGetActiveSubroutineUniformName1(program, shadertype, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveSubroutineName(int program, int shadertype, int index, int bufsize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveSubroutineName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineName"));
    }
        dispatch_glGetActiveSubroutineName1(program, shadertype, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveSubroutineName1(int program, int shadertype, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveSubroutineName}(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetActiveSubroutineName(int program, int shadertype, int index, int bufsize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveSubroutineName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveSubroutineName"));
    }
        dispatch_glGetActiveSubroutineName1(program, shadertype, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniformSubroutinesuiv(int shadertype, int count, IntBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glUniformSubroutinesuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformSubroutinesuiv"));
    }
        dispatch_glUniformSubroutinesuiv1(shadertype, count, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniformSubroutinesuiv1(int shadertype, int count, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformSubroutinesuiv}(GLenum shadertype, GLsizei count, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glUniformSubroutinesuiv(int shadertype, int count, int[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = _pat._addressof_glUniformSubroutinesuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformSubroutinesuiv"));
    }
        dispatch_glUniformSubroutinesuiv1(shadertype, count, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformSubroutineuiv(int shadertype, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformSubroutineuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformSubroutineuiv"));
    }
        dispatch_glGetUniformSubroutineuiv1(shadertype, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformSubroutineuiv1(int shadertype, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformSubroutineuiv}(GLenum shadertype, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetUniformSubroutineuiv(int shadertype, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformSubroutineuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformSubroutineuiv"));
    }
        dispatch_glGetUniformSubroutineuiv1(shadertype, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramStageiv(int program, int shadertype, int pname, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetProgramStageiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStageiv"));
    }
        dispatch_glGetProgramStageiv1(program, shadertype, pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramStageiv1(int program, int shadertype, int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramStageiv}(GLuint program, GLenum shadertype, GLenum pname, GLint *  values) </code> <br>Part of <code>GL_ARB_shader_subroutine</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetProgramStageiv(int program, int shadertype, int pname, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramStageiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStageiv"));
    }
        dispatch_glGetProgramStageiv1(program, shadertype, pname, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_tessellation_shader</code>, <code>GL_EXT_tessellation_shader</code><br>Alias for: <code>glPatchParameteriOES</code>, <code>glPatchParameteriEXT</code>   */
  public void glPatchParameteri(int pname, int value)  {

    final long __addr_ = _pat._addressof_glPatchParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameteri"));
    }
        dispatch_glPatchParameteri1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_tessellation_shader</code>, <code>GL_EXT_tessellation_shader</code><br>Alias for: <code>glPatchParameteriOES</code>, <code>glPatchParameteriEXT</code>   */
  private native void dispatch_glPatchParameteri1(int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPatchParameterfv(int pname, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glPatchParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameterfv"));
    }
        dispatch_glPatchParameterfv1(pname, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_VERSION_4_0</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPatchParameterfv1(int pname, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameterfv}(GLenum pname, const GLfloat *  values) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glPatchParameterfv(int pname, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glPatchParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameterfv"));
    }
        dispatch_glPatchParameterfv1(pname, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glBindTransformFeedbackNV</code>   */
  public void glBindTransformFeedback(int target, int id)  {

    final long __addr_ = _pat._addressof_glBindTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedback"));
    }
        dispatch_glBindTransformFeedback1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glBindTransformFeedbackNV</code>   */
  private native void dispatch_glBindTransformFeedback1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>   */
  public void glDeleteTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>   */
  public void glGenTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glIsTransformFeedbackNV</code>   */
  public boolean glIsTransformFeedback(int id)  {

    final long __addr_ = _pat._addressof_glIsTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedback"));
    }
        return dispatch_glIsTransformFeedback1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glIsTransformFeedbackNV</code>   */
  private native boolean dispatch_glIsTransformFeedback1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glPauseTransformFeedbackNV</code>   */
  public void glPauseTransformFeedback()  {

    final long __addr_ = _pat._addressof_glPauseTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedback"));
    }
        dispatch_glPauseTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glPauseTransformFeedbackNV</code>   */
  private native void dispatch_glPauseTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glResumeTransformFeedbackNV</code>   */
  public void glResumeTransformFeedback()  {

    final long __addr_ = _pat._addressof_glResumeTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedback"));
    }
        dispatch_glResumeTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glResumeTransformFeedbackNV</code>   */
  private native void dispatch_glResumeTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedback}(GLenum mode, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDrawTransformFeedbackNV</code>   */
  public void glDrawTransformFeedback(int mode, int id)  {

    final long __addr_ = _pat._addressof_glDrawTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedback"));
    }
        dispatch_glDrawTransformFeedback1(mode, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedback}(GLenum mode, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDrawTransformFeedbackNV</code>   */
  private native void dispatch_glDrawTransformFeedback1(int mode, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStream}(GLenum mode, GLuint id, GLuint stream) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glDrawTransformFeedbackStream(int mode, int id, int stream)  {

    final long __addr_ = _pat._addressof_glDrawTransformFeedbackStream;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackStream"));
    }
        dispatch_glDrawTransformFeedbackStream1(mode, id, stream, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStream}(GLenum mode, GLuint id, GLuint stream) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glDrawTransformFeedbackStream1(int mode, int id, int stream, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQueryIndexed}(GLenum target, GLuint index, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glBeginQueryIndexed(int target, int index, int id)  {

    final long __addr_ = _pat._addressof_glBeginQueryIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginQueryIndexed"));
    }
        dispatch_glBeginQueryIndexed1(target, index, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQueryIndexed}(GLenum target, GLuint index, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glBeginQueryIndexed1(int target, int index, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQueryIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glEndQueryIndexed(int target, int index)  {

    final long __addr_ = _pat._addressof_glEndQueryIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndQueryIndexed"));
    }
        dispatch_glEndQueryIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQueryIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glEndQueryIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryIndexediv(int target, int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryIndexediv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryIndexediv"));
    }
        dispatch_glGetQueryIndexediv1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryIndexediv1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryIndexediv}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_transform_feedback3</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glGetQueryIndexediv(int target, int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryIndexediv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryIndexediv"));
    }
        dispatch_glGetQueryIndexediv1(target, index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glReleaseShaderCompiler()  {

    if ( !_context.isGLES2Compatible() ) {
    return;
    }
    final long __addr_ = _pat._addressof_glReleaseShaderCompiler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReleaseShaderCompiler"));
    }
        dispatch_glReleaseShaderCompiler1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  private native void dispatch_glReleaseShaderCompiler1(long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, IntBuffer shaders, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(count, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glShaderBinary1(int count, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryformat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, int[] shaders, int shaders_offset, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(count, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    final long __addr_ = _pat._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if(range != null && range.length <= range_offset)
      throw new GLException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new GLException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat n, GLfloat f) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  public void glDepthRangef(float n, float f)  {

    if ( !_context.isGLES2Compatible() && !_context.hasFP32CompatAPI() ) {
    glDepthRange( (double)n, (double)f );
    return;
    }
    final long __addr_ = _pat._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangef"));
    }
        dispatch_glDepthRangef1(n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat n, GLfloat f) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  private native void dispatch_glDepthRangef1(float n, float f, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat d) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  public void glClearDepthf(float d)  {

    if ( !_context.isGLES2Compatible() && !_context.hasFP32CompatAPI() ) {
    glClearDepth( (double)d );
    return;
    }
    final long __addr_ = _pat._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepthf"));
    }
        dispatch_glClearDepthf1(d, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat d) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  private native void dispatch_glClearDepthf1(float d, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, IntBuffer length, IntBuffer binaryFormat, Buffer binary)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean binaryFormat_is_direct = Buffers.isDirect(binaryFormat);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, binaryFormat_is_direct ? binaryFormat : Buffers.getArray(binaryFormat), binaryFormat_is_direct ? Buffers.getDirectBufferByteOffset(binaryFormat) : Buffers.getIndirectBufferByteOffset(binaryFormat), binaryFormat_is_direct, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramBinary1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object binaryFormat, int binaryFormat_byte_offset, boolean binaryFormat_is_direct, Object binary, int binary_byte_offset, boolean binary_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, int[] length, int length_offset, int[] binaryFormat, int binaryFormat_offset, Buffer binary)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(binaryFormat != null && binaryFormat.length <= binaryFormat_offset)
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + binaryFormat_offset + ") equals or exceeds array length (" + binaryFormat.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, binaryFormat, Buffers.SIZEOF_INT * binaryFormat_offset, false, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glProgramBinary(int program, int binaryFormat, Buffer binary, int length)  {

    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBinary"));
    }
        dispatch_glProgramBinary1(program, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glProgramBinary1(int program, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1d}(GLuint program, GLint location, GLdouble v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform1dEXT</code>   */
  public void glProgramUniform1d(int program, int location, double v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1d"));
    }
        dispatch_glProgramUniform1d1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1d}(GLuint program, GLint location, GLdouble v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform1dEXT</code>   */
  private native void dispatch_glProgramUniform1d1(int program, int location, double v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform1dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform1dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dv"));
    }
        dispatch_glProgramUniform1dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform1dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform1dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform1dvEXT</code>   */
  public void glProgramUniform1dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dv"));
    }
        dispatch_glProgramUniform1dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2d}(GLuint program, GLint location, GLdouble v0, GLdouble v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform2dEXT</code>   */
  public void glProgramUniform2d(int program, int location, double v0, double v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2d"));
    }
        dispatch_glProgramUniform2d1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2d}(GLuint program, GLint location, GLdouble v0, GLdouble v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform2dEXT</code>   */
  private native void dispatch_glProgramUniform2d1(int program, int location, double v0, double v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform2dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dv"));
    }
        dispatch_glProgramUniform2dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform2dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform2dvEXT</code>   */
  public void glProgramUniform2dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dv"));
    }
        dispatch_glProgramUniform2dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform3dEXT</code>   */
  public void glProgramUniform3d(int program, int location, double v0, double v1, double v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3d"));
    }
        dispatch_glProgramUniform3d1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform3dEXT</code>   */
  private native void dispatch_glProgramUniform3d1(int program, int location, double v0, double v1, double v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform3dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dv"));
    }
        dispatch_glProgramUniform3dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform3dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform3dvEXT</code>   */
  public void glProgramUniform3dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dv"));
    }
        dispatch_glProgramUniform3dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform4dEXT</code>   */
  public void glProgramUniform4d(int program, int location, double v0, double v1, double v2, double v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4d"));
    }
        dispatch_glProgramUniform4d1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4d}(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform4dEXT</code>   */
  private native void dispatch_glProgramUniform4d1(int program, int location, double v0, double v1, double v2, double v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform4dv(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dv"));
    }
        dispatch_glProgramUniform4dv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform4dv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dv}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniform4dvEXT</code>   */
  public void glProgramUniform4dv(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dv"));
    }
        dispatch_glProgramUniform4dv1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dv"));
    }
        dispatch_glProgramUniformMatrix2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2dvEXT</code>   */
  public void glProgramUniformMatrix2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dv"));
    }
        dispatch_glProgramUniformMatrix2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dv"));
    }
        dispatch_glProgramUniformMatrix3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3dvEXT</code>   */
  public void glProgramUniformMatrix3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dv"));
    }
        dispatch_glProgramUniformMatrix3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dv"));
    }
        dispatch_glProgramUniformMatrix4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4dvEXT</code>   */
  public void glProgramUniformMatrix4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dv"));
    }
        dispatch_glProgramUniformMatrix4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dv"));
    }
        dispatch_glProgramUniformMatrix2x3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x3dvEXT</code>   */
  public void glProgramUniformMatrix2x3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dv"));
    }
        dispatch_glProgramUniformMatrix2x3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dv"));
    }
        dispatch_glProgramUniformMatrix3x2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x2dvEXT</code>   */
  public void glProgramUniformMatrix3x2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dv"));
    }
        dispatch_glProgramUniformMatrix3x2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dv"));
    }
        dispatch_glProgramUniformMatrix2x4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix2x4dvEXT</code>   */
  public void glProgramUniformMatrix2x4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dv"));
    }
        dispatch_glProgramUniformMatrix2x4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x2dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dv"));
    }
        dispatch_glProgramUniformMatrix4x2dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x2dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x2dvEXT</code>   */
  public void glProgramUniformMatrix4x2dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dv"));
    }
        dispatch_glProgramUniformMatrix4x2dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x4dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dv"));
    }
        dispatch_glProgramUniformMatrix3x4dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x4dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix3x4dvEXT</code>   */
  public void glProgramUniformMatrix3x4dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dv"));
    }
        dispatch_glProgramUniformMatrix3x4dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x3dv(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dv"));
    }
        dispatch_glProgramUniformMatrix4x3dv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x3dvEXT</code>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3dv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glProgramUniformMatrix4x3dvEXT</code>   */
  public void glProgramUniformMatrix4x3dv(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dv"));
    }
        dispatch_glProgramUniformMatrix4x3dv1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1d}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL1dEXT</code>   */
  public void glVertexAttribL1d(int index, double x)  {

    final long __addr_ = _pat._addressof_glVertexAttribL1d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1d"));
    }
        dispatch_glVertexAttribL1d1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1d}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL1dEXT</code>   */
  private native void dispatch_glVertexAttribL1d1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2d}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL2dEXT</code>   */
  public void glVertexAttribL2d(int index, double x, double y)  {

    final long __addr_ = _pat._addressof_glVertexAttribL2d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2d"));
    }
        dispatch_glVertexAttribL2d1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2d}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL2dEXT</code>   */
  private native void dispatch_glVertexAttribL2d1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL3dEXT</code>   */
  public void glVertexAttribL3d(int index, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glVertexAttribL3d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3d"));
    }
        dispatch_glVertexAttribL3d1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3d}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL3dEXT</code>   */
  private native void dispatch_glVertexAttribL3d1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL4dEXT</code>   */
  public void glVertexAttribL4d(int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glVertexAttribL4d;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4d"));
    }
        dispatch_glVertexAttribL4d1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4d}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL4dEXT</code>   */
  private native void dispatch_glVertexAttribL4d1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL1dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL1dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1dv"));
    }
        dispatch_glVertexAttribL1dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL1dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL1dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL1dvEXT</code>   */
  public void glVertexAttribL1dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL1dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1dv"));
    }
        dispatch_glVertexAttribL1dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL2dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL2dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2dv"));
    }
        dispatch_glVertexAttribL2dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL2dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL2dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL2dvEXT</code>   */
  public void glVertexAttribL2dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL2dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2dv"));
    }
        dispatch_glVertexAttribL2dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL3dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL3dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3dv"));
    }
        dispatch_glVertexAttribL3dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL3dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL3dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL3dvEXT</code>   */
  public void glVertexAttribL3dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL3dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3dv"));
    }
        dispatch_glVertexAttribL3dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL4dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttribL4dv(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4dv"));
    }
        dispatch_glVertexAttribL4dv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL4dvEXT</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttribL4dv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4dv}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribL4dvEXT</code>   */
  public void glVertexAttribL4dv(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL4dv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4dv"));
    }
        dispatch_glVertexAttribL4dv1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribLPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribLPointer(int index, int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexAttribLPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLPointer"));
    }
        dispatch_glVertexAttribLPointer0(index, size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribLPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribLPointer0(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribLPointerEXT</code>   */
  public void glVertexAttribLPointer(int index, int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribLPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLPointer"));
    }
        dispatch_glVertexAttribLPointer0(index, size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glVertexAttribLPointerEXT</code>   */
  private native void dispatch_glVertexAttribLPointer0(int index, int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glGetVertexAttribLdvEXT</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribLdv(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribLdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLdv"));
    }
        dispatch_glGetVertexAttribLdv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glGetVertexAttribLdvEXT</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribLdv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLdv}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_attrib_64bit</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_vertex_attrib_64bit</code><br>Alias for: <code>glGetVertexAttribLdvEXT</code>   */
  public void glGetVertexAttribLdv(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribLdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLdv"));
    }
        dispatch_glGetVertexAttribLdv1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportArrayvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportArrayv(int first, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glViewportArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayv"));
    }
        dispatch_glViewportArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportArrayvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportArrayv}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportArrayvNV</code>   */
  public void glViewportArrayv(int first, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glViewportArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayv"));
    }
        dispatch_glViewportArrayv1(first, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedf}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportIndexedfNV</code>   */
  public void glViewportIndexedf(int index, float x, float y, float w, float h)  {

    final long __addr_ = _pat._addressof_glViewportIndexedf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedf"));
    }
        dispatch_glViewportIndexedf1(index, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedf}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportIndexedfNV</code>   */
  private native void dispatch_glViewportIndexedf1(int index, float x, float y, float w, float h, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportIndexedfvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportIndexedfv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glViewportIndexedfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfv"));
    }
        dispatch_glViewportIndexedfv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportIndexedfvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportIndexedfv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glViewportIndexedfvNV</code>   */
  public void glViewportIndexedfv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glViewportIndexedfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfv"));
    }
        dispatch_glViewportIndexedfv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorArrayvNV</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorArrayv(int first, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glScissorArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayv"));
    }
        dispatch_glScissorArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorArrayvNV</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorArrayv}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorArrayvNV</code>   */
  public void glScissorArrayv(int first, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glScissorArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayv"));
    }
        dispatch_glScissorArrayv1(first, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexed}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorIndexedNV</code>   */
  public void glScissorIndexed(int index, int left, int bottom, int width, int height)  {

    final long __addr_ = _pat._addressof_glScissorIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexed"));
    }
        dispatch_glScissorIndexed1(index, left, bottom, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexed}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorIndexedNV</code>   */
  private native void dispatch_glScissorIndexed1(int index, int left, int bottom, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorIndexedvNV</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorIndexedv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glScissorIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedv"));
    }
        dispatch_glScissorIndexedv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorIndexedvNV</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorIndexedv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glScissorIndexedvNV</code>   */
  public void glScissorIndexedv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glScissorIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedv"));
    }
        dispatch_glScissorIndexedv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glDepthRangeArrayv(int first, int count, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glDepthRangeArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayv"));
    }
        dispatch_glDepthRangeArrayv1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glDepthRangeArrayv1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayv}(GLuint first, GLsizei count, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glDepthRangeArrayv(int first, int count, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glDepthRangeArrayv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayv"));
    }
        dispatch_glDepthRangeArrayv1(first, count, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexed}(GLuint index, GLdouble n, GLdouble f) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glDepthRangeIndexed(int index, double n, double f)  {

    final long __addr_ = _pat._addressof_glDepthRangeIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeIndexed"));
    }
        dispatch_glDepthRangeIndexed1(index, n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexed}(GLuint index, GLdouble n, GLdouble f) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code><br>   */
  private native void dispatch_glDepthRangeIndexed1(int index, double n, double f, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glGetFloati_vEXT</code>, <code>glGetFloati_vNV</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloati_v(int target, int index, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetFloati_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_v"));
    }
        dispatch_glGetFloati_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glGetFloati_vEXT</code>, <code>glGetFloati_vNV</code>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloati_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_v}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_NV_viewport_array</code><br>Alias for: <code>glGetFloati_vEXT</code>, <code>glGetFloati_vNV</code>   */
  public void glGetFloati_v(int target, int index, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetFloati_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_v"));
    }
        dispatch_glGetFloati_v1(target, index, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetDoublei_vEXT</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoublei_v(int target, int index, DoubleBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetDoublei_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_v"));
    }
        dispatch_glGetDoublei_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetDoublei_vEXT</code>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoublei_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoublei_v}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_ARB_viewport_array</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetDoublei_vEXT</code>   */
  public void glGetDoublei_v(int target, int index, double[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetDoublei_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_v"));
    }
        dispatch_glGetDoublei_v1(target, index, data, Buffers.SIZEOF_DOUBLE * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawArraysInstancedBaseInstanceEXT</code>   */
  public void glDrawArraysInstancedBaseInstance(int mode, int first, int count, int instancecount, int baseinstance)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedBaseInstance"));
    }
        dispatch_glDrawArraysInstancedBaseInstance1(mode, first, count, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawArraysInstancedBaseInstanceEXT</code>   */
  private native void dispatch_glDrawArraysInstancedBaseInstance1(int mode, int first, int count, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseInstance(int mode, int count, int type, Buffer indices, int instancecount, int baseinstance)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>   */
  public void glDrawElementsInstancedBaseInstance(int mode, int count, int type, long indices_buffer_offset, int instancecount, int baseinstance)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseInstance1(mode, count, type, indices_buffer_offset, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseInstance1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, Buffer indices, int instancecount, int basevertex, int baseinstance)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>   */
  public void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, int baseinstance)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(mode, count, type, indices_buffer_offset, instancecount, basevertex, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInternalformativ1(int target, int internalformat, int pname, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>, <code>GL_VERSION_4_2</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveAtomicCounterBufferiv(int program, int bufferIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetActiveAtomicCounterBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAtomicCounterBufferiv"));
    }
        dispatch_glGetActiveAtomicCounterBufferiv1(program, bufferIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>, <code>GL_VERSION_4_2</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveAtomicCounterBufferiv1(int program, int bufferIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAtomicCounterBufferiv}(GLuint program, GLuint bufferIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_atomic_counters</code>, <code>GL_VERSION_4_2</code><br>   */
  public void glGetActiveAtomicCounterBufferiv(int program, int bufferIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveAtomicCounterBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAtomicCounterBufferiv"));
    }
        dispatch_glGetActiveAtomicCounterBufferiv1(program, bufferIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glBindImageTextureEXT</code>   */
  public void glBindImageTexture(int unit, int texture, int level, boolean layered, int layer, int access, int format)  {

    final long __addr_ = _pat._addressof_glBindImageTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindImageTexture"));
    }
        dispatch_glBindImageTexture1(unit, texture, level, layered, layer, access, format, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glBindImageTextureEXT</code>   */
  private native void dispatch_glBindImageTexture1(int unit, int texture, int level, boolean layered, int layer, int access, int format, long procAddress);

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glMemoryBarrierEXT</code>   */
  public void glMemoryBarrier(int barriers)  {

    final long __addr_ = _pat._addressof_glMemoryBarrier;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrier"));
    }
        dispatch_glMemoryBarrier1(barriers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glMemoryBarrierEXT</code>   */
  private native void dispatch_glMemoryBarrier1(int barriers, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackInstanced}(GLenum mode, GLuint id, GLsizei instancecount) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_transform_feedback_instanced</code><br>   */
  public void glDrawTransformFeedbackInstanced(int mode, int id, int instancecount)  {

    final long __addr_ = _pat._addressof_glDrawTransformFeedbackInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackInstanced"));
    }
        dispatch_glDrawTransformFeedbackInstanced1(mode, id, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackInstanced}(GLenum mode, GLuint id, GLsizei instancecount) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_transform_feedback_instanced</code><br>   */
  private native void dispatch_glDrawTransformFeedbackInstanced1(int mode, int id, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStreamInstanced}(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_transform_feedback_instanced</code><br>   */
  public void glDrawTransformFeedbackStreamInstanced(int mode, int id, int stream, int instancecount)  {

    final long __addr_ = _pat._addressof_glDrawTransformFeedbackStreamInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackStreamInstanced"));
    }
        dispatch_glDrawTransformFeedbackStreamInstanced1(mode, id, stream, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackStreamInstanced}(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_transform_feedback_instanced</code><br>   */
  private native void dispatch_glDrawTransformFeedbackStreamInstanced1(int mode, int id, int stream, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferData}(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_clear_buffer_object</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearBufferData(int target, int internalformat, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferData"));
    }
        dispatch_glClearBufferData1(target, internalformat, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferData}(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_clear_buffer_object</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearBufferData1(int target, int internalformat, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferSubData}(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_clear_buffer_object</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearBufferSubData(int target, int internalformat, long offset, long size, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferSubData"));
    }
        dispatch_glClearBufferSubData1(target, internalformat, offset, size, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferSubData}(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_clear_buffer_object</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearBufferSubData1(int target, int internalformat, long offset, long size, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDispatchCompute}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glDispatchCompute(int num_groups_x, int num_groups_y, int num_groups_z)  {

    final long __addr_ = _pat._addressof_glDispatchCompute;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDispatchCompute"));
    }
        dispatch_glDispatchCompute1(num_groups_x, num_groups_y, num_groups_z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchCompute}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glDispatchCompute1(int num_groups_x, int num_groups_y, int num_groups_z, long procAddress);

  /** Entry point to C language function: <code> void {@native glDispatchComputeIndirect}(GLintptr indirect) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glDispatchComputeIndirect(long indirect)  {

    final long __addr_ = _pat._addressof_glDispatchComputeIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDispatchComputeIndirect"));
    }
        dispatch_glDispatchComputeIndirect1(indirect, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchComputeIndirect}(GLintptr indirect) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glDispatchComputeIndirect1(long indirect, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyImageSubData}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) </code> <br>Part of <code>GL_ARB_copy_image</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_NV_copy_image</code>, <code>GL_EXT_copy_image</code>, <code>GL_OES_copy_image</code><br>Alias for: <code>glCopyImageSubDataNV</code>, <code>glCopyImageSubDataEXT</code>, <code>glCopyImageSubDataOES</code>   */
  public void glCopyImageSubData(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)  {

    final long __addr_ = _pat._addressof_glCopyImageSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyImageSubData"));
    }
        dispatch_glCopyImageSubData1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyImageSubData}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) </code> <br>Part of <code>GL_ARB_copy_image</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_NV_copy_image</code>, <code>GL_EXT_copy_image</code>, <code>GL_OES_copy_image</code><br>Alias for: <code>glCopyImageSubDataNV</code>, <code>glCopyImageSubDataEXT</code>, <code>glCopyImageSubDataOES</code>   */
  private native void dispatch_glCopyImageSubData1(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glFramebufferParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glFramebufferParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferParameteri"));
    }
        dispatch_glFramebufferParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glFramebufferParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
    }
        dispatch_glGetFramebufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>   */
  public void glGetFramebufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
    }
        dispatch_glGetFramebufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformati64v}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_internalformat_query2</code>, <code>GL_VERSION_4_3</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInternalformati64v(int target, int internalformat, int pname, int bufSize, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetInternalformati64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformati64v"));
    }
        dispatch_glGetInternalformati64v1(target, internalformat, pname, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformati64v}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_internalformat_query2</code>, <code>GL_VERSION_4_3</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInternalformati64v1(int target, int internalformat, int pname, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformati64v}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_internalformat_query2</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glGetInternalformati64v(int target, int internalformat, int pname, int bufSize, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetInternalformati64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformati64v"));
    }
        dispatch_glGetInternalformati64v1(target, internalformat, pname, bufSize, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateTexSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glInvalidateTexSubImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateTexSubImage"));
    }
        dispatch_glInvalidateTexSubImage1(texture, level, xoffset, yoffset, zoffset, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateTexSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glInvalidateTexSubImage1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateTexImage}(GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateTexImage(int texture, int level)  {

    final long __addr_ = _pat._addressof_glInvalidateTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateTexImage"));
    }
        dispatch_glInvalidateTexImage1(texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateTexImage}(GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glInvalidateTexImage1(int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateBufferSubData(int buffer, long offset, long length)  {

    final long __addr_ = _pat._addressof_glInvalidateBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateBufferSubData"));
    }
        dispatch_glInvalidateBufferSubData1(buffer, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glInvalidateBufferSubData1(int buffer, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateBufferData}(GLuint buffer) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateBufferData(int buffer)  {

    final long __addr_ = _pat._addressof_glInvalidateBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateBufferData"));
    }
        dispatch_glInvalidateBufferData1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateBufferData}(GLuint buffer) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glInvalidateBufferData1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateFramebuffer(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glInvalidateFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, IntBuffer attachments, int x, int y, int width, int height)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateSubFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset, int x, int y, int width, int height)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirect}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_multi_draw_indirect</code>, <code>GL_AMD_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawArraysIndirectEXT</code>, <code>glMultiDrawArraysIndirectAMD</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirect(int mode, Buffer indirect, int drawcount, int stride)  {

    checkIndirectVBOUnbound(true);
    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirect"));
    }
        dispatch_glMultiDrawArraysIndirect1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirect}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_multi_draw_indirect</code>, <code>GL_AMD_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawArraysIndirectEXT</code>, <code>glMultiDrawArraysIndirectAMD</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirect1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirect}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_multi_draw_indirect</code>, <code>GL_AMD_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawArraysIndirectEXT</code>, <code>glMultiDrawArraysIndirectAMD</code>   */
  public void glMultiDrawArraysIndirect(int mode, long indirect_buffer_offset, int drawcount, int stride)  {

    checkIndirectVBOBound(true);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirect"));
    }
        dispatch_glMultiDrawArraysIndirect1(mode, indirect_buffer_offset, drawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirect}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_multi_draw_indirect</code>, <code>GL_AMD_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawArraysIndirectEXT</code>, <code>glMultiDrawArraysIndirectAMD</code>   */
  private native void dispatch_glMultiDrawArraysIndirect1(int mode, long indirect_buffer_offset, int drawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_multi_draw_indirect</code>, <code>GL_EXT_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawElementsIndirectAMD</code>, <code>glMultiDrawElementsIndirectEXT</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirect(int mode, int type, Buffer indirect, int drawcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirect"));
    }
        dispatch_glMultiDrawElementsIndirect1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_multi_draw_indirect</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_multi_draw_indirect</code>, <code>GL_EXT_multi_draw_indirect</code><br>Alias for: <code>glMultiDrawElementsIndirectAMD</code>, <code>glMultiDrawElementsIndirectEXT</code>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirect1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramInterfaceiv(int program, int programInterface, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramInterfaceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
    }
        dispatch_glGetProgramInterfaceiv1(program, programInterface, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramInterfaceiv1(int program, int programInterface, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramInterfaceiv(int program, int programInterface, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramInterfaceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
    }
        dispatch_glGetProgramInterfaceiv1(program, programInterface, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceIndex(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
    }
        return dispatch_glGetProgramResourceIndex1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceIndex1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public int glGetProgramResourceIndex(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
    }
        return dispatch_glGetProgramResourceIndex1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramResourceName(int program, int programInterface, int index, int bufSize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
    }
        dispatch_glGetProgramResourceName1(program, programInterface, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramResourceName1(int program, int programInterface, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramResourceName(int program, int programInterface, int index, int bufSize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
    }
        dispatch_glGetProgramResourceName1(program, programInterface, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param props a direct or array-backed {@link java.nio.IntBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramResourceiv(int program, int programInterface, int index, int propCount, IntBuffer props, int bufSize, IntBuffer length, IntBuffer params)  {

    final boolean props_is_direct = Buffers.isDirect(props);
    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramResourceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
    }
        dispatch_glGetProgramResourceiv1(program, programInterface, index, propCount, props_is_direct ? props : Buffers.getArray(props), props_is_direct ? Buffers.getDirectBufferByteOffset(props) : Buffers.getIndirectBufferByteOffset(props), props_is_direct, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param props a direct or array-backed {@link java.nio.IntBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramResourceiv1(int program, int programInterface, int index, int propCount, Object props, int props_byte_offset, boolean props_is_direct, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramResourceiv(int program, int programInterface, int index, int propCount, int[] props, int props_offset, int bufSize, int[] length, int length_offset, int[] params, int params_offset)  {

    if(props != null && props.length <= props_offset)
      throw new GLException("array offset argument \"props_offset\" (" + props_offset + ") equals or exceeds array length (" + props.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
    }
        dispatch_glGetProgramResourceiv1(program, programInterface, index, propCount, props, Buffers.SIZEOF_INT * props_offset, false, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceLocation(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
    }
        return dispatch_glGetProgramResourceLocation1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceLocation1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public int glGetProgramResourceLocation(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
    }
        return dispatch_glGetProgramResourceLocation1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glGetProgramResourceLocationIndexEXT</code>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceLocationIndex(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceLocationIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndex"));
    }
        return dispatch_glGetProgramResourceLocationIndex1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glGetProgramResourceLocationIndexEXT</code>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceLocationIndex1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code>, <code>GL_EXT_blend_func_extended</code><br>Alias for: <code>glGetProgramResourceLocationIndexEXT</code>   */
  public int glGetProgramResourceLocationIndex(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceLocationIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndex"));
    }
        return dispatch_glGetProgramResourceLocationIndex1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderStorageBlockBinding}(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_shader_storage_buffer_object</code><br>   */
  public void glShaderStorageBlockBinding(int program, int storageBlockIndex, int storageBlockBinding)  {

    final long __addr_ = _pat._addressof_glShaderStorageBlockBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderStorageBlockBinding"));
    }
        dispatch_glShaderStorageBlockBinding1(program, storageBlockIndex, storageBlockBinding, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderStorageBlockBinding}(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_shader_storage_buffer_object</code><br>   */
  private native void dispatch_glShaderStorageBlockBinding1(int program, int storageBlockIndex, int storageBlockBinding, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferRange}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_buffer_range</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code><br>Alias for: <code>glTexBufferRangeOES</code>, <code>glTexBufferRangeEXT</code>   */
  public void glTexBufferRange(int target, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTexBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferRange"));
    }
        dispatch_glTexBufferRange1(target, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferRange}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_buffer_range</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code><br>Alias for: <code>glTexBufferRangeOES</code>, <code>glTexBufferRangeEXT</code>   */
  private native void dispatch_glTexBufferRange1(int target, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glTexStorage2DMultisample(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexStorage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2DMultisample"));
    }
        dispatch_glTexStorage2DMultisample1(target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glTexStorage2DMultisample1(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_OES_texture_storage_multisample_2d_array</code><br>Alias for: <code>glTexStorage3DMultisampleOES</code>   */
  public void glTexStorage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexStorage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3DMultisample"));
    }
        dispatch_glTexStorage3DMultisample1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_OES_texture_storage_multisample_2d_array</code><br>Alias for: <code>glTexStorage3DMultisampleOES</code>   */
  private native void dispatch_glTexStorage3DMultisample1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureView}(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_view</code>, <code>GL_OES_texture_view</code>, <code>GL_EXT_texture_view</code><br>Alias for: <code>glTextureViewOES</code>, <code>glTextureViewEXT</code>   */
  public void glTextureView(int texture, int target, int origtexture, int internalformat, int minlevel, int numlevels, int minlayer, int numlayers)  {

    final long __addr_ = _pat._addressof_glTextureView;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureView"));
    }
        dispatch_glTextureView1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureView}(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_view</code>, <code>GL_OES_texture_view</code>, <code>GL_EXT_texture_view</code><br>Alias for: <code>glTextureViewOES</code>, <code>glTextureViewEXT</code>   */
  private native void dispatch_glTextureView1(int texture, int target, int origtexture, int internalformat, int minlevel, int numlevels, int minlayer, int numlayers, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexBuffer}(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glBindVertexBuffer(int bindingindex, int buffer, long offset, int stride)  {

    final long __addr_ = _pat._addressof_glBindVertexBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffer"));
    }
        dispatch_glBindVertexBuffer1(bindingindex, buffer, offset, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexBuffer}(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glBindVertexBuffer1(int bindingindex, int buffer, long offset, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribFormat}(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribFormatNV</code>   */
  public void glVertexAttribFormat(int attribindex, int size, int type, boolean normalized, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexAttribFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribFormat"));
    }
        dispatch_glVertexAttribFormat1(attribindex, size, type, normalized, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribFormat}(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribFormatNV</code>   */
  private native void dispatch_glVertexAttribFormat1(int attribindex, int size, int type, boolean normalized, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribIFormatNV</code>   */
  public void glVertexAttribIFormat(int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexAttribIFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIFormat"));
    }
        dispatch_glVertexAttribIFormat1(attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribIFormatNV</code>   */
  private native void dispatch_glVertexAttribIFormat1(int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_attrib_integer_64bit</code><br>Alias for: <code>glVertexAttribLFormatNV</code>   */
  public void glVertexAttribLFormat(int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexAttribLFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLFormat"));
    }
        dispatch_glVertexAttribLFormat1(attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_attrib_integer_64bit</code><br>Alias for: <code>glVertexAttribLFormatNV</code>   */
  private native void dispatch_glVertexAttribLFormat1(int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribBinding}(GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexAttribBinding(int attribindex, int bindingindex)  {

    final long __addr_ = _pat._addressof_glVertexAttribBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribBinding"));
    }
        dispatch_glVertexAttribBinding1(attribindex, bindingindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribBinding}(GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexAttribBinding1(int attribindex, int bindingindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexBindingDivisor}(GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexBindingDivisor(int bindingindex, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexBindingDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexBindingDivisor"));
    }
        dispatch_glVertexBindingDivisor1(bindingindex, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexBindingDivisor}(GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexBindingDivisor1(int bindingindex, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageControl(int source, int type, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageControl1(int source, int type, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>   */
  public void glDebugMessageControl(int source, int type, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code>, <code>GL_AMD_debug_output</code><br>Alias for: <code>glDebugMessageInsertARB</code>, <code>glDebugMessageInsertKHR</code>, <code>glDebugMessageInsertAMD</code>   */
  public void glDebugMessageInsert(int source, int type, int id, int severity, int length, String buf)  {

    final long __addr_ = _pat._addressof_glDebugMessageInsert;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsert"));
    }
        dispatch_glDebugMessageInsert1(source, type, id, severity, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code>, <code>GL_AMD_debug_output</code><br>Alias for: <code>glDebugMessageInsertARB</code>, <code>glDebugMessageInsertKHR</code>, <code>glDebugMessageInsertAMD</code>   */
  private native void dispatch_glDebugMessageInsert1(int source, int type, int id, int severity, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLog(int count, int bufSize, IntBuffer sources, IntBuffer types, IntBuffer ids, IntBuffer severities, IntBuffer lengths, ByteBuffer messageLog)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final boolean types_is_direct = Buffers.isDirect(types);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean messageLog_is_direct = Buffers.isDirect(messageLog);
    final long __addr_ = _pat._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufSize, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, types_is_direct ? types : Buffers.getArray(types), types_is_direct ? Buffers.getDirectBufferByteOffset(types) : Buffers.getIndirectBufferByteOffset(types), types_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, messageLog_is_direct ? messageLog : Buffers.getArray(messageLog), messageLog_is_direct ? Buffers.getDirectBufferByteOffset(messageLog) : Buffers.getIndirectBufferByteOffset(messageLog), messageLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLog1(int count, int bufSize, Object sources, int sources_byte_offset, boolean sources_is_direct, Object types, int types_byte_offset, boolean types_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object messageLog, int messageLog_byte_offset, boolean messageLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>   */
  public int glGetDebugMessageLog(int count, int bufSize, int[] sources, int sources_offset, int[] types, int types_offset, int[] ids, int ids_offset, int[] severities, int severities_offset, int[] lengths, int lengths_offset, byte[] messageLog, int messageLog_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new GLException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    if(types != null && types.length <= types_offset)
      throw new GLException("array offset argument \"types_offset\" (" + types_offset + ") equals or exceeds array length (" + types.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(messageLog != null && messageLog.length <= messageLog_offset)
      throw new GLException("array offset argument \"messageLog_offset\" (" + messageLog_offset + ") equals or exceeds array length (" + messageLog.length + ")");
    final long __addr_ = _pat._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufSize, sources, Buffers.SIZEOF_INT * sources_offset, false, types, Buffers.SIZEOF_INT * types_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, messageLog, messageLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPushDebugGroup(int source, int id, int length, ByteBuffer message)  {

    final boolean message_is_direct = Buffers.isDirect(message);
    final long __addr_ = _pat._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPushDebugGroup1(int source, int id, int length, Object message, int message_byte_offset, boolean message_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>   */
  public void glPushDebugGroup(int source, int id, int length, byte[] message, int message_offset)  {

    if(message != null && message.length <= message_offset)
      throw new GLException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
    final long __addr_ = _pat._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message, message_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPopDebugGroupKHR</code>   */
  public void glPopDebugGroup()  {

    final long __addr_ = _pat._addressof_glPopDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopDebugGroup"));
    }
        dispatch_glPopDebugGroup1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPopDebugGroupKHR</code>   */
  private native void dispatch_glPopDebugGroup1(long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectLabel(int identifier, int name, int length, ByteBuffer label)  {

    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectLabel1(int identifier, int name, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>   */
  public void glObjectLabel(int identifier, int name, int length, byte[] label, int label_offset)  {

    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectLabel1(int identifier, int name, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_KHR_debug</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferStorage}(GLenum target, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_VERSION_4_4</code>, <code>GL_EXT_buffer_storage</code><br>Alias for: <code>glBufferStorageEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glBufferStorageDelegate(int target, long size, Buffer data, int flags)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferStorage"));
    }
        dispatch_glBufferStorageDelegate1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferStorage}(GLenum target, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_VERSION_4_4</code>, <code>GL_EXT_buffer_storage</code><br>Alias for: <code>glBufferStorageEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glBufferStorageDelegate1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearTexImage}(GLuint texture, GLint level, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearTexImage(int texture, int level, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearTexImage"));
    }
        dispatch_glClearTexImage1(texture, level, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearTexImage}(GLuint texture, GLint level, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearTexImage1(int texture, int level, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearTexSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearTexSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearTexSubImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearTexSubImage"));
    }
        dispatch_glClearTexSubImage1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearTexSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearTexSubImage1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffersBase}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glBindBuffersBase(int target, int first, int count, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glBindBuffersBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersBase"));
    }
        dispatch_glBindBuffersBase1(target, first, count, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffersBase}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glBindBuffersBase1(int target, int first, int count, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffersBase}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>   */
  public void glBindBuffersBase(int target, int first, int count, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glBindBuffersBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersBase"));
    }
        dispatch_glBindBuffersBase1(target, first, count, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffersRange}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizeiptr *  sizes) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glBindBuffersRange(int target, int first, int count, IntBuffer buffers, PointerBuffer offsets, PointerBuffer sizes)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = _pat._addressof_glBindBuffersRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersRange"));
    }
        dispatch_glBindBuffersRange1(target, first, count, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, sizes_is_direct ? ( sizes != null ? sizes.getBuffer() : null ) : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffersRange}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizeiptr *  sizes) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glBindBuffersRange1(int target, int first, int count, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, Object offsets, int offsets_byte_offset, boolean offsets_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffersRange}(GLenum target, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizeiptr *  sizes) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glBindBuffersRange(int target, int first, int count, int[] buffers, int buffers_offset, PointerBuffer offsets, PointerBuffer sizes)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = _pat._addressof_glBindBuffersRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffersRange"));
    }
        dispatch_glBindBuffersRange1(target, first, count, buffers, Buffers.SIZEOF_INT * buffers_offset, false, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, sizes_is_direct ? ( sizes != null ? sizes.getBuffer() : null ) : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glBindTextures(int first, int count, IntBuffer textures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glBindTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTextures"));
    }
        dispatch_glBindTextures1(first, count, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glBindTextures1(int first, int count, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>   */
  public void glBindTextures(int first, int count, int[] textures, int textures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glBindTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTextures"));
    }
        dispatch_glBindTextures1(first, count, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSamplers}(GLuint first, GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glBindSamplers(int first, int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glBindSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindSamplers"));
    }
        dispatch_glBindSamplers1(first, count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSamplers}(GLuint first, GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glBindSamplers1(int first, int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindSamplers}(GLuint first, GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_4</code><br>   */
  public void glBindSamplers(int first, int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glBindSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindSamplers"));
    }
        dispatch_glBindSamplers1(first, count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glBindImageTextures(int first, int count, IntBuffer textures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glBindImageTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindImageTextures"));
    }
        dispatch_glBindImageTextures1(first, count, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glBindImageTextures1(int first, int count, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindImageTextures}(GLuint first, GLsizei count, const GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_4</code><br>   */
  public void glBindImageTextures(int first, int count, int[] textures, int textures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glBindImageTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindImageTextures"));
    }
        dispatch_glBindImageTextures1(first, count, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexBuffers}(GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param strides a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glBindVertexBuffers(int first, int count, IntBuffer buffers, PointerBuffer offsets, IntBuffer strides)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    final boolean strides_is_direct = Buffers.isDirect(strides);
    final long __addr_ = _pat._addressof_glBindVertexBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffers"));
    }
        dispatch_glBindVertexBuffers1(first, count, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, strides_is_direct ? strides : Buffers.getArray(strides), strides_is_direct ? Buffers.getDirectBufferByteOffset(strides) : Buffers.getIndirectBufferByteOffset(strides), strides_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexBuffers}(GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param strides a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glBindVertexBuffers1(int first, int count, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, Object offsets, int offsets_byte_offset, boolean offsets_is_direct, Object strides, int strides_byte_offset, boolean strides_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexBuffers}(GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_4</code><br>
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glBindVertexBuffers(int first, int count, int[] buffers, int buffers_offset, PointerBuffer offsets, int[] strides, int strides_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    if(strides != null && strides.length <= strides_offset)
      throw new GLException("array offset argument \"strides_offset\" (" + strides_offset + ") equals or exceeds array length (" + strides.length + ")");
    final long __addr_ = _pat._addressof_glBindVertexBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffers"));
    }
        dispatch_glBindVertexBuffers1(first, count, buffers, Buffers.SIZEOF_INT * buffers_offset, false, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, strides, Buffers.SIZEOF_INT * strides_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipControl}(GLenum origin, GLenum depth) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glClipControl(int origin, int depth)  {

    final long __addr_ = _pat._addressof_glClipControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipControl"));
    }
        dispatch_glClipControl1(origin, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipControl}(GLenum origin, GLenum depth) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glClipControl1(int origin, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glCreateTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateTransformFeedbacks"));
    }
        dispatch_glCreateTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glCreateTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateTransformFeedbacks"));
    }
        dispatch_glCreateTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackBufferBase}(GLuint xfb, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glTransformFeedbackBufferBase(int xfb, int index, int buffer)  {

    final long __addr_ = _pat._addressof_glTransformFeedbackBufferBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackBufferBase"));
    }
        dispatch_glTransformFeedbackBufferBase1(xfb, index, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackBufferBase}(GLuint xfb, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glTransformFeedbackBufferBase1(int xfb, int index, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTransformFeedbackBufferRange}(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glTransformFeedbackBufferRange(int xfb, int index, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTransformFeedbackBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackBufferRange"));
    }
        dispatch_glTransformFeedbackBufferRange1(xfb, index, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackBufferRange}(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glTransformFeedbackBufferRange1(int xfb, int index, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackiv}(GLuint xfb, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTransformFeedbackiv(int xfb, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetTransformFeedbackiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackiv"));
    }
        dispatch_glGetTransformFeedbackiv1(xfb, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackiv}(GLuint xfb, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTransformFeedbackiv1(int xfb, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackiv}(GLuint xfb, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetTransformFeedbackiv(int xfb, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetTransformFeedbackiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackiv"));
    }
        dispatch_glGetTransformFeedbackiv1(xfb, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki_v}(GLuint xfb, GLenum pname, GLuint index, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTransformFeedbacki_v(int xfb, int pname, int index, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetTransformFeedbacki_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki_v"));
    }
        dispatch_glGetTransformFeedbacki_v1(xfb, pname, index, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki_v}(GLuint xfb, GLenum pname, GLuint index, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTransformFeedbacki_v1(int xfb, int pname, int index, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki_v}(GLuint xfb, GLenum pname, GLuint index, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetTransformFeedbacki_v(int xfb, int pname, int index, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetTransformFeedbacki_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki_v"));
    }
        dispatch_glGetTransformFeedbacki_v1(xfb, pname, index, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki64_v}(GLuint xfb, GLenum pname, GLuint index, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetTransformFeedbacki64_v(int xfb, int pname, int index, LongBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetTransformFeedbacki64_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki64_v"));
    }
        dispatch_glGetTransformFeedbacki64_v1(xfb, pname, index, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki64_v}(GLuint xfb, GLenum pname, GLuint index, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetTransformFeedbacki64_v1(int xfb, int pname, int index, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbacki64_v}(GLuint xfb, GLenum pname, GLuint index, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetTransformFeedbacki64_v(int xfb, int pname, int index, long[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetTransformFeedbacki64_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbacki64_v"));
    }
        dispatch_glGetTransformFeedbacki64_v1(xfb, pname, index, param, Buffers.SIZEOF_LONG * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateBuffers(int n, IntBuffer buffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glCreateBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateBuffers"));
    }
        dispatch_glCreateBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateBuffers(int n, int[] buffers, int buffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glCreateBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateBuffers"));
    }
        dispatch_glCreateBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferStorage}(GLuint buffer, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferStorageEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glNamedBufferStorageDelegate(int buffer, long size, Buffer data, int flags)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferStorage"));
    }
        dispatch_glNamedBufferStorageDelegate1(buffer, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferStorage}(GLuint buffer, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferStorageEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glNamedBufferStorageDelegate1(int buffer, long size, Object data, int data_byte_offset, boolean data_is_direct, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferData}(GLuint buffer, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glNamedBufferDataDelegate(int buffer, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferData"));
    }
        dispatch_glNamedBufferDataDelegate1(buffer, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferData}(GLuint buffer, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glNamedBufferDataDelegate1(int buffer, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedBufferSubData(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferSubData"));
    }
        dispatch_glNamedBufferSubData1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedBufferSubData1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyNamedBufferSubData}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCopyNamedBufferSubData(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _pat._addressof_glCopyNamedBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyNamedBufferSubData"));
    }
        dispatch_glCopyNamedBufferSubData1(readBuffer, writeBuffer, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyNamedBufferSubData}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glCopyNamedBufferSubData1(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearNamedBufferData}(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_clear_buffer_object</code><br>Alias for: <code>glClearNamedBufferDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearNamedBufferData(int buffer, int internalformat, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearNamedBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedBufferData"));
    }
        dispatch_glClearNamedBufferData1(buffer, internalformat, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedBufferData}(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_clear_buffer_object</code><br>Alias for: <code>glClearNamedBufferDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearNamedBufferData1(int buffer, int internalformat, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearNamedBufferSubData}(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_clear_buffer_object</code><br>Alias for: <code>glClearNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glClearNamedBufferSubData(int buffer, int internalformat, long offset, long size, int format, int type, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glClearNamedBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedBufferSubData"));
    }
        dispatch_glClearNamedBufferSubData1(buffer, internalformat, offset, size, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedBufferSubData}(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_clear_buffer_object</code><br>Alias for: <code>glClearNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glClearNamedBufferSubData1(int buffer, int internalformat, long offset, long size, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapNamedBuffer}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glMapNamedBufferEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private long glMapNamedBufferDelegate(int buffer, int access)  {

    final long __addr_ = _pat._addressof_glMapNamedBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBuffer"));
    }
        return dispatch_glMapNamedBufferDelegate1(buffer, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapNamedBuffer}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glMapNamedBufferEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private native long dispatch_glMapNamedBufferDelegate1(int buffer, int access, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferRange}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glMapNamedBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private long glMapNamedBufferRangeDelegate(int buffer, long offset, long length, int access)  {

    final long __addr_ = _pat._addressof_glMapNamedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferRange"));
    }
        return dispatch_glMapNamedBufferRangeDelegate1(buffer, offset, length, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferRange}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glMapNamedBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private native long dispatch_glMapNamedBufferRangeDelegate1(int buffer, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glUnmapNamedBufferEXT</code>   */
  private boolean glUnmapNamedBufferDelegate(int buffer)  {

    final long __addr_ = _pat._addressof_glUnmapNamedBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapNamedBuffer"));
    }
        return dispatch_glUnmapNamedBufferDelegate1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glUnmapNamedBufferEXT</code>   */
  private native boolean dispatch_glUnmapNamedBufferDelegate1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRange}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glFlushMappedNamedBufferRangeEXT</code>   */
  public void glFlushMappedNamedBufferRange(int buffer, long offset, long length)  {

    final long __addr_ = _pat._addressof_glFlushMappedNamedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedNamedBufferRange"));
    }
        dispatch_glFlushMappedNamedBufferRange1(buffer, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRange}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glFlushMappedNamedBufferRangeEXT</code>   */
  private native void dispatch_glFlushMappedNamedBufferRange1(int buffer, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteriv}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedBufferParameteriv(int buffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteriv"));
    }
        dispatch_glGetNamedBufferParameteriv1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteriv}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedBufferParameteriv1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteriv}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferParameterivEXT</code>   */
  public void glGetNamedBufferParameteriv(int buffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteriv"));
    }
        dispatch_glGetNamedBufferParameteriv1(buffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteri64v}(GLuint buffer, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetNamedBufferParameteri64v(int buffer, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteri64v"));
    }
        dispatch_glGetNamedBufferParameteri64v1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteri64v}(GLuint buffer, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetNamedBufferParameteri64v1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameteri64v}(GLuint buffer, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetNamedBufferParameteri64v(int buffer, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameteri64v"));
    }
        dispatch_glGetNamedBufferParameteri64v1(buffer, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferPointerv}(GLuint buffer, GLenum pname, void *  *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferPointervEXT</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetNamedBufferPointerv(int buffer, int pname, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedBufferPointerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferPointerv"));
    }
        dispatch_glGetNamedBufferPointerv1(buffer, pname, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferPointerv}(GLuint buffer, GLenum pname, void *  *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferPointervEXT</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetNamedBufferPointerv1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetNamedBufferSubData(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetNamedBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferSubData"));
    }
        dispatch_glGetNamedBufferSubData1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubData}(GLuint buffer, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedBufferSubDataEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetNamedBufferSubData1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glCreateFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateFramebuffers"));
    }
        dispatch_glCreateFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glCreateFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateFramebuffers"));
    }
        dispatch_glCreateFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbuffer}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferRenderbufferEXT</code>   */
  public void glNamedFramebufferRenderbuffer(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferRenderbuffer"));
    }
        dispatch_glNamedFramebufferRenderbuffer1(framebuffer, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbuffer}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferRenderbufferEXT</code>   */
  private native void dispatch_glNamedFramebufferRenderbuffer1(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferParameteri}(GLuint framebuffer, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferParameteriEXT</code>   */
  public void glNamedFramebufferParameteri(int framebuffer, int pname, int param)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferParameteri"));
    }
        dispatch_glNamedFramebufferParameteri1(framebuffer, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferParameteri}(GLuint framebuffer, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferParameteriEXT</code>   */
  private native void dispatch_glNamedFramebufferParameteri1(int framebuffer, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferTextureEXT</code>   */
  public void glNamedFramebufferTexture(int framebuffer, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture"));
    }
        dispatch_glNamedFramebufferTexture1(framebuffer, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferTextureEXT</code>   */
  private native void dispatch_glNamedFramebufferTexture1(int framebuffer, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayer}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferTextureLayerEXT</code>   */
  public void glNamedFramebufferTextureLayer(int framebuffer, int attachment, int texture, int level, int layer)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTextureLayer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureLayer"));
    }
        dispatch_glNamedFramebufferTextureLayer1(framebuffer, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayer}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedFramebufferTextureLayerEXT</code>   */
  private native void dispatch_glNamedFramebufferTextureLayer1(int framebuffer, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferDrawBuffer}(GLuint framebuffer, GLenum buf) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glNamedFramebufferDrawBuffer(int framebuffer, int buf)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferDrawBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffer"));
    }
        dispatch_glNamedFramebufferDrawBuffer1(framebuffer, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferDrawBuffer}(GLuint framebuffer, GLenum buf) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glNamedFramebufferDrawBuffer1(int framebuffer, int buf, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferDrawBuffers}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedFramebufferDrawBuffers(int framebuffer, int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = _pat._addressof_glNamedFramebufferDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffers"));
    }
        dispatch_glNamedFramebufferDrawBuffers1(framebuffer, n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferDrawBuffers}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedFramebufferDrawBuffers1(int framebuffer, int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferDrawBuffers}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glNamedFramebufferDrawBuffers(int framebuffer, int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = _pat._addressof_glNamedFramebufferDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferDrawBuffers"));
    }
        dispatch_glNamedFramebufferDrawBuffers1(framebuffer, n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferReadBuffer}(GLuint framebuffer, GLenum src) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glNamedFramebufferReadBuffer(int framebuffer, int src)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferReadBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferReadBuffer"));
    }
        dispatch_glNamedFramebufferReadBuffer1(framebuffer, src, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferReadBuffer}(GLuint framebuffer, GLenum src) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glNamedFramebufferReadBuffer1(int framebuffer, int src, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateNamedFramebufferData(int framebuffer, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateNamedFramebufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferData"));
    }
        dispatch_glInvalidateNamedFramebufferData1(framebuffer, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateNamedFramebufferData1(int framebuffer, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glInvalidateNamedFramebufferData(int framebuffer, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateNamedFramebufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferData"));
    }
        dispatch_glInvalidateNamedFramebufferData1(framebuffer, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferSubData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, IntBuffer attachments, int x, int y, int width, int height)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateNamedFramebufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferSubData"));
    }
        dispatch_glInvalidateNamedFramebufferSubData1(framebuffer, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferSubData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateNamedFramebufferSubData1(int framebuffer, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateNamedFramebufferSubData}(GLuint framebuffer, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glInvalidateNamedFramebufferSubData(int framebuffer, int numAttachments, int[] attachments, int attachments_offset, int x, int y, int width, int height)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateNamedFramebufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateNamedFramebufferSubData"));
    }
        dispatch_glInvalidateNamedFramebufferSubData1(framebuffer, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearNamedFramebufferiv(int framebuffer, int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearNamedFramebufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferiv"));
    }
        dispatch_glClearNamedFramebufferiv1(framebuffer, buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearNamedFramebufferiv1(int framebuffer, int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glClearNamedFramebufferiv(int framebuffer, int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearNamedFramebufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferiv"));
    }
        dispatch_glClearNamedFramebufferiv1(framebuffer, buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferuiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearNamedFramebufferuiv(int framebuffer, int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearNamedFramebufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferuiv"));
    }
        dispatch_glClearNamedFramebufferuiv1(framebuffer, buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferuiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearNamedFramebufferuiv1(int framebuffer, int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferuiv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glClearNamedFramebufferuiv(int framebuffer, int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearNamedFramebufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferuiv"));
    }
        dispatch_glClearNamedFramebufferuiv1(framebuffer, buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferfv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClearNamedFramebufferfv(int framebuffer, int buffer, int drawbuffer, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearNamedFramebufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfv"));
    }
        dispatch_glClearNamedFramebufferfv1(framebuffer, buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferfv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClearNamedFramebufferfv1(int framebuffer, int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferfv}(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glClearNamedFramebufferfv(int framebuffer, int buffer, int drawbuffer, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearNamedFramebufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfv"));
    }
        dispatch_glClearNamedFramebufferfv1(framebuffer, buffer, drawbuffer, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferfi}(GLuint framebuffer, GLenum buffer, const GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glClearNamedFramebufferfi(int framebuffer, int buffer, float depth, int stencil)  {

    final long __addr_ = _pat._addressof_glClearNamedFramebufferfi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearNamedFramebufferfi"));
    }
        dispatch_glClearNamedFramebufferfi1(framebuffer, buffer, depth, stencil, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearNamedFramebufferfi}(GLuint framebuffer, GLenum buffer, const GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glClearNamedFramebufferfi1(int framebuffer, int buffer, float depth, int stencil, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitNamedFramebuffer}(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glBlitNamedFramebuffer(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _pat._addressof_glBlitNamedFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitNamedFramebuffer"));
    }
        dispatch_glBlitNamedFramebuffer1(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitNamedFramebuffer}(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glBlitNamedFramebuffer1(int readFramebuffer, int drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatus}(GLuint framebuffer, GLenum target) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCheckNamedFramebufferStatusEXT</code>   */
  public int glCheckNamedFramebufferStatus(int framebuffer, int target)  {

    final long __addr_ = _pat._addressof_glCheckNamedFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckNamedFramebufferStatus"));
    }
        return dispatch_glCheckNamedFramebufferStatus1(framebuffer, target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatus}(GLuint framebuffer, GLenum target) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCheckNamedFramebufferStatusEXT</code>   */
  private native int dispatch_glCheckNamedFramebufferStatus1(int framebuffer, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferParameteriv}(GLuint framebuffer, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferParameterivEXT</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedFramebufferParameteriv(int framebuffer, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetNamedFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferParameteriv"));
    }
        dispatch_glGetNamedFramebufferParameteriv1(framebuffer, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferParameteriv}(GLuint framebuffer, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferParameterivEXT</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedFramebufferParameteriv1(int framebuffer, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferParameteriv}(GLuint framebuffer, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferParameterivEXT</code>   */
  public void glGetNamedFramebufferParameteriv(int framebuffer, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferParameteriv"));
    }
        dispatch_glGetNamedFramebufferParameteriv1(framebuffer, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameteriv}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferAttachmentParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedFramebufferAttachmentParameteriv(int framebuffer, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetNamedFramebufferAttachmentParameteriv1(framebuffer, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameteriv}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferAttachmentParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedFramebufferAttachmentParameteriv1(int framebuffer, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameteriv}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedFramebufferAttachmentParameterivEXT</code>   */
  public void glGetNamedFramebufferAttachmentParameteriv(int framebuffer, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetNamedFramebufferAttachmentParameteriv1(framebuffer, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glCreateRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateRenderbuffers"));
    }
        dispatch_glCreateRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glCreateRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateRenderbuffers"));
    }
        dispatch_glCreateRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorage}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedRenderbufferStorageEXT</code>   */
  public void glNamedRenderbufferStorage(int renderbuffer, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glNamedRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorage"));
    }
        dispatch_glNamedRenderbufferStorage1(renderbuffer, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorage}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedRenderbufferStorageEXT</code>   */
  private native void dispatch_glNamedRenderbufferStorage1(int renderbuffer, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisample}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedRenderbufferStorageMultisampleEXT</code>   */
  public void glNamedRenderbufferStorageMultisample(int renderbuffer, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glNamedRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisample"));
    }
        dispatch_glNamedRenderbufferStorageMultisample1(renderbuffer, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisample}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glNamedRenderbufferStorageMultisampleEXT</code>   */
  private native void dispatch_glNamedRenderbufferStorageMultisample1(int renderbuffer, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameteriv}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedRenderbufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedRenderbufferParameteriv(int renderbuffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameteriv"));
    }
        dispatch_glGetNamedRenderbufferParameteriv1(renderbuffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameteriv}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedRenderbufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedRenderbufferParameteriv1(int renderbuffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameteriv}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetNamedRenderbufferParameterivEXT</code>   */
  public void glGetNamedRenderbufferParameteriv(int renderbuffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameteriv"));
    }
        dispatch_glGetNamedRenderbufferParameteriv1(renderbuffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateTextures}(GLenum target, GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateTextures(int target, int n, IntBuffer textures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glCreateTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateTextures"));
    }
        dispatch_glCreateTextures1(target, n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateTextures}(GLenum target, GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateTextures1(int target, int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateTextures}(GLenum target, GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateTextures(int target, int n, int[] textures, int textures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glCreateTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateTextures"));
    }
        dispatch_glCreateTextures1(target, n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBuffer}(GLuint texture, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureBufferEXT</code>   */
  public void glTextureBuffer(int texture, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTextureBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBuffer"));
    }
        dispatch_glTextureBuffer1(texture, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBuffer}(GLuint texture, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureBufferEXT</code>   */
  private native void dispatch_glTextureBuffer1(int texture, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureBufferRange}(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_texture_buffer_range</code><br>Alias for: <code>glTextureBufferRangeEXT</code>   */
  public void glTextureBufferRange(int texture, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTextureBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferRange"));
    }
        dispatch_glTextureBufferRange1(texture, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBufferRange}(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_texture_buffer_range</code><br>Alias for: <code>glTextureBufferRangeEXT</code>   */
  private native void dispatch_glTextureBufferRange1(int texture, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage1DEXT</code>   */
  public void glTextureStorage1D(int texture, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTextureStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1D"));
    }
        dispatch_glTextureStorage1D1(texture, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage1DEXT</code>   */
  private native void dispatch_glTextureStorage1D1(int texture, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage2DEXT</code>   */
  public void glTextureStorage2D(int texture, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTextureStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2D"));
    }
        dispatch_glTextureStorage2D1(texture, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage2DEXT</code>   */
  private native void dispatch_glTextureStorage2D1(int texture, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage3DEXT</code>   */
  public void glTextureStorage3D(int texture, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTextureStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3D"));
    }
        dispatch_glTextureStorage3D1(texture, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3D}(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage3DEXT</code>   */
  private native void dispatch_glTextureStorage3D1(int texture, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DMultisample}(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage2DMultisampleEXT</code>   */
  public void glTextureStorage2DMultisample(int texture, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTextureStorage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DMultisample"));
    }
        dispatch_glTextureStorage2DMultisample1(texture, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DMultisample}(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage2DMultisampleEXT</code>   */
  private native void dispatch_glTextureStorage2DMultisample1(int texture, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DMultisample}(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage3DMultisampleEXT</code>   */
  public void glTextureStorage3DMultisample(int texture, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTextureStorage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DMultisample"));
    }
        dispatch_glTextureStorage3DMultisample1(texture, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DMultisample}(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureStorage3DMultisampleEXT</code>   */
  private native void dispatch_glTextureStorage3DMultisample1(int texture, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage1DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage1D(int texture, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1D"));
    }
        dispatch_glTextureSubImage1D1(texture, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage1DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage1D1(int texture, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage1DEXT</code>   */
  public void glTextureSubImage1D(int texture, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1D"));
    }
        dispatch_glTextureSubImage1D1(texture, level, xoffset, width, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage1DEXT</code>   */
  private native void dispatch_glTextureSubImage1D1(int texture, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2D"));
    }
        dispatch_glTextureSubImage2D1(texture, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage2D1(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage2DEXT</code>   */
  public void glTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2D"));
    }
        dispatch_glTextureSubImage2D1(texture, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage2DEXT</code>   */
  private native void dispatch_glTextureSubImage2D1(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3D"));
    }
        dispatch_glTextureSubImage3D1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage3D1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage3DEXT</code>   */
  public void glTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3D"));
    }
        dispatch_glTextureSubImage3D1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureSubImage3DEXT</code>   */
  private native void dispatch_glTextureSubImage3D1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage1DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage1D(int texture, int level, int xoffset, int width, int format, int imageSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage1D"));
    }
        dispatch_glCompressedTextureSubImage1D1(texture, level, xoffset, width, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage1DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage1D1(int texture, int level, int xoffset, int width, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage2DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage2D"));
    }
        dispatch_glCompressedTextureSubImage2D1(texture, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage2DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage2D1(int texture, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage3DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage3D"));
    }
        dispatch_glCompressedTextureSubImage3D1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCompressedTextureSubImage3DEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage3D1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage1DEXT</code>   */
  public void glCopyTextureSubImage1D(int texture, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage1D"));
    }
        dispatch_glCopyTextureSubImage1D1(texture, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1D}(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage1DEXT</code>   */
  private native void dispatch_glCopyTextureSubImage1D1(int texture, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage2DEXT</code>   */
  public void glCopyTextureSubImage2D(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage2D"));
    }
        dispatch_glCopyTextureSubImage2D1(texture, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage2DEXT</code>   */
  private native void dispatch_glCopyTextureSubImage2D1(int texture, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage3DEXT</code>   */
  public void glCopyTextureSubImage3D(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage3D"));
    }
        dispatch_glCopyTextureSubImage3D1(texture, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3D}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glCopyTextureSubImage3DEXT</code>   */
  private native void dispatch_glCopyTextureSubImage3D1(int texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterf}(GLuint texture, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterfEXT</code>   */
  public void glTextureParameterf(int texture, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTextureParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterf"));
    }
        dispatch_glTextureParameterf1(texture, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterf}(GLuint texture, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterfEXT</code>   */
  private native void dispatch_glTextureParameterf1(int texture, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfv}(GLuint texture, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterfvEXT</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTextureParameterfv(int texture, int pname, FloatBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glTextureParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfv"));
    }
        dispatch_glTextureParameterfv1(texture, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfv}(GLuint texture, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterfvEXT</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTextureParameterfv1(int texture, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfv}(GLuint texture, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterfvEXT</code>   */
  public void glTextureParameterfv(int texture, int pname, float[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfv"));
    }
        dispatch_glTextureParameterfv1(texture, pname, param, Buffers.SIZEOF_FLOAT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteri}(GLuint texture, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameteriEXT</code>   */
  public void glTextureParameteri(int texture, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTextureParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteri"));
    }
        dispatch_glTextureParameteri1(texture, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteri}(GLuint texture, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameteriEXT</code>   */
  private native void dispatch_glTextureParameteri1(int texture, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIiv}(GLuint texture, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIiv(int texture, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIiv"));
    }
        dispatch_glTextureParameterIiv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIiv}(GLuint texture, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIiv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIiv}(GLuint texture, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIivEXT</code>   */
  public void glTextureParameterIiv(int texture, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIiv"));
    }
        dispatch_glTextureParameterIiv1(texture, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuiv}(GLuint texture, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIuiv(int texture, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuiv"));
    }
        dispatch_glTextureParameterIuiv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuiv}(GLuint texture, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIuiv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIuiv}(GLuint texture, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterIuivEXT</code>   */
  public void glTextureParameterIuiv(int texture, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuiv"));
    }
        dispatch_glTextureParameterIuiv1(texture, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriv}(GLuint texture, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterivEXT</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameteriv(int texture, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glTextureParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriv"));
    }
        dispatch_glTextureParameteriv1(texture, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriv}(GLuint texture, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterivEXT</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameteriv1(int texture, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameteriv}(GLuint texture, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glTextureParameterivEXT</code>   */
  public void glTextureParameteriv(int texture, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriv"));
    }
        dispatch_glTextureParameteriv1(texture, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmap}(GLuint texture) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGenerateTextureMipmapEXT</code>   */
  public void glGenerateTextureMipmap(int texture)  {

    final long __addr_ = _pat._addressof_glGenerateTextureMipmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateTextureMipmap"));
    }
        dispatch_glGenerateTextureMipmap1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmap}(GLuint texture) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGenerateTextureMipmapEXT</code>   */
  private native void dispatch_glGenerateTextureMipmap1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTextureUnit}(GLuint unit, GLuint texture) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glBindTextureUnit(int unit, int texture)  {

    final long __addr_ = _pat._addressof_glBindTextureUnit;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTextureUnit"));
    }
        dispatch_glBindTextureUnit1(unit, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTextureUnit}(GLuint unit, GLuint texture) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glBindTextureUnit1(int unit, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureImage}(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureImageEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTextureImage(int texture, int level, int format, int type, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetTextureImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureImage"));
    }
        dispatch_glGetTextureImage1(texture, level, format, type, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureImage}(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureImageEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTextureImage1(int texture, int level, int format, int type, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImage}(GLuint texture, GLint level, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetCompressedTextureImageEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTextureImage(int texture, int level, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetCompressedTextureImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureImage"));
    }
        dispatch_glGetCompressedTextureImage1(texture, level, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImage}(GLuint texture, GLint level, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetCompressedTextureImageEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTextureImage1(int texture, int level, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfv}(GLuint texture, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureLevelParameterfv(int texture, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfv"));
    }
        dispatch_glGetTextureLevelParameterfv1(texture, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfv}(GLuint texture, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureLevelParameterfv1(int texture, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfv}(GLuint texture, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterfvEXT</code>   */
  public void glGetTextureLevelParameterfv(int texture, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfv"));
    }
        dispatch_glGetTextureLevelParameterfv1(texture, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameteriv}(GLuint texture, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureLevelParameteriv(int texture, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameteriv"));
    }
        dispatch_glGetTextureLevelParameteriv1(texture, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameteriv}(GLuint texture, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureLevelParameteriv1(int texture, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameteriv}(GLuint texture, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureLevelParameterivEXT</code>   */
  public void glGetTextureLevelParameteriv(int texture, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameteriv"));
    }
        dispatch_glGetTextureLevelParameteriv1(texture, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfv}(GLuint texture, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureParameterfv(int texture, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfv"));
    }
        dispatch_glGetTextureParameterfv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfv}(GLuint texture, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureParameterfv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfv}(GLuint texture, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterfvEXT</code>   */
  public void glGetTextureParameterfv(int texture, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfv"));
    }
        dispatch_glGetTextureParameterfv1(texture, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIiv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIiv(int texture, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIiv"));
    }
        dispatch_glGetTextureParameterIiv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIiv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIiv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIiv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIivEXT</code>   */
  public void glGetTextureParameterIiv(int texture, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIiv"));
    }
        dispatch_glGetTextureParameterIiv1(texture, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuiv}(GLuint texture, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIuiv(int texture, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuiv"));
    }
        dispatch_glGetTextureParameterIuiv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuiv}(GLuint texture, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIuiv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuiv}(GLuint texture, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterIuivEXT</code>   */
  public void glGetTextureParameterIuiv(int texture, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuiv"));
    }
        dispatch_glGetTextureParameterIuiv1(texture, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameteriv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameteriv(int texture, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameteriv"));
    }
        dispatch_glGetTextureParameteriv1(texture, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameteriv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameteriv1(int texture, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameteriv}(GLuint texture, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetTextureParameterivEXT</code>   */
  public void glGetTextureParameteriv(int texture, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameteriv"));
    }
        dispatch_glGetTextureParameteriv1(texture, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glCreateVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateVertexArrays"));
    }
        dispatch_glCreateVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glCreateVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateVertexArrays"));
    }
        dispatch_glCreateVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayAttrib}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glDisableVertexArrayAttribEXT</code>   */
  public void glDisableVertexArrayAttrib(int vaobj, int index)  {

    final long __addr_ = _pat._addressof_glDisableVertexArrayAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayAttrib"));
    }
        dispatch_glDisableVertexArrayAttrib1(vaobj, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayAttrib}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glDisableVertexArrayAttribEXT</code>   */
  private native void dispatch_glDisableVertexArrayAttrib1(int vaobj, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayAttrib}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glEnableVertexArrayAttribEXT</code>   */
  public void glEnableVertexArrayAttrib(int vaobj, int index)  {

    final long __addr_ = _pat._addressof_glEnableVertexArrayAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayAttrib"));
    }
        dispatch_glEnableVertexArrayAttrib1(vaobj, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayAttrib}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glEnableVertexArrayAttribEXT</code>   */
  private native void dispatch_glEnableVertexArrayAttrib1(int vaobj, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayElementBuffer}(GLuint vaobj, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayElementBuffer(int vaobj, int buffer)  {

    final long __addr_ = _pat._addressof_glVertexArrayElementBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayElementBuffer"));
    }
        dispatch_glVertexArrayElementBuffer1(vaobj, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayElementBuffer}(GLuint vaobj, GLuint buffer) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayElementBuffer1(int vaobj, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBuffer}(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayVertexBuffer(int vaobj, int bindingindex, int buffer, long offset, int stride)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffer"));
    }
        dispatch_glVertexArrayVertexBuffer1(vaobj, bindingindex, buffer, offset, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBuffer}(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayVertexBuffer1(int vaobj, int bindingindex, int buffer, long offset, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBuffers}(GLuint vaobj, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param strides a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexArrayVertexBuffers(int vaobj, int first, int count, IntBuffer buffers, PointerBuffer offsets, IntBuffer strides)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    final boolean strides_is_direct = Buffers.isDirect(strides);
    final long __addr_ = _pat._addressof_glVertexArrayVertexBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffers"));
    }
        dispatch_glVertexArrayVertexBuffers1(vaobj, first, count, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, strides_is_direct ? strides : Buffers.getArray(strides), strides_is_direct ? Buffers.getDirectBufferByteOffset(strides) : Buffers.getIndirectBufferByteOffset(strides), strides_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBuffers}(GLuint vaobj, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param strides a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexArrayVertexBuffers1(int vaobj, int first, int count, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, Object offsets, int offsets_byte_offset, boolean offsets_is_direct, Object strides, int strides_byte_offset, boolean strides_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBuffers}(GLuint vaobj, GLuint first, GLsizei count, const GLuint *  buffers, const GLintptr *  offsets, const GLsizei *  strides) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param offsets a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glVertexArrayVertexBuffers(int vaobj, int first, int count, int[] buffers, int buffers_offset, PointerBuffer offsets, int[] strides, int strides_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final boolean offsets_is_direct = Buffers.isDirect(offsets);
    if(strides != null && strides.length <= strides_offset)
      throw new GLException("array offset argument \"strides_offset\" (" + strides_offset + ") equals or exceeds array length (" + strides.length + ")");
    final long __addr_ = _pat._addressof_glVertexArrayVertexBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBuffers"));
    }
        dispatch_glVertexArrayVertexBuffers1(vaobj, first, count, buffers, Buffers.SIZEOF_INT * buffers_offset, false, offsets_is_direct ? ( offsets != null ? offsets.getBuffer() : null ) : Buffers.getArray(offsets), offsets_is_direct ? Buffers.getDirectBufferByteOffset(offsets) : Buffers.getIndirectBufferByteOffset(offsets), offsets_is_direct, strides, Buffers.SIZEOF_INT * strides_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribBinding}(GLuint vaobj, GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayAttribBinding(int vaobj, int attribindex, int bindingindex)  {

    final long __addr_ = _pat._addressof_glVertexArrayAttribBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribBinding"));
    }
        dispatch_glVertexArrayAttribBinding1(vaobj, attribindex, bindingindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribBinding}(GLuint vaobj, GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayAttribBinding1(int vaobj, int attribindex, int bindingindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayAttribFormat(int vaobj, int attribindex, int size, int type, boolean normalized, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayAttribFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribFormat"));
    }
        dispatch_glVertexArrayAttribFormat1(vaobj, attribindex, size, type, normalized, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayAttribFormat1(int vaobj, int attribindex, int size, int type, boolean normalized, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribIFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayAttribIFormat(int vaobj, int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayAttribIFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribIFormat"));
    }
        dispatch_glVertexArrayAttribIFormat1(vaobj, attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribIFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayAttribIFormat1(int vaobj, int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribLFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayAttribLFormat(int vaobj, int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayAttribLFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayAttribLFormat"));
    }
        dispatch_glVertexArrayAttribLFormat1(vaobj, attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayAttribLFormat}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayAttribLFormat1(int vaobj, int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayBindingDivisor}(GLuint vaobj, GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glVertexArrayBindingDivisor(int vaobj, int bindingindex, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexArrayBindingDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayBindingDivisor"));
    }
        dispatch_glVertexArrayBindingDivisor1(vaobj, bindingindex, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayBindingDivisor}(GLuint vaobj, GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glVertexArrayBindingDivisor1(int vaobj, int bindingindex, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayiv}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexArrayiv(int vaobj, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayiv"));
    }
        dispatch_glGetVertexArrayiv1(vaobj, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayiv}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexArrayiv1(int vaobj, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayiv}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetVertexArrayiv(int vaobj, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexArrayiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayiv"));
    }
        dispatch_glGetVertexArrayiv1(vaobj, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexediv}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexArrayIndexediv(int vaobj, int index, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayIndexediv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexediv"));
    }
        dispatch_glGetVertexArrayIndexediv1(vaobj, index, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexediv}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexArrayIndexediv1(int vaobj, int index, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexediv}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetVertexArrayIndexediv(int vaobj, int index, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexArrayIndexediv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexediv"));
    }
        dispatch_glGetVertexArrayIndexediv1(vaobj, index, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexed64iv}(GLuint vaobj, GLuint index, GLenum pname, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexArrayIndexed64iv(int vaobj, int index, int pname, LongBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayIndexed64iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexed64iv"));
    }
        dispatch_glGetVertexArrayIndexed64iv1(vaobj, index, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexed64iv}(GLuint vaobj, GLuint index, GLenum pname, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param param a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexArrayIndexed64iv1(int vaobj, int index, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIndexed64iv}(GLuint vaobj, GLuint index, GLenum pname, GLint64 *  param) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetVertexArrayIndexed64iv(int vaobj, int index, int pname, long[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexArrayIndexed64iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIndexed64iv"));
    }
        dispatch_glGetVertexArrayIndexed64iv1(vaobj, index, pname, param, Buffers.SIZEOF_LONG * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateSamplers}(GLsizei n, GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateSamplers(int n, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glCreateSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateSamplers"));
    }
        dispatch_glCreateSamplers1(n, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateSamplers}(GLsizei n, GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateSamplers1(int n, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateSamplers}(GLsizei n, GLuint *  samplers) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateSamplers(int n, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glCreateSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateSamplers"));
    }
        dispatch_glCreateSamplers1(n, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = _pat._addressof_glCreateProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramPipelines"));
    }
        dispatch_glCreateProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = _pat._addressof_glCreateProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramPipelines"));
    }
        dispatch_glCreateProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateQueries}(GLenum target, GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateQueries(int target, int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glCreateQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateQueries"));
    }
        dispatch_glCreateQueries1(target, n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateQueries}(GLenum target, GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateQueries1(int target, int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateQueries}(GLenum target, GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glCreateQueries(int target, int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glCreateQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateQueries"));
    }
        dispatch_glCreateQueries1(target, n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjecti64v}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetQueryBufferObjecti64v(int id, int buffer, int pname, long offset)  {

    final long __addr_ = _pat._addressof_glGetQueryBufferObjecti64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjecti64v"));
    }
        dispatch_glGetQueryBufferObjecti64v1(id, buffer, pname, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjecti64v}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glGetQueryBufferObjecti64v1(int id, int buffer, int pname, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectiv}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetQueryBufferObjectiv(int id, int buffer, int pname, long offset)  {

    final long __addr_ = _pat._addressof_glGetQueryBufferObjectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectiv"));
    }
        dispatch_glGetQueryBufferObjectiv1(id, buffer, pname, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectiv}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glGetQueryBufferObjectiv1(int id, int buffer, int pname, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectui64v}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetQueryBufferObjectui64v(int id, int buffer, int pname, long offset)  {

    final long __addr_ = _pat._addressof_glGetQueryBufferObjectui64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectui64v"));
    }
        dispatch_glGetQueryBufferObjectui64v1(id, buffer, pname, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectui64v}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glGetQueryBufferObjectui64v1(int id, int buffer, int pname, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectuiv}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  public void glGetQueryBufferObjectuiv(int id, int buffer, int pname, long offset)  {

    final long __addr_ = _pat._addressof_glGetQueryBufferObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryBufferObjectuiv"));
    }
        dispatch_glGetQueryBufferObjectuiv1(id, buffer, pname, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryBufferObjectuiv}(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) </code> <br>Part of <code>GL_VERSION_4_5</code><br>   */
  private native void dispatch_glGetQueryBufferObjectuiv1(int id, int buffer, int pname, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glMemoryBarrierByRegion}(GLbitfield barriers) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_1</code><br>   */
  public void glMemoryBarrierByRegion(int barriers)  {

    final long __addr_ = _pat._addressof_glMemoryBarrierByRegion;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrierByRegion"));
    }
        dispatch_glMemoryBarrierByRegion1(barriers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrierByRegion}(GLbitfield barriers) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_1</code><br>   */
  private native void dispatch_glMemoryBarrierByRegion1(int barriers, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetTextureSubImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureSubImage"));
    }
        dispatch_glGetTextureSubImage1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTextureSubImage1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTextureSubImage(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetCompressedTextureSubImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureSubImage"));
    }
        dispatch_glGetCompressedTextureSubImage1(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureSubImage}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTextureSubImage1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = _pat._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetGraphicsResetStatus"));
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  private native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnCompressedTexImage}(GLenum target, GLint lod, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnCompressedTexImageARB</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnCompressedTexImage(int target, int lod, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetnCompressedTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnCompressedTexImage"));
    }
        dispatch_glGetnCompressedTexImage1(target, lod, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnCompressedTexImage}(GLenum target, GLint lod, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnCompressedTexImageARB</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnCompressedTexImage1(int target, int lod, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnTexImageARB</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnTexImage(int target, int level, int format, int type, int bufSize, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetnTexImage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnTexImage"));
    }
        dispatch_glGetnTexImage1(target, level, format, type, bufSize, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnTexImage}(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *  pixels) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnTexImageARB</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnTexImage1(int target, int level, int format, int type, int bufSize, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformdv}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformdvARB</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetnUniformdv(int program, int location, int bufSize, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformdv"));
    }
        dispatch_glGetnUniformdv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformdv}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformdvARB</code>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetnUniformdv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformdv}(GLuint program, GLint location, GLsizei bufSize, GLdouble *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformdvARB</code>   */
  public void glGetnUniformdv(int program, int location, int bufSize, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformdv"));
    }
        dispatch_glGetnUniformdv1(program, location, bufSize, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvARB</code>, <code>glGetnUniformfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvARB</code>, <code>glGetnUniformfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvARB</code>, <code>glGetnUniformfvEXT</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivARB</code>, <code>glGetnUniformivEXT</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivARB</code>, <code>glGetnUniformivEXT</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivARB</code>, <code>glGetnUniformivEXT</code>, <code>glGetnUniformivKHR</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformuiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformuiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>   */
  public void glGetnUniformuiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsARB</code>, <code>glReadnPixelsEXT</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadnPixels"));
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsARB</code>, <code>glReadnPixelsEXT</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapdv}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapdvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetnMapdv(int target, int query, int bufSize, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetnMapdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapdv"));
    }
        dispatch_glGetnMapdv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapdv}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapdvARB</code>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetnMapdv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapdv}(GLenum target, GLenum query, GLsizei bufSize, GLdouble *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapdvARB</code>   */
  public void glGetnMapdv(int target, int query, int bufSize, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetnMapdv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapdv"));
    }
        dispatch_glGetnMapdv1(target, query, bufSize, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapfv}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapfvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnMapfv(int target, int query, int bufSize, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetnMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapfv"));
    }
        dispatch_glGetnMapfv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapfv}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapfvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnMapfv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapfv}(GLenum target, GLenum query, GLsizei bufSize, GLfloat *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapfvARB</code>   */
  public void glGetnMapfv(int target, int query, int bufSize, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetnMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapfv"));
    }
        dispatch_glGetnMapfv1(target, query, bufSize, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapiv}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnMapiv(int target, int query, int bufSize, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetnMapiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapiv"));
    }
        dispatch_glGetnMapiv1(target, query, bufSize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMapiv}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapivARB</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnMapiv1(int target, int query, int bufSize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMapiv}(GLenum target, GLenum query, GLsizei bufSize, GLint *  v) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMapivARB</code>   */
  public void glGetnMapiv(int target, int query, int bufSize, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetnMapiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMapiv"));
    }
        dispatch_glGetnMapiv1(target, query, bufSize, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfv}(GLenum map, GLsizei bufSize, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapfvARB</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnPixelMapfv(int map, int bufSize, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetnPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapfv"));
    }
        dispatch_glGetnPixelMapfv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfv}(GLenum map, GLsizei bufSize, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapfvARB</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnPixelMapfv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapfv}(GLenum map, GLsizei bufSize, GLfloat *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapfvARB</code>   */
  public void glGetnPixelMapfv(int map, int bufSize, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetnPixelMapfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapfv"));
    }
        dispatch_glGetnPixelMapfv1(map, bufSize, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuiv}(GLenum map, GLsizei bufSize, GLuint *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapuivARB</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnPixelMapuiv(int map, int bufSize, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetnPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapuiv"));
    }
        dispatch_glGetnPixelMapuiv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuiv}(GLenum map, GLsizei bufSize, GLuint *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapuivARB</code>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnPixelMapuiv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapuiv}(GLenum map, GLsizei bufSize, GLuint *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapuivARB</code>   */
  public void glGetnPixelMapuiv(int map, int bufSize, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetnPixelMapuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapuiv"));
    }
        dispatch_glGetnPixelMapuiv1(map, bufSize, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusv}(GLenum map, GLsizei bufSize, GLushort *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapusvARB</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glGetnPixelMapusv(int map, int bufSize, ShortBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetnPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapusv"));
    }
        dispatch_glGetnPixelMapusv1(map, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusv}(GLenum map, GLsizei bufSize, GLushort *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapusvARB</code>
      @param values a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glGetnPixelMapusv1(int map, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPixelMapusv}(GLenum map, GLsizei bufSize, GLushort *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPixelMapusvARB</code>   */
  public void glGetnPixelMapusv(int map, int bufSize, short[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetnPixelMapusv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPixelMapusv"));
    }
        dispatch_glGetnPixelMapusv1(map, bufSize, values, Buffers.SIZEOF_SHORT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPolygonStipple}(GLsizei bufSize, GLubyte *  pattern) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPolygonStippleARB</code>
      @param pattern a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetnPolygonStipple(int bufSize, ByteBuffer pattern)  {

    final boolean pattern_is_direct = Buffers.isDirect(pattern);
    final long __addr_ = _pat._addressof_glGetnPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPolygonStipple"));
    }
        dispatch_glGetnPolygonStipple1(bufSize, pattern_is_direct ? pattern : Buffers.getArray(pattern), pattern_is_direct ? Buffers.getDirectBufferByteOffset(pattern) : Buffers.getIndirectBufferByteOffset(pattern), pattern_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnPolygonStipple}(GLsizei bufSize, GLubyte *  pattern) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPolygonStippleARB</code>
      @param pattern a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetnPolygonStipple1(int bufSize, Object pattern, int pattern_byte_offset, boolean pattern_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnPolygonStipple}(GLsizei bufSize, GLubyte *  pattern) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnPolygonStippleARB</code>   */
  public void glGetnPolygonStipple(int bufSize, byte[] pattern, int pattern_offset)  {

    if(pattern != null && pattern.length <= pattern_offset)
      throw new GLException("array offset argument \"pattern_offset\" (" + pattern_offset + ") equals or exceeds array length (" + pattern.length + ")");
    final long __addr_ = _pat._addressof_glGetnPolygonStipple;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnPolygonStipple"));
    }
        dispatch_glGetnPolygonStipple1(bufSize, pattern, pattern_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnColorTable}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *  table) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnColorTableARB</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnColorTable(int target, int format, int type, int bufSize, Buffer table)  {

    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = _pat._addressof_glGetnColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnColorTable"));
    }
        dispatch_glGetnColorTable1(target, format, type, bufSize, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnColorTable}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *  table) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnColorTableARB</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnColorTable1(int target, int format, int type, int bufSize, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *  image) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnConvolutionFilterARB</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnConvolutionFilter(int target, int format, int type, int bufSize, Buffer image)  {

    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = _pat._addressof_glGetnConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnConvolutionFilter"));
    }
        dispatch_glGetnConvolutionFilter1(target, format, type, bufSize, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnConvolutionFilter}(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *  image) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnConvolutionFilterARB</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnConvolutionFilter1(int target, int format, int type, int bufSize, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnSeparableFilter}(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *  row, GLsizei columnBufSize, void *  column, void *  span) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnSeparableFilterARB</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnSeparableFilter(int target, int format, int type, int rowBufSize, Buffer row, int columnBufSize, Buffer column, Buffer span)  {

    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final boolean span_is_direct = Buffers.isDirect(span);
    final long __addr_ = _pat._addressof_glGetnSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnSeparableFilter"));
    }
        dispatch_glGetnSeparableFilter1(target, format, type, rowBufSize, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, columnBufSize, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, span_is_direct ? span : Buffers.getArray(span), span_is_direct ? Buffers.getDirectBufferByteOffset(span) : Buffers.getIndirectBufferByteOffset(span), span_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnSeparableFilter}(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *  row, GLsizei columnBufSize, void *  column, void *  span) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnSeparableFilterARB</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnSeparableFilter1(int target, int format, int type, int rowBufSize, Object row, int row_byte_offset, boolean row_is_direct, int columnBufSize, Object column, int column_byte_offset, boolean column_is_direct, Object span, int span_byte_offset, boolean span_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnHistogramARB</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnHistogram(int target, boolean reset, int format, int type, int bufSize, Buffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetnHistogram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnHistogram"));
    }
        dispatch_glGetnHistogram1(target, reset, format, type, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnHistogramARB</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnHistogram1(int target, boolean reset, int format, int type, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMinmaxARB</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetnMinmax(int target, boolean reset, int format, int type, int bufSize, Buffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetnMinmax;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnMinmax"));
    }
        dispatch_glGetnMinmax1(target, reset, format, type, bufSize, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *  values) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnMinmaxARB</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetnMinmax1(int target, boolean reset, int format, int type, int bufSize, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureBarrier}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_NV_texture_barrier</code><br>Alias for: <code>glTextureBarrierNV</code>   */
  public void glTextureBarrier()  {

    final long __addr_ = _pat._addressof_glTextureBarrier;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBarrier"));
    }
        dispatch_glTextureBarrier1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBarrier}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_NV_texture_barrier</code><br>Alias for: <code>glTextureBarrierNV</code>   */
  private native void dispatch_glTextureBarrier1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBox}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_OES_primitive_bounding_box</code>, <code>GL_ARB_ES3_2_compatibility</code>, <code>GL_EXT_primitive_bounding_box</code><br>Alias for: <code>glPrimitiveBoundingBoxOES</code>, <code>glPrimitiveBoundingBoxARB</code>, <code>glPrimitiveBoundingBoxEXT</code>   */
  public void glPrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)  {

    final long __addr_ = _pat._addressof_glPrimitiveBoundingBox;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveBoundingBox"));
    }
        dispatch_glPrimitiveBoundingBox1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBox}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_OES_primitive_bounding_box</code>, <code>GL_ARB_ES3_2_compatibility</code>, <code>GL_EXT_primitive_bounding_box</code><br>Alias for: <code>glPrimitiveBoundingBoxOES</code>, <code>glPrimitiveBoundingBoxARB</code>, <code>glPrimitiveBoundingBoxEXT</code>   */
  private native void dispatch_glPrimitiveBoundingBox1(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW, long procAddress);

  /** Entry point to C language function: <code> GLuint64 {@native glGetTextureHandleARB}(GLuint texture) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public long glGetTextureHandleARB(int texture)  {

    final long __addr_ = _pat._addressof_glGetTextureHandleARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureHandleARB"));
    }
        return dispatch_glGetTextureHandleARB1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLuint64 {@native glGetTextureHandleARB}(GLuint texture) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native long dispatch_glGetTextureHandleARB1(int texture, long procAddress);

  /** Entry point to C language function: <code> GLuint64 {@native glGetTextureSamplerHandleARB}(GLuint texture, GLuint sampler) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public long glGetTextureSamplerHandleARB(int texture, int sampler)  {

    final long __addr_ = _pat._addressof_glGetTextureSamplerHandleARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureSamplerHandleARB"));
    }
        return dispatch_glGetTextureSamplerHandleARB1(texture, sampler, __addr_);
  }

  /** Entry point to C language function: <code> GLuint64 {@native glGetTextureSamplerHandleARB}(GLuint texture, GLuint sampler) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native long dispatch_glGetTextureSamplerHandleARB1(int texture, int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeTextureHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glMakeTextureHandleResidentARB(long handle)  {

    final long __addr_ = _pat._addressof_glMakeTextureHandleResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeTextureHandleResidentARB"));
    }
        dispatch_glMakeTextureHandleResidentARB1(handle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeTextureHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glMakeTextureHandleResidentARB1(long handle, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeTextureHandleNonResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glMakeTextureHandleNonResidentARB(long handle)  {

    final long __addr_ = _pat._addressof_glMakeTextureHandleNonResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeTextureHandleNonResidentARB"));
    }
        dispatch_glMakeTextureHandleNonResidentARB1(handle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeTextureHandleNonResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glMakeTextureHandleNonResidentARB1(long handle, long procAddress);

  /** Entry point to C language function: <code> GLuint64 {@native glGetImageHandleARB}(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public long glGetImageHandleARB(int texture, int level, boolean layered, int layer, int format)  {

    final long __addr_ = _pat._addressof_glGetImageHandleARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetImageHandleARB"));
    }
        return dispatch_glGetImageHandleARB1(texture, level, layered, layer, format, __addr_);
  }

  /** Entry point to C language function: <code> GLuint64 {@native glGetImageHandleARB}(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native long dispatch_glGetImageHandleARB1(int texture, int level, boolean layered, int layer, int format, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeImageHandleResidentARB}(GLuint64 handle, GLenum access) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glMakeImageHandleResidentARB(long handle, int access)  {

    final long __addr_ = _pat._addressof_glMakeImageHandleResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeImageHandleResidentARB"));
    }
        dispatch_glMakeImageHandleResidentARB1(handle, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeImageHandleResidentARB}(GLuint64 handle, GLenum access) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glMakeImageHandleResidentARB1(long handle, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeImageHandleNonResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glMakeImageHandleNonResidentARB(long handle)  {

    final long __addr_ = _pat._addressof_glMakeImageHandleNonResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeImageHandleNonResidentARB"));
    }
        dispatch_glMakeImageHandleNonResidentARB1(handle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeImageHandleNonResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glMakeImageHandleNonResidentARB1(long handle, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformHandleui64ARB}(GLint location, GLuint64 value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glUniformHandleui64ARB(int location, long value)  {

    final long __addr_ = _pat._addressof_glUniformHandleui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64ARB"));
    }
        dispatch_glUniformHandleui64ARB1(location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformHandleui64ARB}(GLint location, GLuint64 value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glUniformHandleui64ARB1(int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformHandleui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniformHandleui64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformHandleui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64vARB"));
    }
        dispatch_glUniformHandleui64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformHandleui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniformHandleui64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformHandleui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glUniformHandleui64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformHandleui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformHandleui64vARB"));
    }
        dispatch_glUniformHandleui64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformHandleui64ARB}(GLuint program, GLint location, GLuint64 value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glProgramUniformHandleui64ARB(int program, int location, long value)  {

    final long __addr_ = _pat._addressof_glProgramUniformHandleui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64ARB"));
    }
        dispatch_glProgramUniformHandleui64ARB1(program, location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformHandleui64ARB}(GLuint program, GLint location, GLuint64 value) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glProgramUniformHandleui64ARB1(int program, int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformHandleui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  values) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param values a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniformHandleui64vARB(int program, int location, int count, LongBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glProgramUniformHandleui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64vARB"));
    }
        dispatch_glProgramUniformHandleui64vARB1(program, location, count, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformHandleui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  values) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param values a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniformHandleui64vARB1(int program, int location, int count, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformHandleui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  values) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glProgramUniformHandleui64vARB(int program, int location, int count, long[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformHandleui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformHandleui64vARB"));
    }
        dispatch_glProgramUniformHandleui64vARB1(program, location, count, values, Buffers.SIZEOF_LONG * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTextureHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public boolean glIsTextureHandleResidentARB(long handle)  {

    final long __addr_ = _pat._addressof_glIsTextureHandleResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTextureHandleResidentARB"));
    }
        return dispatch_glIsTextureHandleResidentARB1(handle, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTextureHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native boolean dispatch_glIsTextureHandleResidentARB1(long handle, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsImageHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public boolean glIsImageHandleResidentARB(long handle)  {

    final long __addr_ = _pat._addressof_glIsImageHandleResidentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsImageHandleResidentARB"));
    }
        return dispatch_glIsImageHandleResidentARB1(handle, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsImageHandleResidentARB}(GLuint64 handle) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native boolean dispatch_glIsImageHandleResidentARB1(long handle, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64ARB}(GLuint index, GLuint64EXT x) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glVertexAttribL1ui64ARB(int index, long x)  {

    final long __addr_ = _pat._addressof_glVertexAttribL1ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64ARB"));
    }
        dispatch_glVertexAttribL1ui64ARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64ARB}(GLuint index, GLuint64EXT x) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  private native void dispatch_glVertexAttribL1ui64ARB1(int index, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vARB}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL1ui64vARB(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vARB"));
    }
        dispatch_glVertexAttribL1ui64vARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vARB}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL1ui64vARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vARB}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glVertexAttribL1ui64vARB(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vARB"));
    }
        dispatch_glVertexAttribL1ui64vARB1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vARB}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexAttribLui64vARB(int index, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribLui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vARB"));
    }
        dispatch_glGetVertexAttribLui64vARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vARB}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexAttribLui64vARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vARB}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_ARB_bindless_texture</code><br>   */
  public void glGetVertexAttribLui64vARB(int index, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribLui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vARB"));
    }
        dispatch_glGetVertexAttribLui64vARB1(index, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glCreateSyncFromCLeventARB}(struct _cl_context *  context, struct _cl_event *  event, GLbitfield flags) </code> <br>Part of <code>GL_ARB_cl_event</code><br>   */
  public long glCreateSyncFromCLeventARB(long context, long event, int flags)  {

    final long __addr_ = _pat._addressof_glCreateSyncFromCLeventARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateSyncFromCLeventARB"));
    }
        return dispatch_glCreateSyncFromCLeventARB1(context, event, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glCreateSyncFromCLeventARB}(struct _cl_context *  context, struct _cl_event *  event, GLbitfield flags) </code> <br>Part of <code>GL_ARB_cl_event</code><br>   */
  private native long dispatch_glCreateSyncFromCLeventARB1(long context, long event, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glDispatchComputeGroupSizeARB}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) </code> <br>Part of <code>GL_ARB_compute_variable_group_size</code><br>   */
  public void glDispatchComputeGroupSizeARB(int num_groups_x, int num_groups_y, int num_groups_z, int group_size_x, int group_size_y, int group_size_z)  {

    final long __addr_ = _pat._addressof_glDispatchComputeGroupSizeARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDispatchComputeGroupSizeARB"));
    }
        dispatch_glDispatchComputeGroupSizeARB1(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchComputeGroupSizeARB}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) </code> <br>Part of <code>GL_ARB_compute_variable_group_size</code><br>   */
  private native void dispatch_glDispatchComputeGroupSizeARB1(int num_groups_x, int num_groups_y, int num_groups_z, int group_size_x, int group_size_y, int group_size_z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramStringARB}(GLenum target, GLenum format, GLsizei len, const void *  string) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramStringARB(int target, int format, int len, String string)  {

    final long __addr_ = _pat._addressof_glProgramStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramStringARB"));
    }
        dispatch_glProgramStringARB1(target, format, len, string, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramStringARB}(GLenum target, GLenum format, GLsizei len, const void *  string) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glProgramStringARB1(int target, int format, int len, String string, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindProgramARB}(GLenum target, GLuint program) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glBindProgramARB(int target, int program)  {

    final long __addr_ = _pat._addressof_glBindProgramARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindProgramARB"));
    }
        dispatch_glBindProgramARB1(target, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindProgramARB}(GLenum target, GLuint program) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glBindProgramARB1(int target, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteProgramsARB(int n, IntBuffer programs)  {

    Buffers.rangeCheck(programs, n);
    final boolean programs_is_direct = Buffers.isDirect(programs);
    final long __addr_ = _pat._addressof_glDeleteProgramsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramsARB"));
    }
        dispatch_glDeleteProgramsARB1(n, programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteProgramsARB1(int n, Object programs, int programs_byte_offset, boolean programs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramsARB}(GLsizei n, const GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glDeleteProgramsARB(int n, int[] programs, int programs_offset)  {

    Buffers.rangeCheck(programs, programs_offset, n);
    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    final long __addr_ = _pat._addressof_glDeleteProgramsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramsARB"));
    }
        dispatch_glDeleteProgramsARB1(n, programs, Buffers.SIZEOF_INT * programs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenProgramsARB(int n, IntBuffer programs)  {

    Buffers.rangeCheck(programs, n);
    final boolean programs_is_direct = Buffers.isDirect(programs);
    final long __addr_ = _pat._addressof_glGenProgramsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramsARB"));
    }
        dispatch_glGenProgramsARB1(n, programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenProgramsARB1(int n, Object programs, int programs_byte_offset, boolean programs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenProgramsARB}(GLsizei n, GLuint *  programs) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGenProgramsARB(int n, int[] programs, int programs_offset)  {

    Buffers.rangeCheck(programs, programs_offset, n);
    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    final long __addr_ = _pat._addressof_glGenProgramsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramsARB"));
    }
        dispatch_glGenProgramsARB1(n, programs, Buffers.SIZEOF_INT * programs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramEnvParameter4dARB(int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glProgramEnvParameter4dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dARB"));
    }
        dispatch_glProgramEnvParameter4dARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glProgramEnvParameter4dARB1(int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramEnvParameter4dvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dvARB"));
    }
        dispatch_glProgramEnvParameter4dvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramEnvParameter4dvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramEnvParameter4dvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4dvARB"));
    }
        dispatch_glProgramEnvParameter4dvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramEnvParameter4fARB(int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glProgramEnvParameter4fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fARB"));
    }
        dispatch_glProgramEnvParameter4fARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glProgramEnvParameter4fARB1(int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramEnvParameter4fvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fvARB"));
    }
        dispatch_glProgramEnvParameter4fvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramEnvParameter4fvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramEnvParameter4fvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameter4fvARB"));
    }
        dispatch_glProgramEnvParameter4fvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramLocalParameter4dARB(int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glProgramLocalParameter4dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dARB"));
    }
        dispatch_glProgramLocalParameter4dARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dARB}(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glProgramLocalParameter4dARB1(int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramLocalParameter4dvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dvARB"));
    }
        dispatch_glProgramLocalParameter4dvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramLocalParameter4dvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4dvARB}(GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramLocalParameter4dvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParameter4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4dvARB"));
    }
        dispatch_glProgramLocalParameter4dvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramLocalParameter4fARB(int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glProgramLocalParameter4fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fARB"));
    }
        dispatch_glProgramLocalParameter4fARB1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fARB}(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native void dispatch_glProgramLocalParameter4fARB1(int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramLocalParameter4fvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fvARB"));
    }
        dispatch_glProgramLocalParameter4fvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramLocalParameter4fvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameter4fvARB}(GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glProgramLocalParameter4fvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParameter4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameter4fvARB"));
    }
        dispatch_glProgramLocalParameter4fvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetProgramEnvParameterdvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterdvARB"));
    }
        dispatch_glGetProgramEnvParameterdvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetProgramEnvParameterdvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGetProgramEnvParameterdvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterdvARB"));
    }
        dispatch_glGetProgramEnvParameterdvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetProgramEnvParameterfvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterfvARB"));
    }
        dispatch_glGetProgramEnvParameterfvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetProgramEnvParameterfvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGetProgramEnvParameterfvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterfvARB"));
    }
        dispatch_glGetProgramEnvParameterfvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetProgramLocalParameterdvARB(int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterdvARB"));
    }
        dispatch_glGetProgramLocalParameterdvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetProgramLocalParameterdvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterdvARB}(GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGetProgramLocalParameterdvARB(int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterdvARB"));
    }
        dispatch_glGetProgramLocalParameterdvARB1(target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetProgramLocalParameterfvARB(int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterfvARB"));
    }
        dispatch_glGetProgramLocalParameterfvARB1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetProgramLocalParameterfvARB1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterfvARB}(GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGetProgramLocalParameterfvARB(int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterfvARB"));
    }
        dispatch_glGetProgramLocalParameterfvARB1(target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramivARB(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramivARB"));
    }
        dispatch_glGetProgramivARB1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramivARB1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramivARB}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public void glGetProgramivARB(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramivARB"));
    }
        dispatch_glGetProgramivARB1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStringARB}(GLenum target, GLenum pname, void *  string) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param string a direct only {@link java.nio.Buffer}   */
  public void glGetProgramStringARB(int target, int pname, Buffer string)  {

    if (!Buffers.isDirect(string))
      throw new GLException("Argument \"string\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glGetProgramStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramStringARB"));
    }
        dispatch_glGetProgramStringARB0(target, pname, string, Buffers.getDirectBufferByteOffset(string), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramStringARB}(GLenum target, GLenum pname, void *  string) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>
      @param string a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramStringARB0(int target, int pname, Object string, int string_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramARB}(GLuint program) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  public boolean glIsProgramARB(int program)  {

    final long __addr_ = _pat._addressof_glIsProgramARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgramARB"));
    }
        return dispatch_glIsProgramARB1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramARB}(GLuint program) </code> <br>Part of <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code><br>   */
  private native boolean dispatch_glIsProgramARB1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramParameteriARB}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  public void glProgramParameteriARB(int program, int pname, int value)  {

    final long __addr_ = _pat._addressof_glProgramParameteriARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteriARB"));
    }
        dispatch_glProgramParameteriARB1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteriARB}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  private native void dispatch_glProgramParameteriARB1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureARB}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  public void glFramebufferTextureARB(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureARB"));
    }
        dispatch_glFramebufferTextureARB1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureARB}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  private native void dispatch_glFramebufferTextureARB1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  public void glFramebufferTextureLayerARB(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureLayerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayerARB"));
    }
        dispatch_glFramebufferTextureLayerARB1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayerARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  private native void dispatch_glFramebufferTextureLayerARB1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  public void glFramebufferTextureFaceARB(int target, int attachment, int texture, int level, int face)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureFaceARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureFaceARB"));
    }
        dispatch_glFramebufferTextureFaceARB1(target, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceARB}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_ARB_geometry_shader4</code><br>   */
  private native void dispatch_glFramebufferTextureFaceARB1(int target, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64ARB}(GLint location, GLint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform1i64ARB(int location, long x)  {

    final long __addr_ = _pat._addressof_glUniform1i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64ARB"));
    }
        dispatch_glUniform1i64ARB1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64ARB}(GLint location, GLint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform1i64ARB1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64ARB}(GLint location, GLint64 x, GLint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform2i64ARB(int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glUniform2i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64ARB"));
    }
        dispatch_glUniform2i64ARB1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64ARB}(GLint location, GLint64 x, GLint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform2i64ARB1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64ARB}(GLint location, GLint64 x, GLint64 y, GLint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform3i64ARB(int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glUniform3i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64ARB"));
    }
        dispatch_glUniform3i64ARB1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64ARB}(GLint location, GLint64 x, GLint64 y, GLint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform3i64ARB1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64ARB}(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform4i64ARB(int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glUniform4i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64ARB"));
    }
        dispatch_glUniform4i64ARB1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64ARB}(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform4i64ARB1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1i64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vARB"));
    }
        dispatch_glUniform1i64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1i64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform1i64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vARB"));
    }
        dispatch_glUniform1i64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2i64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vARB"));
    }
        dispatch_glUniform2i64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2i64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform2i64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vARB"));
    }
        dispatch_glUniform2i64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3i64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vARB"));
    }
        dispatch_glUniform3i64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3i64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform3i64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vARB"));
    }
        dispatch_glUniform3i64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4i64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vARB"));
    }
        dispatch_glUniform4i64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4i64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64vARB}(GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform4i64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vARB"));
    }
        dispatch_glUniform4i64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64ARB}(GLint location, GLuint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform1ui64ARB(int location, long x)  {

    final long __addr_ = _pat._addressof_glUniform1ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64ARB"));
    }
        dispatch_glUniform1ui64ARB1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64ARB}(GLint location, GLuint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform1ui64ARB1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64ARB}(GLint location, GLuint64 x, GLuint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform2ui64ARB(int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glUniform2ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64ARB"));
    }
        dispatch_glUniform2ui64ARB1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64ARB}(GLint location, GLuint64 x, GLuint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform2ui64ARB1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64ARB}(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform3ui64ARB(int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glUniform3ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64ARB"));
    }
        dispatch_glUniform3ui64ARB1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64ARB}(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform3ui64ARB1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64ARB}(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform4ui64ARB(int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glUniform4ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64ARB"));
    }
        dispatch_glUniform4ui64ARB1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64ARB}(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform4ui64ARB1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1ui64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vARB"));
    }
        dispatch_glUniform1ui64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1ui64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform1ui64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vARB"));
    }
        dispatch_glUniform1ui64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2ui64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vARB"));
    }
        dispatch_glUniform2ui64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2ui64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform2ui64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vARB"));
    }
        dispatch_glUniform2ui64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3ui64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vARB"));
    }
        dispatch_glUniform3ui64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3ui64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform3ui64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vARB"));
    }
        dispatch_glUniform3ui64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4ui64vARB(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vARB"));
    }
        dispatch_glUniform4ui64vARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4ui64vARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64vARB}(GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glUniform4ui64vARB(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vARB"));
    }
        dispatch_glUniform4ui64vARB1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vARB}(GLuint program, GLint location, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformi64vARB(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformi64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vARB"));
    }
        dispatch_glGetUniformi64vARB1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vARB}(GLuint program, GLint location, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformi64vARB1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformi64vARB}(GLuint program, GLint location, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glGetUniformi64vARB(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformi64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vARB"));
    }
        dispatch_glGetUniformi64vARB1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vARB}(GLuint program, GLint location, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformui64vARB(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vARB"));
    }
        dispatch_glGetUniformui64vARB1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vARB}(GLuint program, GLint location, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformui64vARB1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformui64vARB}(GLuint program, GLint location, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glGetUniformui64vARB(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vARB"));
    }
        dispatch_glGetUniformui64vARB1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformi64vARB}(GLuint program, GLint location, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetnUniformi64vARB(int program, int location, int bufSize, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformi64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformi64vARB"));
    }
        dispatch_glGetnUniformi64vARB1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformi64vARB}(GLuint program, GLint location, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetnUniformi64vARB1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformi64vARB}(GLuint program, GLint location, GLsizei bufSize, GLint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glGetnUniformi64vARB(int program, int location, int bufSize, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformi64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformi64vARB"));
    }
        dispatch_glGetnUniformi64vARB1(program, location, bufSize, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformui64vARB}(GLuint program, GLint location, GLsizei bufSize, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetnUniformui64vARB(int program, int location, int bufSize, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformui64vARB"));
    }
        dispatch_glGetnUniformui64vARB1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformui64vARB}(GLuint program, GLint location, GLsizei bufSize, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetnUniformui64vARB1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformui64vARB}(GLuint program, GLint location, GLsizei bufSize, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glGetnUniformui64vARB(int program, int location, int bufSize, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformui64vARB"));
    }
        dispatch_glGetnUniformui64vARB1(program, location, bufSize, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64ARB}(GLuint program, GLint location, GLint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform1i64ARB(int program, int location, long x)  {

    final long __addr_ = _pat._addressof_glProgramUniform1i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64ARB"));
    }
        dispatch_glProgramUniform1i64ARB1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64ARB}(GLuint program, GLint location, GLint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform1i64ARB1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform2i64ARB(int program, int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glProgramUniform2i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64ARB"));
    }
        dispatch_glProgramUniform2i64ARB1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform2i64ARB1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform3i64ARB(int program, int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glProgramUniform3i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64ARB"));
    }
        dispatch_glProgramUniform3i64ARB1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform3i64ARB1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform4i64ARB(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glProgramUniform4i64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64ARB"));
    }
        dispatch_glProgramUniform4i64ARB1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64ARB}(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform4i64ARB1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1i64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vARB"));
    }
        dispatch_glProgramUniform1i64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1i64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform1i64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vARB"));
    }
        dispatch_glProgramUniform1i64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2i64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vARB"));
    }
        dispatch_glProgramUniform2i64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2i64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform2i64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vARB"));
    }
        dispatch_glProgramUniform2i64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3i64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vARB"));
    }
        dispatch_glProgramUniform3i64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3i64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform3i64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vARB"));
    }
        dispatch_glProgramUniform3i64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4i64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vARB"));
    }
        dispatch_glProgramUniform4i64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4i64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vARB}(GLuint program, GLint location, GLsizei count, const GLint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform4i64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4i64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vARB"));
    }
        dispatch_glProgramUniform4i64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64ARB}(GLuint program, GLint location, GLuint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform1ui64ARB(int program, int location, long x)  {

    final long __addr_ = _pat._addressof_glProgramUniform1ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64ARB"));
    }
        dispatch_glProgramUniform1ui64ARB1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64ARB}(GLuint program, GLint location, GLuint64 x) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform1ui64ARB1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform2ui64ARB(int program, int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glProgramUniform2ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64ARB"));
    }
        dispatch_glProgramUniform2ui64ARB1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform2ui64ARB1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform3ui64ARB(int program, int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glProgramUniform3ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64ARB"));
    }
        dispatch_glProgramUniform3ui64ARB1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform3ui64ARB1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform4ui64ARB(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glProgramUniform4ui64ARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64ARB"));
    }
        dispatch_glProgramUniform4ui64ARB1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64ARB}(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform4ui64ARB1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1ui64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vARB"));
    }
        dispatch_glProgramUniform1ui64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1ui64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform1ui64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vARB"));
    }
        dispatch_glProgramUniform1ui64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2ui64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vARB"));
    }
        dispatch_glProgramUniform2ui64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2ui64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform2ui64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vARB"));
    }
        dispatch_glProgramUniform2ui64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3ui64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vARB"));
    }
        dispatch_glProgramUniform3ui64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3ui64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform3ui64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vARB"));
    }
        dispatch_glProgramUniform3ui64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4ui64vARB(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vARB"));
    }
        dispatch_glProgramUniform4ui64vARB1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4ui64vARB1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vARB}(GLuint program, GLint location, GLsizei count, const GLuint64 *  value) </code> <br>Part of <code>GL_ARB_gpu_shader_int64</code><br>   */
  public void glProgramUniform4ui64vARB(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4ui64vARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vARB"));
    }
        dispatch_glProgramUniform4ui64vARB1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableEXT</code>, <code>glColorTableSGI</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorTable(int target, int internalformat, int width, int format, int type, Buffer table)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(table, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = _pat._addressof_glColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTable"));
    }
        dispatch_glColorTable1(target, internalformat, width, format, type, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableEXT</code>, <code>glColorTableSGI</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorTable1(int target, int internalformat, int width, int format, int type, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableEXT</code>, <code>glColorTableSGI</code>   */
  public void glColorTable(int target, int internalformat, int width, int format, int type, long table_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTable"));
    }
        dispatch_glColorTable1(target, internalformat, width, format, type, table_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTable}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableEXT</code>, <code>glColorTableSGI</code>   */
  private native void dispatch_glColorTable1(int target, int internalformat, int width, int format, int type, long table_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterfvSGI</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glColorTableParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameterfv"));
    }
        dispatch_glColorTableParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterfvSGI</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glColorTableParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterfvSGI</code>   */
  public void glColorTableParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameterfv"));
    }
        dispatch_glColorTableParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterivSGI</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glColorTableParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameteriv"));
    }
        dispatch_glColorTableParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterivSGI</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glColorTableParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorTableParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glColorTableParameterivSGI</code>   */
  public void glColorTableParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorTableParameteriv"));
    }
        dispatch_glColorTableParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyColorTable}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glCopyColorTableSGI</code>   */
  public void glCopyColorTable(int target, int internalformat, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyColorTable"));
    }
        dispatch_glCopyColorTable1(target, internalformat, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyColorTable}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glCopyColorTableSGI</code>   */
  private native void dispatch_glCopyColorTable1(int target, int internalformat, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableSGI</code>, <code>glGetColorTableEXT</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetColorTable(int target, int format, int type, Buffer table)  {

    checkPackPBOUnbound(true);
    final boolean table_is_direct = Buffers.isDirect(table);
    final long __addr_ = _pat._addressof_glGetColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTable"));
    }
        dispatch_glGetColorTable1(target, format, type, table_is_direct ? table : Buffers.getArray(table), table_is_direct ? Buffers.getDirectBufferByteOffset(table) : Buffers.getIndirectBufferByteOffset(table), table_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableSGI</code>, <code>glGetColorTableEXT</code>
      @param table a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetColorTable1(int target, int format, int type, Object table, int table_byte_offset, boolean table_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableSGI</code>, <code>glGetColorTableEXT</code>   */
  public void glGetColorTable(int target, int format, int type, long table_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetColorTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTable"));
    }
        dispatch_glGetColorTable1(target, format, type, table_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTable}(GLenum target, GLenum format, GLenum type, void *  table) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableSGI</code>, <code>glGetColorTableEXT</code>   */
  private native void dispatch_glGetColorTable1(int target, int format, int type, long table_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glGetColorTableParameterfvEXT</code>, <code>glGetColorTableParameterfvSGI</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetColorTableParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameterfv"));
    }
        dispatch_glGetColorTableParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glGetColorTableParameterfvEXT</code>, <code>glGetColorTableParameterfvSGI</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetColorTableParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_paletted_texture</code>, <code>GL_SGI_color_table</code><br>Alias for: <code>glGetColorTableParameterfvEXT</code>, <code>glGetColorTableParameterfvSGI</code>   */
  public void glGetColorTableParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetColorTableParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameterfv"));
    }
        dispatch_glGetColorTableParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableParameterivSGI</code>, <code>glGetColorTableParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetColorTableParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameteriv"));
    }
        dispatch_glGetColorTableParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableParameterivSGI</code>, <code>glGetColorTableParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetColorTableParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetColorTableParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_SGI_color_table</code>, <code>GL_EXT_paletted_texture</code><br>Alias for: <code>glGetColorTableParameterivSGI</code>, <code>glGetColorTableParameterivEXT</code>   */
  public void glGetColorTableParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetColorTableParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetColorTableParameteriv"));
    }
        dispatch_glGetColorTableParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glColorSubTableEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glColorSubTable(int target, int start, int count, int format, int type, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glColorSubTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorSubTable"));
    }
        dispatch_glColorSubTable1(target, start, count, format, type, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glColorSubTableEXT</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glColorSubTable1(int target, int start, int count, int format, int type, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glColorSubTableEXT</code>   */
  public void glColorSubTable(int target, int start, int count, int format, int type, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glColorSubTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorSubTable"));
    }
        dispatch_glColorSubTable1(target, start, count, format, type, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorSubTable}(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *  data) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glColorSubTableEXT</code>   */
  private native void dispatch_glColorSubTable1(int target, int start, int count, int format, int type, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyColorSubTable}(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glCopyColorSubTableEXT</code>   */
  public void glCopyColorSubTable(int target, int start, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyColorSubTable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyColorSubTable"));
    }
        dispatch_glCopyColorSubTable1(target, start, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyColorSubTable}(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_color_subtable</code><br>Alias for: <code>glCopyColorSubTableEXT</code>   */
  private native void dispatch_glCopyColorSubTable1(int target, int start, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter1DEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, Buffer image)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(image, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = _pat._addressof_glConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter1D"));
    }
        dispatch_glConvolutionFilter1D1(target, internalformat, width, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter1DEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glConvolutionFilter1D1(int target, int internalformat, int width, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter1DEXT</code>   */
  public void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, long image_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter1D"));
    }
        dispatch_glConvolutionFilter1D1(target, internalformat, width, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter1D}(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter1DEXT</code>   */
  private native void dispatch_glConvolutionFilter1D1(int target, int internalformat, int width, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter2DEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, Buffer image)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(image, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = _pat._addressof_glConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter2D"));
    }
        dispatch_glConvolutionFilter2D1(target, internalformat, width, height, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter2DEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glConvolutionFilter2D1(int target, int internalformat, int width, int height, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter2DEXT</code>   */
  public void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, long image_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionFilter2D"));
    }
        dispatch_glConvolutionFilter2D1(target, internalformat, width, height, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionFilter2DEXT</code>   */
  private native void dispatch_glConvolutionFilter2D1(int target, int internalformat, int width, int height, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterf}(GLenum target, GLenum pname, GLfloat params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterfEXT</code>   */
  public void glConvolutionParameterf(int target, int pname, float params)  {

    final long __addr_ = _pat._addressof_glConvolutionParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterf"));
    }
        dispatch_glConvolutionParameterf1(target, pname, params, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameterf}(GLenum target, GLenum pname, GLfloat params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterfEXT</code>   */
  private native void dispatch_glConvolutionParameterf1(int target, int pname, float params, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glConvolutionParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterfv"));
    }
        dispatch_glConvolutionParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glConvolutionParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterfvEXT</code>   */
  public void glConvolutionParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameterfv"));
    }
        dispatch_glConvolutionParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteri}(GLenum target, GLenum pname, GLint params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameteriEXT</code>   */
  public void glConvolutionParameteri(int target, int pname, int params)  {

    final long __addr_ = _pat._addressof_glConvolutionParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteri"));
    }
        dispatch_glConvolutionParameteri1(target, pname, params, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteri}(GLenum target, GLenum pname, GLint params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameteriEXT</code>   */
  private native void dispatch_glConvolutionParameteri1(int target, int pname, int params, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glConvolutionParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteriv"));
    }
        dispatch_glConvolutionParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glConvolutionParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glConvolutionParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glConvolutionParameterivEXT</code>   */
  public void glConvolutionParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConvolutionParameteriv"));
    }
        dispatch_glConvolutionParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter1D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glCopyConvolutionFilter1DEXT</code>   */
  public void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyConvolutionFilter1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyConvolutionFilter1D"));
    }
        dispatch_glCopyConvolutionFilter1D1(target, internalformat, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter1D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glCopyConvolutionFilter1DEXT</code>   */
  private native void dispatch_glCopyConvolutionFilter1D1(int target, int internalformat, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter2D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glCopyConvolutionFilter2DEXT</code>   */
  public void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyConvolutionFilter2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyConvolutionFilter2D"));
    }
        dispatch_glCopyConvolutionFilter2D1(target, internalformat, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyConvolutionFilter2D}(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glCopyConvolutionFilter2DEXT</code>   */
  private native void dispatch_glCopyConvolutionFilter2D1(int target, int internalformat, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionFilterEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetConvolutionFilter(int target, int format, int type, Buffer image)  {

    checkPackPBOUnbound(true);
    final boolean image_is_direct = Buffers.isDirect(image);
    final long __addr_ = _pat._addressof_glGetConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionFilter"));
    }
        dispatch_glGetConvolutionFilter1(target, format, type, image_is_direct ? image : Buffers.getArray(image), image_is_direct ? Buffers.getDirectBufferByteOffset(image) : Buffers.getIndirectBufferByteOffset(image), image_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionFilterEXT</code>
      @param image a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetConvolutionFilter1(int target, int format, int type, Object image, int image_byte_offset, boolean image_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionFilterEXT</code>   */
  public void glGetConvolutionFilter(int target, int format, int type, long image_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetConvolutionFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionFilter"));
    }
        dispatch_glGetConvolutionFilter1(target, format, type, image_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionFilter}(GLenum target, GLenum format, GLenum type, void *  image) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionFilterEXT</code>   */
  private native void dispatch_glGetConvolutionFilter1(int target, int format, int type, long image_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetConvolutionParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameterfv"));
    }
        dispatch_glGetConvolutionParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetConvolutionParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterfvEXT</code>   */
  public void glGetConvolutionParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetConvolutionParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameterfv"));
    }
        dispatch_glGetConvolutionParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetConvolutionParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameteriv"));
    }
        dispatch_glGetConvolutionParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetConvolutionParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetConvolutionParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetConvolutionParameterivEXT</code>   */
  public void glGetConvolutionParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetConvolutionParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetConvolutionParameteriv"));
    }
        dispatch_glGetConvolutionParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, void *  row, void *  column, void *  span) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetSeparableFilterEXT</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetSeparableFilter(int target, int format, int type, Buffer row, Buffer column, Buffer span)  {

    checkPackPBOUnbound(true);
    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final boolean span_is_direct = Buffers.isDirect(span);
    final long __addr_ = _pat._addressof_glGetSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSeparableFilter"));
    }
        dispatch_glGetSeparableFilter1(target, format, type, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, span_is_direct ? span : Buffers.getArray(span), span_is_direct ? Buffers.getDirectBufferByteOffset(span) : Buffers.getIndirectBufferByteOffset(span), span_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, void *  row, void *  column, void *  span) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetSeparableFilterEXT</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}
      @param span a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetSeparableFilter1(int target, int format, int type, Object row, int row_byte_offset, boolean row_is_direct, Object column, int column_byte_offset, boolean column_is_direct, Object span, int span_byte_offset, boolean span_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, void *  row, void *  column, void *  span) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetSeparableFilterEXT</code>   */
  public void glGetSeparableFilter(int target, int format, int type, long row_buffer_offset, long column_buffer_offset, long span_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetSeparableFilter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSeparableFilter"));
    }
        dispatch_glGetSeparableFilter1(target, format, type, row_buffer_offset, column_buffer_offset, span_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSeparableFilter}(GLenum target, GLenum format, GLenum type, void *  row, void *  column, void *  span) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glGetSeparableFilterEXT</code>   */
  private native void dispatch_glGetSeparableFilter1(int target, int format, int type, long row_buffer_offset, long column_buffer_offset, long span_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  row, const void *  column) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glSeparableFilter2DEXT</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}   */
  public void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, Buffer row, Buffer column)  {

    checkUnpackPBOUnbound(true);
    final boolean row_is_direct = Buffers.isDirect(row);
    final boolean column_is_direct = Buffers.isDirect(column);
    final long __addr_ = _pat._addressof_glSeparableFilter2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSeparableFilter2D"));
    }
        dispatch_glSeparableFilter2D1(target, internalformat, width, height, format, type, row_is_direct ? row : Buffers.getArray(row), row_is_direct ? Buffers.getDirectBufferByteOffset(row) : Buffers.getIndirectBufferByteOffset(row), row_is_direct, column_is_direct ? column : Buffers.getArray(column), column_is_direct ? Buffers.getDirectBufferByteOffset(column) : Buffers.getIndirectBufferByteOffset(column), column_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  row, const void *  column) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glSeparableFilter2DEXT</code>
      @param row a direct or array-backed {@link java.nio.Buffer}
      @param column a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSeparableFilter2D1(int target, int internalformat, int width, int height, int format, int type, Object row, int row_byte_offset, boolean row_is_direct, Object column, int column_byte_offset, boolean column_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  row, const void *  column) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glSeparableFilter2DEXT</code>   */
  public void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, long row_buffer_offset, long column_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glSeparableFilter2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSeparableFilter2D"));
    }
        dispatch_glSeparableFilter2D1(target, internalformat, width, height, format, type, row_buffer_offset, column_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSeparableFilter2D}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  row, const void *  column) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_convolution</code><br>Alias for: <code>glSeparableFilter2DEXT</code>   */
  private native void dispatch_glSeparableFilter2D1(int target, int internalformat, int width, int height, int format, int type, long row_buffer_offset, long column_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramEXT</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetHistogram(int target, boolean reset, int format, int type, Buffer values)  {

    checkPackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetHistogram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogram"));
    }
        dispatch_glGetHistogram1(target, reset, format, type, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramEXT</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetHistogram1(int target, boolean reset, int format, int type, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramEXT</code>   */
  public void glGetHistogram(int target, boolean reset, int format, int type, long values_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetHistogram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogram"));
    }
        dispatch_glGetHistogram1(target, reset, format, type, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogram}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramEXT</code>   */
  private native void dispatch_glGetHistogram1(int target, boolean reset, int format, int type, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetHistogramParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetHistogramParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameterfv"));
    }
        dispatch_glGetHistogramParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetHistogramParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterfvEXT</code>   */
  public void glGetHistogramParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetHistogramParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameterfv"));
    }
        dispatch_glGetHistogramParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetHistogramParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetHistogramParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameteriv"));
    }
        dispatch_glGetHistogramParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetHistogramParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetHistogramParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetHistogramParameterivEXT</code>   */
  public void glGetHistogramParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetHistogramParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHistogramParameteriv"));
    }
        dispatch_glGetHistogramParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxEXT</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMinmax(int target, boolean reset, int format, int type, Buffer values)  {

    checkPackPBOUnbound(true);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetMinmax;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmax"));
    }
        dispatch_glGetMinmax1(target, reset, format, type, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxEXT</code>
      @param values a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMinmax1(int target, boolean reset, int format, int type, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxEXT</code>   */
  public void glGetMinmax(int target, boolean reset, int format, int type, long values_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glGetMinmax;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmax"));
    }
        dispatch_glGetMinmax1(target, reset, format, type, values_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmax}(GLenum target, GLboolean reset, GLenum format, GLenum type, void *  values) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxEXT</code>   */
  private native void dispatch_glGetMinmax1(int target, boolean reset, int format, int type, long values_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMinmaxParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMinmaxParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameterfv"));
    }
        dispatch_glGetMinmaxParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterfvEXT</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMinmaxParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterfvEXT</code>   */
  public void glGetMinmaxParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMinmaxParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameterfv"));
    }
        dispatch_glGetMinmaxParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMinmaxParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMinmaxParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameteriv"));
    }
        dispatch_glGetMinmaxParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMinmaxParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMinmaxParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glGetMinmaxParameterivEXT</code>   */
  public void glGetMinmaxParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMinmaxParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMinmaxParameteriv"));
    }
        dispatch_glGetMinmaxParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHistogram}(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glHistogramEXT</code>   */
  public void glHistogram(int target, int width, int internalformat, boolean sink)  {

    final long __addr_ = _pat._addressof_glHistogram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHistogram"));
    }
        dispatch_glHistogram1(target, width, internalformat, sink, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHistogram}(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glHistogramEXT</code>   */
  private native void dispatch_glHistogram1(int target, int width, int internalformat, boolean sink, long procAddress);

  /** Entry point to C language function: <code> void {@native glMinmax}(GLenum target, GLenum internalformat, GLboolean sink) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glMinmaxEXT</code>   */
  public void glMinmax(int target, int internalformat, boolean sink)  {

    final long __addr_ = _pat._addressof_glMinmax;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMinmax"));
    }
        dispatch_glMinmax1(target, internalformat, sink, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinmax}(GLenum target, GLenum internalformat, GLboolean sink) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glMinmaxEXT</code>   */
  private native void dispatch_glMinmax1(int target, int internalformat, boolean sink, long procAddress);

  /** Entry point to C language function: <code> void {@native glResetHistogram}(GLenum target) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glResetHistogramEXT</code>   */
  public void glResetHistogram(int target)  {

    final long __addr_ = _pat._addressof_glResetHistogram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResetHistogram"));
    }
        dispatch_glResetHistogram1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResetHistogram}(GLenum target) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glResetHistogramEXT</code>   */
  private native void dispatch_glResetHistogram1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glResetMinmax}(GLenum target) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glResetMinmaxEXT</code>   */
  public void glResetMinmax(int target)  {

    final long __addr_ = _pat._addressof_glResetMinmax;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResetMinmax"));
    }
        dispatch_glResetMinmax1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResetMinmax}(GLenum target) </code> <br>Part of <code>GL_ARB_imaging</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_histogram</code><br>Alias for: <code>glResetMinmaxEXT</code>   */
  private native void dispatch_glResetMinmax1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectCountARB}(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_indirect_parameters</code><br>   */
  public void glMultiDrawArraysIndirectCountARB(int mode, long indirect, long drawcount, int maxdrawcount, int stride)  {

    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirectCountARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectCountARB"));
    }
        dispatch_glMultiDrawArraysIndirectCountARB1(mode, indirect, drawcount, maxdrawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectCountARB}(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_indirect_parameters</code><br>   */
  private native void dispatch_glMultiDrawArraysIndirectCountARB1(int mode, long indirect, long drawcount, int maxdrawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectCountARB}(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_indirect_parameters</code><br>   */
  public void glMultiDrawElementsIndirectCountARB(int mode, int type, long indirect, long drawcount, int maxdrawcount, int stride)  {

    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirectCountARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectCountARB"));
    }
        dispatch_glMultiDrawElementsIndirectCountARB1(mode, type, indirect, drawcount, maxdrawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectCountARB}(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) </code> <br>Part of <code>GL_ARB_indirect_parameters</code><br>   */
  private native void dispatch_glMultiDrawElementsIndirectCountARB1(int mode, int type, long indirect, long drawcount, int maxdrawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixARB}(GLint index) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  public void glCurrentPaletteMatrixARB(int index)  {

    final long __addr_ = _pat._addressof_glCurrentPaletteMatrixARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCurrentPaletteMatrixARB"));
    }
        dispatch_glCurrentPaletteMatrixARB1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixARB}(GLint index) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  private native void dispatch_glCurrentPaletteMatrixARB1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMatrixIndexubvARB(int size, ByteBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glMatrixIndexubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexubvARB"));
    }
        dispatch_glMatrixIndexubvARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMatrixIndexubvARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexubvARB}(GLint size, const GLubyte *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  public void glMatrixIndexubvARB(int size, byte[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = _pat._addressof_glMatrixIndexubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexubvARB"));
    }
        dispatch_glMatrixIndexubvARB1(size, indices, indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMatrixIndexusvARB(int size, ShortBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glMatrixIndexusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexusvARB"));
    }
        dispatch_glMatrixIndexusvARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMatrixIndexusvARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexusvARB}(GLint size, const GLushort *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  public void glMatrixIndexusvARB(int size, short[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = _pat._addressof_glMatrixIndexusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexusvARB"));
    }
        dispatch_glMatrixIndexusvARB1(size, indices, Buffers.SIZEOF_SHORT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMatrixIndexuivARB(int size, IntBuffer indices)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glMatrixIndexuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexuivARB"));
    }
        dispatch_glMatrixIndexuivARB1(size, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMatrixIndexuivARB1(int size, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexuivARB}(GLint size, const GLuint *  indices) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  public void glMatrixIndexuivARB(int size, int[] indices, int indices_offset)  {

    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = _pat._addressof_glMatrixIndexuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexuivARB"));
    }
        dispatch_glMatrixIndexuivARB1(size, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glMatrixIndexPointerARB(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glMatrixIndexPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexPointerARB"));
    }
        dispatch_glMatrixIndexPointerARB0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glMatrixIndexPointerARB0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  public void glMatrixIndexPointerARB(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glMatrixIndexPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexPointerARB"));
    }
        dispatch_glMatrixIndexPointerARB0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_matrix_palette</code><br>   */
  private native void dispatch_glMatrixIndexPointerARB0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaxShaderCompilerThreadsARB}(GLuint count) </code> <br>Part of <code>GL_ARB_parallel_shader_compile</code><br>   */
  public void glMaxShaderCompilerThreadsARB(int count)  {

    final long __addr_ = _pat._addressof_glMaxShaderCompilerThreadsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaxShaderCompilerThreadsARB"));
    }
        dispatch_glMaxShaderCompilerThreadsARB1(count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaxShaderCompilerThreadsARB}(GLuint count) </code> <br>Part of <code>GL_ARB_parallel_shader_compile</code><br>   */
  private native void dispatch_glMaxShaderCompilerThreadsARB1(int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvARB}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFramebufferSampleLocationsfvARB(int target, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvARB"));
    }
        dispatch_glFramebufferSampleLocationsfvARB1(target, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvARB}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFramebufferSampleLocationsfvARB1(int target, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvARB}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>   */
  public void glFramebufferSampleLocationsfvARB(int target, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvARB"));
    }
        dispatch_glFramebufferSampleLocationsfvARB1(target, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvARB}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedFramebufferSampleLocationsfvARB(int framebuffer, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvARB"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvARB1(framebuffer, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvARB}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedFramebufferSampleLocationsfvARB1(int framebuffer, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvARB}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>   */
  public void glNamedFramebufferSampleLocationsfvARB(int framebuffer, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvARB"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvARB1(framebuffer, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvaluateDepthValuesARB}(void) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>   */
  public void glEvaluateDepthValuesARB()  {

    final long __addr_ = _pat._addressof_glEvaluateDepthValuesARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvaluateDepthValuesARB"));
    }
        dispatch_glEvaluateDepthValuesARB1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvaluateDepthValuesARB}(void) </code> <br>Part of <code>GL_ARB_sample_locations</code><br>   */
  private native void dispatch_glEvaluateDepthValuesARB1(long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteObjectARB}(GLhandleARB obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glDeleteObjectARB(long obj)  {

    final long __addr_ = _pat._addressof_glDeleteObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteObjectARB"));
    }
        dispatch_glDeleteObjectARB1(obj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteObjectARB}(GLhandleARB obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glDeleteObjectARB1(long obj, long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glGetHandleARB}(GLenum pname) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public long glGetHandleARB(int pname)  {

    final long __addr_ = _pat._addressof_glGetHandleARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetHandleARB"));
    }
        return dispatch_glGetHandleARB1(pname, __addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glGetHandleARB}(GLenum pname) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native long dispatch_glGetHandleARB1(int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachObjectARB}(GLhandleARB containerObj, GLhandleARB attachedObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glDetachObjectARB(long containerObj, long attachedObj)  {

    final long __addr_ = _pat._addressof_glDetachObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDetachObjectARB"));
    }
        dispatch_glDetachObjectARB1(containerObj, attachedObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachObjectARB}(GLhandleARB containerObj, GLhandleARB attachedObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glDetachObjectARB1(long containerObj, long attachedObj, long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateShaderObjectARB}(GLenum shaderType) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public long glCreateShaderObjectARB(int shaderType)  {

    final long __addr_ = _pat._addressof_glCreateShaderObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShaderObjectARB"));
    }
        return dispatch_glCreateShaderObjectARB1(shaderType, __addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateShaderObjectARB}(GLenum shaderType) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native long dispatch_glCreateShaderObjectARB1(int shaderType, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSourceARB(long shaderObj, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSourceARB"));
    }
        dispatch_glShaderSourceARB1(shaderObj, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSourceARB1(long shaderObj, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSourceARB}(GLhandleARB shaderObj, GLsizei count, const GLcharARB *  *  string, const GLint *  length) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glShaderSourceARB(long shaderObj, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSourceARB"));
    }
        dispatch_glShaderSourceARB1(shaderObj, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShaderARB}(GLhandleARB shaderObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glCompileShaderARB(long shaderObj)  {

    final long __addr_ = _pat._addressof_glCompileShaderARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderARB"));
    }
        dispatch_glCompileShaderARB1(shaderObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShaderARB}(GLhandleARB shaderObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glCompileShaderARB1(long shaderObj, long procAddress);

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateProgramObjectARB}(void) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public long glCreateProgramObjectARB()  {

    final long __addr_ = _pat._addressof_glCreateProgramObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgramObjectARB"));
    }
        return dispatch_glCreateProgramObjectARB1(__addr_);
  }

  /** Entry point to C language function: <code> GLhandleARB {@native glCreateProgramObjectARB}(void) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native long dispatch_glCreateProgramObjectARB1(long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachObjectARB}(GLhandleARB containerObj, GLhandleARB obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glAttachObjectARB(long containerObj, long obj)  {

    final long __addr_ = _pat._addressof_glAttachObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAttachObjectARB"));
    }
        dispatch_glAttachObjectARB1(containerObj, obj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachObjectARB}(GLhandleARB containerObj, GLhandleARB obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glAttachObjectARB1(long containerObj, long obj, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgramARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glLinkProgramARB(long programObj)  {

    final long __addr_ = _pat._addressof_glLinkProgramARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLinkProgramARB"));
    }
        dispatch_glLinkProgramARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgramARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glLinkProgramARB1(long programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glUseProgramObjectARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUseProgramObjectARB(long programObj)  {

    final long __addr_ = _pat._addressof_glUseProgramObjectARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgramObjectARB"));
    }
        dispatch_glUseProgramObjectARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramObjectARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUseProgramObjectARB1(long programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgramARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glValidateProgramARB(long programObj)  {

    final long __addr_ = _pat._addressof_glValidateProgramARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgramARB"));
    }
        dispatch_glValidateProgramARB1(programObj, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramARB}(GLhandleARB programObj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glValidateProgramARB1(long programObj, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fARB}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform1fARB(int location, float v0)  {

    final long __addr_ = _pat._addressof_glUniform1fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fARB"));
    }
        dispatch_glUniform1fARB1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fARB}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform1fARB1(int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fARB}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform2fARB(int location, float v0, float v1)  {

    final long __addr_ = _pat._addressof_glUniform2fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fARB"));
    }
        dispatch_glUniform2fARB1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fARB}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform2fARB1(int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform3fARB(int location, float v0, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glUniform3fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fARB"));
    }
        dispatch_glUniform3fARB1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform3fARB1(int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform4fARB(int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = _pat._addressof_glUniform4fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fARB"));
    }
        dispatch_glUniform4fARB1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fARB}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform4fARB1(int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iARB}(GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform1iARB(int location, int v0)  {

    final long __addr_ = _pat._addressof_glUniform1iARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iARB"));
    }
        dispatch_glUniform1iARB1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iARB}(GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform1iARB1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iARB}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform2iARB(int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glUniform2iARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iARB"));
    }
        dispatch_glUniform2iARB1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iARB}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform2iARB1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iARB}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform3iARB(int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glUniform3iARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iARB"));
    }
        dispatch_glUniform3iARB1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iARB}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform3iARB1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iARB}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform4iARB(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glUniform4iARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iARB"));
    }
        dispatch_glUniform4iARB1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iARB}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native void dispatch_glUniform4iARB1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fvARB"));
    }
        dispatch_glUniform1fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform1fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fvARB"));
    }
        dispatch_glUniform1fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fvARB"));
    }
        dispatch_glUniform2fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform2fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fvARB"));
    }
        dispatch_glUniform2fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fvARB"));
    }
        dispatch_glUniform3fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform3fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fvARB"));
    }
        dispatch_glUniform3fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fvARB(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fvARB"));
    }
        dispatch_glUniform4fvARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fvARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fvARB}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform4fvARB(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fvARB"));
    }
        dispatch_glUniform4fvARB1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ivARB"));
    }
        dispatch_glUniform1ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform1ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ivARB"));
    }
        dispatch_glUniform1ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ivARB"));
    }
        dispatch_glUniform2ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform2ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ivARB"));
    }
        dispatch_glUniform2ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ivARB"));
    }
        dispatch_glUniform3ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform3ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ivARB"));
    }
        dispatch_glUniform3ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4ivARB(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ivARB"));
    }
        dispatch_glUniform4ivARB1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4ivARB1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ivARB}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniform4ivARB(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ivARB"));
    }
        dispatch_glUniform4ivARB1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fvARB"));
    }
        dispatch_glUniformMatrix2fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniformMatrix2fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fvARB"));
    }
        dispatch_glUniformMatrix2fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fvARB"));
    }
        dispatch_glUniformMatrix3fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniformMatrix3fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fvARB"));
    }
        dispatch_glUniformMatrix3fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fvARB(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fvARB"));
    }
        dispatch_glUniformMatrix4fvARB1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fvARB1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fvARB}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glUniformMatrix4fvARB(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fvARB"));
    }
        dispatch_glUniformMatrix4fvARB1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetObjectParameterfvARB(long obj, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetObjectParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterfvARB"));
    }
        dispatch_glGetObjectParameterfvARB1(obj, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetObjectParameterfvARB1(long obj, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterfvARB}(GLhandleARB obj, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetObjectParameterfvARB(long obj, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectParameterfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterfvARB"));
    }
        dispatch_glGetObjectParameterfvARB1(obj, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetObjectParameterivARB(long obj, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetObjectParameterivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivARB"));
    }
        dispatch_glGetObjectParameterivARB1(obj, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetObjectParameterivARB1(long obj, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivARB}(GLhandleARB obj, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetObjectParameterivARB(long obj, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectParameterivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivARB"));
    }
        dispatch_glGetObjectParameterivARB1(obj, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetInfoLogARB(long obj, int maxLength, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetInfoLogARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInfoLogARB"));
    }
        dispatch_glGetInfoLogARB1(obj, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetInfoLogARB1(long obj, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInfoLogARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  infoLog) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetInfoLogARB(long obj, int maxLength, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetInfoLogARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInfoLogARB"));
    }
        dispatch_glGetInfoLogARB1(obj, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetAttachedObjectsARB(long containerObj, int maxCount, IntBuffer count, LongBuffer obj)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean obj_is_direct = Buffers.isDirect(obj);
    final long __addr_ = _pat._addressof_glGetAttachedObjectsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedObjectsARB"));
    }
        dispatch_glGetAttachedObjectsARB1(containerObj, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, obj_is_direct ? obj : Buffers.getArray(obj), obj_is_direct ? Buffers.getDirectBufferByteOffset(obj) : Buffers.getIndirectBufferByteOffset(obj), obj_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param obj a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetAttachedObjectsARB1(long containerObj, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object obj, int obj_byte_offset, boolean obj_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedObjectsARB}(GLhandleARB containerObj, GLsizei maxCount, GLsizei *  count, GLhandleARB *  obj) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetAttachedObjectsARB(long containerObj, int maxCount, int[] count, int count_offset, long[] obj, int obj_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(obj != null && obj.length <= obj_offset)
      throw new GLException("array offset argument \"obj_offset\" (" + obj_offset + ") equals or exceeds array length (" + obj.length + ")");
    final long __addr_ = _pat._addressof_glGetAttachedObjectsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedObjectsARB"));
    }
        dispatch_glGetAttachedObjectsARB1(containerObj, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, obj, Buffers.SIZEOF_LONG * obj_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocationARB}(GLhandleARB programObj, const GLcharARB *  name) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public int glGetUniformLocationARB(long programObj, String name)  {

    final long __addr_ = _pat._addressof_glGetUniformLocationARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocationARB"));
    }
        return dispatch_glGetUniformLocationARB1(programObj, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocationARB}(GLhandleARB programObj, const GLcharARB *  name) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  private native int dispatch_glGetUniformLocationARB1(long programObj, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformARB(long programObj, int index, int maxLength, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveUniformARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformARB"));
    }
        dispatch_glGetActiveUniformARB1(programObj, index, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformARB1(long programObj, int index, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformARB}(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *  length, GLint *  size, GLenum *  type, GLcharARB *  name) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetActiveUniformARB(long programObj, int index, int maxLength, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformARB"));
    }
        dispatch_glGetActiveUniformARB1(programObj, index, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfvARB(long programObj, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfvARB"));
    }
        dispatch_glGetUniformfvARB1(programObj, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfvARB1(long programObj, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfvARB}(GLhandleARB programObj, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetUniformfvARB(long programObj, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfvARB"));
    }
        dispatch_glGetUniformfvARB1(programObj, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformivARB(long programObj, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformivARB"));
    }
        dispatch_glGetUniformivARB1(programObj, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformivARB1(long programObj, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformivARB}(GLhandleARB programObj, GLint location, GLint *  params) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetUniformivARB(long programObj, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformivARB"));
    }
        dispatch_glGetUniformivARB1(programObj, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSourceARB(long obj, int maxLength, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = _pat._addressof_glGetShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSourceARB"));
    }
        dispatch_glGetShaderSourceARB1(obj, maxLength, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSourceARB1(long obj, int maxLength, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSourceARB}(GLhandleARB obj, GLsizei maxLength, GLsizei *  length, GLcharARB *  source) </code> <br>Part of <code>GL_ARB_shader_objects</code><br>   */
  public void glGetShaderSourceARB(long obj, int maxLength, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderSourceARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSourceARB"));
    }
        dispatch_glGetShaderSourceARB1(obj, maxLength, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedStringARB}(GLenum type, GLint namelen, const GLchar *  name, GLint stringlen, const GLchar *  string) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public void glNamedStringARB(int type, int namelen, String name, int stringlen, String string)  {

    final long __addr_ = _pat._addressof_glNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedStringARB"));
    }
        dispatch_glNamedStringARB1(type, namelen, name, stringlen, string, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedStringARB}(GLenum type, GLint namelen, const GLchar *  name, GLint stringlen, const GLchar *  string) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  private native void dispatch_glNamedStringARB1(int type, int namelen, String name, int stringlen, String string, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteNamedStringARB}(GLint namelen, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public void glDeleteNamedStringARB(int namelen, String name)  {

    final long __addr_ = _pat._addressof_glDeleteNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamedStringARB"));
    }
        dispatch_glDeleteNamedStringARB1(namelen, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteNamedStringARB}(GLint namelen, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  private native void dispatch_glDeleteNamedStringARB1(int namelen, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar * const  *  path, const GLint *  length) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCompileShaderIncludeARB(int shader, int count, String[] path, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glCompileShaderIncludeARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderIncludeARB"));
    }
        dispatch_glCompileShaderIncludeARB1(shader, count, path, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar * const  *  path, const GLint *  length) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCompileShaderIncludeARB1(int shader, int count, String[] path, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShaderIncludeARB}(GLuint shader, GLsizei count, const GLchar * const  *  path, const GLint *  length) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public void glCompileShaderIncludeARB(int shader, int count, String[] path, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glCompileShaderIncludeARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShaderIncludeARB"));
    }
        dispatch_glCompileShaderIncludeARB1(shader, count, path, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedStringARB}(GLint namelen, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public boolean glIsNamedStringARB(int namelen, String name)  {

    final long __addr_ = _pat._addressof_glIsNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsNamedStringARB"));
    }
        return dispatch_glIsNamedStringARB1(namelen, name, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedStringARB}(GLint namelen, const GLchar *  name) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  private native boolean dispatch_glIsNamedStringARB1(int namelen, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param stringlen a direct or array-backed {@link java.nio.IntBuffer}
      @param string a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetNamedStringARB(int namelen, String name, int bufSize, IntBuffer stringlen, ByteBuffer string)  {

    final boolean stringlen_is_direct = Buffers.isDirect(stringlen);
    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = _pat._addressof_glGetNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringARB"));
    }
        dispatch_glGetNamedStringARB1(namelen, name, bufSize, stringlen_is_direct ? stringlen : Buffers.getArray(stringlen), stringlen_is_direct ? Buffers.getDirectBufferByteOffset(stringlen) : Buffers.getIndirectBufferByteOffset(stringlen), stringlen_is_direct, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param stringlen a direct or array-backed {@link java.nio.IntBuffer}
      @param string a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetNamedStringARB1(int namelen, String name, int bufSize, Object stringlen, int stringlen_byte_offset, boolean stringlen_is_direct, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedStringARB}(GLint namelen, const GLchar *  name, GLsizei bufSize, GLint *  stringlen, GLchar *  string) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public void glGetNamedStringARB(int namelen, String name, int bufSize, int[] stringlen, int stringlen_offset, byte[] string, int string_offset)  {

    if(stringlen != null && stringlen.length <= stringlen_offset)
      throw new GLException("array offset argument \"stringlen_offset\" (" + stringlen_offset + ") equals or exceeds array length (" + stringlen.length + ")");
    if(string != null && string.length <= string_offset)
      throw new GLException("array offset argument \"string_offset\" (" + string_offset + ") equals or exceeds array length (" + string.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringARB"));
    }
        dispatch_glGetNamedStringARB1(namelen, name, bufSize, stringlen, Buffers.SIZEOF_INT * stringlen_offset, false, string, string_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedStringivARB(int namelen, String name, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedStringivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringivARB"));
    }
        dispatch_glGetNamedStringivARB1(namelen, name, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedStringivARB1(int namelen, String name, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedStringivARB}(GLint namelen, const GLchar *  name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_shading_language_include</code><br>   */
  public void glGetNamedStringivARB(int namelen, String name, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedStringivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedStringivARB"));
    }
        dispatch_glGetNamedStringivARB1(namelen, name, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferPageCommitmentARB}(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  public void glBufferPageCommitmentARB(int target, long offset, long size, boolean commit)  {

    final long __addr_ = _pat._addressof_glBufferPageCommitmentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferPageCommitmentARB"));
    }
        dispatch_glBufferPageCommitmentARB1(target, offset, size, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferPageCommitmentARB}(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  private native void dispatch_glBufferPageCommitmentARB1(int target, long offset, long size, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferPageCommitmentEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  public void glNamedBufferPageCommitmentEXT(int buffer, long offset, long size, boolean commit)  {

    final long __addr_ = _pat._addressof_glNamedBufferPageCommitmentEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferPageCommitmentEXT"));
    }
        dispatch_glNamedBufferPageCommitmentEXT1(buffer, offset, size, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferPageCommitmentEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  private native void dispatch_glNamedBufferPageCommitmentEXT1(int buffer, long offset, long size, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferPageCommitmentARB}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  public void glNamedBufferPageCommitmentARB(int buffer, long offset, long size, boolean commit)  {

    final long __addr_ = _pat._addressof_glNamedBufferPageCommitmentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferPageCommitmentARB"));
    }
        dispatch_glNamedBufferPageCommitmentARB1(buffer, offset, size, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferPageCommitmentARB}(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_buffer</code><br>   */
  private native void dispatch_glNamedBufferPageCommitmentARB1(int buffer, long offset, long size, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexPageCommitmentARB}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_texture</code><br>   */
  public void glTexPageCommitmentARB(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit)  {

    final long __addr_ = _pat._addressof_glTexPageCommitmentARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexPageCommitmentARB"));
    }
        dispatch_glTexPageCommitmentARB1(target, level, xoffset, yoffset, zoffset, width, height, depth, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexPageCommitmentARB}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_ARB_sparse_texture</code><br>   */
  private native void dispatch_glTexPageCommitmentARB1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glWeightbvARB(int size, ByteBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightbvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightbvARB"));
    }
        dispatch_glWeightbvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glWeightbvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightbvARB}(GLint size, const GLbyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightbvARB(int size, byte[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightbvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightbvARB"));
    }
        dispatch_glWeightbvARB1(size, weights, weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWeightsvARB(int size, ShortBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightsvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightsvARB"));
    }
        dispatch_glWeightsvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWeightsvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightsvARB}(GLint size, const GLshort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightsvARB(int size, short[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightsvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightsvARB"));
    }
        dispatch_glWeightsvARB1(size, weights, Buffers.SIZEOF_SHORT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWeightivARB(int size, IntBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightivARB"));
    }
        dispatch_glWeightivARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWeightivARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightivARB}(GLint size, const GLint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightivARB(int size, int[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightivARB"));
    }
        dispatch_glWeightivARB1(size, weights, Buffers.SIZEOF_INT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glWeightfvARB(int size, FloatBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightfvARB"));
    }
        dispatch_glWeightfvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glWeightfvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightfvARB}(GLint size, const GLfloat *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightfvARB(int size, float[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightfvARB"));
    }
        dispatch_glWeightfvARB1(size, weights, Buffers.SIZEOF_FLOAT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glWeightdvARB(int size, DoubleBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightdvARB"));
    }
        dispatch_glWeightdvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glWeightdvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightdvARB}(GLint size, const GLdouble *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightdvARB(int size, double[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightdvARB"));
    }
        dispatch_glWeightdvARB1(size, weights, Buffers.SIZEOF_DOUBLE * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glWeightubvARB(int size, ByteBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightubvARB"));
    }
        dispatch_glWeightubvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glWeightubvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightubvARB}(GLint size, const GLubyte *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightubvARB(int size, byte[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightubvARB"));
    }
        dispatch_glWeightubvARB1(size, weights, weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glWeightusvARB(int size, ShortBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightusvARB"));
    }
        dispatch_glWeightusvARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glWeightusvARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightusvARB}(GLint size, const GLushort *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightusvARB(int size, short[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightusvARB"));
    }
        dispatch_glWeightusvARB1(size, weights, Buffers.SIZEOF_SHORT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glWeightuivARB(int size, IntBuffer weights)  {

    final boolean weights_is_direct = Buffers.isDirect(weights);
    final long __addr_ = _pat._addressof_glWeightuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightuivARB"));
    }
        dispatch_glWeightuivARB1(size, weights_is_direct ? weights : Buffers.getArray(weights), weights_is_direct ? Buffers.getDirectBufferByteOffset(weights) : Buffers.getIndirectBufferByteOffset(weights), weights_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param weights a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glWeightuivARB1(int size, Object weights, int weights_byte_offset, boolean weights_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightuivARB}(GLint size, const GLuint *  weights) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightuivARB(int size, int[] weights, int weights_offset)  {

    if(weights != null && weights.length <= weights_offset)
      throw new GLException("array offset argument \"weights_offset\" (" + weights_offset + ") equals or exceeds array length (" + weights.length + ")");
    final long __addr_ = _pat._addressof_glWeightuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightuivARB"));
    }
        dispatch_glWeightuivARB1(size, weights, Buffers.SIZEOF_INT * weights_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glWeightPointerARB(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glWeightPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightPointerARB"));
    }
        dispatch_glWeightPointerARB0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glWeightPointerARB0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glWeightPointerARB(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glWeightPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightPointerARB"));
    }
        dispatch_glWeightPointerARB0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerARB}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  private native void dispatch_glWeightPointerARB0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexBlendARB}(GLint count) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  public void glVertexBlendARB(int count)  {

    final long __addr_ = _pat._addressof_glVertexBlendARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexBlendARB"));
    }
        dispatch_glVertexBlendARB1(count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexBlendARB}(GLint count) </code> <br>Part of <code>GL_ARB_vertex_blend</code><br>   */
  private native void dispatch_glVertexBlendARB1(int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dARB}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1dARB(int index, double x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dARB"));
    }
        dispatch_glVertexAttrib1dARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dARB}(GLuint index, GLdouble x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib1dARB1(int index, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib1dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dvARB"));
    }
        dispatch_glVertexAttrib1dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib1dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1dvARB"));
    }
        dispatch_glVertexAttrib1dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fARB}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1fARB(int index, float x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fARB"));
    }
        dispatch_glVertexAttrib1fARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fARB}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib1fARB1(int index, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fvARB"));
    }
        dispatch_glVertexAttrib1fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fvARB"));
    }
        dispatch_glVertexAttrib1fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sARB}(GLuint index, GLshort x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1sARB(int index, short x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1sARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1sARB"));
    }
        dispatch_glVertexAttrib1sARB1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1sARB}(GLuint index, GLshort x) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib1sARB1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1svARB"));
    }
        dispatch_glVertexAttrib1svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib1svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1svARB"));
    }
        dispatch_glVertexAttrib1svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dARB}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2dARB(int index, double x, double y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dARB"));
    }
        dispatch_glVertexAttrib2dARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dARB}(GLuint index, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib2dARB1(int index, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib2dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dvARB"));
    }
        dispatch_glVertexAttrib2dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib2dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2dvARB"));
    }
        dispatch_glVertexAttrib2dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fARB}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2fARB(int index, float x, float y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fARB"));
    }
        dispatch_glVertexAttrib2fARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fARB}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib2fARB1(int index, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fvARB"));
    }
        dispatch_glVertexAttrib2fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fvARB"));
    }
        dispatch_glVertexAttrib2fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sARB}(GLuint index, GLshort x, GLshort y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2sARB(int index, short x, short y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2sARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2sARB"));
    }
        dispatch_glVertexAttrib2sARB1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2sARB}(GLuint index, GLshort x, GLshort y) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib2sARB1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2svARB"));
    }
        dispatch_glVertexAttrib2svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib2svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2svARB"));
    }
        dispatch_glVertexAttrib2svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3dARB(int index, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dARB"));
    }
        dispatch_glVertexAttrib3dARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib3dARB1(int index, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib3dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dvARB"));
    }
        dispatch_glVertexAttrib3dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib3dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3dvARB"));
    }
        dispatch_glVertexAttrib3dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3fARB(int index, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fARB"));
    }
        dispatch_glVertexAttrib3fARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib3fARB1(int index, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fvARB"));
    }
        dispatch_glVertexAttrib3fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fvARB"));
    }
        dispatch_glVertexAttrib3fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sARB}(GLuint index, GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3sARB(int index, short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3sARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3sARB"));
    }
        dispatch_glVertexAttrib3sARB1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3sARB}(GLuint index, GLshort x, GLshort y, GLshort z) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib3sARB1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3svARB"));
    }
        dispatch_glVertexAttrib3svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib3svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3svARB"));
    }
        dispatch_glVertexAttrib3svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4NbvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NbvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NbvARB"));
    }
        dispatch_glVertexAttrib4NbvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4NbvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NbvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NbvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NbvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NbvARB"));
    }
        dispatch_glVertexAttrib4NbvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4NivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NivARB"));
    }
        dispatch_glVertexAttrib4NivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4NivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NivARB"));
    }
        dispatch_glVertexAttrib4NivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4NsvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NsvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NsvARB"));
    }
        dispatch_glVertexAttrib4NsvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4NsvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NsvARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NsvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NsvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NsvARB"));
    }
        dispatch_glVertexAttrib4NsvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubARB}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NubARB(int index, byte x, byte y, byte z, byte w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4NubARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubARB"));
    }
        dispatch_glVertexAttrib4NubARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubARB}(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib4NubARB1(int index, byte x, byte y, byte z, byte w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4NubvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubvARB"));
    }
        dispatch_glVertexAttrib4NubvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4NubvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NubvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NubvARB"));
    }
        dispatch_glVertexAttrib4NubvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4NuivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NuivARB"));
    }
        dispatch_glVertexAttrib4NuivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4NuivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NuivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NuivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NuivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NuivARB"));
    }
        dispatch_glVertexAttrib4NuivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4NusvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4NusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NusvARB"));
    }
        dispatch_glVertexAttrib4NusvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4NusvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4NusvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4NusvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4NusvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4NusvARB"));
    }
        dispatch_glVertexAttrib4NusvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4bvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4bvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bvARB"));
    }
        dispatch_glVertexAttrib4bvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4bvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4bvARB}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4bvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4bvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4bvARB"));
    }
        dispatch_glVertexAttrib4bvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4dARB(int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4dARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dARB"));
    }
        dispatch_glVertexAttrib4dARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dARB}(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib4dARB1(int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVertexAttrib4dvARB(int index, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dvARB"));
    }
        dispatch_glVertexAttrib4dvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVertexAttrib4dvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4dvARB}(GLuint index, const GLdouble *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4dvARB(int index, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4dvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4dvARB"));
    }
        dispatch_glVertexAttrib4dvARB1(index, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4fARB(int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4fARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fARB"));
    }
        dispatch_glVertexAttrib4fARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fARB}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib4fARB1(int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fvARB(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fvARB"));
    }
        dispatch_glVertexAttrib4fvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fvARB}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4fvARB(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4fvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fvARB"));
    }
        dispatch_glVertexAttrib4fvARB1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4ivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ivARB"));
    }
        dispatch_glVertexAttrib4ivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4ivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ivARB}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4ivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4ivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ivARB"));
    }
        dispatch_glVertexAttrib4ivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sARB}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4sARB(int index, short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4sARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4sARB"));
    }
        dispatch_glVertexAttrib4sARB1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4sARB}(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttrib4sARB1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4svARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4svARB"));
    }
        dispatch_glVertexAttrib4svARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4svARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4svARB}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4svARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4svARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4svARB"));
    }
        dispatch_glVertexAttrib4svARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttrib4ubvARB(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4ubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubvARB"));
    }
        dispatch_glVertexAttrib4ubvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttrib4ubvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4ubvARB}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4ubvARB(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4ubvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4ubvARB"));
    }
        dispatch_glVertexAttrib4ubvARB1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttrib4uivARB(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4uivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uivARB"));
    }
        dispatch_glVertexAttrib4uivARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttrib4uivARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4uivARB}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4uivARB(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4uivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4uivARB"));
    }
        dispatch_glVertexAttrib4uivARB1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4usvARB(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4usvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usvARB"));
    }
        dispatch_glVertexAttrib4usvARB1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4usvARB1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4usvARB}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttrib4usvARB(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4usvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4usvARB"));
    }
        dispatch_glVertexAttrib4usvARB1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribPointerARB(int index, int size, int type, boolean normalized, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glVertexAttribPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointerARB"));
    }
        dispatch_glVertexAttribPointerARB1(index, size, type, normalized, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointerARB1(int index, int size, int type, boolean normalized, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glVertexAttribPointerARB(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribPointerARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointerARB"));
    }
        dispatch_glVertexAttribPointerARB1(index, size, type, normalized, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointerARB}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glVertexAttribPointerARB1(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArrayARB}(GLuint index) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glEnableVertexAttribArrayARB(int index)  {

    final long __addr_ = _pat._addressof_glEnableVertexAttribArrayARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArrayARB"));
    }
        dispatch_glEnableVertexAttribArrayARB1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArrayARB}(GLuint index) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glEnableVertexAttribArrayARB1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArrayARB}(GLuint index) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glDisableVertexAttribArrayARB(int index)  {

    final long __addr_ = _pat._addressof_glDisableVertexAttribArrayARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArrayARB"));
    }
        dispatch_glDisableVertexAttribArrayARB1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArrayARB}(GLuint index) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  private native void dispatch_glDisableVertexAttribArrayARB1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVertexAttribdvARB(int index, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdvARB"));
    }
        dispatch_glGetVertexAttribdvARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVertexAttribdvARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribdvARB}(GLuint index, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glGetVertexAttribdvARB(int index, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribdvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribdvARB"));
    }
        dispatch_glGetVertexAttribdvARB1(index, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfvARB(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfvARB"));
    }
        dispatch_glGetVertexAttribfvARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfvARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfvARB}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glGetVertexAttribfvARB(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfvARB"));
    }
        dispatch_glGetVertexAttribfvARB1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribivARB(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribivARB"));
    }
        dispatch_glGetVertexAttribivARB1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribivARB1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribivARB}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_vertex_program</code><br>   */
  public void glGetVertexAttribivARB(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribivARB"));
    }
        dispatch_glGetVertexAttribivARB1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendBarrier}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_blend_equation_advanced</code>, <code>GL_NV_blend_equation_advanced</code><br>Alias for: <code>glBlendBarrierKHR</code>, <code>glBlendBarrierNV</code>   */
  public void glBlendBarrier()  {

    final long __addr_ = _pat._addressof_glBlendBarrier;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendBarrier"));
    }
        dispatch_glBlendBarrier1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendBarrier}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_blend_equation_advanced</code>, <code>GL_NV_blend_equation_advanced</code><br>Alias for: <code>glBlendBarrierKHR</code>, <code>glBlendBarrierNV</code>   */
  private native void dispatch_glBlendBarrier1(long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1bOES}(GLenum texture, GLbyte s) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord1bOES(int texture, byte s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bOES"));
    }
        dispatch_glMultiTexCoord1bOES1(texture, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1bOES}(GLenum texture, GLbyte s) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glMultiTexCoord1bOES1(int texture, byte s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMultiTexCoord1bvOES(int texture, ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoord1bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bvOES"));
    }
        dispatch_glMultiTexCoord1bvOES1(texture, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMultiTexCoord1bvOES1(int texture, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord1bvOES(int texture, byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1bvOES"));
    }
        dispatch_glMultiTexCoord1bvOES1(texture, coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2bOES}(GLenum texture, GLbyte s, GLbyte t) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord2bOES(int texture, byte s, byte t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bOES"));
    }
        dispatch_glMultiTexCoord2bOES1(texture, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2bOES}(GLenum texture, GLbyte s, GLbyte t) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glMultiTexCoord2bOES1(int texture, byte s, byte t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMultiTexCoord2bvOES(int texture, ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoord2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bvOES"));
    }
        dispatch_glMultiTexCoord2bvOES1(texture, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMultiTexCoord2bvOES1(int texture, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord2bvOES(int texture, byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2bvOES"));
    }
        dispatch_glMultiTexCoord2bvOES1(texture, coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3bOES}(GLenum texture, GLbyte s, GLbyte t, GLbyte r) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord3bOES(int texture, byte s, byte t, byte r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bOES"));
    }
        dispatch_glMultiTexCoord3bOES1(texture, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3bOES}(GLenum texture, GLbyte s, GLbyte t, GLbyte r) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glMultiTexCoord3bOES1(int texture, byte s, byte t, byte r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMultiTexCoord3bvOES(int texture, ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoord3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bvOES"));
    }
        dispatch_glMultiTexCoord3bvOES1(texture, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMultiTexCoord3bvOES1(int texture, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord3bvOES(int texture, byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3bvOES"));
    }
        dispatch_glMultiTexCoord3bvOES1(texture, coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4bOES}(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord4bOES(int texture, byte s, byte t, byte r, byte q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bOES"));
    }
        dispatch_glMultiTexCoord4bOES1(texture, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4bOES}(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glMultiTexCoord4bOES1(int texture, byte s, byte t, byte r, byte q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glMultiTexCoord4bvOES(int texture, ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glMultiTexCoord4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bvOES"));
    }
        dispatch_glMultiTexCoord4bvOES1(texture, coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glMultiTexCoord4bvOES1(int texture, Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4bvOES}(GLenum texture, const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glMultiTexCoord4bvOES(int texture, byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4bvOES"));
    }
        dispatch_glMultiTexCoord4bvOES1(texture, coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1bOES}(GLbyte s) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord1bOES(byte s)  {

    final long __addr_ = _pat._addressof_glTexCoord1bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bOES"));
    }
        dispatch_glTexCoord1bOES1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1bOES}(GLbyte s) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glTexCoord1bOES1(byte s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glTexCoord1bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoord1bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bvOES"));
    }
        dispatch_glTexCoord1bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glTexCoord1bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord1bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1bvOES"));
    }
        dispatch_glTexCoord1bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2bOES}(GLbyte s, GLbyte t) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord2bOES(byte s, byte t)  {

    final long __addr_ = _pat._addressof_glTexCoord2bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bOES"));
    }
        dispatch_glTexCoord2bOES1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2bOES}(GLbyte s, GLbyte t) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glTexCoord2bOES1(byte s, byte t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glTexCoord2bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoord2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bvOES"));
    }
        dispatch_glTexCoord2bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glTexCoord2bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord2bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2bvOES"));
    }
        dispatch_glTexCoord2bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3bOES}(GLbyte s, GLbyte t, GLbyte r) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord3bOES(byte s, byte t, byte r)  {

    final long __addr_ = _pat._addressof_glTexCoord3bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bOES"));
    }
        dispatch_glTexCoord3bOES1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3bOES}(GLbyte s, GLbyte t, GLbyte r) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glTexCoord3bOES1(byte s, byte t, byte r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glTexCoord3bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoord3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bvOES"));
    }
        dispatch_glTexCoord3bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glTexCoord3bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord3bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3bvOES"));
    }
        dispatch_glTexCoord3bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4bOES}(GLbyte s, GLbyte t, GLbyte r, GLbyte q) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord4bOES(byte s, byte t, byte r, byte q)  {

    final long __addr_ = _pat._addressof_glTexCoord4bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bOES"));
    }
        dispatch_glTexCoord4bOES1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4bOES}(GLbyte s, GLbyte t, GLbyte r, GLbyte q) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glTexCoord4bOES1(byte s, byte t, byte r, byte q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glTexCoord4bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glTexCoord4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bvOES"));
    }
        dispatch_glTexCoord4bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glTexCoord4bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glTexCoord4bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4bvOES"));
    }
        dispatch_glTexCoord4bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2bOES}(GLbyte x, GLbyte y) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex2bOES(byte x, byte y)  {

    final long __addr_ = _pat._addressof_glVertex2bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2bOES"));
    }
        dispatch_glVertex2bOES1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2bOES}(GLbyte x, GLbyte y) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glVertex2bOES1(byte x, byte y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertex2bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glVertex2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2bvOES"));
    }
        dispatch_glVertex2bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertex2bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex2bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glVertex2bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2bvOES"));
    }
        dispatch_glVertex2bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3bOES}(GLbyte x, GLbyte y, GLbyte z) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex3bOES(byte x, byte y, byte z)  {

    final long __addr_ = _pat._addressof_glVertex3bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3bOES"));
    }
        dispatch_glVertex3bOES1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3bOES}(GLbyte x, GLbyte y, GLbyte z) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glVertex3bOES1(byte x, byte y, byte z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertex3bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glVertex3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3bvOES"));
    }
        dispatch_glVertex3bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertex3bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex3bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glVertex3bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3bvOES"));
    }
        dispatch_glVertex3bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4bOES}(GLbyte x, GLbyte y, GLbyte z, GLbyte w) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex4bOES(byte x, byte y, byte z, byte w)  {

    final long __addr_ = _pat._addressof_glVertex4bOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4bOES"));
    }
        dispatch_glVertex4bOES1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4bOES}(GLbyte x, GLbyte y, GLbyte z, GLbyte w) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  private native void dispatch_glVertex4bOES1(byte x, byte y, byte z, byte w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertex4bvOES(ByteBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glVertex4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4bvOES"));
    }
        dispatch_glVertex4bvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>
      @param coords a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertex4bvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4bvOES}(const GLbyte *  coords) </code> <br>Part of <code>GL_OES_byte_coordinates</code><br>   */
  public void glVertex4bvOES(byte[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glVertex4bvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4bvOES"));
    }
        dispatch_glVertex4bvOES1(coords, coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glQueryMatrixxOES(IntBuffer mantissa, IntBuffer exponent)  {

    final boolean mantissa_is_direct = Buffers.isDirect(mantissa);
    final boolean exponent_is_direct = Buffers.isDirect(exponent);
    final long __addr_ = _pat._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
    }
        return dispatch_glQueryMatrixxOES1(mantissa_is_direct ? mantissa : Buffers.getArray(mantissa), mantissa_is_direct ? Buffers.getDirectBufferByteOffset(mantissa) : Buffers.getIndirectBufferByteOffset(mantissa), mantissa_is_direct, exponent_is_direct ? exponent : Buffers.getArray(exponent), exponent_is_direct ? Buffers.getDirectBufferByteOffset(exponent) : Buffers.getIndirectBufferByteOffset(exponent), exponent_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glQueryMatrixxOES1(Object mantissa, int mantissa_byte_offset, boolean mantissa_is_direct, Object exponent, int exponent_byte_offset, boolean exponent_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>   */
  public int glQueryMatrixxOES(int[] mantissa, int mantissa_offset, int[] exponent, int exponent_offset)  {

    if(mantissa != null && mantissa.length <= mantissa_offset)
      throw new GLException("array offset argument \"mantissa_offset\" (" + mantissa_offset + ") equals or exceeds array length (" + mantissa.length + ")");
    if(exponent != null && exponent.length <= exponent_offset)
      throw new GLException("array offset argument \"exponent_offset\" (" + exponent_offset + ") equals or exceeds array length (" + exponent.length + ")");
    final long __addr_ = _pat._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
    }
        return dispatch_glQueryMatrixxOES1(mantissa, Buffers.SIZEOF_INT * mantissa_offset, false, exponent, Buffers.SIZEOF_INT * exponent_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClipPlanef(int plane, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
    }
        dispatch_glClipPlanef1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClipPlanef1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>   */
  public void glClipPlanef(int plane, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
    }
        dispatch_glClipPlanef1(plane, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glFrustumfOES</code>   */
  public void glFrustumf(float l, float r, float b, float t, float n, float f)  {

    if ( !_context.hasFP32CompatAPI() ) {
    glFrustum((double)l, (double)r, (double)b, (double)t, (double)n, (double)f);
    return;
    }
    final long __addr_ = _pat._addressof_glFrustumf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrustumf"));
    }
        dispatch_glFrustumf1(l, r, b, t, n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glFrustumfOES</code>   */
  private native void dispatch_glFrustumf1(float l, float r, float b, float t, float n, float f, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum plane, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetClipPlanef(int plane, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
    }
        dispatch_glGetClipPlanef1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum plane, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetClipPlanef1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum plane, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>   */
  public void glGetClipPlanef(int plane, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
    }
        dispatch_glGetClipPlanef1(plane, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glOrthofOES</code>   */
  public void glOrthof(float l, float r, float b, float t, float n, float f)  {

    if ( !_context.hasFP32CompatAPI() ) {
    glOrtho((double)l, (double)r, (double)b, (double)t, (double)n, (double)f);
    return;
    }
    final long __addr_ = _pat._addressof_glOrthof;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glOrthof"));
    }
        dispatch_glOrthof1(l, r, b, t, n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glOrthofOES</code>   */
  private native void dispatch_glOrthof1(float l, float r, float b, float t, float n, float f, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_AMD_debug_output</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageEnableAMD(int category, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDebugMessageEnableAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageEnableAMD"));
    }
        dispatch_glDebugMessageEnableAMD1(category, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_AMD_debug_output</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageEnableAMD1(int category, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageEnableAMD}(GLenum category, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_AMD_debug_output</code><br>   */
  public void glDebugMessageEnableAMD(int category, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDebugMessageEnableAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageEnableAMD"));
    }
        dispatch_glDebugMessageEnableAMD1(category, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertAMD}(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_AMD_debug_output</code><br>   */
  public void glDebugMessageInsertAMD(int category, int severity, int id, int length, String buf)  {

    final long __addr_ = _pat._addressof_glDebugMessageInsertAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsertAMD"));
    }
        dispatch_glDebugMessageInsertAMD1(category, severity, id, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsertAMD}(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_AMD_debug_output</code><br>   */
  private native void dispatch_glDebugMessageInsertAMD1(int category, int severity, int id, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message) </code> <br>Part of <code>GL_AMD_debug_output</code><br>
      @param categories a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLogAMD(int count, int bufsize, IntBuffer categories, IntBuffer severities, IntBuffer ids, IntBuffer lengths, ByteBuffer message)  {

    final boolean categories_is_direct = Buffers.isDirect(categories);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean message_is_direct = Buffers.isDirect(message);
    final long __addr_ = _pat._addressof_glGetDebugMessageLogAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLogAMD"));
    }
        return dispatch_glGetDebugMessageLogAMD1(count, bufsize, categories_is_direct ? categories : Buffers.getArray(categories), categories_is_direct ? Buffers.getDirectBufferByteOffset(categories) : Buffers.getIndirectBufferByteOffset(categories), categories_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message) </code> <br>Part of <code>GL_AMD_debug_output</code><br>
      @param categories a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLogAMD1(int count, int bufsize, Object categories, int categories_byte_offset, boolean categories_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object message, int message_byte_offset, boolean message_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLogAMD}(GLuint count, GLsizei bufsize, GLenum *  categories, GLuint *  severities, GLuint *  ids, GLsizei *  lengths, GLchar *  message) </code> <br>Part of <code>GL_AMD_debug_output</code><br>   */
  public int glGetDebugMessageLogAMD(int count, int bufsize, int[] categories, int categories_offset, int[] severities, int severities_offset, int[] ids, int ids_offset, int[] lengths, int lengths_offset, byte[] message, int message_offset)  {

    if(categories != null && categories.length <= categories_offset)
      throw new GLException("array offset argument \"categories_offset\" (" + categories_offset + ") equals or exceeds array length (" + categories.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(message != null && message.length <= message_offset)
      throw new GLException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
    final long __addr_ = _pat._addressof_glGetDebugMessageLogAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLogAMD"));
    }
        return dispatch_glGetDebugMessageLogAMD1(count, bufsize, categories, Buffers.SIZEOF_INT * categories_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, message, message_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncIndexedAMD}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  public void glBlendFuncIndexedAMD(int buf, int src, int dst)  {

    final long __addr_ = _pat._addressof_glBlendFuncIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncIndexedAMD"));
    }
        dispatch_glBlendFuncIndexedAMD1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncIndexedAMD}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  private native void dispatch_glBlendFuncIndexedAMD1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateIndexedAMD}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  public void glBlendFuncSeparateIndexedAMD(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparateIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateIndexedAMD"));
    }
        dispatch_glBlendFuncSeparateIndexedAMD1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateIndexedAMD}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  private native void dispatch_glBlendFuncSeparateIndexedAMD1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationIndexedAMD}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  public void glBlendEquationIndexedAMD(int buf, int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquationIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationIndexedAMD"));
    }
        dispatch_glBlendEquationIndexedAMD1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationIndexedAMD}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  private native void dispatch_glBlendEquationIndexedAMD1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateIndexedAMD}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  public void glBlendEquationSeparateIndexedAMD(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparateIndexedAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparateIndexedAMD"));
    }
        dispatch_glBlendEquationSeparateIndexedAMD1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateIndexedAMD}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_AMD_draw_buffers_blend</code><br>   */
  private native void dispatch_glBlendEquationSeparateIndexedAMD1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64NV}(GLint location, GLint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform1i64NV(int location, long x)  {

    final long __addr_ = _pat._addressof_glUniform1i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64NV"));
    }
        dispatch_glUniform1i64NV1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64NV}(GLint location, GLint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform1i64NV1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64NV}(GLint location, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform2i64NV(int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glUniform2i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64NV"));
    }
        dispatch_glUniform2i64NV1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64NV}(GLint location, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform2i64NV1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform3i64NV(int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glUniform3i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64NV"));
    }
        dispatch_glUniform3i64NV1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform3i64NV1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform4i64NV(int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glUniform4i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64NV"));
    }
        dispatch_glUniform4i64NV1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64NV}(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform4i64NV1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vNV"));
    }
        dispatch_glUniform1i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform1i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i64vNV"));
    }
        dispatch_glUniform1i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vNV"));
    }
        dispatch_glUniform2i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform2i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i64vNV"));
    }
        dispatch_glUniform2i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vNV"));
    }
        dispatch_glUniform3i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform3i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i64vNV"));
    }
        dispatch_glUniform3i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4i64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vNV"));
    }
        dispatch_glUniform4i64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4i64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4i64vNV}(GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform4i64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i64vNV"));
    }
        dispatch_glUniform4i64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64NV}(GLint location, GLuint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform1ui64NV(int location, long x)  {

    final long __addr_ = _pat._addressof_glUniform1ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64NV"));
    }
        dispatch_glUniform1ui64NV1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64NV}(GLint location, GLuint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform1ui64NV1(int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform2ui64NV(int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glUniform2ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64NV"));
    }
        dispatch_glUniform2ui64NV1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform2ui64NV1(int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform3ui64NV(int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glUniform3ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64NV"));
    }
        dispatch_glUniform3ui64NV1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform3ui64NV1(int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform4ui64NV(int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glUniform4ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64NV"));
    }
        dispatch_glUniform4ui64NV1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64NV}(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glUniform4ui64NV1(int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform1ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vNV"));
    }
        dispatch_glUniform1ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform1ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform1ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui64vNV"));
    }
        dispatch_glUniform1ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform2ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vNV"));
    }
        dispatch_glUniform2ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform2ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform2ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui64vNV"));
    }
        dispatch_glUniform2ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform3ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vNV"));
    }
        dispatch_glUniform3ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform3ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform3ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui64vNV"));
    }
        dispatch_glUniform3ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniform4ui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vNV"));
    }
        dispatch_glUniform4ui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniform4ui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glUniform4ui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui64vNV"));
    }
        dispatch_glUniform4ui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformi64vNV(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformi64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vNV"));
    }
        dispatch_glGetUniformi64vNV1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformi64vNV1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformi64vNV}(GLuint program, GLint location, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glGetUniformi64vNV(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformi64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformi64vNV"));
    }
        dispatch_glGetUniformi64vNV1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetUniformui64vNV(int program, int location, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vNV"));
    }
        dispatch_glGetUniformui64vNV1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetUniformui64vNV1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformui64vNV}(GLuint program, GLint location, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glGetUniformui64vNV(int program, int location, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformui64vNV"));
    }
        dispatch_glGetUniformui64vNV1(program, location, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64NV}(GLuint program, GLint location, GLint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform1i64NV(int program, int location, long x)  {

    final long __addr_ = _pat._addressof_glProgramUniform1i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64NV"));
    }
        dispatch_glProgramUniform1i64NV1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64NV}(GLuint program, GLint location, GLint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform1i64NV1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform2i64NV(int program, int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glProgramUniform2i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64NV"));
    }
        dispatch_glProgramUniform2i64NV1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform2i64NV1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform3i64NV(int program, int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glProgramUniform3i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64NV"));
    }
        dispatch_glProgramUniform3i64NV1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform3i64NV1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform4i64NV(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glProgramUniform4i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64NV"));
    }
        dispatch_glProgramUniform4i64NV1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64NV}(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform4i64NV1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vNV"));
    }
        dispatch_glProgramUniform1i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform1i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i64vNV"));
    }
        dispatch_glProgramUniform1i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vNV"));
    }
        dispatch_glProgramUniform2i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform2i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i64vNV"));
    }
        dispatch_glProgramUniform2i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vNV"));
    }
        dispatch_glProgramUniform3i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform3i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i64vNV"));
    }
        dispatch_glProgramUniform3i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4i64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vNV"));
    }
        dispatch_glProgramUniform4i64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4i64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i64vNV}(GLuint program, GLint location, GLsizei count, const GLint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform4i64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i64vNV"));
    }
        dispatch_glProgramUniform4i64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64NV}(GLuint program, GLint location, GLuint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform1ui64NV(int program, int location, long x)  {

    final long __addr_ = _pat._addressof_glProgramUniform1ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64NV"));
    }
        dispatch_glProgramUniform1ui64NV1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64NV}(GLuint program, GLint location, GLuint64EXT x) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform1ui64NV1(int program, int location, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform2ui64NV(int program, int location, long x, long y)  {

    final long __addr_ = _pat._addressof_glProgramUniform2ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64NV"));
    }
        dispatch_glProgramUniform2ui64NV1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform2ui64NV1(int program, int location, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform3ui64NV(int program, int location, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glProgramUniform3ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64NV"));
    }
        dispatch_glProgramUniform3ui64NV1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform3ui64NV1(int program, int location, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform4ui64NV(int program, int location, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glProgramUniform4ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64NV"));
    }
        dispatch_glProgramUniform4ui64NV1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64NV}(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  private native void dispatch_glProgramUniform4ui64NV1(int program, int location, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform1ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vNV"));
    }
        dispatch_glProgramUniform1ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform1ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform1ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui64vNV"));
    }
        dispatch_glProgramUniform1ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform2ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vNV"));
    }
        dispatch_glProgramUniform2ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform2ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform2ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui64vNV"));
    }
        dispatch_glProgramUniform2ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform3ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vNV"));
    }
        dispatch_glProgramUniform3ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform3ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform3ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui64vNV"));
    }
        dispatch_glProgramUniform3ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniform4ui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vNV"));
    }
        dispatch_glProgramUniform4ui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniform4ui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_gpu_shader5</code>, <code>GL_AMD_gpu_shader_int64</code><br>   */
  public void glProgramUniform4ui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui64vNV"));
    }
        dispatch_glProgramUniform4ui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribParameteriAMD}(GLuint index, GLenum pname, GLint param) </code> <br>Part of <code>GL_AMD_interleaved_elements</code><br>   */
  public void glVertexAttribParameteriAMD(int index, int pname, int param)  {

    final long __addr_ = _pat._addressof_glVertexAttribParameteriAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribParameteriAMD"));
    }
        dispatch_glVertexAttribParameteriAMD1(index, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribParameteriAMD}(GLuint index, GLenum pname, GLint param) </code> <br>Part of <code>GL_AMD_interleaved_elements</code><br>   */
  private native void dispatch_glVertexAttribParameteriAMD1(int index, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectAMD}(GLenum mode, const void *  indirect, GLsizei primcount, GLsizei stride) </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirectAMD(int mode, Buffer indirect, int primcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirectAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectAMD"));
    }
        dispatch_glMultiDrawArraysIndirectAMD1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, primcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectAMD}(GLenum mode, const void *  indirect, GLsizei primcount, GLsizei stride) </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirectAMD1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int primcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectAMD}(GLenum mode, GLenum type, const void *  indirect, GLsizei primcount, GLsizei stride) </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirectAMD(int mode, int type, Buffer indirect, int primcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirectAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectAMD"));
    }
        dispatch_glMultiDrawElementsIndirectAMD1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, primcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectAMD}(GLenum mode, GLenum type, const void *  indirect, GLsizei primcount, GLsizei stride) </code> <br>Part of <code>GL_AMD_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirectAMD1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int primcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenNamesAMD(int identifier, int num, IntBuffer names)  {

    final boolean names_is_direct = Buffers.isDirect(names);
    final long __addr_ = _pat._addressof_glGenNamesAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenNamesAMD"));
    }
        dispatch_glGenNamesAMD1(identifier, num, names_is_direct ? names : Buffers.getArray(names), names_is_direct ? Buffers.getDirectBufferByteOffset(names) : Buffers.getIndirectBufferByteOffset(names), names_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenNamesAMD1(int identifier, int num, Object names, int names_byte_offset, boolean names_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenNamesAMD}(GLenum identifier, GLuint num, GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>   */
  public void glGenNamesAMD(int identifier, int num, int[] names, int names_offset)  {

    if(names != null && names.length <= names_offset)
      throw new GLException("array offset argument \"names_offset\" (" + names_offset + ") equals or exceeds array length (" + names.length + ")");
    final long __addr_ = _pat._addressof_glGenNamesAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenNamesAMD"));
    }
        dispatch_glGenNamesAMD1(identifier, num, names, Buffers.SIZEOF_INT * names_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteNamesAMD(int identifier, int num, IntBuffer names)  {

    final boolean names_is_direct = Buffers.isDirect(names);
    final long __addr_ = _pat._addressof_glDeleteNamesAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamesAMD"));
    }
        dispatch_glDeleteNamesAMD1(identifier, num, names_is_direct ? names : Buffers.getArray(names), names_is_direct ? Buffers.getDirectBufferByteOffset(names) : Buffers.getIndirectBufferByteOffset(names), names_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>
      @param names a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteNamesAMD1(int identifier, int num, Object names, int names_byte_offset, boolean names_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteNamesAMD}(GLenum identifier, GLuint num, const GLuint *  names) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>   */
  public void glDeleteNamesAMD(int identifier, int num, int[] names, int names_offset)  {

    if(names != null && names.length <= names_offset)
      throw new GLException("array offset argument \"names_offset\" (" + names_offset + ") equals or exceeds array length (" + names.length + ")");
    final long __addr_ = _pat._addressof_glDeleteNamesAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteNamesAMD"));
    }
        dispatch_glDeleteNamesAMD1(identifier, num, names, Buffers.SIZEOF_INT * names_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNameAMD}(GLenum identifier, GLuint name) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>   */
  public boolean glIsNameAMD(int identifier, int name)  {

    final long __addr_ = _pat._addressof_glIsNameAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsNameAMD"));
    }
        return dispatch_glIsNameAMD1(identifier, name, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNameAMD}(GLenum identifier, GLuint name) </code> <br>Part of <code>GL_AMD_name_gen_delete</code><br>   */
  private native boolean dispatch_glIsNameAMD1(int identifier, int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glQueryObjectParameteruiAMD}(GLenum target, GLuint id, GLenum pname, GLuint param) </code> <br>Part of <code>GL_AMD_occlusion_query_event</code><br>   */
  public void glQueryObjectParameteruiAMD(int target, int id, int pname, int param)  {

    final long __addr_ = _pat._addressof_glQueryObjectParameteruiAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryObjectParameteruiAMD"));
    }
        dispatch_glQueryObjectParameteruiAMD1(target, id, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryObjectParameteruiAMD}(GLenum target, GLuint id, GLenum pname, GLuint param) </code> <br>Part of <code>GL_AMD_occlusion_query_event</code><br>   */
  private native void dispatch_glQueryObjectParameteruiAMD1(int target, int id, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorGroupsAMD(IntBuffer numGroups, int groupsSize, IntBuffer groups)  {

    final boolean numGroups_is_direct = Buffers.isDirect(numGroups);
    final boolean groups_is_direct = Buffers.isDirect(groups);
    final long __addr_ = _pat._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups_is_direct ? numGroups : Buffers.getArray(numGroups), numGroups_is_direct ? Buffers.getDirectBufferByteOffset(numGroups) : Buffers.getIndirectBufferByteOffset(numGroups), numGroups_is_direct, groupsSize, groups_is_direct ? groups : Buffers.getArray(groups), groups_is_direct ? Buffers.getDirectBufferByteOffset(groups) : Buffers.getIndirectBufferByteOffset(groups), groups_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupsAMD1(Object numGroups, int numGroups_byte_offset, boolean numGroups_is_direct, int groupsSize, Object groups, int groups_byte_offset, boolean groups_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGetPerfMonitorGroupsAMD(int[] numGroups, int numGroups_offset, int groupsSize, int[] groups, int groups_offset)  {

    if(numGroups != null && numGroups.length <= numGroups_offset)
      throw new GLException("array offset argument \"numGroups_offset\" (" + numGroups_offset + ") equals or exceeds array length (" + numGroups.length + ")");
    if(groups != null && groups.length <= groups_offset)
      throw new GLException("array offset argument \"groups_offset\" (" + groups_offset + ") equals or exceeds array length (" + groups.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups, Buffers.SIZEOF_INT * numGroups_offset, false, groupsSize, groups, Buffers.SIZEOF_INT * groups_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCountersAMD(int group, IntBuffer numCounters, IntBuffer maxActiveCounters, int counterSize, IntBuffer counters)  {

    final boolean numCounters_is_direct = Buffers.isDirect(numCounters);
    final boolean maxActiveCounters_is_direct = Buffers.isDirect(maxActiveCounters);
    final boolean counters_is_direct = Buffers.isDirect(counters);
    final long __addr_ = _pat._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters_is_direct ? numCounters : Buffers.getArray(numCounters), numCounters_is_direct ? Buffers.getDirectBufferByteOffset(numCounters) : Buffers.getIndirectBufferByteOffset(numCounters), numCounters_is_direct, maxActiveCounters_is_direct ? maxActiveCounters : Buffers.getArray(maxActiveCounters), maxActiveCounters_is_direct ? Buffers.getDirectBufferByteOffset(maxActiveCounters) : Buffers.getIndirectBufferByteOffset(maxActiveCounters), maxActiveCounters_is_direct, counterSize, counters_is_direct ? counters : Buffers.getArray(counters), counters_is_direct ? Buffers.getDirectBufferByteOffset(counters) : Buffers.getIndirectBufferByteOffset(counters), counters_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCountersAMD1(int group, Object numCounters, int numCounters_byte_offset, boolean numCounters_is_direct, Object maxActiveCounters, int maxActiveCounters_byte_offset, boolean maxActiveCounters_is_direct, int counterSize, Object counters, int counters_byte_offset, boolean counters_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGetPerfMonitorCountersAMD(int group, int[] numCounters, int numCounters_offset, int[] maxActiveCounters, int maxActiveCounters_offset, int counterSize, int[] counters, int counters_offset)  {

    if(numCounters != null && numCounters.length <= numCounters_offset)
      throw new GLException("array offset argument \"numCounters_offset\" (" + numCounters_offset + ") equals or exceeds array length (" + numCounters.length + ")");
    if(maxActiveCounters != null && maxActiveCounters.length <= maxActiveCounters_offset)
      throw new GLException("array offset argument \"maxActiveCounters_offset\" (" + maxActiveCounters_offset + ") equals or exceeds array length (" + maxActiveCounters.length + ")");
    if(counters != null && counters.length <= counters_offset)
      throw new GLException("array offset argument \"counters_offset\" (" + counters_offset + ") equals or exceeds array length (" + counters.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters, Buffers.SIZEOF_INT * numCounters_offset, false, maxActiveCounters, Buffers.SIZEOF_INT * maxActiveCounters_offset, false, counterSize, counters, Buffers.SIZEOF_INT * counters_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, IntBuffer length, ByteBuffer groupString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean groupString_is_direct = Buffers.isDirect(groupString);
    final long __addr_ = _pat._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, groupString_is_direct ? groupString : Buffers.getArray(groupString), groupString_is_direct ? Buffers.getDirectBufferByteOffset(groupString) : Buffers.getIndirectBufferByteOffset(groupString), groupString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupStringAMD1(int group, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object groupString, int groupString_byte_offset, boolean groupString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, int[] length, int length_offset, byte[] groupString, int groupString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(groupString != null && groupString.length <= groupString_offset)
      throw new GLException("array offset argument \"groupString_offset\" (" + groupString_offset + ") equals or exceeds array length (" + groupString.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, groupString, groupString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, IntBuffer length, ByteBuffer counterString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean counterString_is_direct = Buffers.isDirect(counterString);
    final long __addr_ = _pat._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, counterString_is_direct ? counterString : Buffers.getArray(counterString), counterString_is_direct ? Buffers.getDirectBufferByteOffset(counterString) : Buffers.getIndirectBufferByteOffset(counterString), counterString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterStringAMD1(int group, int counter, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object counterString, int counterString_byte_offset, boolean counterString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, int[] length, int length_offset, byte[] counterString, int counterString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(counterString != null && counterString.length <= counterString_offset)
      throw new GLException("array offset argument \"counterString_offset\" (" + counterString_offset + ") equals or exceeds array length (" + counterString.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, counterString, counterString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, void *  data) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetPerfMonitorCounterInfoAMD(int group, int counter, int pname, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetPerfMonitorCounterInfoAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterInfoAMD"));
    }
        dispatch_glGetPerfMonitorCounterInfoAMD1(group, counter, pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, void *  data) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetPerfMonitorCounterInfoAMD1(int group, int counter, int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenPerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = _pat._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenPerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGenPerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = _pat._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeletePerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = _pat._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeletePerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glDeletePerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = _pat._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param counterList a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, IntBuffer counterList)  {

    final boolean counterList_is_direct = Buffers.isDirect(counterList);
    final long __addr_ = _pat._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, counterList_is_direct ? counterList : Buffers.getArray(counterList), counterList_is_direct ? Buffers.getDirectBufferByteOffset(counterList) : Buffers.getIndirectBufferByteOffset(counterList), counterList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param counterList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectPerfMonitorCountersAMD1(int monitor, boolean enable, int group, int numCounters, Object counterList, int counterList_byte_offset, boolean counterList_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  counterList) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, int[] counterList, int counterList_offset)  {

    if(counterList != null && counterList.length <= counterList_offset)
      throw new GLException("array offset argument \"counterList_offset\" (" + counterList_offset + ") equals or exceeds array length (" + counterList.length + ")");
    final long __addr_ = _pat._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, counterList, Buffers.SIZEOF_INT * counterList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glBeginPerfMonitorAMD(int monitor)  {

    final long __addr_ = _pat._addressof_glBeginPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginPerfMonitorAMD"));
    }
        dispatch_glBeginPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  private native void dispatch_glBeginPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glEndPerfMonitorAMD(int monitor)  {

    final long __addr_ = _pat._addressof_glEndPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndPerfMonitorAMD"));
    }
        dispatch_glEndPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  private native void dispatch_glEndPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, IntBuffer data, IntBuffer bytesWritten)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final boolean bytesWritten_is_direct = Buffers.isDirect(bytesWritten);
    final long __addr_ = _pat._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten_is_direct ? bytesWritten : Buffers.getArray(bytesWritten), bytesWritten_is_direct ? Buffers.getDirectBufferByteOffset(bytesWritten) : Buffers.getIndirectBufferByteOffset(bytesWritten), bytesWritten_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterDataAMD1(int monitor, int pname, int dataSize, Object data, int data_byte_offset, boolean data_is_direct, Object bytesWritten, int bytesWritten_byte_offset, boolean bytesWritten_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten) </code> <br>Part of <code>GL_AMD_performance_monitor</code><br>   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, int[] data, int data_offset, int[] bytesWritten, int bytesWritten_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    if(bytesWritten != null && bytesWritten.length <= bytesWritten_offset)
      throw new GLException("array offset argument \"bytesWritten_offset\" (" + bytesWritten_offset + ") equals or exceeds array length (" + bytesWritten.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data, Buffers.SIZEOF_INT * data_offset, false, bytesWritten, Buffers.SIZEOF_INT * bytesWritten_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val) </code> <br>Part of <code>GL_AMD_sample_positions</code><br>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSetMultisamplefvAMD(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = _pat._addressof_glSetMultisamplefvAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSetMultisamplefvAMD"));
    }
        dispatch_glSetMultisamplefvAMD1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val) </code> <br>Part of <code>GL_AMD_sample_positions</code><br>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSetMultisamplefvAMD1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetMultisamplefvAMD}(GLenum pname, GLuint index, const GLfloat *  val) </code> <br>Part of <code>GL_AMD_sample_positions</code><br>   */
  public void glSetMultisamplefvAMD(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = _pat._addressof_glSetMultisamplefvAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSetMultisamplefvAMD"));
    }
        dispatch_glSetMultisamplefvAMD1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorageSparseAMD}(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) </code> <br>Part of <code>GL_AMD_sparse_texture</code><br>   */
  public void glTexStorageSparseAMD(int target, int internalFormat, int width, int height, int depth, int layers, int flags)  {

    final long __addr_ = _pat._addressof_glTexStorageSparseAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorageSparseAMD"));
    }
        dispatch_glTexStorageSparseAMD1(target, internalFormat, width, height, depth, layers, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorageSparseAMD}(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) </code> <br>Part of <code>GL_AMD_sparse_texture</code><br>   */
  private native void dispatch_glTexStorageSparseAMD1(int target, int internalFormat, int width, int height, int depth, int layers, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorageSparseAMD}(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) </code> <br>Part of <code>GL_AMD_sparse_texture</code><br>   */
  public void glTextureStorageSparseAMD(int texture, int target, int internalFormat, int width, int height, int depth, int layers, int flags)  {

    final long __addr_ = _pat._addressof_glTextureStorageSparseAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorageSparseAMD"));
    }
        dispatch_glTextureStorageSparseAMD1(texture, target, internalFormat, width, height, depth, layers, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorageSparseAMD}(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) </code> <br>Part of <code>GL_AMD_sparse_texture</code><br>   */
  private native void dispatch_glTextureStorageSparseAMD1(int texture, int target, int internalFormat, int width, int height, int depth, int layers, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpValueAMD}(GLenum face, GLuint value) </code> <br>Part of <code>GL_AMD_stencil_operation_extended</code><br>   */
  public void glStencilOpValueAMD(int face, int value)  {

    final long __addr_ = _pat._addressof_glStencilOpValueAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOpValueAMD"));
    }
        dispatch_glStencilOpValueAMD1(face, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpValueAMD}(GLenum face, GLuint value) </code> <br>Part of <code>GL_AMD_stencil_operation_extended</code><br>   */
  private native void dispatch_glStencilOpValueAMD1(int face, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glTessellationFactorAMD}(GLfloat factor) </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code><br>   */
  public void glTessellationFactorAMD(float factor)  {

    final long __addr_ = _pat._addressof_glTessellationFactorAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTessellationFactorAMD"));
    }
        dispatch_glTessellationFactorAMD1(factor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTessellationFactorAMD}(GLfloat factor) </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code><br>   */
  private native void dispatch_glTessellationFactorAMD1(float factor, long procAddress);

  /** Entry point to C language function: <code> void {@native glTessellationModeAMD}(GLenum mode) </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code><br>   */
  public void glTessellationModeAMD(int mode)  {

    final long __addr_ = _pat._addressof_glTessellationModeAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTessellationModeAMD"));
    }
        dispatch_glTessellationModeAMD1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTessellationModeAMD}(GLenum mode) </code> <br>Part of <code>GL_AMD_vertex_shader_tesselator</code>, <code>GL_AMD_vertex_shader_tessellator</code><br>   */
  private native void dispatch_glTessellationModeAMD1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glBufferParameteriAPPLE</code>   */
  public void glBufferParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glBufferParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferParameteri"));
    }
        dispatch_glBufferParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glBufferParameteriAPPLE</code>   */
  private native void dispatch_glBufferParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glObjectPurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>   */
  public int glObjectPurgeableAPPLE(int objectType, int name, int option)  {

    final long __addr_ = _pat._addressof_glObjectPurgeableAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPurgeableAPPLE"));
    }
        return dispatch_glObjectPurgeableAPPLE1(objectType, name, option, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glObjectPurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>   */
  private native int dispatch_glObjectPurgeableAPPLE1(int objectType, int name, int option, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glObjectUnpurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>   */
  public int glObjectUnpurgeableAPPLE(int objectType, int name, int option)  {

    final long __addr_ = _pat._addressof_glObjectUnpurgeableAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectUnpurgeableAPPLE"));
    }
        return dispatch_glObjectUnpurgeableAPPLE1(objectType, name, option, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glObjectUnpurgeableAPPLE}(GLenum objectType, GLuint name, GLenum option) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>   */
  private native int dispatch_glObjectUnpurgeableAPPLE1(int objectType, int name, int option, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetObjectParameterivAPPLE(int objectType, int name, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetObjectParameterivAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivAPPLE"));
    }
        dispatch_glGetObjectParameterivAPPLE1(objectType, name, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetObjectParameterivAPPLE1(int objectType, int name, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectParameterivAPPLE}(GLenum objectType, GLuint name, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_APPLE_object_purgeable</code><br>   */
  public void glGetObjectParameterivAPPLE(int objectType, int name, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectParameterivAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectParameterivAPPLE"));
    }
        dispatch_glGetObjectParameterivAPPLE1(objectType, name, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRangeAPPLE}(GLenum target, GLsizei length, const void *  pointer) </code> <br>Part of <code>GL_APPLE_texture_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureRangeAPPLE(int target, int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glTextureRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureRangeAPPLE"));
    }
        dispatch_glTextureRangeAPPLE1(target, length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRangeAPPLE}(GLenum target, GLsizei length, const void *  pointer) </code> <br>Part of <code>GL_APPLE_texture_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureRangeAPPLE1(int target, int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeAPPLE}(GLsizei length, void *  pointer) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexArrayRangeAPPLE(int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glVertexArrayRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayRangeAPPLE"));
    }
        dispatch_glVertexArrayRangeAPPLE1(length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayRangeAPPLE}(GLsizei length, void *  pointer) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexArrayRangeAPPLE1(int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeAPPLE}(GLsizei length, void *  pointer) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glFlushVertexArrayRangeAPPLE(int length, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glFlushVertexArrayRangeAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushVertexArrayRangeAPPLE"));
    }
        dispatch_glFlushVertexArrayRangeAPPLE1(length, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushVertexArrayRangeAPPLE}(GLsizei length, void *  pointer) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glFlushVertexArrayRangeAPPLE1(int length, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayParameteriAPPLE}(GLenum pname, GLint param) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>   */
  public void glVertexArrayParameteriAPPLE(int pname, int param)  {

    final long __addr_ = _pat._addressof_glVertexArrayParameteriAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayParameteriAPPLE"));
    }
        dispatch_glVertexArrayParameteriAPPLE1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayParameteriAPPLE}(GLenum pname, GLint param) </code> <br>Part of <code>GL_APPLE_vertex_array_range</code><br>   */
  private native void dispatch_glVertexArrayParameteriAPPLE1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glEnableVertexAttribAPPLE(int index, int pname)  {

    final long __addr_ = _pat._addressof_glEnableVertexAttribAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribAPPLE"));
    }
        dispatch_glEnableVertexAttribAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  private native void dispatch_glEnableVertexAttribAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glDisableVertexAttribAPPLE(int index, int pname)  {

    final long __addr_ = _pat._addressof_glDisableVertexAttribAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribAPPLE"));
    }
        dispatch_glDisableVertexAttribAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  private native void dispatch_glDisableVertexAttribAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexAttribEnabledAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public boolean glIsVertexAttribEnabledAPPLE(int index, int pname)  {

    final long __addr_ = _pat._addressof_glIsVertexAttribEnabledAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexAttribEnabledAPPLE"));
    }
        return dispatch_glIsVertexAttribEnabledAPPLE1(index, pname, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexAttribEnabledAPPLE}(GLuint index, GLenum pname) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  private native boolean dispatch_glIsVertexAttribEnabledAPPLE1(int index, int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMapVertexAttrib1dAPPLE(int index, int size, double u1, double u2, int stride, int order, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMapVertexAttrib1dAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1dAPPLE"));
    }
        dispatch_glMapVertexAttrib1dAPPLE1(index, size, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMapVertexAttrib1dAPPLE1(int index, int size, double u1, double u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glMapVertexAttrib1dAPPLE(int index, int size, double u1, double u2, int stride, int order, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMapVertexAttrib1dAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1dAPPLE"));
    }
        dispatch_glMapVertexAttrib1dAPPLE1(index, size, u1, u2, stride, order, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapVertexAttrib1fAPPLE(int index, int size, float u1, float u2, int stride, int order, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMapVertexAttrib1fAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1fAPPLE"));
    }
        dispatch_glMapVertexAttrib1fAPPLE1(index, size, u1, u2, stride, order, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapVertexAttrib1fAPPLE1(int index, int size, float u1, float u2, int stride, int order, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib1fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glMapVertexAttrib1fAPPLE(int index, int size, float u1, float u2, int stride, int order, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMapVertexAttrib1fAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib1fAPPLE"));
    }
        dispatch_glMapVertexAttrib1fAPPLE1(index, size, u1, u2, stride, order, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMapVertexAttrib2dAPPLE(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, DoubleBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMapVertexAttrib2dAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2dAPPLE"));
    }
        dispatch_glMapVertexAttrib2dAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMapVertexAttrib2dAPPLE1(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2dAPPLE}(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glMapVertexAttrib2dAPPLE(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMapVertexAttrib2dAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2dAPPLE"));
    }
        dispatch_glMapVertexAttrib2dAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_DOUBLE * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapVertexAttrib2fAPPLE(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, FloatBuffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMapVertexAttrib2fAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2fAPPLE"));
    }
        dispatch_glMapVertexAttrib2fAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapVertexAttrib2fAPPLE1(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapVertexAttrib2fAPPLE}(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *  points) </code> <br>Part of <code>GL_APPLE_vertex_program_evaluators</code><br>   */
  public void glMapVertexAttrib2fAPPLE(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points, int points_offset)  {

    if(points != null && points.length <= points_offset)
      throw new GLException("array offset argument \"points_offset\" (" + points_offset + ") equals or exceeds array length (" + points.length + ")");
    final long __addr_ = _pat._addressof_glMapVertexAttrib2fAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapVertexAttrib2fAPPLE"));
    }
        dispatch_glMapVertexAttrib2fAPPLE1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points, Buffers.SIZEOF_FLOAT * points_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ATI_draw_buffers</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffersATI(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = _pat._addressof_glDrawBuffersATI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersATI"));
    }
        dispatch_glDrawBuffersATI1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ATI_draw_buffers</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffersATI1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersATI}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ATI_draw_buffers</code><br>   */
  public void glDrawBuffersATI(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = _pat._addressof_glDrawBuffersATI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersATI"));
    }
        dispatch_glDrawBuffersATI1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPNTrianglesiATI}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ATI_pn_triangles</code><br>   */
  public void glPNTrianglesiATI(int pname, int param)  {

    final long __addr_ = _pat._addressof_glPNTrianglesiATI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPNTrianglesiATI"));
    }
        dispatch_glPNTrianglesiATI1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPNTrianglesiATI}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ATI_pn_triangles</code><br>   */
  private native void dispatch_glPNTrianglesiATI1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPNTrianglesfATI}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ATI_pn_triangles</code><br>   */
  public void glPNTrianglesfATI(int pname, float param)  {

    final long __addr_ = _pat._addressof_glPNTrianglesfATI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPNTrianglesfATI"));
    }
        dispatch_glPNTrianglesfATI1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPNTrianglesfATI}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ATI_pn_triangles</code><br>   */
  private native void dispatch_glPNTrianglesfATI1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformBufferEXT}(GLuint program, GLint location, GLuint buffer) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  public void glUniformBufferEXT(int program, int location, int buffer)  {

    final long __addr_ = _pat._addressof_glUniformBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformBufferEXT"));
    }
        dispatch_glUniformBufferEXT1(program, location, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBufferEXT}(GLuint program, GLint location, GLuint buffer) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  private native void dispatch_glUniformBufferEXT1(int program, int location, int buffer, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetUniformBufferSizeEXT}(GLuint program, GLint location) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  public int glGetUniformBufferSizeEXT(int program, int location)  {

    final long __addr_ = _pat._addressof_glGetUniformBufferSizeEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBufferSizeEXT"));
    }
        return dispatch_glGetUniformBufferSizeEXT1(program, location, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformBufferSizeEXT}(GLuint program, GLint location) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  private native int dispatch_glGetUniformBufferSizeEXT1(int program, int location, long procAddress);

  /** Entry point to C language function: <code> GLintptr {@native glGetUniformOffsetEXT}(GLuint program, GLint location) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  public long glGetUniformOffsetEXT(int program, int location)  {

    final long __addr_ = _pat._addressof_glGetUniformOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformOffsetEXT"));
    }
        return dispatch_glGetUniformOffsetEXT1(program, location, __addr_);
  }

  /** Entry point to C language function: <code> GLintptr {@native glGetUniformOffsetEXT}(GLuint program, GLint location) </code> <br>Part of <code>GL_EXT_bindable_uniform</code><br>   */
  private native long dispatch_glGetUniformOffsetEXT1(int program, int location, long procAddress);

  /** Entry point to C language function: <code> void {@native glLockArraysEXT}(GLint first, GLsizei count) </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code><br>   */
  public void glLockArraysEXT(int first, int count)  {

    final long __addr_ = _pat._addressof_glLockArraysEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLockArraysEXT"));
    }
        dispatch_glLockArraysEXT1(first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLockArraysEXT}(GLint first, GLsizei count) </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code><br>   */
  private native void dispatch_glLockArraysEXT1(int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glUnlockArraysEXT}(void) </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code><br>   */
  public void glUnlockArraysEXT()  {

    final long __addr_ = _pat._addressof_glUnlockArraysEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnlockArraysEXT"));
    }
        dispatch_glUnlockArraysEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glUnlockArraysEXT}(void) </code> <br>Part of <code>GL_EXT_compiled_vertex_array</code><br>   */
  private native void dispatch_glUnlockArraysEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glCullParameterdvEXT(int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glCullParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullParameterdvEXT"));
    }
        dispatch_glCullParameterdvEXT1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glCullParameterdvEXT1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterdvEXT}(GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>   */
  public void glCullParameterdvEXT(int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glCullParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullParameterdvEXT"));
    }
        dispatch_glCullParameterdvEXT1(pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glCullParameterfvEXT(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glCullParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullParameterfvEXT"));
    }
        dispatch_glCullParameterfvEXT1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glCullParameterfvEXT1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullParameterfvEXT}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_cull_vertex</code><br>   */
  public void glCullParameterfvEXT(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glCullParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullParameterfvEXT"));
    }
        dispatch_glCullParameterfvEXT1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthBoundsEXT}(GLclampd zmin, GLclampd zmax) </code> <br>Part of <code>GL_EXT_depth_bounds_test</code><br>   */
  public void glDepthBoundsEXT(double zmin, double zmax)  {

    final long __addr_ = _pat._addressof_glDepthBoundsEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthBoundsEXT"));
    }
        dispatch_glDepthBoundsEXT1(zmin, zmax, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthBoundsEXT}(GLclampd zmin, GLclampd zmax) </code> <br>Part of <code>GL_EXT_depth_bounds_test</code><br>   */
  private native void dispatch_glDepthBoundsEXT1(double zmin, double zmax, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixLoadfEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixLoadfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadfEXT"));
    }
        dispatch_glMatrixLoadfEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixLoadfEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixLoadfEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixLoadfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadfEXT"));
    }
        dispatch_glMatrixLoadfEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixLoaddEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixLoaddEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoaddEXT"));
    }
        dispatch_glMatrixLoaddEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixLoaddEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoaddEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixLoaddEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixLoaddEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoaddEXT"));
    }
        dispatch_glMatrixLoaddEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixMultfEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixMultfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultfEXT"));
    }
        dispatch_glMatrixMultfEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixMultfEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultfEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixMultfEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixMultfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultfEXT"));
    }
        dispatch_glMatrixMultfEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixMultdEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixMultdEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultdEXT"));
    }
        dispatch_glMatrixMultdEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixMultdEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultdEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixMultdEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixMultdEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultdEXT"));
    }
        dispatch_glMatrixMultdEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadIdentityEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixLoadIdentityEXT(int mode)  {

    final long __addr_ = _pat._addressof_glMatrixLoadIdentityEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadIdentityEXT"));
    }
        dispatch_glMatrixLoadIdentityEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadIdentityEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixLoadIdentityEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixRotatefEXT}(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixRotatefEXT(int mode, float angle, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glMatrixRotatefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixRotatefEXT"));
    }
        dispatch_glMatrixRotatefEXT1(mode, angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixRotatefEXT}(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixRotatefEXT1(int mode, float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixRotatedEXT}(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixRotatedEXT(int mode, double angle, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glMatrixRotatedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixRotatedEXT"));
    }
        dispatch_glMatrixRotatedEXT1(mode, angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixRotatedEXT}(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixRotatedEXT1(int mode, double angle, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixScalefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixScalefEXT(int mode, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glMatrixScalefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixScalefEXT"));
    }
        dispatch_glMatrixScalefEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixScalefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixScalefEXT1(int mode, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixScaledEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixScaledEXT(int mode, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glMatrixScaledEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixScaledEXT"));
    }
        dispatch_glMatrixScaledEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixScaledEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixScaledEXT1(int mode, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixTranslatefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixTranslatefEXT(int mode, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glMatrixTranslatefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixTranslatefEXT"));
    }
        dispatch_glMatrixTranslatefEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixTranslatefEXT}(GLenum mode, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixTranslatefEXT1(int mode, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixTranslatedEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixTranslatedEXT(int mode, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glMatrixTranslatedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixTranslatedEXT"));
    }
        dispatch_glMatrixTranslatedEXT1(mode, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixTranslatedEXT}(GLenum mode, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixTranslatedEXT1(int mode, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixFrustumEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixFrustumEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar)  {

    final long __addr_ = _pat._addressof_glMatrixFrustumEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixFrustumEXT"));
    }
        dispatch_glMatrixFrustumEXT1(mode, left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixFrustumEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixFrustumEXT1(int mode, double left, double right, double bottom, double top, double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixOrthoEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixOrthoEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar)  {

    final long __addr_ = _pat._addressof_glMatrixOrthoEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixOrthoEXT"));
    }
        dispatch_glMatrixOrthoEXT1(mode, left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixOrthoEXT}(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixOrthoEXT1(int mode, double left, double right, double bottom, double top, double zNear, double zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixPopEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixPopEXT(int mode)  {

    final long __addr_ = _pat._addressof_glMatrixPopEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixPopEXT"));
    }
        dispatch_glMatrixPopEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixPopEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixPopEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixPushEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixPushEXT(int mode)  {

    final long __addr_ = _pat._addressof_glMatrixPushEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixPushEXT"));
    }
        dispatch_glMatrixPushEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixPushEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMatrixPushEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientAttribDefaultEXT}(GLbitfield mask) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glClientAttribDefaultEXT(int mask)  {

    final long __addr_ = _pat._addressof_glClientAttribDefaultEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientAttribDefaultEXT"));
    }
        dispatch_glClientAttribDefaultEXT1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientAttribDefaultEXT}(GLbitfield mask) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glClientAttribDefaultEXT1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushClientAttribDefaultEXT}(GLbitfield mask) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glPushClientAttribDefaultEXT(int mask)  {

    final long __addr_ = _pat._addressof_glPushClientAttribDefaultEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushClientAttribDefaultEXT"));
    }
        dispatch_glPushClientAttribDefaultEXT1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushClientAttribDefaultEXT}(GLbitfield mask) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glPushClientAttribDefaultEXT1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameterfEXT(int texture, int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTextureParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfEXT"));
    }
        dispatch_glTextureParameterfEXT1(texture, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureParameterfEXT1(int texture, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTextureParameterfvEXT(int texture, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfvEXT"));
    }
        dispatch_glTextureParameterfvEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTextureParameterfvEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameterfvEXT(int texture, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterfvEXT"));
    }
        dispatch_glTextureParameterfvEXT1(texture, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriEXT}(GLuint texture, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameteriEXT(int texture, int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTextureParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameteriEXT"));
    }
        dispatch_glTextureParameteriEXT1(texture, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameteriEXT}(GLuint texture, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureParameteriEXT1(int texture, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterivEXT"));
    }
        dispatch_glTextureParameterivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameterivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterivEXT"));
    }
        dispatch_glTextureParameterivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage1DEXT(int texture, int target, int level, int internalformat, int width, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage1DEXT"));
    }
        dispatch_glTextureImage1DEXT1(texture, target, level, internalformat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage1DEXT1(int texture, int target, int level, int internalformat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureImage1DEXT(int texture, int target, int level, int internalformat, int width, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage1DEXT"));
    }
        dispatch_glTextureImage1DEXT1(texture, target, level, internalformat, width, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureImage1DEXT1(int texture, int target, int level, int internalformat, int width, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage2DEXT(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DEXT"));
    }
        dispatch_glTextureImage2DEXT1(texture, target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage2DEXT1(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureImage2DEXT(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DEXT"));
    }
        dispatch_glTextureImage2DEXT1(texture, target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureImage2DEXT1(int texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, 1  , 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1DEXT"));
    }
        dispatch_glTextureSubImage1DEXT1(texture, target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage1DEXT"));
    }
        dispatch_glTextureSubImage1DEXT1(texture, target, level, xoffset, width, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int width, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2DEXT"));
    }
        dispatch_glTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage2DEXT"));
    }
        dispatch_glTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyTextureImage1DEXT(int texture, int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = _pat._addressof_glCopyTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureImage1DEXT"));
    }
        dispatch_glCopyTextureImage1DEXT1(texture, target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyTextureImage1DEXT1(int texture, int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyTextureImage2DEXT(int texture, int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = _pat._addressof_glCopyTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureImage2DEXT"));
    }
        dispatch_glCopyTextureImage2DEXT1(texture, target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyTextureImage2DEXT1(int texture, int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage1DEXT"));
    }
        dispatch_glCopyTextureSubImage1DEXT1(texture, target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage2DEXT"));
    }
        dispatch_glCopyTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureImageEXT}(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetTextureImageEXT(int texture, int target, int level, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetTextureImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureImageEXT"));
    }
        dispatch_glGetTextureImageEXT1(texture, target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureImageEXT}(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetTextureImageEXT1(int texture, int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureParameterfvEXT(int texture, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfvEXT"));
    }
        dispatch_glGetTextureParameterfvEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureParameterfvEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterfvEXT}(GLuint texture, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureParameterfvEXT(int texture, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterfvEXT"));
    }
        dispatch_glGetTextureParameterfvEXT1(texture, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterivEXT"));
    }
        dispatch_glGetTextureParameterivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureParameterivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterivEXT"));
    }
        dispatch_glGetTextureParameterivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTextureLevelParameterfvEXT(int texture, int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfvEXT"));
    }
        dispatch_glGetTextureLevelParameterfvEXT1(texture, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTextureLevelParameterfvEXT1(int texture, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterfvEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureLevelParameterfvEXT(int texture, int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterfvEXT"));
    }
        dispatch_glGetTextureLevelParameterfvEXT1(texture, target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureLevelParameterivEXT(int texture, int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterivEXT"));
    }
        dispatch_glGetTextureLevelParameterivEXT1(texture, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureLevelParameterivEXT1(int texture, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureLevelParameterivEXT}(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureLevelParameterivEXT(int texture, int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureLevelParameterivEXT"));
    }
        dispatch_glGetTextureLevelParameterivEXT1(texture, target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureImage3DEXT(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DEXT"));
    }
        dispatch_glTextureImage3DEXT1(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureImage3DEXT1(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureImage3DEXT(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DEXT"));
    }
        dispatch_glTextureImage3DEXT1(texture, target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureImage3DEXT1(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3DEXT"));
    }
        dispatch_glTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureSubImage3DEXT"));
    }
        dispatch_glTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureSubImage3DEXT"));
    }
        dispatch_glCopyTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindMultiTextureEXT}(GLenum texunit, GLenum target, GLuint texture) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glBindMultiTextureEXT(int texunit, int target, int texture)  {

    final long __addr_ = _pat._addressof_glBindMultiTextureEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindMultiTextureEXT"));
    }
        dispatch_glBindMultiTextureEXT1(texunit, target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindMultiTextureEXT}(GLenum texunit, GLenum target, GLuint texture) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glBindMultiTextureEXT1(int texunit, int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoordPointerEXT}(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glMultiTexCoordPointerEXT(int texunit, int size, int type, int stride, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glMultiTexCoordPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoordPointerEXT"));
    }
        dispatch_glMultiTexCoordPointerEXT0(texunit, size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoordPointerEXT}(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexCoordPointerEXT0(int texunit, int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexEnvfEXT(int texunit, int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glMultiTexEnvfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfEXT"));
    }
        dispatch_glMultiTexEnvfEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexEnvfEXT1(int texunit, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexEnvfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfvEXT"));
    }
        dispatch_glMultiTexEnvfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexEnvfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexEnvfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvfvEXT"));
    }
        dispatch_glMultiTexEnvfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnviEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexEnviEXT(int texunit, int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glMultiTexEnviEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnviEXT"));
    }
        dispatch_glMultiTexEnviEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnviEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexEnviEXT1(int texunit, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexEnvivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvivEXT"));
    }
        dispatch_glMultiTexEnvivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexEnvivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexEnvivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexEnvivEXT"));
    }
        dispatch_glMultiTexEnvivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGendEXT(int texunit, int coord, int pname, double param)  {

    final long __addr_ = _pat._addressof_glMultiTexGendEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendEXT"));
    }
        dispatch_glMultiTexGendEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexGendEXT1(int texunit, int coord, int pname, double param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMultiTexGendvEXT(int texunit, int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendvEXT"));
    }
        dispatch_glMultiTexGendvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMultiTexGendvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGendvEXT(int texunit, int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGendvEXT"));
    }
        dispatch_glMultiTexGendvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGenfEXT(int texunit, int coord, int pname, float param)  {

    final long __addr_ = _pat._addressof_glMultiTexGenfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfEXT"));
    }
        dispatch_glMultiTexGenfEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexGenfEXT1(int texunit, int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexGenfvEXT(int texunit, int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfvEXT"));
    }
        dispatch_glMultiTexGenfvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexGenfvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGenfvEXT(int texunit, int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenfvEXT"));
    }
        dispatch_glMultiTexGenfvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGeniEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGeniEXT(int texunit, int coord, int pname, int param)  {

    final long __addr_ = _pat._addressof_glMultiTexGeniEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGeniEXT"));
    }
        dispatch_glMultiTexGeniEXT1(texunit, coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGeniEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexGeniEXT1(int texunit, int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexGenivEXT(int texunit, int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenivEXT"));
    }
        dispatch_glMultiTexGenivEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexGenivEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexGenivEXT(int texunit, int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexGenivEXT"));
    }
        dispatch_glMultiTexGenivEXT1(texunit, coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvfvEXT"));
    }
        dispatch_glGetMultiTexEnvfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexEnvfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexEnvfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvfvEXT"));
    }
        dispatch_glGetMultiTexEnvfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexEnvivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvivEXT"));
    }
        dispatch_glGetMultiTexEnvivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexEnvivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexEnvivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexEnvivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexEnvivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexEnvivEXT"));
    }
        dispatch_glGetMultiTexEnvivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetMultiTexGendvEXT(int texunit, int coord, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGendvEXT"));
    }
        dispatch_glGetMultiTexGendvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetMultiTexGendvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGendvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexGendvEXT(int texunit, int coord, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexGendvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGendvEXT"));
    }
        dispatch_glGetMultiTexGendvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenfvEXT"));
    }
        dispatch_glGetMultiTexGenfvEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexGenfvEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenfvEXT}(GLenum texunit, GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexGenfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenfvEXT"));
    }
        dispatch_glGetMultiTexGenfvEXT1(texunit, coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexGenivEXT(int texunit, int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenivEXT"));
    }
        dispatch_glGetMultiTexGenivEXT1(texunit, coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexGenivEXT1(int texunit, int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexGenivEXT}(GLenum texunit, GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexGenivEXT(int texunit, int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexGenivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexGenivEXT"));
    }
        dispatch_glGetMultiTexGenivEXT1(texunit, coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameteriEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameteriEXT(int texunit, int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glMultiTexParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameteriEXT"));
    }
        dispatch_glMultiTexParameteriEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameteriEXT}(GLenum texunit, GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexParameteriEXT1(int texunit, int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterivEXT"));
    }
        dispatch_glMultiTexParameterivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameterivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterivEXT"));
    }
        dispatch_glMultiTexParameterivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameterfEXT(int texunit, int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glMultiTexParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfEXT"));
    }
        dispatch_glMultiTexParameterfEXT1(texunit, target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexParameterfEXT1(int texunit, int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultiTexParameterfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfvEXT"));
    }
        dispatch_glMultiTexParameterfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultiTexParameterfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameterfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterfvEXT"));
    }
        dispatch_glMultiTexParameterfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage1DEXT"));
    }
        dispatch_glMultiTexImage1DEXT1(texunit, target, level, internalformat, width, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage2DEXT"));
    }
        dispatch_glMultiTexImage2DEXT1(texunit, target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage1DEXT"));
    }
        dispatch_glMultiTexSubImage1DEXT1(texunit, target, level, xoffset, width, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int width, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage2DEXT"));
    }
        dispatch_glMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int border)  {

    final long __addr_ = _pat._addressof_glCopyMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexImage1DEXT"));
    }
        dispatch_glCopyMultiTexImage1DEXT1(texunit, target, level, internalformat, x, y, width, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int x, int y, int width, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = _pat._addressof_glCopyMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexImage2DEXT"));
    }
        dispatch_glCopyMultiTexImage2DEXT1(texunit, target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int x, int y, int width)  {

    final long __addr_ = _pat._addressof_glCopyMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage1DEXT"));
    }
        dispatch_glCopyMultiTexSubImage1DEXT1(texunit, target, level, xoffset, x, y, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int x, int y, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage2DEXT"));
    }
        dispatch_glCopyMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexImageEXT}(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMultiTexImageEXT(int texunit, int target, int level, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glGetMultiTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexImageEXT"));
    }
        dispatch_glGetMultiTexImageEXT1(texunit, target, level, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexImageEXT}(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMultiTexImageEXT1(int texunit, int target, int level, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterfvEXT"));
    }
        dispatch_glGetMultiTexParameterfvEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexParameterfvEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterfvEXT}(GLenum texunit, GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterfvEXT"));
    }
        dispatch_glGetMultiTexParameterfvEXT1(texunit, target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterivEXT"));
    }
        dispatch_glGetMultiTexParameterivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexParameterivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterivEXT"));
    }
        dispatch_glGetMultiTexParameterivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterfvEXT"));
    }
        dispatch_glGetMultiTexLevelParameterfvEXT1(texunit, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultiTexLevelParameterfvEXT1(int texunit, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterfvEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexLevelParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterfvEXT"));
    }
        dispatch_glGetMultiTexLevelParameterfvEXT1(texunit, target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterivEXT"));
    }
        dispatch_glGetMultiTexLevelParameterivEXT1(texunit, target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexLevelParameterivEXT1(int texunit, int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexLevelParameterivEXT}(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexLevelParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexLevelParameterivEXT"));
    }
        dispatch_glGetMultiTexLevelParameterivEXT1(texunit, target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexImage3DEXT"));
    }
        dispatch_glMultiTexImage3DEXT1(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexImage3DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexSubImage3DEXT"));
    }
        dispatch_glMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glCopyMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyMultiTexSubImage3DEXT"));
    }
        dispatch_glCopyMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glCopyMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientStateIndexedEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glEnableClientStateIndexedEXT(int array, int index)  {

    final long __addr_ = _pat._addressof_glEnableClientStateIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableClientStateIndexedEXT"));
    }
        dispatch_glEnableClientStateIndexedEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientStateIndexedEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glEnableClientStateIndexedEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientStateIndexedEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glDisableClientStateIndexedEXT(int array, int index)  {

    final long __addr_ = _pat._addressof_glDisableClientStateIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableClientStateIndexedEXT"));
    }
        dispatch_glDisableClientStateIndexedEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientStateIndexedEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glDisableClientStateIndexedEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatIndexedvEXT(int target, int index, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetFloatIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatIndexedvEXT"));
    }
        dispatch_glGetFloatIndexedvEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatIndexedvEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatIndexedvEXT}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetFloatIndexedvEXT(int target, int index, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetFloatIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatIndexedvEXT"));
    }
        dispatch_glGetFloatIndexedvEXT1(target, index, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoubleIndexedvEXT(int target, int index, DoubleBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetDoubleIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoubleIndexedvEXT"));
    }
        dispatch_glGetDoubleIndexedvEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoubleIndexedvEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoubleIndexedvEXT}(GLenum target, GLuint index, GLdouble *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetDoubleIndexedvEXT(int target, int index, double[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetDoubleIndexedvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoubleIndexedvEXT"));
    }
        dispatch_glGetDoubleIndexedvEXT1(target, index, data, Buffers.SIZEOF_DOUBLE * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glEnableIndexedEXT</code>   */
  public void glEnableIndexed(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnableIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableIndexed"));
    }
        dispatch_glEnableIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glEnableIndexedEXT</code>   */
  private native void dispatch_glEnableIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glDisableIndexedEXT</code>   */
  public void glDisableIndexed(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisableIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableIndexed"));
    }
        dispatch_glDisableIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glDisableIndexedEXT</code>   */
  private native void dispatch_glDisableIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glIsEnabledIndexedEXT</code>   */
  public boolean glIsEnabledIndexed(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnabledIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabledIndexed"));
    }
        return dispatch_glIsEnabledIndexed1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledIndexed}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glIsEnabledIndexedEXT</code>   */
  private native boolean dispatch_glIsEnabledIndexed1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedv}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetIntegerIndexedvEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerIndexedv(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetIntegerIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerIndexedv"));
    }
        dispatch_glGetIntegerIndexedv1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedv}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetIntegerIndexedvEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerIndexedv1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerIndexedv}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetIntegerIndexedvEXT</code>   */
  public void glGetIntegerIndexedv(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerIndexedv"));
    }
        dispatch_glGetIntegerIndexedv1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedv}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetBooleanIndexedvEXT</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanIndexedv(int target, int index, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetBooleanIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanIndexedv"));
    }
        dispatch_glGetBooleanIndexedv1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedv}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetBooleanIndexedvEXT</code>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanIndexedv1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanIndexedv}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_EXT_draw_buffers2</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetBooleanIndexedvEXT</code>   */
  public void glGetBooleanIndexedv(int target, int index, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleanIndexedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanIndexedv"));
    }
        dispatch_glGetBooleanIndexedv1(target, index, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage3DEXT(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage3DEXT"));
    }
        dispatch_glCompressedTextureImage3DEXT1(texture, target, level, internalformat, width, height, depth, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage3DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage3DEXT1(int texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage2DEXT(int texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage2DEXT"));
    }
        dispatch_glCompressedTextureImage2DEXT1(texture, target, level, internalformat, width, height, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage2DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage2DEXT1(int texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureImage1DEXT(int texture, int target, int level, int internalformat, int width, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureImage1DEXT"));
    }
        dispatch_glCompressedTextureImage1DEXT1(texture, target, level, internalformat, width, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureImage1DEXT}(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureImage1DEXT1(int texture, int target, int level, int internalformat, int width, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage3DEXT(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage3DEXT"));
    }
        dispatch_glCompressedTextureSubImage3DEXT1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage3DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage3DEXT1(int texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage2DEXT(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage2DEXT"));
    }
        dispatch_glCompressedTextureSubImage2DEXT1(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage2DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage2DEXT1(int texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTextureSubImage1DEXT(int texture, int target, int level, int xoffset, int width, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedTextureSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTextureSubImage1DEXT"));
    }
        dispatch_glCompressedTextureSubImage1DEXT1(texture, target, level, xoffset, width, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTextureSubImage1DEXT}(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTextureSubImage1DEXT1(int texture, int target, int level, int xoffset, int width, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImageEXT}(GLuint texture, GLenum target, GLint lod, void *  img) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedTextureImageEXT(int texture, int target, int lod, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = _pat._addressof_glGetCompressedTextureImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedTextureImageEXT"));
    }
        dispatch_glGetCompressedTextureImageEXT1(texture, target, lod, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedTextureImageEXT}(GLuint texture, GLenum target, GLint lod, void *  img) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedTextureImageEXT1(int texture, int target, int lod, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage3DEXT"));
    }
        dispatch_glCompressedMultiTexImage3DEXT1(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage3DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage2DEXT"));
    }
        dispatch_glCompressedMultiTexImage2DEXT1(texunit, target, level, internalformat, width, height, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage2DEXT1(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexImage1DEXT"));
    }
        dispatch_glCompressedMultiTexImage1DEXT1(texunit, target, level, internalformat, width, border, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexImage1DEXT1(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexSubImage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage3DEXT"));
    }
        dispatch_glCompressedMultiTexSubImage3DEXT1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage3DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage3DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexSubImage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage2DEXT"));
    }
        dispatch_glCompressedMultiTexSubImage2DEXT1(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage2DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage2DEXT1(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, Buffer bits)  {

    final boolean bits_is_direct = Buffers.isDirect(bits);
    final long __addr_ = _pat._addressof_glCompressedMultiTexSubImage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedMultiTexSubImage1DEXT"));
    }
        dispatch_glCompressedMultiTexSubImage1DEXT1(texunit, target, level, xoffset, width, format, imageSize, bits_is_direct ? bits : Buffers.getArray(bits), bits_is_direct ? Buffers.getDirectBufferByteOffset(bits) : Buffers.getIndirectBufferByteOffset(bits), bits_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedMultiTexSubImage1DEXT}(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *  bits) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bits a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedMultiTexSubImage1DEXT1(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, Object bits, int bits_byte_offset, boolean bits_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCompressedMultiTexImageEXT}(GLenum texunit, GLenum target, GLint lod, void *  img) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetCompressedMultiTexImageEXT(int texunit, int target, int lod, Buffer img)  {

    final boolean img_is_direct = Buffers.isDirect(img);
    final long __addr_ = _pat._addressof_glGetCompressedMultiTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCompressedMultiTexImageEXT"));
    }
        dispatch_glGetCompressedMultiTexImageEXT1(texunit, target, lod, img_is_direct ? img : Buffers.getArray(img), img_is_direct ? Buffers.getDirectBufferByteOffset(img) : Buffers.getIndirectBufferByteOffset(img), img_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCompressedMultiTexImageEXT}(GLenum texunit, GLenum target, GLint lod, void *  img) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param img a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetCompressedMultiTexImageEXT1(int texunit, int target, int lod, Object img, int img_byte_offset, boolean img_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixLoadTransposefEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixLoadTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposefEXT"));
    }
        dispatch_glMatrixLoadTransposefEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixLoadTransposefEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixLoadTransposefEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixLoadTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposefEXT"));
    }
        dispatch_glMatrixLoadTransposefEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixLoadTransposedEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixLoadTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposedEXT"));
    }
        dispatch_glMatrixLoadTransposedEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixLoadTransposedEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixLoadTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixLoadTransposedEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixLoadTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixLoadTransposedEXT"));
    }
        dispatch_glMatrixLoadTransposedEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMatrixMultTransposefEXT(int mode, FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixMultTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposefEXT"));
    }
        dispatch_glMatrixMultTransposefEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMatrixMultTransposefEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposefEXT}(GLenum mode, const GLfloat *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixMultTransposefEXT(int mode, float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixMultTransposefEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposefEXT"));
    }
        dispatch_glMatrixMultTransposefEXT1(mode, m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glMatrixMultTransposedEXT(int mode, DoubleBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMatrixMultTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposedEXT"));
    }
        dispatch_glMatrixMultTransposedEXT1(mode, m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param m a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glMatrixMultTransposedEXT1(int mode, Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixMultTransposedEXT}(GLenum mode, const GLdouble *  m) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMatrixMultTransposedEXT(int mode, double[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMatrixMultTransposedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMultTransposedEXT"));
    }
        dispatch_glMatrixMultTransposedEXT1(mode, m, Buffers.SIZEOF_DOUBLE * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferDataEXT}(GLuint buffer, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glNamedBufferDataEXTDelegate(int buffer, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferDataEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferDataEXT"));
    }
        dispatch_glNamedBufferDataEXTDelegate1(buffer, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferDataEXT}(GLuint buffer, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glNamedBufferDataEXTDelegate1(int buffer, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedBufferSubDataEXT(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferSubDataEXT"));
    }
        dispatch_glNamedBufferSubDataEXT1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedBufferSubDataEXT1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferEXT}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private long glMapNamedBufferEXTDelegate(int buffer, int access)  {

    final long __addr_ = _pat._addressof_glMapNamedBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferEXT"));
    }
        return dispatch_glMapNamedBufferEXTDelegate1(buffer, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferEXT}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private native long dispatch_glMapNamedBufferEXTDelegate1(int buffer, int access, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBufferEXT}(GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public boolean glUnmapNamedBufferEXT(int buffer)  {

    final long __addr_ = _pat._addressof_glUnmapNamedBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapNamedBufferEXT"));
    }
        return dispatch_glUnmapNamedBufferEXT1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapNamedBufferEXT}(GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native boolean dispatch_glUnmapNamedBufferEXT1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedBufferParameterivEXT(int buffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedBufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterivEXT"));
    }
        dispatch_glGetNamedBufferParameterivEXT1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedBufferParameterivEXT1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterivEXT}(GLuint buffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedBufferParameterivEXT(int buffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedBufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterivEXT"));
    }
        dispatch_glGetNamedBufferParameterivEXT1(buffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetNamedBufferSubDataEXT(int buffer, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetNamedBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferSubDataEXT"));
    }
        dispatch_glGetNamedBufferSubDataEXT1(buffer, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferSubDataEXT}(GLuint buffer, GLintptr offset, GLsizeiptr size, void *  data) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetNamedBufferSubDataEXT1(int buffer, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureBufferEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureBufferEXT(int texture, int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTextureBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferEXT"));
    }
        dispatch_glTextureBufferEXT1(texture, target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBufferEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureBufferEXT1(int texture, int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexBufferEXT}(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexBufferEXT(int texunit, int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glMultiTexBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexBufferEXT"));
    }
        dispatch_glMultiTexBufferEXT1(texunit, target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexBufferEXT}(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexBufferEXT1(int texunit, int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIivEXT"));
    }
        dispatch_glTextureParameterIivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameterIivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIivEXT"));
    }
        dispatch_glTextureParameterIivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTextureParameterIuivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuivEXT"));
    }
        dispatch_glTextureParameterIuivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTextureParameterIuivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureParameterIuivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureParameterIuivEXT"));
    }
        dispatch_glTextureParameterIuivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIivEXT"));
    }
        dispatch_glGetTextureParameterIivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIivEXT}(GLuint texture, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureParameterIivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIivEXT"));
    }
        dispatch_glGetTextureParameterIivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTextureParameterIuivEXT(int texture, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuivEXT"));
    }
        dispatch_glGetTextureParameterIuivEXT1(texture, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTextureParameterIuivEXT1(int texture, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTextureParameterIuivEXT}(GLuint texture, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetTextureParameterIuivEXT(int texture, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTextureParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTextureParameterIuivEXT"));
    }
        dispatch_glGetTextureParameterIuivEXT1(texture, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterIivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIivEXT"));
    }
        dispatch_glMultiTexParameterIivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterIivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameterIivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIivEXT"));
    }
        dispatch_glMultiTexParameterIivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiTexParameterIuivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIuivEXT"));
    }
        dispatch_glMultiTexParameterIuivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiTexParameterIuivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexParameterIuivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexParameterIuivEXT"));
    }
        dispatch_glMultiTexParameterIuivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIivEXT"));
    }
        dispatch_glGetMultiTexParameterIivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterIivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIivEXT}(GLenum texunit, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIivEXT"));
    }
        dispatch_glGetMultiTexParameterIivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIuivEXT"));
    }
        dispatch_glGetMultiTexParameterIuivEXT1(texunit, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMultiTexParameterIuivEXT1(int texunit, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultiTexParameterIuivEXT}(GLenum texunit, GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMultiTexParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultiTexParameterIuivEXT"));
    }
        dispatch_glGetMultiTexParameterIuivEXT1(texunit, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedProgramLocalParameters4fvEXT(int program, int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameters4fvEXT"));
    }
        dispatch_glNamedProgramLocalParameters4fvEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedProgramLocalParameters4fvEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameters4fvEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameters4fvEXT(int program, int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameters4fvEXT"));
    }
        dispatch_glNamedProgramLocalParameters4fvEXT1(program, target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4iEXT}(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameterI4iEXT(int program, int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4iEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4iEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4iEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4iEXT}(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedProgramLocalParameterI4iEXT1(int program, int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParameterI4ivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4ivEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4ivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParameterI4ivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4ivEXT}(GLuint program, GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameterI4ivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4ivEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4ivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParametersI4ivEXT(int program, int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParametersI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4ivEXT"));
    }
        dispatch_glNamedProgramLocalParametersI4ivEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParametersI4ivEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4ivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParametersI4ivEXT(int program, int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParametersI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4ivEXT"));
    }
        dispatch_glNamedProgramLocalParametersI4ivEXT1(program, target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uiEXT}(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameterI4uiEXT(int program, int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4uiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uiEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4uiEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uiEXT}(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedProgramLocalParameterI4uiEXT1(int program, int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParameterI4uivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uivEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4uivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParameterI4uivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameterI4uivEXT}(GLuint program, GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameterI4uivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameterI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameterI4uivEXT"));
    }
        dispatch_glNamedProgramLocalParameterI4uivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glNamedProgramLocalParametersI4uivEXT(int program, int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParametersI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4uivEXT"));
    }
        dispatch_glNamedProgramLocalParametersI4uivEXT1(program, target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glNamedProgramLocalParametersI4uivEXT1(int program, int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParametersI4uivEXT}(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParametersI4uivEXT(int program, int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParametersI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParametersI4uivEXT"));
    }
        dispatch_glNamedProgramLocalParametersI4uivEXT1(program, target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramLocalParameterIivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIivEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterIivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterIivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIivEXT}(GLuint program, GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedProgramLocalParameterIivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIivEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterIivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramLocalParameterIuivEXT(int program, int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIuivEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterIuivEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterIuivEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterIuivEXT}(GLuint program, GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedProgramLocalParameterIuivEXT(int program, int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterIuivEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterIuivEXT1(program, target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientStateiEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glEnableClientStateiEXT(int array, int index)  {

    final long __addr_ = _pat._addressof_glEnableClientStateiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableClientStateiEXT"));
    }
        dispatch_glEnableClientStateiEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientStateiEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glEnableClientStateiEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientStateiEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glDisableClientStateiEXT(int array, int index)  {

    final long __addr_ = _pat._addressof_glDisableClientStateiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableClientStateiEXT"));
    }
        dispatch_glDisableClientStateiEXT1(array, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientStateiEXT}(GLenum array, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glDisableClientStateiEXT1(int array, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_vEXT}(GLenum pname, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloati_vEXT(int pname, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFloati_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vEXT"));
    }
        dispatch_glGetFloati_vEXT1(pname, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloati_vEXT}(GLenum pname, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloati_vEXT1(int pname, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_vEXT}(GLenum pname, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetFloati_vEXT(int pname, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFloati_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vEXT"));
    }
        dispatch_glGetFloati_vEXT1(pname, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_vEXT}(GLenum pname, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetDoublei_vEXT(int pname, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetDoublei_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_vEXT"));
    }
        dispatch_glGetDoublei_vEXT1(pname, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDoublei_vEXT}(GLenum pname, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetDoublei_vEXT1(int pname, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDoublei_vEXT}(GLenum pname, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetDoublei_vEXT(int pname, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetDoublei_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDoublei_vEXT"));
    }
        dispatch_glGetDoublei_vEXT1(pname, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPointeri_vEXT}(GLenum pname, GLuint index, void *  *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetPointeri_vEXT(int pname, int index, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetPointeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPointeri_vEXT"));
    }
        dispatch_glGetPointeri_vEXT1(pname, index, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPointeri_vEXT}(GLenum pname, GLuint index, void *  *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetPointeri_vEXT1(int pname, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramStringEXT}(GLuint program, GLenum target, GLenum format, GLsizei len, const void *  string) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glNamedProgramStringEXT(int program, int target, int format, int len, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = _pat._addressof_glNamedProgramStringEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramStringEXT"));
    }
        dispatch_glNamedProgramStringEXT1(program, target, format, len, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramStringEXT}(GLuint program, GLenum target, GLenum format, GLsizei len, const void *  string) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glNamedProgramStringEXT1(int program, int target, int format, int len, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dEXT}(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameter4dEXT(int program, int target, int index, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4dEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dEXT"));
    }
        dispatch_glNamedProgramLocalParameter4dEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dEXT}(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedProgramLocalParameter4dEXT1(int program, int target, int index, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glNamedProgramLocalParameter4dvEXT(int program, int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dvEXT"));
    }
        dispatch_glNamedProgramLocalParameter4dvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glNamedProgramLocalParameter4dvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4dvEXT}(GLuint program, GLenum target, GLuint index, const GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameter4dvEXT(int program, int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4dvEXT"));
    }
        dispatch_glNamedProgramLocalParameter4dvEXT1(program, target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fEXT}(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameter4fEXT(int program, int target, int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4fEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fEXT"));
    }
        dispatch_glNamedProgramLocalParameter4fEXT1(program, target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fEXT}(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedProgramLocalParameter4fEXT1(int program, int target, int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedProgramLocalParameter4fvEXT(int program, int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fvEXT"));
    }
        dispatch_glNamedProgramLocalParameter4fvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedProgramLocalParameter4fvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedProgramLocalParameter4fvEXT}(GLuint program, GLenum target, GLuint index, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedProgramLocalParameter4fvEXT(int program, int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glNamedProgramLocalParameter4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedProgramLocalParameter4fvEXT"));
    }
        dispatch_glNamedProgramLocalParameter4fvEXT1(program, target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetNamedProgramLocalParameterdvEXT(int program, int target, int index, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterdvEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterdvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterdvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterdvEXT}(GLuint program, GLenum target, GLuint index, GLdouble *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedProgramLocalParameterdvEXT(int program, int target, int index, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterdvEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterdvEXT1(program, target, index, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetNamedProgramLocalParameterfvEXT(int program, int target, int index, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterfvEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterfvEXT1(program, target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetNamedProgramLocalParameterfvEXT1(int program, int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramLocalParameterfvEXT}(GLuint program, GLenum target, GLuint index, GLfloat *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedProgramLocalParameterfvEXT(int program, int target, int index, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedProgramLocalParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramLocalParameterfvEXT"));
    }
        dispatch_glGetNamedProgramLocalParameterfvEXT1(program, target, index, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedProgramivEXT(int program, int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedProgramivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramivEXT"));
    }
        dispatch_glGetNamedProgramivEXT1(program, target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedProgramivEXT1(int program, int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedProgramivEXT}(GLuint program, GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedProgramivEXT(int program, int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedProgramivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramivEXT"));
    }
        dispatch_glGetNamedProgramivEXT1(program, target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramStringEXT}(GLuint program, GLenum target, GLenum pname, void *  string) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetNamedProgramStringEXT(int program, int target, int pname, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = _pat._addressof_glGetNamedProgramStringEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedProgramStringEXT"));
    }
        dispatch_glGetNamedProgramStringEXT1(program, target, pname, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedProgramStringEXT}(GLuint program, GLenum target, GLenum pname, void *  string) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetNamedProgramStringEXT1(int program, int target, int pname, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageEXT}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedRenderbufferStorageEXT(int renderbuffer, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glNamedRenderbufferStorageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageEXT"));
    }
        dispatch_glNamedRenderbufferStorageEXT1(renderbuffer, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageEXT}(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedRenderbufferStorageEXT1(int renderbuffer, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedRenderbufferParameterivEXT(int renderbuffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedRenderbufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameterivEXT"));
    }
        dispatch_glGetNamedRenderbufferParameterivEXT1(renderbuffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedRenderbufferParameterivEXT1(int renderbuffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedRenderbufferParameterivEXT}(GLuint renderbuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedRenderbufferParameterivEXT(int renderbuffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedRenderbufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedRenderbufferParameterivEXT"));
    }
        dispatch_glGetNamedRenderbufferParameterivEXT1(renderbuffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleEXT}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedRenderbufferStorageMultisampleEXT(int renderbuffer, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glNamedRenderbufferStorageMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisampleEXT"));
    }
        dispatch_glNamedRenderbufferStorageMultisampleEXT1(renderbuffer, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleEXT}(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedRenderbufferStorageMultisampleEXT1(int renderbuffer, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleCoverageEXT}(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedRenderbufferStorageMultisampleCoverageEXT(int renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glNamedRenderbufferStorageMultisampleCoverageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedRenderbufferStorageMultisampleCoverageEXT"));
    }
        dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(renderbuffer, coverageSamples, colorSamples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedRenderbufferStorageMultisampleCoverageEXT}(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedRenderbufferStorageMultisampleCoverageEXT1(int renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatusEXT}(GLuint framebuffer, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public int glCheckNamedFramebufferStatusEXT(int framebuffer, int target)  {

    final long __addr_ = _pat._addressof_glCheckNamedFramebufferStatusEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckNamedFramebufferStatusEXT"));
    }
        return dispatch_glCheckNamedFramebufferStatusEXT1(framebuffer, target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckNamedFramebufferStatusEXT}(GLuint framebuffer, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native int dispatch_glCheckNamedFramebufferStatusEXT1(int framebuffer, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture1DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTexture1DEXT(int framebuffer, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTexture1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture1DEXT"));
    }
        dispatch_glNamedFramebufferTexture1DEXT1(framebuffer, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture1DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTexture1DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture2DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTexture2DEXT(int framebuffer, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTexture2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture2DEXT"));
    }
        dispatch_glNamedFramebufferTexture2DEXT1(framebuffer, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture2DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTexture2DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture3DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTexture3DEXT(int framebuffer, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTexture3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTexture3DEXT"));
    }
        dispatch_glNamedFramebufferTexture3DEXT1(framebuffer, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTexture3DEXT}(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTexture3DEXT1(int framebuffer, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbufferEXT}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferRenderbufferEXT(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferRenderbufferEXT"));
    }
        dispatch_glNamedFramebufferRenderbufferEXT1(framebuffer, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferRenderbufferEXT}(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferRenderbufferEXT1(int framebuffer, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNamedFramebufferAttachmentParameterivEXT(int framebuffer, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameterivEXT"));
    }
        dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(framebuffer, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(int framebuffer, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedFramebufferAttachmentParameterivEXT}(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetNamedFramebufferAttachmentParameterivEXT(int framebuffer, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedFramebufferAttachmentParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedFramebufferAttachmentParameterivEXT"));
    }
        dispatch_glGetNamedFramebufferAttachmentParameterivEXT1(framebuffer, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmapEXT}(GLuint texture, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGenerateTextureMipmapEXT(int texture, int target)  {

    final long __addr_ = _pat._addressof_glGenerateTextureMipmapEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateTextureMipmapEXT"));
    }
        dispatch_glGenerateTextureMipmapEXT1(texture, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateTextureMipmapEXT}(GLuint texture, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glGenerateTextureMipmapEXT1(int texture, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenerateMultiTexMipmapEXT}(GLenum texunit, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGenerateMultiTexMipmapEXT(int texunit, int target)  {

    final long __addr_ = _pat._addressof_glGenerateMultiTexMipmapEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateMultiTexMipmapEXT"));
    }
        dispatch_glGenerateMultiTexMipmapEXT1(texunit, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMultiTexMipmapEXT}(GLenum texunit, GLenum target) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glGenerateMultiTexMipmapEXT1(int texunit, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBufferEXT}(GLuint framebuffer, GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glFramebufferDrawBufferEXT(int framebuffer, int mode)  {

    final long __addr_ = _pat._addressof_glFramebufferDrawBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBufferEXT"));
    }
        dispatch_glFramebufferDrawBufferEXT1(framebuffer, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBufferEXT}(GLuint framebuffer, GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glFramebufferDrawBufferEXT1(int framebuffer, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFramebufferDrawBuffersEXT(int framebuffer, int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = _pat._addressof_glFramebufferDrawBuffersEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBuffersEXT"));
    }
        dispatch_glFramebufferDrawBuffersEXT1(framebuffer, n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFramebufferDrawBuffersEXT1(int framebuffer, int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferDrawBuffersEXT}(GLuint framebuffer, GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glFramebufferDrawBuffersEXT(int framebuffer, int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = _pat._addressof_glFramebufferDrawBuffersEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferDrawBuffersEXT"));
    }
        dispatch_glFramebufferDrawBuffersEXT1(framebuffer, n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferReadBufferEXT}(GLuint framebuffer, GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glFramebufferReadBufferEXT(int framebuffer, int mode)  {

    final long __addr_ = _pat._addressof_glFramebufferReadBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferReadBufferEXT"));
    }
        dispatch_glFramebufferReadBufferEXT1(framebuffer, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferReadBufferEXT}(GLuint framebuffer, GLenum mode) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glFramebufferReadBufferEXT1(int framebuffer, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferParameterivEXT(int framebuffer, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameterivEXT"));
    }
        dispatch_glGetFramebufferParameterivEXT1(framebuffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferParameterivEXT1(int framebuffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameterivEXT}(GLuint framebuffer, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetFramebufferParameterivEXT(int framebuffer, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameterivEXT"));
    }
        dispatch_glGetFramebufferParameterivEXT1(framebuffer, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedCopyBufferSubDataEXT}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedCopyBufferSubDataEXT(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _pat._addressof_glNamedCopyBufferSubDataEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedCopyBufferSubDataEXT"));
    }
        dispatch_glNamedCopyBufferSubDataEXT1(readBuffer, writeBuffer, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedCopyBufferSubDataEXT}(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedCopyBufferSubDataEXT1(int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTextureEXT(int framebuffer, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTextureEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureEXT"));
    }
        dispatch_glNamedFramebufferTextureEXT1(framebuffer, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTextureEXT1(int framebuffer, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayerEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTextureLayerEXT(int framebuffer, int attachment, int texture, int level, int layer)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTextureLayerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureLayerEXT"));
    }
        dispatch_glNamedFramebufferTextureLayerEXT1(framebuffer, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureLayerEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTextureLayerEXT1(int framebuffer, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureFaceEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glNamedFramebufferTextureFaceEXT(int framebuffer, int attachment, int texture, int level, int face)  {

    final long __addr_ = _pat._addressof_glNamedFramebufferTextureFaceEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferTextureFaceEXT"));
    }
        dispatch_glNamedFramebufferTextureFaceEXT1(framebuffer, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferTextureFaceEXT}(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glNamedFramebufferTextureFaceEXT1(int framebuffer, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureRenderbufferEXT}(GLuint texture, GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureRenderbufferEXT(int texture, int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glTextureRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureRenderbufferEXT"));
    }
        dispatch_glTextureRenderbufferEXT1(texture, target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureRenderbufferEXT}(GLuint texture, GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureRenderbufferEXT1(int texture, int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexRenderbufferEXT}(GLenum texunit, GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glMultiTexRenderbufferEXT(int texunit, int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glMultiTexRenderbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexRenderbufferEXT"));
    }
        dispatch_glMultiTexRenderbufferEXT1(texunit, target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexRenderbufferEXT}(GLenum texunit, GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glMultiTexRenderbufferEXT1(int texunit, int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayVertexOffsetEXT(int vaobj, int buffer, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexOffsetEXT"));
    }
        dispatch_glVertexArrayVertexOffsetEXT1(vaobj, buffer, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayVertexOffsetEXT1(int vaobj, int buffer, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayColorOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayColorOffsetEXT(int vaobj, int buffer, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayColorOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayColorOffsetEXT"));
    }
        dispatch_glVertexArrayColorOffsetEXT1(vaobj, buffer, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayColorOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayColorOffsetEXT1(int vaobj, int buffer, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayEdgeFlagOffsetEXT}(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayEdgeFlagOffsetEXT(int vaobj, int buffer, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayEdgeFlagOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayEdgeFlagOffsetEXT"));
    }
        dispatch_glVertexArrayEdgeFlagOffsetEXT1(vaobj, buffer, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayEdgeFlagOffsetEXT}(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayEdgeFlagOffsetEXT1(int vaobj, int buffer, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayIndexOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayIndexOffsetEXT(int vaobj, int buffer, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayIndexOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayIndexOffsetEXT"));
    }
        dispatch_glVertexArrayIndexOffsetEXT1(vaobj, buffer, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayIndexOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayIndexOffsetEXT1(int vaobj, int buffer, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayNormalOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayNormalOffsetEXT(int vaobj, int buffer, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayNormalOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayNormalOffsetEXT"));
    }
        dispatch_glVertexArrayNormalOffsetEXT1(vaobj, buffer, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayNormalOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayNormalOffsetEXT1(int vaobj, int buffer, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayTexCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayTexCoordOffsetEXT(int vaobj, int buffer, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayTexCoordOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayTexCoordOffsetEXT"));
    }
        dispatch_glVertexArrayTexCoordOffsetEXT1(vaobj, buffer, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayTexCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayTexCoordOffsetEXT1(int vaobj, int buffer, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayMultiTexCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayMultiTexCoordOffsetEXT(int vaobj, int buffer, int texunit, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayMultiTexCoordOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayMultiTexCoordOffsetEXT"));
    }
        dispatch_glVertexArrayMultiTexCoordOffsetEXT1(vaobj, buffer, texunit, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayMultiTexCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayMultiTexCoordOffsetEXT1(int vaobj, int buffer, int texunit, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayFogCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayFogCoordOffsetEXT(int vaobj, int buffer, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayFogCoordOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayFogCoordOffsetEXT"));
    }
        dispatch_glVertexArrayFogCoordOffsetEXT1(vaobj, buffer, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayFogCoordOffsetEXT}(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayFogCoordOffsetEXT1(int vaobj, int buffer, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArraySecondaryColorOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArraySecondaryColorOffsetEXT(int vaobj, int buffer, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArraySecondaryColorOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArraySecondaryColorOffsetEXT"));
    }
        dispatch_glVertexArraySecondaryColorOffsetEXT1(vaobj, buffer, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArraySecondaryColorOffsetEXT}(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArraySecondaryColorOffsetEXT1(int vaobj, int buffer, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayVertexAttribOffsetEXT(int vaobj, int buffer, int index, int size, int type, boolean normalized, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribOffsetEXT"));
    }
        dispatch_glVertexArrayVertexAttribOffsetEXT1(vaobj, buffer, index, size, type, normalized, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribOffsetEXT1(int vaobj, int buffer, int index, int size, int type, boolean normalized, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribIOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayVertexAttribIOffsetEXT(int vaobj, int buffer, int index, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribIOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribIOffsetEXT"));
    }
        dispatch_glVertexArrayVertexAttribIOffsetEXT1(vaobj, buffer, index, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribIOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribIOffsetEXT1(int vaobj, int buffer, int index, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayEXT}(GLuint vaobj, GLenum array) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glEnableVertexArrayEXT(int vaobj, int array)  {

    final long __addr_ = _pat._addressof_glEnableVertexArrayEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayEXT"));
    }
        dispatch_glEnableVertexArrayEXT1(vaobj, array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayEXT}(GLuint vaobj, GLenum array) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glEnableVertexArrayEXT1(int vaobj, int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayEXT}(GLuint vaobj, GLenum array) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glDisableVertexArrayEXT(int vaobj, int array)  {

    final long __addr_ = _pat._addressof_glDisableVertexArrayEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayEXT"));
    }
        dispatch_glDisableVertexArrayEXT1(vaobj, array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayEXT}(GLuint vaobj, GLenum array) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glDisableVertexArrayEXT1(int vaobj, int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayAttribEXT}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glEnableVertexArrayAttribEXT(int vaobj, int index)  {

    final long __addr_ = _pat._addressof_glEnableVertexArrayAttribEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexArrayAttribEXT"));
    }
        dispatch_glEnableVertexArrayAttribEXT1(vaobj, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexArrayAttribEXT}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glEnableVertexArrayAttribEXT1(int vaobj, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayAttribEXT}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glDisableVertexArrayAttribEXT(int vaobj, int index)  {

    final long __addr_ = _pat._addressof_glDisableVertexArrayAttribEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexArrayAttribEXT"));
    }
        dispatch_glDisableVertexArrayAttribEXT1(vaobj, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexArrayAttribEXT}(GLuint vaobj, GLuint index) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glDisableVertexArrayAttribEXT1(int vaobj, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegervEXT}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexArrayIntegervEXT(int vaobj, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegervEXT"));
    }
        dispatch_glGetVertexArrayIntegervEXT1(vaobj, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegervEXT}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexArrayIntegervEXT1(int vaobj, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegervEXT}(GLuint vaobj, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetVertexArrayIntegervEXT(int vaobj, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexArrayIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegervEXT"));
    }
        dispatch_glGetVertexArrayIntegervEXT1(vaobj, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayPointervEXT}(GLuint vaobj, GLenum pname, void *  *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetVertexArrayPointervEXT(int vaobj, int pname, PointerBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayPointervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayPointervEXT"));
    }
        dispatch_glGetVertexArrayPointervEXT1(vaobj, pname, param_is_direct ? ( param != null ? param.getBuffer() : null ) : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayPointervEXT}(GLuint vaobj, GLenum pname, void *  *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetVertexArrayPointervEXT1(int vaobj, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegeri_vEXT}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexArrayIntegeri_vEXT(int vaobj, int index, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegeri_vEXT"));
    }
        dispatch_glGetVertexArrayIntegeri_vEXT1(vaobj, index, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegeri_vEXT}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexArrayIntegeri_vEXT1(int vaobj, int index, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexArrayIntegeri_vEXT}(GLuint vaobj, GLuint index, GLenum pname, GLint *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glGetVertexArrayIntegeri_vEXT(int vaobj, int index, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexArrayIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayIntegeri_vEXT"));
    }
        dispatch_glGetVertexArrayIntegeri_vEXT1(vaobj, index, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayPointeri_vEXT}(GLuint vaobj, GLuint index, GLenum pname, void *  *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetVertexArrayPointeri_vEXT(int vaobj, int index, int pname, PointerBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetVertexArrayPointeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexArrayPointeri_vEXT"));
    }
        dispatch_glGetVertexArrayPointeri_vEXT1(vaobj, index, pname, param_is_direct ? ( param != null ? param.getBuffer() : null ) : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexArrayPointeri_vEXT}(GLuint vaobj, GLuint index, GLenum pname, void *  *  param) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param param a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetVertexArrayPointeri_vEXT1(int vaobj, int index, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private long glMapNamedBufferRangeEXTDelegate(int buffer, long offset, long length, int access)  {

    final long __addr_ = _pat._addressof_glMapNamedBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapNamedBufferRangeEXT"));
    }
        return dispatch_glMapNamedBufferRangeEXTDelegate1(buffer, offset, length, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL2#mapNamedBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private native long dispatch_glMapNamedBufferRangeEXTDelegate1(int buffer, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glFlushMappedNamedBufferRangeEXT(int buffer, long offset, long length)  {

    final long __addr_ = _pat._addressof_glFlushMappedNamedBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedNamedBufferRangeEXT"));
    }
        dispatch_glFlushMappedNamedBufferRangeEXT1(buffer, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedNamedBufferRangeEXT}(GLuint buffer, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glFlushMappedNamedBufferRangeEXT1(int buffer, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedBufferStorageEXT}(GLuint buffer, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glNamedBufferStorageEXTDelegate(int buffer, long size, Buffer data, int flags)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glNamedBufferStorageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedBufferStorageEXT"));
    }
        dispatch_glNamedBufferStorageEXTDelegate1(buffer, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedBufferStorageEXT}(GLuint buffer, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-or-equal zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glNamedBufferStorageEXTDelegate1(int buffer, long size, Object data, int data_byte_offset, boolean data_is_direct, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dEXT}(GLuint program, GLint location, GLdouble x) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform1dEXT(int program, int location, double x)  {

    final long __addr_ = _pat._addressof_glProgramUniform1dEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dEXT"));
    }
        dispatch_glProgramUniform1dEXT1(program, location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dEXT}(GLuint program, GLint location, GLdouble x) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glProgramUniform1dEXT1(int program, int location, double x, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform2dEXT(int program, int location, double x, double y)  {

    final long __addr_ = _pat._addressof_glProgramUniform2dEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dEXT"));
    }
        dispatch_glProgramUniform2dEXT1(program, location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glProgramUniform2dEXT1(int program, int location, double x, double y, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform3dEXT(int program, int location, double x, double y, double z)  {

    final long __addr_ = _pat._addressof_glProgramUniform3dEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dEXT"));
    }
        dispatch_glProgramUniform3dEXT1(program, location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glProgramUniform3dEXT1(int program, int location, double x, double y, double z, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform4dEXT(int program, int location, double x, double y, double z, double w)  {

    final long __addr_ = _pat._addressof_glProgramUniform4dEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dEXT"));
    }
        dispatch_glProgramUniform4dEXT1(program, location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dEXT}(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glProgramUniform4dEXT1(int program, int location, double x, double y, double z, double w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform1dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dvEXT"));
    }
        dispatch_glProgramUniform1dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform1dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform1dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1dvEXT"));
    }
        dispatch_glProgramUniform1dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform2dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dvEXT"));
    }
        dispatch_glProgramUniform2dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform2dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform2dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2dvEXT"));
    }
        dispatch_glProgramUniform2dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform3dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dvEXT"));
    }
        dispatch_glProgramUniform3dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform3dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform3dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3dvEXT"));
    }
        dispatch_glProgramUniform3dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniform4dvEXT(int program, int location, int count, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dvEXT"));
    }
        dispatch_glProgramUniform4dvEXT1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniform4dvEXT1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4dvEXT}(GLuint program, GLint location, GLsizei count, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniform4dvEXT(int program, int location, int count, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4dvEXT"));
    }
        dispatch_glProgramUniform4dvEXT1(program, location, count, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dvEXT"));
    }
        dispatch_glProgramUniformMatrix2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2dvEXT"));
    }
        dispatch_glProgramUniformMatrix2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dvEXT"));
    }
        dispatch_glProgramUniformMatrix3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3dvEXT"));
    }
        dispatch_glProgramUniformMatrix3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dvEXT"));
    }
        dispatch_glProgramUniformMatrix4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4dvEXT"));
    }
        dispatch_glProgramUniformMatrix4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dvEXT"));
    }
        dispatch_glProgramUniformMatrix2x3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix2x3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3dvEXT"));
    }
        dispatch_glProgramUniformMatrix2x3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix2x4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dvEXT"));
    }
        dispatch_glProgramUniformMatrix2x4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix2x4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4dvEXT"));
    }
        dispatch_glProgramUniformMatrix2x4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dvEXT"));
    }
        dispatch_glProgramUniformMatrix3x2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix3x2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2dvEXT"));
    }
        dispatch_glProgramUniformMatrix3x2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix3x4dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dvEXT"));
    }
        dispatch_glProgramUniformMatrix3x4dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix3x4dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4dvEXT"));
    }
        dispatch_glProgramUniformMatrix3x4dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x2dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dvEXT"));
    }
        dispatch_glProgramUniformMatrix4x2dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix4x2dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2dvEXT"));
    }
        dispatch_glProgramUniformMatrix4x2dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glProgramUniformMatrix4x3dvEXT(int program, int location, int count, boolean transpose, DoubleBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dvEXT"));
    }
        dispatch_glProgramUniformMatrix4x3dvEXT1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>
      @param value a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3dvEXT1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3dvEXT}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *  value) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glProgramUniformMatrix4x3dvEXT(int program, int location, int count, boolean transpose, double[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3dvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3dvEXT"));
    }
        dispatch_glProgramUniformMatrix4x3dvEXT1(program, location, count, transpose, value, Buffers.SIZEOF_DOUBLE * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBufferRangeEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_texture_buffer_range</code><br>   */
  public void glTextureBufferRangeEXT(int texture, int target, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTextureBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBufferRangeEXT"));
    }
        dispatch_glTextureBufferRangeEXT1(texture, target, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBufferRangeEXT}(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_texture_buffer_range</code><br>   */
  private native void dispatch_glTextureBufferRangeEXT1(int texture, int target, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DMultisampleEXT}(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage2DMultisampleEXT(int texture, int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTextureStorage2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DMultisampleEXT"));
    }
        dispatch_glTextureStorage2DMultisampleEXT1(texture, target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DMultisampleEXT}(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage2DMultisampleEXT1(int texture, int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DMultisampleEXT}(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage3DMultisampleEXT(int texture, int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTextureStorage3DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DMultisampleEXT"));
    }
        dispatch_glTextureStorage3DMultisampleEXT1(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DMultisampleEXT}(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage3DMultisampleEXT1(int texture, int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayBindVertexBufferEXT}(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayBindVertexBufferEXT(int vaobj, int bindingindex, int buffer, long offset, int stride)  {

    final long __addr_ = _pat._addressof_glVertexArrayBindVertexBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayBindVertexBufferEXT"));
    }
        dispatch_glVertexArrayBindVertexBufferEXT1(vaobj, bindingindex, buffer, offset, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayBindVertexBufferEXT}(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayBindVertexBufferEXT1(int vaobj, int bindingindex, int buffer, long offset, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayVertexAttribFormatEXT(int vaobj, int attribindex, int size, int type, boolean normalized, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribFormatEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribFormatEXT"));
    }
        dispatch_glVertexArrayVertexAttribFormatEXT1(vaobj, attribindex, size, type, normalized, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribFormatEXT1(int vaobj, int attribindex, int size, int type, boolean normalized, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribIFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayVertexAttribIFormatEXT(int vaobj, int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribIFormatEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribIFormatEXT"));
    }
        dispatch_glVertexArrayVertexAttribIFormatEXT1(vaobj, attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribIFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribIFormatEXT1(int vaobj, int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribLFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayVertexAttribLFormatEXT(int vaobj, int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribLFormatEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribLFormatEXT"));
    }
        dispatch_glVertexArrayVertexAttribLFormatEXT1(vaobj, attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribLFormatEXT}(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribLFormatEXT1(int vaobj, int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribBindingEXT}(GLuint vaobj, GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayVertexAttribBindingEXT(int vaobj, int attribindex, int bindingindex)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribBindingEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribBindingEXT"));
    }
        dispatch_glVertexArrayVertexAttribBindingEXT1(vaobj, attribindex, bindingindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribBindingEXT}(GLuint vaobj, GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribBindingEXT1(int vaobj, int attribindex, int bindingindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBindingDivisorEXT}(GLuint vaobj, GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexArrayVertexBindingDivisorEXT(int vaobj, int bindingindex, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexBindingDivisorEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexBindingDivisorEXT"));
    }
        dispatch_glVertexArrayVertexBindingDivisorEXT1(vaobj, bindingindex, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexBindingDivisorEXT}(GLuint vaobj, GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_EXT_direct_state_access</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexArrayVertexBindingDivisorEXT1(int vaobj, int bindingindex, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribLOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_vertex_attrib_64bit</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayVertexAttribLOffsetEXT(int vaobj, int buffer, int index, int size, int type, int stride, long offset)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribLOffsetEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribLOffsetEXT"));
    }
        dispatch_glVertexArrayVertexAttribLOffsetEXT1(vaobj, buffer, index, size, type, stride, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribLOffsetEXT}(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) </code> <br>Part of <code>GL_EXT_vertex_attrib_64bit</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribLOffsetEXT1(int vaobj, int buffer, int index, int size, int type, int stride, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexturePageCommitmentEXT}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glTexturePageCommitmentEXT(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit)  {

    final long __addr_ = _pat._addressof_glTexturePageCommitmentEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexturePageCommitmentEXT"));
    }
        dispatch_glTexturePageCommitmentEXT1(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexturePageCommitmentEXT}(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTexturePageCommitmentEXT1(int texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribDivisorEXT}(GLuint vaobj, GLuint index, GLuint divisor) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  public void glVertexArrayVertexAttribDivisorEXT(int vaobj, int index, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexArrayVertexAttribDivisorEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexArrayVertexAttribDivisorEXT"));
    }
        dispatch_glVertexArrayVertexAttribDivisorEXT1(vaobj, index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexArrayVertexAttribDivisorEXT}(GLuint vaobj, GLuint index, GLuint divisor) </code> <br>Part of <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glVertexArrayVertexAttribDivisorEXT1(int vaobj, int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaskIndexed}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_EXT_draw_buffers2</code><br>Alias for: <code>glColorMaskIndexedEXT</code>   */
  public void glColorMaskIndexed(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = _pat._addressof_glColorMaskIndexed;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaskIndexed"));
    }
        dispatch_glColorMaskIndexed1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaskIndexed}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_EXT_draw_buffers2</code><br>Alias for: <code>glColorMaskIndexedEXT</code>   */
  private native void dispatch_glColorMaskIndexed1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramEnvParameters4fvEXT(int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameters4fvEXT"));
    }
        dispatch_glProgramEnvParameters4fvEXT1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramEnvParameters4fvEXT1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>   */
  public void glProgramEnvParameters4fvEXT(int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameters4fvEXT"));
    }
        dispatch_glProgramEnvParameters4fvEXT1(target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramLocalParameters4fvEXT(int target, int index, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameters4fvEXT"));
    }
        dispatch_glProgramLocalParameters4fvEXT1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramLocalParameters4fvEXT1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameters4fvEXT}(GLenum target, GLuint index, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_gpu_program_parameters</code><br>   */
  public void glProgramLocalParameters4fvEXT(int target, int index, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParameters4fvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameters4fvEXT"));
    }
        dispatch_glProgramLocalParameters4fvEXT1(target, index, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexFuncEXT}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_EXT_index_func</code><br>   */
  public void glIndexFuncEXT(int func, float ref)  {

    final long __addr_ = _pat._addressof_glIndexFuncEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexFuncEXT"));
    }
        dispatch_glIndexFuncEXT1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexFuncEXT}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_EXT_index_func</code><br>   */
  private native void dispatch_glIndexFuncEXT1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexMaterialEXT}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_EXT_index_material</code><br>   */
  public void glIndexMaterialEXT(int face, int mode)  {

    final long __addr_ = _pat._addressof_glIndexMaterialEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexMaterialEXT"));
    }
        dispatch_glIndexMaterialEXT1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexMaterialEXT}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_EXT_index_material</code><br>   */
  private native void dispatch_glIndexMaterialEXT1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glApplyTextureEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  public void glApplyTextureEXT(int mode)  {

    final long __addr_ = _pat._addressof_glApplyTextureEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glApplyTextureEXT"));
    }
        dispatch_glApplyTextureEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glApplyTextureEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  private native void dispatch_glApplyTextureEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureLightEXT}(GLenum pname) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  public void glTextureLightEXT(int pname)  {

    final long __addr_ = _pat._addressof_glTextureLightEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureLightEXT"));
    }
        dispatch_glTextureLightEXT1(pname, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureLightEXT}(GLenum pname) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  private native void dispatch_glTextureLightEXT1(int pname, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureMaterialEXT}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  public void glTextureMaterialEXT(int face, int mode)  {

    final long __addr_ = _pat._addressof_glTextureMaterialEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureMaterialEXT"));
    }
        dispatch_glTextureMaterialEXT1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureMaterialEXT}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_EXT_light_texture</code><br>   */
  private native void dispatch_glTextureMaterialEXT1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameteriEXT}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glPixelTransformParameteriEXT(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glPixelTransformParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameteriEXT"));
    }
        dispatch_glPixelTransformParameteriEXT1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameteriEXT}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  private native void dispatch_glPixelTransformParameteriEXT1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfEXT}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glPixelTransformParameterfEXT(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glPixelTransformParameterfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfEXT"));
    }
        dispatch_glPixelTransformParameterfEXT1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfEXT}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  private native void dispatch_glPixelTransformParameterfEXT1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPixelTransformParameterivEXT(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterivEXT"));
    }
        dispatch_glPixelTransformParameterivEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPixelTransformParameterivEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterivEXT}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glPixelTransformParameterivEXT(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterivEXT"));
    }
        dispatch_glPixelTransformParameterivEXT1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPixelTransformParameterfvEXT(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfvEXT"));
    }
        dispatch_glPixelTransformParameterfvEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPixelTransformParameterfvEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelTransformParameterfvEXT}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glPixelTransformParameterfvEXT(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelTransformParameterfvEXT"));
    }
        dispatch_glPixelTransformParameterfvEXT1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterivEXT}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPixelTransformParameterivEXT(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterivEXT"));
    }
        dispatch_glGetPixelTransformParameterivEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterivEXT}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPixelTransformParameterivEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterivEXT}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glGetPixelTransformParameterivEXT(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetPixelTransformParameterivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterivEXT"));
    }
        dispatch_glGetPixelTransformParameterivEXT1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterfvEXT}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetPixelTransformParameterfvEXT(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterfvEXT"));
    }
        dispatch_glGetPixelTransformParameterfvEXT1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterfvEXT}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetPixelTransformParameterfvEXT1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPixelTransformParameterfvEXT}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_EXT_pixel_transform</code><br>   */
  public void glGetPixelTransformParameterfvEXT(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetPixelTransformParameterfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPixelTransformParameterfvEXT"));
    }
        dispatch_glGetPixelTransformParameterfvEXT1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffsetClampEXT}(GLfloat factor, GLfloat units, GLfloat clamp) </code> <br>Part of <code>GL_EXT_polygon_offset_clamp</code><br>   */
  public void glPolygonOffsetClampEXT(float factor, float units, float clamp)  {

    final long __addr_ = _pat._addressof_glPolygonOffsetClampEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffsetClampEXT"));
    }
        dispatch_glPolygonOffsetClampEXT1(factor, units, clamp, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffsetClampEXT}(GLfloat factor, GLfloat units, GLfloat clamp) </code> <br>Part of <code>GL_EXT_polygon_offset_clamp</code><br>   */
  private native void dispatch_glPolygonOffsetClampEXT1(float factor, float units, float clamp, long procAddress);

  /** Entry point to C language function: <code> void {@native glProvokingVertexEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_provoking_vertex</code><br>   */
  public void glProvokingVertexEXT(int mode)  {

    final long __addr_ = _pat._addressof_glProvokingVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProvokingVertexEXT"));
    }
        dispatch_glProvokingVertexEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProvokingVertexEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_provoking_vertex</code><br>   */
  private native void dispatch_glProvokingVertexEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterSamplesEXT}(GLuint samples, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_EXT_raster_multisample</code><br>   */
  public void glRasterSamplesEXT(int samples, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glRasterSamplesEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterSamplesEXT"));
    }
        dispatch_glRasterSamplesEXT1(samples, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterSamplesEXT}(GLuint samples, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_EXT_raster_multisample</code><br>   */
  private native void dispatch_glRasterSamplesEXT1(int samples, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilClearTagEXT}(GLsizei stencilTagBits, GLuint stencilClearTag) </code> <br>Part of <code>GL_EXT_stencil_clear_tag</code><br>   */
  public void glStencilClearTagEXT(int stencilTagBits, int stencilClearTag)  {

    final long __addr_ = _pat._addressof_glStencilClearTagEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilClearTagEXT"));
    }
        dispatch_glStencilClearTagEXT1(stencilTagBits, stencilClearTag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilClearTagEXT}(GLsizei stencilTagBits, GLuint stencilClearTag) </code> <br>Part of <code>GL_EXT_stencil_clear_tag</code><br>   */
  private native void dispatch_glStencilClearTagEXT1(int stencilTagBits, int stencilClearTag, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveStencilFaceEXT}(GLenum face) </code> <br>Part of <code>GL_EXT_stencil_two_side</code><br>   */
  public void glActiveStencilFaceEXT(int face)  {

    final long __addr_ = _pat._addressof_glActiveStencilFaceEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveStencilFaceEXT"));
    }
        dispatch_glActiveStencilFaceEXT1(face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveStencilFaceEXT}(GLenum face) </code> <br>Part of <code>GL_EXT_stencil_two_side</code><br>   */
  private native void dispatch_glActiveStencilFaceEXT1(int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorIi}(GLint red, GLint green, GLint blue, GLint alpha) </code> <br>Part of <code>GL_EXT_texture_integer</code><br>Alias for: <code>glClearColorIiEXT</code>   */
  public void glClearColorIi(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glClearColorIi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColorIi"));
    }
        dispatch_glClearColorIi1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorIi}(GLint red, GLint green, GLint blue, GLint alpha) </code> <br>Part of <code>GL_EXT_texture_integer</code><br>Alias for: <code>glClearColorIiEXT</code>   */
  private native void dispatch_glClearColorIi1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorIui}(GLuint red, GLuint green, GLuint blue, GLuint alpha) </code> <br>Part of <code>GL_EXT_texture_integer</code><br>Alias for: <code>glClearColorIuiEXT</code>   */
  public void glClearColorIui(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glClearColorIui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColorIui"));
    }
        dispatch_glClearColorIui1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorIui}(GLuint red, GLuint green, GLuint blue, GLuint alpha) </code> <br>Part of <code>GL_EXT_texture_integer</code><br>Alias for: <code>glClearColorIuiEXT</code>   */
  private native void dispatch_glClearColorIui1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureNormalEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_texture_perturb_normal</code><br>   */
  public void glTextureNormalEXT(int mode)  {

    final long __addr_ = _pat._addressof_glTextureNormalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureNormalEXT"));
    }
        dispatch_glTextureNormalEXT1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureNormalEXT}(GLenum mode) </code> <br>Part of <code>GL_EXT_texture_perturb_normal</code><br>   */
  private native void dispatch_glTextureNormalEXT1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>   */
  public void glGetQueryObjecti64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>   */
  public void glGetQueryObjectui64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVertexShaderEXT}(void) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glBeginVertexShaderEXT()  {

    final long __addr_ = _pat._addressof_glBeginVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginVertexShaderEXT"));
    }
        dispatch_glBeginVertexShaderEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVertexShaderEXT}(void) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glBeginVertexShaderEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glEndVertexShaderEXT}(void) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glEndVertexShaderEXT()  {

    final long __addr_ = _pat._addressof_glEndVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndVertexShaderEXT"));
    }
        dispatch_glEndVertexShaderEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndVertexShaderEXT}(void) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glEndVertexShaderEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexShaderEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glBindVertexShaderEXT(int id)  {

    final long __addr_ = _pat._addressof_glBindVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexShaderEXT"));
    }
        dispatch_glBindVertexShaderEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexShaderEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glBindVertexShaderEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGenVertexShadersEXT}(GLuint range) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glGenVertexShadersEXT(int range)  {

    final long __addr_ = _pat._addressof_glGenVertexShadersEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexShadersEXT"));
    }
        return dispatch_glGenVertexShadersEXT1(range, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenVertexShadersEXT}(GLuint range) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glGenVertexShadersEXT1(int range, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexShaderEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glDeleteVertexShaderEXT(int id)  {

    final long __addr_ = _pat._addressof_glDeleteVertexShaderEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexShaderEXT"));
    }
        dispatch_glDeleteVertexShaderEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexShaderEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glDeleteVertexShaderEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderOp1EXT}(GLenum op, GLuint res, GLuint arg1) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glShaderOp1EXT(int op, int res, int arg1)  {

    final long __addr_ = _pat._addressof_glShaderOp1EXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderOp1EXT"));
    }
        dispatch_glShaderOp1EXT1(op, res, arg1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp1EXT}(GLenum op, GLuint res, GLuint arg1) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glShaderOp1EXT1(int op, int res, int arg1, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderOp2EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glShaderOp2EXT(int op, int res, int arg1, int arg2)  {

    final long __addr_ = _pat._addressof_glShaderOp2EXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderOp2EXT"));
    }
        dispatch_glShaderOp2EXT1(op, res, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp2EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glShaderOp2EXT1(int op, int res, int arg1, int arg2, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderOp3EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glShaderOp3EXT(int op, int res, int arg1, int arg2, int arg3)  {

    final long __addr_ = _pat._addressof_glShaderOp3EXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderOp3EXT"));
    }
        dispatch_glShaderOp3EXT1(op, res, arg1, arg2, arg3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderOp3EXT}(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glShaderOp3EXT1(int op, int res, int arg1, int arg2, int arg3, long procAddress);

  /** Entry point to C language function: <code> void {@native glSwizzleEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glSwizzleEXT(int res, int in, int outX, int outY, int outZ, int outW)  {

    final long __addr_ = _pat._addressof_glSwizzleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSwizzleEXT"));
    }
        dispatch_glSwizzleEXT1(res, in, outX, outY, outZ, outW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSwizzleEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glSwizzleEXT1(int res, int in, int outX, int outY, int outZ, int outW, long procAddress);

  /** Entry point to C language function: <code> void {@native glWriteMaskEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glWriteMaskEXT(int res, int in, int outX, int outY, int outZ, int outW)  {

    final long __addr_ = _pat._addressof_glWriteMaskEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWriteMaskEXT"));
    }
        dispatch_glWriteMaskEXT1(res, in, outX, outY, outZ, outW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWriteMaskEXT}(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glWriteMaskEXT1(int res, int in, int outX, int outY, int outZ, int outW, long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertComponentEXT}(GLuint res, GLuint src, GLuint num) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glInsertComponentEXT(int res, int src, int num)  {

    final long __addr_ = _pat._addressof_glInsertComponentEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInsertComponentEXT"));
    }
        dispatch_glInsertComponentEXT1(res, src, num, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInsertComponentEXT}(GLuint res, GLuint src, GLuint num) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glInsertComponentEXT1(int res, int src, int num, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtractComponentEXT}(GLuint res, GLuint src, GLuint num) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glExtractComponentEXT(int res, int src, int num)  {

    final long __addr_ = _pat._addressof_glExtractComponentEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtractComponentEXT"));
    }
        dispatch_glExtractComponentEXT1(res, src, num, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtractComponentEXT}(GLuint res, GLuint src, GLuint num) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glExtractComponentEXT1(int res, int src, int num, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGenSymbolsEXT}(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glGenSymbolsEXT(int datatype, int storagetype, int range, int components)  {

    final long __addr_ = _pat._addressof_glGenSymbolsEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSymbolsEXT"));
    }
        return dispatch_glGenSymbolsEXT1(datatype, storagetype, range, components, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGenSymbolsEXT}(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glGenSymbolsEXT1(int datatype, int storagetype, int range, int components, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetInvariantEXT}(GLuint id, GLenum type, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  public void glSetInvariantEXT(int id, int type, Buffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glSetInvariantEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSetInvariantEXT"));
    }
        dispatch_glSetInvariantEXT1(id, type, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetInvariantEXT}(GLuint id, GLenum type, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSetInvariantEXT1(int id, int type, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSetLocalConstantEXT}(GLuint id, GLenum type, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  public void glSetLocalConstantEXT(int id, int type, Buffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glSetLocalConstantEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSetLocalConstantEXT"));
    }
        dispatch_glSetLocalConstantEXT1(id, type, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetLocalConstantEXT}(GLuint id, GLenum type, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glSetLocalConstantEXT1(int id, int type, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVariantbvEXT(int id, ByteBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantbvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantbvEXT"));
    }
        dispatch_glVariantbvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVariantbvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantbvEXT}(GLuint id, const GLbyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantbvEXT(int id, byte[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantbvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantbvEXT"));
    }
        dispatch_glVariantbvEXT1(id, addr, addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVariantsvEXT(int id, ShortBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantsvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantsvEXT"));
    }
        dispatch_glVariantsvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVariantsvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantsvEXT}(GLuint id, const GLshort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantsvEXT(int id, short[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantsvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantsvEXT"));
    }
        dispatch_glVariantsvEXT1(id, addr, Buffers.SIZEOF_SHORT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVariantivEXT(int id, IntBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantivEXT"));
    }
        dispatch_glVariantivEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVariantivEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantivEXT}(GLuint id, const GLint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantivEXT(int id, int[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantivEXT"));
    }
        dispatch_glVariantivEXT1(id, addr, Buffers.SIZEOF_INT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVariantfvEXT(int id, FloatBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantfvEXT"));
    }
        dispatch_glVariantfvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVariantfvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantfvEXT}(GLuint id, const GLfloat *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantfvEXT(int id, float[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantfvEXT"));
    }
        dispatch_glVariantfvEXT1(id, addr, Buffers.SIZEOF_FLOAT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVariantdvEXT(int id, DoubleBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantdvEXT"));
    }
        dispatch_glVariantdvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVariantdvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantdvEXT}(GLuint id, const GLdouble *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantdvEXT(int id, double[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantdvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantdvEXT"));
    }
        dispatch_glVariantdvEXT1(id, addr, Buffers.SIZEOF_DOUBLE * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVariantubvEXT(int id, ByteBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantubvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantubvEXT"));
    }
        dispatch_glVariantubvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVariantubvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantubvEXT}(GLuint id, const GLubyte *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantubvEXT(int id, byte[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantubvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantubvEXT"));
    }
        dispatch_glVariantubvEXT1(id, addr, addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVariantusvEXT(int id, ShortBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantusvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantusvEXT"));
    }
        dispatch_glVariantusvEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVariantusvEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantusvEXT}(GLuint id, const GLushort *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantusvEXT(int id, short[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantusvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantusvEXT"));
    }
        dispatch_glVariantusvEXT1(id, addr, Buffers.SIZEOF_SHORT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVariantuivEXT(int id, IntBuffer addr)  {

    final boolean addr_is_direct = Buffers.isDirect(addr);
    final long __addr_ = _pat._addressof_glVariantuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantuivEXT"));
    }
        dispatch_glVariantuivEXT1(id, addr_is_direct ? addr : Buffers.getArray(addr), addr_is_direct ? Buffers.getDirectBufferByteOffset(addr) : Buffers.getIndirectBufferByteOffset(addr), addr_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVariantuivEXT1(int id, Object addr, int addr_byte_offset, boolean addr_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantuivEXT}(GLuint id, const GLuint *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantuivEXT(int id, int[] addr, int addr_offset)  {

    if(addr != null && addr.length <= addr_offset)
      throw new GLException("array offset argument \"addr_offset\" (" + addr_offset + ") equals or exceeds array length (" + addr.length + ")");
    final long __addr_ = _pat._addressof_glVariantuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantuivEXT"));
    }
        dispatch_glVariantuivEXT1(id, addr, Buffers.SIZEOF_INT * addr_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct only {@link java.nio.Buffer}   */
  public void glVariantPointerEXT(int id, int type, int stride, Buffer addr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(addr, 1);
    if (!Buffers.isDirect(addr))
      throw new GLException("Argument \"addr\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVariantPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantPointerEXT"));
    }
        dispatch_glVariantPointerEXT0(id, type, stride, addr, Buffers.getDirectBufferByteOffset(addr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param addr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVariantPointerEXT0(int id, int type, int stride, Object addr, int addr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glVariantPointerEXT(int id, int type, int stride, long addr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVariantPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVariantPointerEXT"));
    }
        dispatch_glVariantPointerEXT0(id, type, stride, addr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVariantPointerEXT}(GLuint id, GLenum type, GLuint stride, const void *  addr) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glVariantPointerEXT0(int id, int type, int stride, long addr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVariantClientStateEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glEnableVariantClientStateEXT(int id)  {

    final long __addr_ = _pat._addressof_glEnableVariantClientStateEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVariantClientStateEXT"));
    }
        dispatch_glEnableVariantClientStateEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVariantClientStateEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glEnableVariantClientStateEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVariantClientStateEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glDisableVariantClientStateEXT(int id)  {

    final long __addr_ = _pat._addressof_glDisableVariantClientStateEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVariantClientStateEXT"));
    }
        dispatch_glDisableVariantClientStateEXT1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVariantClientStateEXT}(GLuint id) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native void dispatch_glDisableVariantClientStateEXT1(int id, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindLightParameterEXT}(GLenum light, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glBindLightParameterEXT(int light, int value)  {

    final long __addr_ = _pat._addressof_glBindLightParameterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindLightParameterEXT"));
    }
        return dispatch_glBindLightParameterEXT1(light, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindLightParameterEXT}(GLenum light, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glBindLightParameterEXT1(int light, int value, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindMaterialParameterEXT}(GLenum face, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glBindMaterialParameterEXT(int face, int value)  {

    final long __addr_ = _pat._addressof_glBindMaterialParameterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindMaterialParameterEXT"));
    }
        return dispatch_glBindMaterialParameterEXT1(face, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindMaterialParameterEXT}(GLenum face, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glBindMaterialParameterEXT1(int face, int value, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindTexGenParameterEXT}(GLenum unit, GLenum coord, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glBindTexGenParameterEXT(int unit, int coord, int value)  {

    final long __addr_ = _pat._addressof_glBindTexGenParameterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTexGenParameterEXT"));
    }
        return dispatch_glBindTexGenParameterEXT1(unit, coord, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindTexGenParameterEXT}(GLenum unit, GLenum coord, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glBindTexGenParameterEXT1(int unit, int coord, int value, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindTextureUnitParameterEXT}(GLenum unit, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glBindTextureUnitParameterEXT(int unit, int value)  {

    final long __addr_ = _pat._addressof_glBindTextureUnitParameterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTextureUnitParameterEXT"));
    }
        return dispatch_glBindTextureUnitParameterEXT1(unit, value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindTextureUnitParameterEXT}(GLenum unit, GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glBindTextureUnitParameterEXT1(int unit, int value, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glBindParameterEXT}(GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public int glBindParameterEXT(int value)  {

    final long __addr_ = _pat._addressof_glBindParameterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindParameterEXT"));
    }
        return dispatch_glBindParameterEXT1(value, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glBindParameterEXT}(GLenum value) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native int dispatch_glBindParameterEXT1(int value, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVariantEnabledEXT}(GLuint id, GLenum cap) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public boolean glIsVariantEnabledEXT(int id, int cap)  {

    final long __addr_ = _pat._addressof_glIsVariantEnabledEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVariantEnabledEXT"));
    }
        return dispatch_glIsVariantEnabledEXT1(id, cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVariantEnabledEXT}(GLuint id, GLenum cap) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  private native boolean dispatch_glIsVariantEnabledEXT1(int id, int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetVariantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetVariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantBooleanvEXT"));
    }
        dispatch_glGetVariantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetVariantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetVariantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetVariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantBooleanvEXT"));
    }
        dispatch_glGetVariantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVariantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetVariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantIntegervEXT"));
    }
        dispatch_glGetVariantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVariantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetVariantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetVariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantIntegervEXT"));
    }
        dispatch_glGetVariantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVariantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetVariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantFloatvEXT"));
    }
        dispatch_glGetVariantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVariantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetVariantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetVariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVariantFloatvEXT"));
    }
        dispatch_glGetVariantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetInvariantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInvariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantBooleanvEXT"));
    }
        dispatch_glGetInvariantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetInvariantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetInvariantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInvariantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantBooleanvEXT"));
    }
        dispatch_glGetInvariantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInvariantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInvariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantIntegervEXT"));
    }
        dispatch_glGetInvariantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInvariantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetInvariantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInvariantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantIntegervEXT"));
    }
        dispatch_glGetInvariantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetInvariantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInvariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantFloatvEXT"));
    }
        dispatch_glGetInvariantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetInvariantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInvariantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetInvariantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInvariantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInvariantFloatvEXT"));
    }
        dispatch_glGetInvariantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetLocalConstantBooleanvEXT(int id, int value, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetLocalConstantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantBooleanvEXT"));
    }
        dispatch_glGetLocalConstantBooleanvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetLocalConstantBooleanvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantBooleanvEXT}(GLuint id, GLenum value, GLboolean *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetLocalConstantBooleanvEXT(int id, int value, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetLocalConstantBooleanvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantBooleanvEXT"));
    }
        dispatch_glGetLocalConstantBooleanvEXT1(id, value, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLocalConstantIntegervEXT(int id, int value, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetLocalConstantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantIntegervEXT"));
    }
        dispatch_glGetLocalConstantIntegervEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLocalConstantIntegervEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantIntegervEXT}(GLuint id, GLenum value, GLint *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetLocalConstantIntegervEXT(int id, int value, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetLocalConstantIntegervEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantIntegervEXT"));
    }
        dispatch_glGetLocalConstantIntegervEXT1(id, value, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLocalConstantFloatvEXT(int id, int value, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetLocalConstantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantFloatvEXT"));
    }
        dispatch_glGetLocalConstantFloatvEXT1(id, value, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLocalConstantFloatvEXT1(int id, int value, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLocalConstantFloatvEXT}(GLuint id, GLenum value, GLfloat *  data) </code> <br>Part of <code>GL_EXT_vertex_shader</code><br>   */
  public void glGetLocalConstantFloatvEXT(int id, int value, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetLocalConstantFloatvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLocalConstantFloatvEXT"));
    }
        dispatch_glGetLocalConstantFloatvEXT1(id, value, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightfEXT}(GLfloat weight) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>   */
  public void glVertexWeightfEXT(float weight)  {

    final long __addr_ = _pat._addressof_glVertexWeightfEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfEXT"));
    }
        dispatch_glVertexWeightfEXT1(weight, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightfEXT}(GLfloat weight) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>   */
  private native void dispatch_glVertexWeightfEXT1(float weight, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>
      @param weight a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexWeightfvEXT(FloatBuffer weight)  {

    final boolean weight_is_direct = Buffers.isDirect(weight);
    final long __addr_ = _pat._addressof_glVertexWeightfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfvEXT"));
    }
        dispatch_glVertexWeightfvEXT1(weight_is_direct ? weight : Buffers.getArray(weight), weight_is_direct ? Buffers.getDirectBufferByteOffset(weight) : Buffers.getIndirectBufferByteOffset(weight), weight_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>
      @param weight a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexWeightfvEXT1(Object weight, int weight_byte_offset, boolean weight_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightfvEXT}(const GLfloat *  weight) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>   */
  public void glVertexWeightfvEXT(float[] weight, int weight_offset)  {

    if(weight != null && weight.length <= weight_offset)
      throw new GLException("array offset argument \"weight_offset\" (" + weight_offset + ") equals or exceeds array length (" + weight.length + ")");
    final long __addr_ = _pat._addressof_glVertexWeightfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightfvEXT"));
    }
        dispatch_glVertexWeightfvEXT1(weight, Buffers.SIZEOF_FLOAT * weight_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexWeightPointerEXT(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexWeightPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightPointerEXT"));
    }
        dispatch_glVertexWeightPointerEXT0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexWeightPointerEXT0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>   */
  public void glVertexWeightPointerEXT(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexWeightPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeightPointerEXT"));
    }
        dispatch_glVertexWeightPointerEXT0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeightPointerEXT}(GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_EXT_vertex_weighting</code><br>   */
  private native void dispatch_glVertexWeightPointerEXT0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glImportSyncEXT}(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) </code> <br>Part of <code>GL_EXT_x11_sync_object</code><br>   */
  public long glImportSyncEXT(int external_sync_type, long external_sync, int flags)  {

    final long __addr_ = _pat._addressof_glImportSyncEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glImportSyncEXT"));
    }
        return dispatch_glImportSyncEXT1(external_sync_type, external_sync, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glImportSyncEXT}(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) </code> <br>Part of <code>GL_EXT_x11_sync_object</code><br>   */
  private native long dispatch_glImportSyncEXT1(int external_sync_type, long external_sync, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrameTerminatorGREMEDY}(void) </code> <br>Part of <code>GL_GREMEDY_frame_terminator</code><br>   */
  public void glFrameTerminatorGREMEDY()  {

    final long __addr_ = _pat._addressof_glFrameTerminatorGREMEDY;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrameTerminatorGREMEDY"));
    }
        dispatch_glFrameTerminatorGREMEDY1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrameTerminatorGREMEDY}(void) </code> <br>Part of <code>GL_GREMEDY_frame_terminator</code><br>   */
  private native void dispatch_glFrameTerminatorGREMEDY1(long procAddress);

  /** Entry point to C language function: <code> void {@native glStringMarkerGREMEDY}(GLsizei len, const void *  string) </code> <br>Part of <code>GL_GREMEDY_string_marker</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  public void glStringMarkerGREMEDY(int len, Buffer string)  {

    final boolean string_is_direct = Buffers.isDirect(string);
    final long __addr_ = _pat._addressof_glStringMarkerGREMEDY;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStringMarkerGREMEDY"));
    }
        dispatch_glStringMarkerGREMEDY1(len, string_is_direct ? string : Buffers.getArray(string), string_is_direct ? Buffers.getDirectBufferByteOffset(string) : Buffers.getIndirectBufferByteOffset(string), string_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStringMarkerGREMEDY}(GLsizei len, const void *  string) </code> <br>Part of <code>GL_GREMEDY_string_marker</code><br>
      @param string a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glStringMarkerGREMEDY1(int len, Object string, int string_byte_offset, boolean string_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateINGR}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_INGR_blend_func_separate</code><br>   */
  public void glBlendFuncSeparateINGR(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparateINGR;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateINGR"));
    }
        dispatch_glBlendFuncSeparateINGR1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateINGR}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_INGR_blend_func_separate</code><br>   */
  private native void dispatch_glBlendFuncSeparateINGR1(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glApplyFramebufferAttachmentCMAAINTEL}(void) </code> <br>Part of <code>GL_INTEL_framebuffer_CMAA</code><br>   */
  public void glApplyFramebufferAttachmentCMAAINTEL()  {

    final long __addr_ = _pat._addressof_glApplyFramebufferAttachmentCMAAINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glApplyFramebufferAttachmentCMAAINTEL"));
    }
        dispatch_glApplyFramebufferAttachmentCMAAINTEL1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glApplyFramebufferAttachmentCMAAINTEL}(void) </code> <br>Part of <code>GL_INTEL_framebuffer_CMAA</code><br>   */
  private native void dispatch_glApplyFramebufferAttachmentCMAAINTEL1(long procAddress);

  /** Entry point to C language function: <code> void {@native glSyncTextureINTEL}(GLuint texture) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>   */
  public void glSyncTextureINTEL(int texture)  {

    final long __addr_ = _pat._addressof_glSyncTextureINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSyncTextureINTEL"));
    }
        dispatch_glSyncTextureINTEL1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSyncTextureINTEL}(GLuint texture) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>   */
  private native void dispatch_glSyncTextureINTEL1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glUnmapTexture2DINTEL}(GLuint texture, GLint level) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>   */
  public void glUnmapTexture2DINTEL(int texture, int level)  {

    final long __addr_ = _pat._addressof_glUnmapTexture2DINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapTexture2DINTEL"));
    }
        dispatch_glUnmapTexture2DINTEL1(texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUnmapTexture2DINTEL}(GLuint texture, GLint level) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>   */
  private native void dispatch_glUnmapTexture2DINTEL1(int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapTexture2DINTEL}(GLuint texture, GLint level, GLbitfield access, GLint *  stride, GLenum *  layout) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>
      @param stride a direct or array-backed {@link java.nio.IntBuffer}
      @param layout a direct or array-backed {@link java.nio.IntBuffer}   */
  public ByteBuffer glMapTexture2DINTEL(int texture, int level, int access, IntBuffer stride, IntBuffer layout)  {

    final boolean stride_is_direct = Buffers.isDirect(stride);
    final boolean layout_is_direct = Buffers.isDirect(layout);
    final long __addr_ = _pat._addressof_glMapTexture2DINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapTexture2DINTEL"));
    }
    final ByteBuffer _res;
    _res = dispatch_glMapTexture2DINTEL1(texture, level, access, stride_is_direct ? stride : Buffers.getArray(stride), stride_is_direct ? Buffers.getDirectBufferByteOffset(stride) : Buffers.getIndirectBufferByteOffset(stride), stride_is_direct, layout_is_direct ? layout : Buffers.getArray(layout), layout_is_direct ? Buffers.getDirectBufferByteOffset(layout) : Buffers.getIndirectBufferByteOffset(layout), layout_is_direct, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> void *  {@native glMapTexture2DINTEL}(GLuint texture, GLint level, GLbitfield access, GLint *  stride, GLenum *  layout) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>
      @param stride a direct or array-backed {@link java.nio.IntBuffer}
      @param layout a direct or array-backed {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glMapTexture2DINTEL1(int texture, int level, int access, Object stride, int stride_byte_offset, boolean stride_is_direct, Object layout, int layout_byte_offset, boolean layout_is_direct, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapTexture2DINTEL}(GLuint texture, GLint level, GLbitfield access, GLint *  stride, GLenum *  layout) </code> <br>Part of <code>GL_INTEL_map_texture</code><br>   */
  public ByteBuffer glMapTexture2DINTEL(int texture, int level, int access, int[] stride, int stride_offset, int[] layout, int layout_offset)  {

    if(stride != null && stride.length <= stride_offset)
      throw new GLException("array offset argument \"stride_offset\" (" + stride_offset + ") equals or exceeds array length (" + stride.length + ")");
    if(layout != null && layout.length <= layout_offset)
      throw new GLException("array offset argument \"layout_offset\" (" + layout_offset + ") equals or exceeds array length (" + layout.length + ")");
    final long __addr_ = _pat._addressof_glMapTexture2DINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapTexture2DINTEL"));
    }
    final ByteBuffer _res;
    _res = dispatch_glMapTexture2DINTEL1(texture, level, access, stride, Buffers.SIZEOF_INT * stride_offset, false, layout, Buffers.SIZEOF_INT * layout_offset, false, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glBeginPerfQueryINTEL(int queryHandle)  {

    final long __addr_ = _pat._addressof_glBeginPerfQueryINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginPerfQueryINTEL"));
    }
        dispatch_glBeginPerfQueryINTEL1(queryHandle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  private native void dispatch_glBeginPerfQueryINTEL1(int queryHandle, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreatePerfQueryINTEL}(GLuint queryId, GLuint *  queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryHandle a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreatePerfQueryINTEL(int queryId, IntBuffer queryHandle)  {

    final boolean queryHandle_is_direct = Buffers.isDirect(queryHandle);
    final long __addr_ = _pat._addressof_glCreatePerfQueryINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreatePerfQueryINTEL"));
    }
        dispatch_glCreatePerfQueryINTEL1(queryId, queryHandle_is_direct ? queryHandle : Buffers.getArray(queryHandle), queryHandle_is_direct ? Buffers.getDirectBufferByteOffset(queryHandle) : Buffers.getIndirectBufferByteOffset(queryHandle), queryHandle_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreatePerfQueryINTEL}(GLuint queryId, GLuint *  queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryHandle a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreatePerfQueryINTEL1(int queryId, Object queryHandle, int queryHandle_byte_offset, boolean queryHandle_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreatePerfQueryINTEL}(GLuint queryId, GLuint *  queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glCreatePerfQueryINTEL(int queryId, int[] queryHandle, int queryHandle_offset)  {

    if(queryHandle != null && queryHandle.length <= queryHandle_offset)
      throw new GLException("array offset argument \"queryHandle_offset\" (" + queryHandle_offset + ") equals or exceeds array length (" + queryHandle.length + ")");
    final long __addr_ = _pat._addressof_glCreatePerfQueryINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreatePerfQueryINTEL"));
    }
        dispatch_glCreatePerfQueryINTEL1(queryId, queryHandle, Buffers.SIZEOF_INT * queryHandle_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glDeletePerfQueryINTEL(int queryHandle)  {

    final long __addr_ = _pat._addressof_glDeletePerfQueryINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfQueryINTEL"));
    }
        dispatch_glDeletePerfQueryINTEL1(queryHandle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  private native void dispatch_glDeletePerfQueryINTEL1(int queryHandle, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndPerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glEndPerfQueryINTEL(int queryHandle)  {

    final long __addr_ = _pat._addressof_glEndPerfQueryINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndPerfQueryINTEL"));
    }
        dispatch_glEndPerfQueryINTEL1(queryHandle, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndPerfQueryINTEL}(GLuint queryHandle) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  private native void dispatch_glEndPerfQueryINTEL1(int queryHandle, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFirstPerfQueryIdINTEL}(GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryId a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFirstPerfQueryIdINTEL(IntBuffer queryId)  {

    final boolean queryId_is_direct = Buffers.isDirect(queryId);
    final long __addr_ = _pat._addressof_glGetFirstPerfQueryIdINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFirstPerfQueryIdINTEL"));
    }
        dispatch_glGetFirstPerfQueryIdINTEL1(queryId_is_direct ? queryId : Buffers.getArray(queryId), queryId_is_direct ? Buffers.getDirectBufferByteOffset(queryId) : Buffers.getIndirectBufferByteOffset(queryId), queryId_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFirstPerfQueryIdINTEL}(GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryId a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFirstPerfQueryIdINTEL1(Object queryId, int queryId_byte_offset, boolean queryId_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFirstPerfQueryIdINTEL}(GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glGetFirstPerfQueryIdINTEL(int[] queryId, int queryId_offset)  {

    if(queryId != null && queryId.length <= queryId_offset)
      throw new GLException("array offset argument \"queryId_offset\" (" + queryId_offset + ") equals or exceeds array length (" + queryId.length + ")");
    final long __addr_ = _pat._addressof_glGetFirstPerfQueryIdINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFirstPerfQueryIdINTEL"));
    }
        dispatch_glGetFirstPerfQueryIdINTEL1(queryId, Buffers.SIZEOF_INT * queryId_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNextPerfQueryIdINTEL}(GLuint queryId, GLuint *  nextQueryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param nextQueryId a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetNextPerfQueryIdINTEL(int queryId, IntBuffer nextQueryId)  {

    final boolean nextQueryId_is_direct = Buffers.isDirect(nextQueryId);
    final long __addr_ = _pat._addressof_glGetNextPerfQueryIdINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNextPerfQueryIdINTEL"));
    }
        dispatch_glGetNextPerfQueryIdINTEL1(queryId, nextQueryId_is_direct ? nextQueryId : Buffers.getArray(nextQueryId), nextQueryId_is_direct ? Buffers.getDirectBufferByteOffset(nextQueryId) : Buffers.getIndirectBufferByteOffset(nextQueryId), nextQueryId_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNextPerfQueryIdINTEL}(GLuint queryId, GLuint *  nextQueryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param nextQueryId a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetNextPerfQueryIdINTEL1(int queryId, Object nextQueryId, int nextQueryId_byte_offset, boolean nextQueryId_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNextPerfQueryIdINTEL}(GLuint queryId, GLuint *  nextQueryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glGetNextPerfQueryIdINTEL(int queryId, int[] nextQueryId, int nextQueryId_offset)  {

    if(nextQueryId != null && nextQueryId.length <= nextQueryId_offset)
      throw new GLException("array offset argument \"nextQueryId_offset\" (" + nextQueryId_offset + ") equals or exceeds array length (" + nextQueryId.length + ")");
    final long __addr_ = _pat._addressof_glGetNextPerfQueryIdINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNextPerfQueryIdINTEL"));
    }
        dispatch_glGetNextPerfQueryIdINTEL1(queryId, nextQueryId, Buffers.SIZEOF_INT * nextQueryId_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfCounterInfoINTEL}(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *  counterName, GLuint counterDescLength, GLchar *  counterDesc, GLuint *  counterOffset, GLuint *  counterDataSize, GLuint *  counterTypeEnum, GLuint *  counterDataTypeEnum, GLuint64 *  rawCounterMaxValue) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param counterName a direct or array-backed {@link java.nio.ByteBuffer}
      @param counterDesc a direct or array-backed {@link java.nio.ByteBuffer}
      @param counterOffset a direct or array-backed {@link java.nio.IntBuffer}
      @param counterDataSize a direct or array-backed {@link java.nio.IntBuffer}
      @param counterTypeEnum a direct or array-backed {@link java.nio.IntBuffer}
      @param counterDataTypeEnum a direct or array-backed {@link java.nio.IntBuffer}
      @param rawCounterMaxValue a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetPerfCounterInfoINTEL(int queryId, int counterId, int counterNameLength, ByteBuffer counterName, int counterDescLength, ByteBuffer counterDesc, IntBuffer counterOffset, IntBuffer counterDataSize, IntBuffer counterTypeEnum, IntBuffer counterDataTypeEnum, LongBuffer rawCounterMaxValue)  {

    final boolean counterName_is_direct = Buffers.isDirect(counterName);
    final boolean counterDesc_is_direct = Buffers.isDirect(counterDesc);
    final boolean counterOffset_is_direct = Buffers.isDirect(counterOffset);
    final boolean counterDataSize_is_direct = Buffers.isDirect(counterDataSize);
    final boolean counterTypeEnum_is_direct = Buffers.isDirect(counterTypeEnum);
    final boolean counterDataTypeEnum_is_direct = Buffers.isDirect(counterDataTypeEnum);
    final boolean rawCounterMaxValue_is_direct = Buffers.isDirect(rawCounterMaxValue);
    final long __addr_ = _pat._addressof_glGetPerfCounterInfoINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfCounterInfoINTEL"));
    }
        dispatch_glGetPerfCounterInfoINTEL1(queryId, counterId, counterNameLength, counterName_is_direct ? counterName : Buffers.getArray(counterName), counterName_is_direct ? Buffers.getDirectBufferByteOffset(counterName) : Buffers.getIndirectBufferByteOffset(counterName), counterName_is_direct, counterDescLength, counterDesc_is_direct ? counterDesc : Buffers.getArray(counterDesc), counterDesc_is_direct ? Buffers.getDirectBufferByteOffset(counterDesc) : Buffers.getIndirectBufferByteOffset(counterDesc), counterDesc_is_direct, counterOffset_is_direct ? counterOffset : Buffers.getArray(counterOffset), counterOffset_is_direct ? Buffers.getDirectBufferByteOffset(counterOffset) : Buffers.getIndirectBufferByteOffset(counterOffset), counterOffset_is_direct, counterDataSize_is_direct ? counterDataSize : Buffers.getArray(counterDataSize), counterDataSize_is_direct ? Buffers.getDirectBufferByteOffset(counterDataSize) : Buffers.getIndirectBufferByteOffset(counterDataSize), counterDataSize_is_direct, counterTypeEnum_is_direct ? counterTypeEnum : Buffers.getArray(counterTypeEnum), counterTypeEnum_is_direct ? Buffers.getDirectBufferByteOffset(counterTypeEnum) : Buffers.getIndirectBufferByteOffset(counterTypeEnum), counterTypeEnum_is_direct, counterDataTypeEnum_is_direct ? counterDataTypeEnum : Buffers.getArray(counterDataTypeEnum), counterDataTypeEnum_is_direct ? Buffers.getDirectBufferByteOffset(counterDataTypeEnum) : Buffers.getIndirectBufferByteOffset(counterDataTypeEnum), counterDataTypeEnum_is_direct, rawCounterMaxValue_is_direct ? rawCounterMaxValue : Buffers.getArray(rawCounterMaxValue), rawCounterMaxValue_is_direct ? Buffers.getDirectBufferByteOffset(rawCounterMaxValue) : Buffers.getIndirectBufferByteOffset(rawCounterMaxValue), rawCounterMaxValue_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfCounterInfoINTEL}(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *  counterName, GLuint counterDescLength, GLchar *  counterDesc, GLuint *  counterOffset, GLuint *  counterDataSize, GLuint *  counterTypeEnum, GLuint *  counterDataTypeEnum, GLuint64 *  rawCounterMaxValue) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param counterName a direct or array-backed {@link java.nio.ByteBuffer}
      @param counterDesc a direct or array-backed {@link java.nio.ByteBuffer}
      @param counterOffset a direct or array-backed {@link java.nio.IntBuffer}
      @param counterDataSize a direct or array-backed {@link java.nio.IntBuffer}
      @param counterTypeEnum a direct or array-backed {@link java.nio.IntBuffer}
      @param counterDataTypeEnum a direct or array-backed {@link java.nio.IntBuffer}
      @param rawCounterMaxValue a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetPerfCounterInfoINTEL1(int queryId, int counterId, int counterNameLength, Object counterName, int counterName_byte_offset, boolean counterName_is_direct, int counterDescLength, Object counterDesc, int counterDesc_byte_offset, boolean counterDesc_is_direct, Object counterOffset, int counterOffset_byte_offset, boolean counterOffset_is_direct, Object counterDataSize, int counterDataSize_byte_offset, boolean counterDataSize_is_direct, Object counterTypeEnum, int counterTypeEnum_byte_offset, boolean counterTypeEnum_is_direct, Object counterDataTypeEnum, int counterDataTypeEnum_byte_offset, boolean counterDataTypeEnum_is_direct, Object rawCounterMaxValue, int rawCounterMaxValue_byte_offset, boolean rawCounterMaxValue_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfCounterInfoINTEL}(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar *  counterName, GLuint counterDescLength, GLchar *  counterDesc, GLuint *  counterOffset, GLuint *  counterDataSize, GLuint *  counterTypeEnum, GLuint *  counterDataTypeEnum, GLuint64 *  rawCounterMaxValue) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glGetPerfCounterInfoINTEL(int queryId, int counterId, int counterNameLength, byte[] counterName, int counterName_offset, int counterDescLength, byte[] counterDesc, int counterDesc_offset, int[] counterOffset, int counterOffset_offset, int[] counterDataSize, int counterDataSize_offset, int[] counterTypeEnum, int counterTypeEnum_offset, int[] counterDataTypeEnum, int counterDataTypeEnum_offset, long[] rawCounterMaxValue, int rawCounterMaxValue_offset)  {

    if(counterName != null && counterName.length <= counterName_offset)
      throw new GLException("array offset argument \"counterName_offset\" (" + counterName_offset + ") equals or exceeds array length (" + counterName.length + ")");
    if(counterDesc != null && counterDesc.length <= counterDesc_offset)
      throw new GLException("array offset argument \"counterDesc_offset\" (" + counterDesc_offset + ") equals or exceeds array length (" + counterDesc.length + ")");
    if(counterOffset != null && counterOffset.length <= counterOffset_offset)
      throw new GLException("array offset argument \"counterOffset_offset\" (" + counterOffset_offset + ") equals or exceeds array length (" + counterOffset.length + ")");
    if(counterDataSize != null && counterDataSize.length <= counterDataSize_offset)
      throw new GLException("array offset argument \"counterDataSize_offset\" (" + counterDataSize_offset + ") equals or exceeds array length (" + counterDataSize.length + ")");
    if(counterTypeEnum != null && counterTypeEnum.length <= counterTypeEnum_offset)
      throw new GLException("array offset argument \"counterTypeEnum_offset\" (" + counterTypeEnum_offset + ") equals or exceeds array length (" + counterTypeEnum.length + ")");
    if(counterDataTypeEnum != null && counterDataTypeEnum.length <= counterDataTypeEnum_offset)
      throw new GLException("array offset argument \"counterDataTypeEnum_offset\" (" + counterDataTypeEnum_offset + ") equals or exceeds array length (" + counterDataTypeEnum.length + ")");
    if(rawCounterMaxValue != null && rawCounterMaxValue.length <= rawCounterMaxValue_offset)
      throw new GLException("array offset argument \"rawCounterMaxValue_offset\" (" + rawCounterMaxValue_offset + ") equals or exceeds array length (" + rawCounterMaxValue.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfCounterInfoINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfCounterInfoINTEL"));
    }
        dispatch_glGetPerfCounterInfoINTEL1(queryId, counterId, counterNameLength, counterName, counterName_offset, false, counterDescLength, counterDesc, counterDesc_offset, false, counterOffset, Buffers.SIZEOF_INT * counterOffset_offset, false, counterDataSize, Buffers.SIZEOF_INT * counterDataSize_offset, false, counterTypeEnum, Buffers.SIZEOF_INT * counterTypeEnum_offset, false, counterDataTypeEnum, Buffers.SIZEOF_INT * counterDataTypeEnum_offset, false, rawCounterMaxValue, Buffers.SIZEOF_LONG * rawCounterMaxValue_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryDataINTEL}(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *  data, GLuint *  bytesWritten) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfQueryDataINTEL(int queryHandle, int flags, int dataSize, Buffer data, IntBuffer bytesWritten)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final boolean bytesWritten_is_direct = Buffers.isDirect(bytesWritten);
    final long __addr_ = _pat._addressof_glGetPerfQueryDataINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryDataINTEL"));
    }
        dispatch_glGetPerfQueryDataINTEL1(queryHandle, flags, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten_is_direct ? bytesWritten : Buffers.getArray(bytesWritten), bytesWritten_is_direct ? Buffers.getDirectBufferByteOffset(bytesWritten) : Buffers.getIndirectBufferByteOffset(bytesWritten), bytesWritten_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryDataINTEL}(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *  data, GLuint *  bytesWritten) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfQueryDataINTEL1(int queryHandle, int flags, int dataSize, Object data, int data_byte_offset, boolean data_is_direct, Object bytesWritten, int bytesWritten_byte_offset, boolean bytesWritten_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfQueryDataINTEL}(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid *  data, GLuint *  bytesWritten) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetPerfQueryDataINTEL(int queryHandle, int flags, int dataSize, Buffer data, int[] bytesWritten, int bytesWritten_offset)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    if(bytesWritten != null && bytesWritten.length <= bytesWritten_offset)
      throw new GLException("array offset argument \"bytesWritten_offset\" (" + bytesWritten_offset + ") equals or exceeds array length (" + bytesWritten.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfQueryDataINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryDataINTEL"));
    }
        dispatch_glGetPerfQueryDataINTEL1(queryHandle, flags, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten, Buffers.SIZEOF_INT * bytesWritten_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryIdByNameINTEL}(GLchar *  queryName, GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryName a direct or array-backed {@link java.nio.ByteBuffer}
      @param queryId a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfQueryIdByNameINTEL(ByteBuffer queryName, IntBuffer queryId)  {

    final boolean queryName_is_direct = Buffers.isDirect(queryName);
    final boolean queryId_is_direct = Buffers.isDirect(queryId);
    final long __addr_ = _pat._addressof_glGetPerfQueryIdByNameINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryIdByNameINTEL"));
    }
        dispatch_glGetPerfQueryIdByNameINTEL1(queryName_is_direct ? queryName : Buffers.getArray(queryName), queryName_is_direct ? Buffers.getDirectBufferByteOffset(queryName) : Buffers.getIndirectBufferByteOffset(queryName), queryName_is_direct, queryId_is_direct ? queryId : Buffers.getArray(queryId), queryId_is_direct ? Buffers.getDirectBufferByteOffset(queryId) : Buffers.getIndirectBufferByteOffset(queryId), queryId_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryIdByNameINTEL}(GLchar *  queryName, GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryName a direct or array-backed {@link java.nio.ByteBuffer}
      @param queryId a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfQueryIdByNameINTEL1(Object queryName, int queryName_byte_offset, boolean queryName_is_direct, Object queryId, int queryId_byte_offset, boolean queryId_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfQueryIdByNameINTEL}(GLchar *  queryName, GLuint *  queryId) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glGetPerfQueryIdByNameINTEL(byte[] queryName, int queryName_offset, int[] queryId, int queryId_offset)  {

    if(queryName != null && queryName.length <= queryName_offset)
      throw new GLException("array offset argument \"queryName_offset\" (" + queryName_offset + ") equals or exceeds array length (" + queryName.length + ")");
    if(queryId != null && queryId.length <= queryId_offset)
      throw new GLException("array offset argument \"queryId_offset\" (" + queryId_offset + ") equals or exceeds array length (" + queryId.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfQueryIdByNameINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryIdByNameINTEL"));
    }
        dispatch_glGetPerfQueryIdByNameINTEL1(queryName, queryName_offset, false, queryId, Buffers.SIZEOF_INT * queryId_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryInfoINTEL}(GLuint queryId, GLuint queryNameLength, GLchar *  queryName, GLuint *  dataSize, GLuint *  noCounters, GLuint *  noInstances, GLuint *  capsMask) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryName a direct or array-backed {@link java.nio.ByteBuffer}
      @param dataSize a direct or array-backed {@link java.nio.IntBuffer}
      @param noCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param noInstances a direct or array-backed {@link java.nio.IntBuffer}
      @param capsMask a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfQueryInfoINTEL(int queryId, int queryNameLength, ByteBuffer queryName, IntBuffer dataSize, IntBuffer noCounters, IntBuffer noInstances, IntBuffer capsMask)  {

    final boolean queryName_is_direct = Buffers.isDirect(queryName);
    final boolean dataSize_is_direct = Buffers.isDirect(dataSize);
    final boolean noCounters_is_direct = Buffers.isDirect(noCounters);
    final boolean noInstances_is_direct = Buffers.isDirect(noInstances);
    final boolean capsMask_is_direct = Buffers.isDirect(capsMask);
    final long __addr_ = _pat._addressof_glGetPerfQueryInfoINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryInfoINTEL"));
    }
        dispatch_glGetPerfQueryInfoINTEL1(queryId, queryNameLength, queryName_is_direct ? queryName : Buffers.getArray(queryName), queryName_is_direct ? Buffers.getDirectBufferByteOffset(queryName) : Buffers.getIndirectBufferByteOffset(queryName), queryName_is_direct, dataSize_is_direct ? dataSize : Buffers.getArray(dataSize), dataSize_is_direct ? Buffers.getDirectBufferByteOffset(dataSize) : Buffers.getIndirectBufferByteOffset(dataSize), dataSize_is_direct, noCounters_is_direct ? noCounters : Buffers.getArray(noCounters), noCounters_is_direct ? Buffers.getDirectBufferByteOffset(noCounters) : Buffers.getIndirectBufferByteOffset(noCounters), noCounters_is_direct, noInstances_is_direct ? noInstances : Buffers.getArray(noInstances), noInstances_is_direct ? Buffers.getDirectBufferByteOffset(noInstances) : Buffers.getIndirectBufferByteOffset(noInstances), noInstances_is_direct, capsMask_is_direct ? capsMask : Buffers.getArray(capsMask), capsMask_is_direct ? Buffers.getDirectBufferByteOffset(capsMask) : Buffers.getIndirectBufferByteOffset(capsMask), capsMask_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfQueryInfoINTEL}(GLuint queryId, GLuint queryNameLength, GLchar *  queryName, GLuint *  dataSize, GLuint *  noCounters, GLuint *  noInstances, GLuint *  capsMask) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>
      @param queryName a direct or array-backed {@link java.nio.ByteBuffer}
      @param dataSize a direct or array-backed {@link java.nio.IntBuffer}
      @param noCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param noInstances a direct or array-backed {@link java.nio.IntBuffer}
      @param capsMask a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfQueryInfoINTEL1(int queryId, int queryNameLength, Object queryName, int queryName_byte_offset, boolean queryName_is_direct, Object dataSize, int dataSize_byte_offset, boolean dataSize_is_direct, Object noCounters, int noCounters_byte_offset, boolean noCounters_is_direct, Object noInstances, int noInstances_byte_offset, boolean noInstances_is_direct, Object capsMask, int capsMask_byte_offset, boolean capsMask_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfQueryInfoINTEL}(GLuint queryId, GLuint queryNameLength, GLchar *  queryName, GLuint *  dataSize, GLuint *  noCounters, GLuint *  noInstances, GLuint *  capsMask) </code> <br>Part of <code>GL_INTEL_performance_query</code><br>   */
  public void glGetPerfQueryInfoINTEL(int queryId, int queryNameLength, byte[] queryName, int queryName_offset, int[] dataSize, int dataSize_offset, int[] noCounters, int noCounters_offset, int[] noInstances, int noInstances_offset, int[] capsMask, int capsMask_offset)  {

    if(queryName != null && queryName.length <= queryName_offset)
      throw new GLException("array offset argument \"queryName_offset\" (" + queryName_offset + ") equals or exceeds array length (" + queryName.length + ")");
    if(dataSize != null && dataSize.length <= dataSize_offset)
      throw new GLException("array offset argument \"dataSize_offset\" (" + dataSize_offset + ") equals or exceeds array length (" + dataSize.length + ")");
    if(noCounters != null && noCounters.length <= noCounters_offset)
      throw new GLException("array offset argument \"noCounters_offset\" (" + noCounters_offset + ") equals or exceeds array length (" + noCounters.length + ")");
    if(noInstances != null && noInstances.length <= noInstances_offset)
      throw new GLException("array offset argument \"noInstances_offset\" (" + noInstances_offset + ") equals or exceeds array length (" + noInstances.length + ")");
    if(capsMask != null && capsMask.length <= capsMask_offset)
      throw new GLException("array offset argument \"capsMask_offset\" (" + capsMask_offset + ") equals or exceeds array length (" + capsMask.length + ")");
    final long __addr_ = _pat._addressof_glGetPerfQueryInfoINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfQueryInfoINTEL"));
    }
        dispatch_glGetPerfQueryInfoINTEL1(queryId, queryNameLength, queryName, queryName_offset, false, dataSize, Buffers.SIZEOF_INT * dataSize_offset, false, noCounters, Buffers.SIZEOF_INT * noCounters_offset, false, noInstances, Buffers.SIZEOF_INT * noInstances_offset, false, capsMask, Buffers.SIZEOF_INT * capsMask_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginConditionalRenderNVX}(GLuint id) </code> <br>Part of <code>GL_NVX_conditional_render</code><br>   */
  public void glBeginConditionalRenderNVX(int id)  {

    final long __addr_ = _pat._addressof_glBeginConditionalRenderNVX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginConditionalRenderNVX"));
    }
        dispatch_glBeginConditionalRenderNVX1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginConditionalRenderNVX}(GLuint id) </code> <br>Part of <code>GL_NVX_conditional_render</code><br>   */
  private native void dispatch_glBeginConditionalRenderNVX1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndConditionalRenderNVX}(void) </code> <br>Part of <code>GL_NVX_conditional_render</code><br>   */
  public void glEndConditionalRenderNVX()  {

    final long __addr_ = _pat._addressof_glEndConditionalRenderNVX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndConditionalRenderNVX"));
    }
        dispatch_glEndConditionalRenderNVX1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndConditionalRenderNVX}(void) </code> <br>Part of <code>GL_NVX_conditional_render</code><br>   */
  private native void dispatch_glEndConditionalRenderNVX1(long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectBindlessNV}(GLenum mode, const void *  indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirectBindlessNV(int mode, Buffer indirect, int drawCount, int stride, int vertexBufferCount)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirectBindlessNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectBindlessNV"));
    }
        dispatch_glMultiDrawArraysIndirectBindlessNV1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawCount, stride, vertexBufferCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectBindlessNV}(GLenum mode, const void *  indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirectBindlessNV1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawCount, int stride, int vertexBufferCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectBindlessNV}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirectBindlessNV(int mode, int type, Buffer indirect, int drawCount, int stride, int vertexBufferCount)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirectBindlessNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectBindlessNV"));
    }
        dispatch_glMultiDrawElementsIndirectBindlessNV1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawCount, stride, vertexBufferCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectBindlessNV}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirectBindlessNV1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawCount, int stride, int vertexBufferCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectBindlessCountNV}(GLenum mode, const void *  indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect_count</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirectBindlessCountNV(int mode, Buffer indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirectBindlessCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectBindlessCountNV"));
    }
        dispatch_glMultiDrawArraysIndirectBindlessCountNV1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawCount, maxDrawCount, stride, vertexBufferCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectBindlessCountNV}(GLenum mode, const void *  indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect_count</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirectBindlessCountNV1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawCount, int maxDrawCount, int stride, int vertexBufferCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectBindlessCountNV}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect_count</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirectBindlessCountNV(int mode, int type, Buffer indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirectBindlessCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectBindlessCountNV"));
    }
        dispatch_glMultiDrawElementsIndirectBindlessCountNV1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawCount, maxDrawCount, stride, vertexBufferCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectBindlessCountNV}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) </code> <br>Part of <code>GL_NV_bindless_multi_draw_indirect_count</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirectBindlessCountNV1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawCount, int maxDrawCount, int stride, int vertexBufferCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateStatesNV}(GLsizei n, GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param states a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateStatesNV(int n, IntBuffer states)  {

    final boolean states_is_direct = Buffers.isDirect(states);
    final long __addr_ = _pat._addressof_glCreateStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateStatesNV"));
    }
        dispatch_glCreateStatesNV1(n, states_is_direct ? states : Buffers.getArray(states), states_is_direct ? Buffers.getDirectBufferByteOffset(states) : Buffers.getIndirectBufferByteOffset(states), states_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateStatesNV}(GLsizei n, GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param states a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateStatesNV1(int n, Object states, int states_byte_offset, boolean states_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateStatesNV}(GLsizei n, GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glCreateStatesNV(int n, int[] states, int states_offset)  {

    if(states != null && states.length <= states_offset)
      throw new GLException("array offset argument \"states_offset\" (" + states_offset + ") equals or exceeds array length (" + states.length + ")");
    final long __addr_ = _pat._addressof_glCreateStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateStatesNV"));
    }
        dispatch_glCreateStatesNV1(n, states, Buffers.SIZEOF_INT * states_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteStatesNV}(GLsizei n, const GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param states a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteStatesNV(int n, IntBuffer states)  {

    final boolean states_is_direct = Buffers.isDirect(states);
    final long __addr_ = _pat._addressof_glDeleteStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteStatesNV"));
    }
        dispatch_glDeleteStatesNV1(n, states_is_direct ? states : Buffers.getArray(states), states_is_direct ? Buffers.getDirectBufferByteOffset(states) : Buffers.getIndirectBufferByteOffset(states), states_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteStatesNV}(GLsizei n, const GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param states a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteStatesNV1(int n, Object states, int states_byte_offset, boolean states_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteStatesNV}(GLsizei n, const GLuint *  states) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glDeleteStatesNV(int n, int[] states, int states_offset)  {

    if(states != null && states.length <= states_offset)
      throw new GLException("array offset argument \"states_offset\" (" + states_offset + ") equals or exceeds array length (" + states.length + ")");
    final long __addr_ = _pat._addressof_glDeleteStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteStatesNV"));
    }
        dispatch_glDeleteStatesNV1(n, states, Buffers.SIZEOF_INT * states_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsStateNV}(GLuint state) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public boolean glIsStateNV(int state)  {

    final long __addr_ = _pat._addressof_glIsStateNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsStateNV"));
    }
        return dispatch_glIsStateNV1(state, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsStateNV}(GLuint state) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native boolean dispatch_glIsStateNV1(int state, long procAddress);

  /** Entry point to C language function: <code> void {@native glStateCaptureNV}(GLuint state, GLenum mode) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glStateCaptureNV(int state, int mode)  {

    final long __addr_ = _pat._addressof_glStateCaptureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStateCaptureNV"));
    }
        dispatch_glStateCaptureNV1(state, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStateCaptureNV}(GLuint state, GLenum mode) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native void dispatch_glStateCaptureNV1(int state, int mode, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetCommandHeaderNV}(GLenum tokenID, GLuint size) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public int glGetCommandHeaderNV(int tokenID, int size)  {

    final long __addr_ = _pat._addressof_glGetCommandHeaderNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCommandHeaderNV"));
    }
        return dispatch_glGetCommandHeaderNV1(tokenID, size, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetCommandHeaderNV}(GLenum tokenID, GLuint size) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native int dispatch_glGetCommandHeaderNV1(int tokenID, int size, long procAddress);

  /** Entry point to C language function: <code> GLushort {@native glGetStageIndexNV}(GLenum shadertype) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public short glGetStageIndexNV(int shadertype)  {

    final long __addr_ = _pat._addressof_glGetStageIndexNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetStageIndexNV"));
    }
        return dispatch_glGetStageIndexNV1(shadertype, __addr_);
  }

  /** Entry point to C language function: <code> GLushort {@native glGetStageIndexNV}(GLenum shadertype) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native short dispatch_glGetStageIndexNV1(int shadertype, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawCommandsNV}(GLenum primitiveMode, GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawCommandsNV(int primitiveMode, int buffer, PointerBuffer indirects, IntBuffer sizes, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = _pat._addressof_glDrawCommandsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsNV"));
    }
        dispatch_glDrawCommandsNV1(primitiveMode, buffer, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsNV}(GLenum primitiveMode, GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawCommandsNV1(int primitiveMode, int buffer, Object indirects, int indirects_byte_offset, boolean indirects_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawCommandsNV}(GLenum primitiveMode, GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glDrawCommandsNV(int primitiveMode, int buffer, PointerBuffer indirects, int[] sizes, int sizes_offset, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    if(sizes != null && sizes.length <= sizes_offset)
      throw new GLException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    final long __addr_ = _pat._addressof_glDrawCommandsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsNV"));
    }
        dispatch_glDrawCommandsNV1(primitiveMode, buffer, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes, Buffers.SIZEOF_INT * sizes_offset, false, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsAddressNV}(GLenum primitiveMode, const GLuint64 *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link java.nio.LongBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawCommandsAddressNV(int primitiveMode, LongBuffer indirects, IntBuffer sizes, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = _pat._addressof_glDrawCommandsAddressNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsAddressNV"));
    }
        dispatch_glDrawCommandsAddressNV1(primitiveMode, indirects_is_direct ? indirects : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsAddressNV}(GLenum primitiveMode, const GLuint64 *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link java.nio.LongBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawCommandsAddressNV1(int primitiveMode, Object indirects, int indirects_byte_offset, boolean indirects_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawCommandsAddressNV}(GLenum primitiveMode, const GLuint64 *  indirects, const GLsizei *  sizes, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glDrawCommandsAddressNV(int primitiveMode, long[] indirects, int indirects_offset, int[] sizes, int sizes_offset, int count)  {

    if(indirects != null && indirects.length <= indirects_offset)
      throw new GLException("array offset argument \"indirects_offset\" (" + indirects_offset + ") equals or exceeds array length (" + indirects.length + ")");
    if(sizes != null && sizes.length <= sizes_offset)
      throw new GLException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    final long __addr_ = _pat._addressof_glDrawCommandsAddressNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsAddressNV"));
    }
        dispatch_glDrawCommandsAddressNV1(primitiveMode, indirects, Buffers.SIZEOF_LONG * indirects_offset, false, sizes, Buffers.SIZEOF_INT * sizes_offset, false, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesNV}(GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawCommandsStatesNV(int buffer, PointerBuffer indirects, IntBuffer sizes, IntBuffer states, IntBuffer fbos, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final boolean states_is_direct = Buffers.isDirect(states);
    final boolean fbos_is_direct = Buffers.isDirect(fbos);
    final long __addr_ = _pat._addressof_glDrawCommandsStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesNV"));
    }
        dispatch_glDrawCommandsStatesNV1(buffer, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, states_is_direct ? states : Buffers.getArray(states), states_is_direct ? Buffers.getDirectBufferByteOffset(states) : Buffers.getIndirectBufferByteOffset(states), states_is_direct, fbos_is_direct ? fbos : Buffers.getArray(fbos), fbos_is_direct ? Buffers.getDirectBufferByteOffset(fbos) : Buffers.getIndirectBufferByteOffset(fbos), fbos_is_direct, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesNV}(GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawCommandsStatesNV1(int buffer, Object indirects, int indirects_byte_offset, boolean indirects_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, Object states, int states_byte_offset, boolean states_is_direct, Object fbos, int fbos_byte_offset, boolean fbos_is_direct, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesNV}(GLuint buffer, const GLintptr *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glDrawCommandsStatesNV(int buffer, PointerBuffer indirects, int[] sizes, int sizes_offset, int[] states, int states_offset, int[] fbos, int fbos_offset, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    if(sizes != null && sizes.length <= sizes_offset)
      throw new GLException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    if(states != null && states.length <= states_offset)
      throw new GLException("array offset argument \"states_offset\" (" + states_offset + ") equals or exceeds array length (" + states.length + ")");
    if(fbos != null && fbos.length <= fbos_offset)
      throw new GLException("array offset argument \"fbos_offset\" (" + fbos_offset + ") equals or exceeds array length (" + fbos.length + ")");
    final long __addr_ = _pat._addressof_glDrawCommandsStatesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesNV"));
    }
        dispatch_glDrawCommandsStatesNV1(buffer, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes, Buffers.SIZEOF_INT * sizes_offset, false, states, Buffers.SIZEOF_INT * states_offset, false, fbos, Buffers.SIZEOF_INT * fbos_offset, false, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesAddressNV}(const GLuint64 *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link java.nio.LongBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawCommandsStatesAddressNV(LongBuffer indirects, IntBuffer sizes, IntBuffer states, IntBuffer fbos, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final boolean states_is_direct = Buffers.isDirect(states);
    final boolean fbos_is_direct = Buffers.isDirect(fbos);
    final long __addr_ = _pat._addressof_glDrawCommandsStatesAddressNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesAddressNV"));
    }
        dispatch_glDrawCommandsStatesAddressNV1(indirects_is_direct ? indirects : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, states_is_direct ? states : Buffers.getArray(states), states_is_direct ? Buffers.getDirectBufferByteOffset(states) : Buffers.getIndirectBufferByteOffset(states), states_is_direct, fbos_is_direct ? fbos : Buffers.getArray(fbos), fbos_is_direct ? Buffers.getDirectBufferByteOffset(fbos) : Buffers.getIndirectBufferByteOffset(fbos), fbos_is_direct, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesAddressNV}(const GLuint64 *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link java.nio.LongBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawCommandsStatesAddressNV1(Object indirects, int indirects_byte_offset, boolean indirects_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, Object states, int states_byte_offset, boolean states_is_direct, Object fbos, int fbos_byte_offset, boolean fbos_is_direct, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawCommandsStatesAddressNV}(const GLuint64 *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glDrawCommandsStatesAddressNV(long[] indirects, int indirects_offset, int[] sizes, int sizes_offset, int[] states, int states_offset, int[] fbos, int fbos_offset, int count)  {

    if(indirects != null && indirects.length <= indirects_offset)
      throw new GLException("array offset argument \"indirects_offset\" (" + indirects_offset + ") equals or exceeds array length (" + indirects.length + ")");
    if(sizes != null && sizes.length <= sizes_offset)
      throw new GLException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    if(states != null && states.length <= states_offset)
      throw new GLException("array offset argument \"states_offset\" (" + states_offset + ") equals or exceeds array length (" + states.length + ")");
    if(fbos != null && fbos.length <= fbos_offset)
      throw new GLException("array offset argument \"fbos_offset\" (" + fbos_offset + ") equals or exceeds array length (" + fbos.length + ")");
    final long __addr_ = _pat._addressof_glDrawCommandsStatesAddressNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawCommandsStatesAddressNV"));
    }
        dispatch_glDrawCommandsStatesAddressNV1(indirects, Buffers.SIZEOF_LONG * indirects_offset, false, sizes, Buffers.SIZEOF_INT * sizes_offset, false, states, Buffers.SIZEOF_INT * states_offset, false, fbos, Buffers.SIZEOF_INT * fbos_offset, false, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateCommandListsNV}(GLsizei n, GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param lists a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glCreateCommandListsNV(int n, IntBuffer lists)  {

    final boolean lists_is_direct = Buffers.isDirect(lists);
    final long __addr_ = _pat._addressof_glCreateCommandListsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateCommandListsNV"));
    }
        dispatch_glCreateCommandListsNV1(n, lists_is_direct ? lists : Buffers.getArray(lists), lists_is_direct ? Buffers.getDirectBufferByteOffset(lists) : Buffers.getIndirectBufferByteOffset(lists), lists_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCreateCommandListsNV}(GLsizei n, GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param lists a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glCreateCommandListsNV1(int n, Object lists, int lists_byte_offset, boolean lists_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCreateCommandListsNV}(GLsizei n, GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glCreateCommandListsNV(int n, int[] lists, int lists_offset)  {

    if(lists != null && lists.length <= lists_offset)
      throw new GLException("array offset argument \"lists_offset\" (" + lists_offset + ") equals or exceeds array length (" + lists.length + ")");
    final long __addr_ = _pat._addressof_glCreateCommandListsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateCommandListsNV"));
    }
        dispatch_glCreateCommandListsNV1(n, lists, Buffers.SIZEOF_INT * lists_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteCommandListsNV}(GLsizei n, const GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param lists a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteCommandListsNV(int n, IntBuffer lists)  {

    final boolean lists_is_direct = Buffers.isDirect(lists);
    final long __addr_ = _pat._addressof_glDeleteCommandListsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteCommandListsNV"));
    }
        dispatch_glDeleteCommandListsNV1(n, lists_is_direct ? lists : Buffers.getArray(lists), lists_is_direct ? Buffers.getDirectBufferByteOffset(lists) : Buffers.getIndirectBufferByteOffset(lists), lists_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteCommandListsNV}(GLsizei n, const GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param lists a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteCommandListsNV1(int n, Object lists, int lists_byte_offset, boolean lists_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteCommandListsNV}(GLsizei n, const GLuint *  lists) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glDeleteCommandListsNV(int n, int[] lists, int lists_offset)  {

    if(lists != null && lists.length <= lists_offset)
      throw new GLException("array offset argument \"lists_offset\" (" + lists_offset + ") equals or exceeds array length (" + lists.length + ")");
    final long __addr_ = _pat._addressof_glDeleteCommandListsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteCommandListsNV"));
    }
        dispatch_glDeleteCommandListsNV1(n, lists, Buffers.SIZEOF_INT * lists_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public boolean glIsCommandListNV(int list)  {

    final long __addr_ = _pat._addressof_glIsCommandListNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsCommandListNV"));
    }
        return dispatch_glIsCommandListNV1(list, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native boolean dispatch_glIsCommandListNV1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glListDrawCommandsStatesClientNV}(GLuint list, GLuint segment, const void *  *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glListDrawCommandsStatesClientNV(int list, int segment, PointerBuffer indirects, IntBuffer sizes, IntBuffer states, IntBuffer fbos, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final boolean states_is_direct = Buffers.isDirect(states);
    final boolean fbos_is_direct = Buffers.isDirect(fbos);
    final long __addr_ = _pat._addressof_glListDrawCommandsStatesClientNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glListDrawCommandsStatesClientNV"));
    }
        dispatch_glListDrawCommandsStatesClientNV1(list, segment, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, states_is_direct ? states : Buffers.getArray(states), states_is_direct ? Buffers.getDirectBufferByteOffset(states) : Buffers.getIndirectBufferByteOffset(states), states_is_direct, fbos_is_direct ? fbos : Buffers.getArray(fbos), fbos_is_direct ? Buffers.getDirectBufferByteOffset(fbos) : Buffers.getIndirectBufferByteOffset(fbos), fbos_is_direct, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glListDrawCommandsStatesClientNV}(GLuint list, GLuint segment, const void *  *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}
      @param states a direct or array-backed {@link java.nio.IntBuffer}
      @param fbos a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glListDrawCommandsStatesClientNV1(int list, int segment, Object indirects, int indirects_byte_offset, boolean indirects_is_direct, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, Object states, int states_byte_offset, boolean states_is_direct, Object fbos, int fbos_byte_offset, boolean fbos_is_direct, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glListDrawCommandsStatesClientNV}(GLuint list, GLuint segment, const void *  *  indirects, const GLsizei *  sizes, const GLuint *  states, const GLuint *  fbos, GLuint count) </code> <br>Part of <code>GL_NV_command_list</code><br>
      @param indirects a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glListDrawCommandsStatesClientNV(int list, int segment, PointerBuffer indirects, int[] sizes, int sizes_offset, int[] states, int states_offset, int[] fbos, int fbos_offset, int count)  {

    final boolean indirects_is_direct = Buffers.isDirect(indirects);
    if(sizes != null && sizes.length <= sizes_offset)
      throw new GLException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    if(states != null && states.length <= states_offset)
      throw new GLException("array offset argument \"states_offset\" (" + states_offset + ") equals or exceeds array length (" + states.length + ")");
    if(fbos != null && fbos.length <= fbos_offset)
      throw new GLException("array offset argument \"fbos_offset\" (" + fbos_offset + ") equals or exceeds array length (" + fbos.length + ")");
    final long __addr_ = _pat._addressof_glListDrawCommandsStatesClientNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glListDrawCommandsStatesClientNV"));
    }
        dispatch_glListDrawCommandsStatesClientNV1(list, segment, indirects_is_direct ? ( indirects != null ? indirects.getBuffer() : null ) : Buffers.getArray(indirects), indirects_is_direct ? Buffers.getDirectBufferByteOffset(indirects) : Buffers.getIndirectBufferByteOffset(indirects), indirects_is_direct, sizes, Buffers.SIZEOF_INT * sizes_offset, false, states, Buffers.SIZEOF_INT * states_offset, false, fbos, Buffers.SIZEOF_INT * fbos_offset, false, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCommandListSegmentsNV}(GLuint list, GLuint segments) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glCommandListSegmentsNV(int list, int segments)  {

    final long __addr_ = _pat._addressof_glCommandListSegmentsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCommandListSegmentsNV"));
    }
        dispatch_glCommandListSegmentsNV1(list, segments, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCommandListSegmentsNV}(GLuint list, GLuint segments) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native void dispatch_glCommandListSegmentsNV1(int list, int segments, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glCompileCommandListNV(int list)  {

    final long __addr_ = _pat._addressof_glCompileCommandListNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileCommandListNV"));
    }
        dispatch_glCompileCommandListNV1(list, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native void dispatch_glCompileCommandListNV1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glCallCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  public void glCallCommandListNV(int list)  {

    final long __addr_ = _pat._addressof_glCallCommandListNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCallCommandListNV"));
    }
        dispatch_glCallCommandListNV1(list, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCallCommandListNV}(GLuint list) </code> <br>Part of <code>GL_NV_command_list</code><br>   */
  private native void dispatch_glCallCommandListNV1(int list, long procAddress);

  /** Entry point to C language function: <code> void {@native glSubpixelPrecisionBiasNV}(GLuint xbits, GLuint ybits) </code> <br>Part of <code>GL_NV_conservative_raster</code><br>   */
  public void glSubpixelPrecisionBiasNV(int xbits, int ybits)  {

    final long __addr_ = _pat._addressof_glSubpixelPrecisionBiasNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSubpixelPrecisionBiasNV"));
    }
        dispatch_glSubpixelPrecisionBiasNV1(xbits, ybits, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSubpixelPrecisionBiasNV}(GLuint xbits, GLuint ybits) </code> <br>Part of <code>GL_NV_conservative_raster</code><br>   */
  private native void dispatch_glSubpixelPrecisionBiasNV1(int xbits, int ybits, long procAddress);

  /** Entry point to C language function: <code> void {@native glConservativeRasterParameterfNV}(GLenum pname, GLfloat value) </code> <br>Part of <code>GL_NV_conservative_raster_dilate</code><br>   */
  public void glConservativeRasterParameterfNV(int pname, float value)  {

    final long __addr_ = _pat._addressof_glConservativeRasterParameterfNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glConservativeRasterParameterfNV"));
    }
        dispatch_glConservativeRasterParameterfNV1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glConservativeRasterParameterfNV}(GLenum pname, GLfloat value) </code> <br>Part of <code>GL_NV_conservative_raster_dilate</code><br>   */
  private native void dispatch_glConservativeRasterParameterfNV1(int pname, float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyImageSubDataNV}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_NV_copy_image</code><br>   */
  public void glCopyImageSubDataNV(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyImageSubDataNV"));
    }
        dispatch_glCopyImageSubDataNV1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyImageSubDataNV}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_NV_copy_image</code><br>   */
  private native void dispatch_glCopyImageSubDataNV1(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTextureNV}(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) </code> <br>Part of <code>GL_NV_draw_texture</code><br>   */
  public void glDrawTextureNV(int texture, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)  {

    final long __addr_ = _pat._addressof_glDrawTextureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTextureNV"));
    }
        dispatch_glDrawTextureNV1(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTextureNV}(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) </code> <br>Part of <code>GL_NV_draw_texture</code><br>   */
  private native void dispatch_glDrawTextureNV1(int texture, int sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *  points) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  public void glMapControlPointsNV(int target, int index, int type, int ustride, int vstride, int uorder, int vorder, boolean packed, Buffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glMapControlPointsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapControlPointsNV"));
    }
        dispatch_glMapControlPointsNV1(target, index, type, ustride, vstride, uorder, vorder, packed, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *  points) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMapControlPointsNV1(int target, int index, int type, int ustride, int vstride, int uorder, int vorder, boolean packed, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMapParameterivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapParameterivNV"));
    }
        dispatch_glMapParameterivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMapParameterivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterivNV}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glMapParameterivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapParameterivNV"));
    }
        dispatch_glMapParameterivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMapParameterfvNV(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapParameterfvNV"));
    }
        dispatch_glMapParameterfvNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMapParameterfvNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMapParameterfvNV}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glMapParameterfvNV(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapParameterfvNV"));
    }
        dispatch_glMapParameterfvNV1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *  points) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetMapControlPointsNV(int target, int index, int type, int ustride, int vstride, boolean packed, Buffer points)  {

    final boolean points_is_direct = Buffers.isDirect(points);
    final long __addr_ = _pat._addressof_glGetMapControlPointsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapControlPointsNV"));
    }
        dispatch_glGetMapControlPointsNV1(target, index, type, ustride, vstride, packed, points_is_direct ? points : Buffers.getArray(points), points_is_direct ? Buffers.getDirectBufferByteOffset(points) : Buffers.getIndirectBufferByteOffset(points), points_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapControlPointsNV}(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *  points) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param points a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetMapControlPointsNV1(int target, int index, int type, int ustride, int vstride, boolean packed, Object points, int points_byte_offset, boolean points_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapParameterivNV(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterivNV"));
    }
        dispatch_glGetMapParameterivNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapParameterivNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterivNV}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glGetMapParameterivNV(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMapParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterivNV"));
    }
        dispatch_glGetMapParameterivNV1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapParameterfvNV(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterfvNV"));
    }
        dispatch_glGetMapParameterfvNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapParameterfvNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapParameterfvNV}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glGetMapParameterfvNV(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMapParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapParameterfvNV"));
    }
        dispatch_glGetMapParameterfvNV1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMapAttribParameterivNV(int target, int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMapAttribParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterivNV"));
    }
        dispatch_glGetMapAttribParameterivNV1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMapAttribParameterivNV1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterivNV}(GLenum target, GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glGetMapAttribParameterivNV(int target, int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMapAttribParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterivNV"));
    }
        dispatch_glGetMapAttribParameterivNV1(target, index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMapAttribParameterfvNV(int target, int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMapAttribParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterfvNV"));
    }
        dispatch_glGetMapAttribParameterfvNV1(target, index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMapAttribParameterfvNV1(int target, int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMapAttribParameterfvNV}(GLenum target, GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glGetMapAttribParameterfvNV(int target, int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMapAttribParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMapAttribParameterfvNV"));
    }
        dispatch_glGetMapAttribParameterfvNV1(target, index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMapsNV}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  public void glEvalMapsNV(int target, int mode)  {

    final long __addr_ = _pat._addressof_glEvalMapsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEvalMapsNV"));
    }
        dispatch_glEvalMapsNV1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEvalMapsNV}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_NV_evaluators</code><br>   */
  private native void dispatch_glEvalMapsNV1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultisamplefvNV(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = _pat._addressof_glGetMultisamplefvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefvNV"));
    }
        dispatch_glGetMultisamplefvNV1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultisamplefvNV1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefvNV}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>   */
  public void glGetMultisamplefvNV(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = _pat._addressof_glGetMultisamplefvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefvNV"));
    }
        dispatch_glGetMultisamplefvNV1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaskIndexedNV}(GLuint index, GLbitfield mask) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>   */
  public void glSampleMaskIndexedNV(int index, int mask)  {

    final long __addr_ = _pat._addressof_glSampleMaskIndexedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleMaskIndexedNV"));
    }
        dispatch_glSampleMaskIndexedNV1(index, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaskIndexedNV}(GLuint index, GLbitfield mask) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>   */
  private native void dispatch_glSampleMaskIndexedNV1(int index, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexRenderbufferNV}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>   */
  public void glTexRenderbufferNV(int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glTexRenderbufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexRenderbufferNV"));
    }
        dispatch_glTexRenderbufferNV1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexRenderbufferNV}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_NV_explicit_multisample</code><br>   */
  private native void dispatch_glTexRenderbufferNV1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFragmentCoverageColorNV}(GLuint color) </code> <br>Part of <code>GL_NV_fragment_coverage_to_color</code><br>   */
  public void glFragmentCoverageColorNV(int color)  {

    final long __addr_ = _pat._addressof_glFragmentCoverageColorNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFragmentCoverageColorNV"));
    }
        dispatch_glFragmentCoverageColorNV1(color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFragmentCoverageColorNV}(GLuint color) </code> <br>Part of <code>GL_NV_fragment_coverage_to_color</code><br>   */
  private native void dispatch_glFragmentCoverageColorNV1(int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glCoverageModulationTableNV(int n, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
    }
        dispatch_glCoverageModulationTableNV1(n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glCoverageModulationTableNV1(int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glCoverageModulationTableNV(int n, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
    }
        dispatch_glCoverageModulationTableNV1(n, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetCoverageModulationTableNV(int bufsize, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
    }
        dispatch_glGetCoverageModulationTableNV1(bufsize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetCoverageModulationTableNV1(int bufsize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glGetCoverageModulationTableNV(int bufsize, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
    }
        dispatch_glGetCoverageModulationTableNV1(bufsize, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationNV}(GLenum components) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glCoverageModulationNV(int components)  {

    final long __addr_ = _pat._addressof_glCoverageModulationNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationNV"));
    }
        dispatch_glCoverageModulationNV1(components, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationNV}(GLenum components) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  private native void dispatch_glCoverageModulationNV1(int components, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_framebuffer_multisample_coverage</code><br>   */
  public void glRenderbufferStorageMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleCoverageNV"));
    }
        dispatch_glRenderbufferStorageMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_framebuffer_multisample_coverage</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramVertexLimitNV}(GLenum target, GLint limit) </code> <br>Part of <code>GL_NV_geometry_program4</code><br>   */
  public void glProgramVertexLimitNV(int target, int limit)  {

    final long __addr_ = _pat._addressof_glProgramVertexLimitNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramVertexLimitNV"));
    }
        dispatch_glProgramVertexLimitNV1(target, limit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramVertexLimitNV}(GLenum target, GLint limit) </code> <br>Part of <code>GL_NV_geometry_program4</code><br>   */
  private native void dispatch_glProgramVertexLimitNV1(int target, int limit, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code><br>   */
  public void glFramebufferTextureEXT(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureEXT"));
    }
        dispatch_glFramebufferTextureEXT1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code><br>   */
  private native void dispatch_glFramebufferTextureEXT1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_NV_geometry_program4</code><br>   */
  public void glFramebufferTextureFaceEXT(int target, int attachment, int texture, int level, int face)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureFaceEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureFaceEXT"));
    }
        dispatch_glFramebufferTextureFaceEXT1(target, attachment, texture, level, face, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureFaceEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) </code> <br>Part of <code>GL_NV_geometry_program4</code><br>   */
  private native void dispatch_glFramebufferTextureFaceEXT1(int target, int attachment, int texture, int level, int face, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParameterI4iNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glProgramLocalParameterI4iNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4iNV"));
    }
        dispatch_glProgramLocalParameterI4iNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  private native void dispatch_glProgramLocalParameterI4iNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParameterI4ivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4ivNV"));
    }
        dispatch_glProgramLocalParameterI4ivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParameterI4ivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParameterI4ivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4ivNV"));
    }
        dispatch_glProgramLocalParameterI4ivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParametersI4ivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4ivNV"));
    }
        dispatch_glProgramLocalParametersI4ivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParametersI4ivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParametersI4ivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4ivNV"));
    }
        dispatch_glProgramLocalParametersI4ivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParameterI4uiNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glProgramLocalParameterI4uiNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uiNV"));
    }
        dispatch_glProgramLocalParameterI4uiNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  private native void dispatch_glProgramLocalParameterI4uiNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParameterI4uivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uivNV"));
    }
        dispatch_glProgramLocalParameterI4uivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParameterI4uivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParameterI4uivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParameterI4uivNV"));
    }
        dispatch_glProgramLocalParameterI4uivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramLocalParametersI4uivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramLocalParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4uivNV"));
    }
        dispatch_glProgramLocalParametersI4uivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramLocalParametersI4uivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramLocalParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramLocalParametersI4uivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramLocalParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramLocalParametersI4uivNV"));
    }
        dispatch_glProgramLocalParametersI4uivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParameterI4iNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glProgramEnvParameterI4iNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4iNV"));
    }
        dispatch_glProgramEnvParameterI4iNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4iNV}(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  private native void dispatch_glProgramEnvParameterI4iNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParameterI4ivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4ivNV"));
    }
        dispatch_glProgramEnvParameterI4ivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParameterI4ivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4ivNV}(GLenum target, GLuint index, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParameterI4ivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParameterI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4ivNV"));
    }
        dispatch_glProgramEnvParameterI4ivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParametersI4ivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4ivNV"));
    }
        dispatch_glProgramEnvParametersI4ivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParametersI4ivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4ivNV}(GLenum target, GLuint index, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParametersI4ivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParametersI4ivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4ivNV"));
    }
        dispatch_glProgramEnvParametersI4ivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParameterI4uiNV(int target, int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glProgramEnvParameterI4uiNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uiNV"));
    }
        dispatch_glProgramEnvParameterI4uiNV1(target, index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uiNV}(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  private native void dispatch_glProgramEnvParameterI4uiNV1(int target, int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParameterI4uivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uivNV"));
    }
        dispatch_glProgramEnvParameterI4uivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParameterI4uivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParameterI4uivNV}(GLenum target, GLuint index, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParameterI4uivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParameterI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParameterI4uivNV"));
    }
        dispatch_glProgramEnvParameterI4uivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramEnvParametersI4uivNV(int target, int index, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramEnvParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4uivNV"));
    }
        dispatch_glProgramEnvParametersI4uivNV1(target, index, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramEnvParametersI4uivNV1(int target, int index, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramEnvParametersI4uivNV}(GLenum target, GLuint index, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glProgramEnvParametersI4uivNV(int target, int index, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramEnvParametersI4uivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramEnvParametersI4uivNV"));
    }
        dispatch_glProgramEnvParametersI4uivNV1(target, index, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramLocalParameterIivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIivNV"));
    }
        dispatch_glGetProgramLocalParameterIivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramLocalParameterIivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glGetProgramLocalParameterIivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIivNV"));
    }
        dispatch_glGetProgramLocalParameterIivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramLocalParameterIuivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIuivNV"));
    }
        dispatch_glGetProgramLocalParameterIuivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramLocalParameterIuivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramLocalParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glGetProgramLocalParameterIuivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramLocalParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramLocalParameterIuivNV"));
    }
        dispatch_glGetProgramLocalParameterIuivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramEnvParameterIivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIivNV"));
    }
        dispatch_glGetProgramEnvParameterIivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramEnvParameterIivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIivNV}(GLenum target, GLuint index, GLint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glGetProgramEnvParameterIivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIivNV"));
    }
        dispatch_glGetProgramEnvParameterIivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramEnvParameterIuivNV(int target, int index, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIuivNV"));
    }
        dispatch_glGetProgramEnvParameterIuivNV1(target, index, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramEnvParameterIuivNV1(int target, int index, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramEnvParameterIuivNV}(GLenum target, GLuint index, GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program4</code><br>   */
  public void glGetProgramEnvParameterIuivNV(int target, int index, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramEnvParameterIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramEnvParameterIuivNV"));
    }
        dispatch_glGetProgramEnvParameterIuivNV1(target, index, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramSubroutineParametersuivNV(int target, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramSubroutineParametersuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramSubroutineParametersuivNV"));
    }
        dispatch_glProgramSubroutineParametersuivNV1(target, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramSubroutineParametersuivNV1(int target, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramSubroutineParametersuivNV}(GLenum target, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>   */
  public void glProgramSubroutineParametersuivNV(int target, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramSubroutineParametersuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramSubroutineParametersuivNV"));
    }
        dispatch_glProgramSubroutineParametersuivNV1(target, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramSubroutineParameteruivNV(int target, int index, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glGetProgramSubroutineParameteruivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramSubroutineParameteruivNV"));
    }
        dispatch_glGetProgramSubroutineParameteruivNV1(target, index, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramSubroutineParameteruivNV1(int target, int index, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramSubroutineParameteruivNV}(GLenum target, GLuint index, GLuint *  param) </code> <br>Part of <code>GL_NV_gpu_program5</code><br>   */
  public void glGetProgramSubroutineParameteruivNV(int target, int index, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramSubroutineParameteruivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramSubroutineParameteruivNV"));
    }
        dispatch_glGetProgramSubroutineParameteruivNV1(target, index, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2h}(GLhalfNV x, GLhalfNV y) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex2hNV</code>   */
  public void glVertex2h(short x, short y)  {

    final long __addr_ = _pat._addressof_glVertex2h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2h"));
    }
        dispatch_glVertex2h1(x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2h}(GLhalfNV x, GLhalfNV y) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex2hNV</code>   */
  private native void dispatch_glVertex2h1(short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex2hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2hv"));
    }
        dispatch_glVertex2hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex2hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex2hvNV</code>   */
  public void glVertex2hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex2hv"));
    }
        dispatch_glVertex2hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3h}(GLhalfNV x, GLhalfNV y, GLhalfNV z) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex3hNV</code>   */
  public void glVertex3h(short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glVertex3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3h"));
    }
        dispatch_glVertex3h1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3h}(GLhalfNV x, GLhalfNV y, GLhalfNV z) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex3hNV</code>   */
  private native void dispatch_glVertex3h1(short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3hv"));
    }
        dispatch_glVertex3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex3hvNV</code>   */
  public void glVertex3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex3hv"));
    }
        dispatch_glVertex3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4h}(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex4hNV</code>   */
  public void glVertex4h(short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glVertex4h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4h"));
    }
        dispatch_glVertex4h1(x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4h}(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex4hNV</code>   */
  private native void dispatch_glVertex4h1(short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertex4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertex4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4hv"));
    }
        dispatch_glVertex4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertex4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertex4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertex4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertex4hvNV</code>   */
  public void glVertex4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertex4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertex4hv"));
    }
        dispatch_glVertex4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3h}(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glNormal3hNV</code>   */
  public void glNormal3h(short nx, short ny, short nz)  {

    final long __addr_ = _pat._addressof_glNormal3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3h"));
    }
        dispatch_glNormal3h1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3h}(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glNormal3hNV</code>   */
  private native void dispatch_glNormal3h1(short nx, short ny, short nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glNormal3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glNormal3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNormal3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3hv"));
    }
        dispatch_glNormal3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glNormal3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glNormal3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glNormal3hvNV</code>   */
  public void glNormal3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNormal3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3hv"));
    }
        dispatch_glNormal3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor3hNV</code>   */
  public void glColor3h(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glColor3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3h"));
    }
        dispatch_glColor3h1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor3hNV</code>   */
  private native void dispatch_glColor3h1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3hv"));
    }
        dispatch_glColor3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor3hvNV</code>   */
  public void glColor3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor3hv"));
    }
        dispatch_glColor3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor4hNV</code>   */
  public void glColor4h(short red, short green, short blue, short alpha)  {

    final long __addr_ = _pat._addressof_glColor4h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4h"));
    }
        dispatch_glColor4h1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor4hNV</code>   */
  private native void dispatch_glColor4h1(short red, short green, short blue, short alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glColor4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glColor4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4hv"));
    }
        dispatch_glColor4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glColor4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glColor4hvNV</code>   */
  public void glColor4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glColor4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4hv"));
    }
        dispatch_glColor4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1h}(GLhalfNV s) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord1hNV</code>   */
  public void glTexCoord1h(short s)  {

    final long __addr_ = _pat._addressof_glTexCoord1h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1h"));
    }
        dispatch_glTexCoord1h1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1h}(GLhalfNV s) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord1hNV</code>   */
  private native void dispatch_glTexCoord1h1(short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord1hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1hv"));
    }
        dispatch_glTexCoord1hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord1hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord1hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord1hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord1hvNV</code>   */
  public void glTexCoord1hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord1hv"));
    }
        dispatch_glTexCoord1hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2h}(GLhalfNV s, GLhalfNV t) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord2hNV</code>   */
  public void glTexCoord2h(short s, short t)  {

    final long __addr_ = _pat._addressof_glTexCoord2h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2h"));
    }
        dispatch_glTexCoord2h1(s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2h}(GLhalfNV s, GLhalfNV t) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord2hNV</code>   */
  private native void dispatch_glTexCoord2h1(short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord2hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2hv"));
    }
        dispatch_glTexCoord2hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord2hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord2hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord2hvNV</code>   */
  public void glTexCoord2hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord2hv"));
    }
        dispatch_glTexCoord2hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3h}(GLhalfNV s, GLhalfNV t, GLhalfNV r) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord3hNV</code>   */
  public void glTexCoord3h(short s, short t, short r)  {

    final long __addr_ = _pat._addressof_glTexCoord3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3h"));
    }
        dispatch_glTexCoord3h1(s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3h}(GLhalfNV s, GLhalfNV t, GLhalfNV r) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord3hNV</code>   */
  private native void dispatch_glTexCoord3h1(short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3hv"));
    }
        dispatch_glTexCoord3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord3hvNV</code>   */
  public void glTexCoord3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord3hv"));
    }
        dispatch_glTexCoord3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4h}(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord4hNV</code>   */
  public void glTexCoord4h(short s, short t, short r, short q)  {

    final long __addr_ = _pat._addressof_glTexCoord4h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4h"));
    }
        dispatch_glTexCoord4h1(s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4h}(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord4hNV</code>   */
  private native void dispatch_glTexCoord4h1(short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glTexCoord4hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4hv"));
    }
        dispatch_glTexCoord4hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoord4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glTexCoord4hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoord4hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glTexCoord4hvNV</code>   */
  public void glTexCoord4hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoord4hv"));
    }
        dispatch_glTexCoord4hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1h}(GLenum target, GLhalfNV s) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord1hNV</code>   */
  public void glMultiTexCoord1h(int target, short s)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord1h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1h"));
    }
        dispatch_glMultiTexCoord1h1(target, s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1h}(GLenum target, GLhalfNV s) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord1hNV</code>   */
  private native void dispatch_glMultiTexCoord1h1(int target, short s, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord1hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1hv"));
    }
        dispatch_glMultiTexCoord1hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord1hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord1hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord1hvNV</code>   */
  public void glMultiTexCoord1hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord1hv"));
    }
        dispatch_glMultiTexCoord1hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2h}(GLenum target, GLhalfNV s, GLhalfNV t) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord2hNV</code>   */
  public void glMultiTexCoord2h(int target, short s, short t)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord2h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2h"));
    }
        dispatch_glMultiTexCoord2h1(target, s, t, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2h}(GLenum target, GLhalfNV s, GLhalfNV t) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord2hNV</code>   */
  private native void dispatch_glMultiTexCoord2h1(int target, short s, short t, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord2hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2hv"));
    }
        dispatch_glMultiTexCoord2hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord2hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord2hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord2hvNV</code>   */
  public void glMultiTexCoord2hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord2hv"));
    }
        dispatch_glMultiTexCoord2hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3h}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord3hNV</code>   */
  public void glMultiTexCoord3h(int target, short s, short t, short r)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3h"));
    }
        dispatch_glMultiTexCoord3h1(target, s, t, r, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3h}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord3hNV</code>   */
  private native void dispatch_glMultiTexCoord3h1(int target, short s, short t, short r, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord3hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3hv"));
    }
        dispatch_glMultiTexCoord3hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord3hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord3hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord3hvNV</code>   */
  public void glMultiTexCoord3hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord3hv"));
    }
        dispatch_glMultiTexCoord3hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4h}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord4hNV</code>   */
  public void glMultiTexCoord4h(int target, short s, short t, short r, short q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4h"));
    }
        dispatch_glMultiTexCoord4h1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4h}(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord4hNV</code>   */
  private native void dispatch_glMultiTexCoord4h1(int target, short s, short t, short r, short q, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glMultiTexCoord4hv(int target, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glMultiTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4hv"));
    }
        dispatch_glMultiTexCoord4hv1(target, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glMultiTexCoord4hv1(int target, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4hv}(GLenum target, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glMultiTexCoord4hvNV</code>   */
  public void glMultiTexCoord4hv(int target, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glMultiTexCoord4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4hv"));
    }
        dispatch_glMultiTexCoord4hv1(target, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordh}(GLhalfNV fog) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glFogCoordhNV</code>   */
  public void glFogCoordh(short fog)  {

    final long __addr_ = _pat._addressof_glFogCoordh;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordh"));
    }
        dispatch_glFogCoordh1(fog, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordh}(GLhalfNV fog) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glFogCoordhNV</code>   */
  private native void dispatch_glFogCoordh1(short fog, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordhv}(const GLhalfNV *  fog) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glFogCoordhvNV</code>
      @param fog a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glFogCoordhv(ShortBuffer fog)  {

    final boolean fog_is_direct = Buffers.isDirect(fog);
    final long __addr_ = _pat._addressof_glFogCoordhv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordhv"));
    }
        dispatch_glFogCoordhv1(fog_is_direct ? fog : Buffers.getArray(fog), fog_is_direct ? Buffers.getDirectBufferByteOffset(fog) : Buffers.getIndirectBufferByteOffset(fog), fog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordhv}(const GLhalfNV *  fog) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glFogCoordhvNV</code>
      @param fog a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glFogCoordhv1(Object fog, int fog_byte_offset, boolean fog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordhv}(const GLhalfNV *  fog) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glFogCoordhvNV</code>   */
  public void glFogCoordhv(short[] fog, int fog_offset)  {

    if(fog != null && fog.length <= fog_offset)
      throw new GLException("array offset argument \"fog_offset\" (" + fog_offset + ") equals or exceeds array length (" + fog.length + ")");
    final long __addr_ = _pat._addressof_glFogCoordhv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordhv"));
    }
        dispatch_glFogCoordhv1(fog, Buffers.SIZEOF_SHORT * fog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glSecondaryColor3hNV</code>   */
  public void glSecondaryColor3h(short red, short green, short blue)  {

    final long __addr_ = _pat._addressof_glSecondaryColor3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3h"));
    }
        dispatch_glSecondaryColor3h1(red, green, blue, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3h}(GLhalfNV red, GLhalfNV green, GLhalfNV blue) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glSecondaryColor3hNV</code>   */
  private native void dispatch_glSecondaryColor3h1(short red, short green, short blue, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glSecondaryColor3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glSecondaryColor3hv(ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glSecondaryColor3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3hv"));
    }
        dispatch_glSecondaryColor3hv1(v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glSecondaryColor3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glSecondaryColor3hv1(Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColor3hv}(const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glSecondaryColor3hvNV</code>   */
  public void glSecondaryColor3hv(short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glSecondaryColor3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColor3hv"));
    }
        dispatch_glSecondaryColor3hv1(v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighth}(GLhalfNV weight) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexWeighthNV</code>   */
  public void glVertexWeighth(short weight)  {

    final long __addr_ = _pat._addressof_glVertexWeighth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighth"));
    }
        dispatch_glVertexWeighth1(weight, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighth}(GLhalfNV weight) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexWeighthNV</code>   */
  private native void dispatch_glVertexWeighth1(short weight, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeighthv}(const GLhalfNV *  weight) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexWeighthvNV</code>
      @param weight a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexWeighthv(ShortBuffer weight)  {

    final boolean weight_is_direct = Buffers.isDirect(weight);
    final long __addr_ = _pat._addressof_glVertexWeighthv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighthv"));
    }
        dispatch_glVertexWeighthv1(weight_is_direct ? weight : Buffers.getArray(weight), weight_is_direct ? Buffers.getDirectBufferByteOffset(weight) : Buffers.getIndirectBufferByteOffset(weight), weight_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexWeighthv}(const GLhalfNV *  weight) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexWeighthvNV</code>
      @param weight a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexWeighthv1(Object weight, int weight_byte_offset, boolean weight_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexWeighthv}(const GLhalfNV *  weight) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexWeighthvNV</code>   */
  public void glVertexWeighthv(short[] weight, int weight_offset)  {

    if(weight != null && weight.length <= weight_offset)
      throw new GLException("array offset argument \"weight_offset\" (" + weight_offset + ") equals or exceeds array length (" + weight.length + ")");
    final long __addr_ = _pat._addressof_glVertexWeighthv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexWeighthv"));
    }
        dispatch_glVertexWeighthv1(weight, Buffers.SIZEOF_SHORT * weight_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1h}(GLuint index, GLhalfNV x) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib1hNV</code>   */
  public void glVertexAttrib1h(int index, short x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1h"));
    }
        dispatch_glVertexAttrib1h1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1h}(GLuint index, GLhalfNV x) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib1hNV</code>   */
  private native void dispatch_glVertexAttrib1h1(int index, short x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib1hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1hv"));
    }
        dispatch_glVertexAttrib1hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib1hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib1hvNV</code>   */
  public void glVertexAttrib1hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1hv"));
    }
        dispatch_glVertexAttrib1hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2h}(GLuint index, GLhalfNV x, GLhalfNV y) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib2hNV</code>   */
  public void glVertexAttrib2h(int index, short x, short y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2h"));
    }
        dispatch_glVertexAttrib2h1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2h}(GLuint index, GLhalfNV x, GLhalfNV y) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib2hNV</code>   */
  private native void dispatch_glVertexAttrib2h1(int index, short x, short y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib2hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2hv"));
    }
        dispatch_glVertexAttrib2hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib2hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib2hvNV</code>   */
  public void glVertexAttrib2hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2hv"));
    }
        dispatch_glVertexAttrib2hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3h}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib3hNV</code>   */
  public void glVertexAttrib3h(int index, short x, short y, short z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3h"));
    }
        dispatch_glVertexAttrib3h1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3h}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib3hNV</code>   */
  private native void dispatch_glVertexAttrib3h1(int index, short x, short y, short z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib3hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3hv"));
    }
        dispatch_glVertexAttrib3hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib3hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib3hvNV</code>   */
  public void glVertexAttrib3hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3hv"));
    }
        dispatch_glVertexAttrib3hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4h}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib4hNV</code>   */
  public void glVertexAttrib4h(int index, short x, short y, short z, short w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4h;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4h"));
    }
        dispatch_glVertexAttrib4h1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4h}(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib4hNV</code>   */
  private native void dispatch_glVertexAttrib4h1(int index, short x, short y, short z, short w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttrib4hv(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4hv"));
    }
        dispatch_glVertexAttrib4hv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttrib4hv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4hv}(GLuint index, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttrib4hvNV</code>   */
  public void glVertexAttrib4hv(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4hv"));
    }
        dispatch_glVertexAttrib4hv1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs1hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribs1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs1hv"));
    }
        dispatch_glVertexAttribs1hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs1hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs1hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs1hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs1hvNV</code>   */
  public void glVertexAttribs1hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribs1hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs1hv"));
    }
        dispatch_glVertexAttribs1hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs2hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribs2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs2hv"));
    }
        dispatch_glVertexAttribs2hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs2hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs2hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs2hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs2hvNV</code>   */
  public void glVertexAttribs2hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribs2hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs2hv"));
    }
        dispatch_glVertexAttribs2hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs3hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribs3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs3hv"));
    }
        dispatch_glVertexAttribs3hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs3hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs3hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs3hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs3hvNV</code>   */
  public void glVertexAttribs3hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribs3hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs3hv"));
    }
        dispatch_glVertexAttribs3hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribs4hv(int index, int n, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribs4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs4hv"));
    }
        dispatch_glVertexAttribs4hv1(index, n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs4hvNV</code>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribs4hv1(int index, int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribs4hv}(GLuint index, GLsizei n, const GLhalfNV *  v) </code> <br>Part of <code>GL_NV_half_float</code><br>Alias for: <code>glVertexAttribs4hvNV</code>   */
  public void glVertexAttribs4hv(int index, int n, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribs4hv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribs4hv"));
    }
        dispatch_glVertexAttribs4hv1(index, n, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenOcclusionQueriesNV(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenOcclusionQueriesNV"));
    }
        dispatch_glGenOcclusionQueriesNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenOcclusionQueriesNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenOcclusionQueriesNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glGenOcclusionQueriesNV(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenOcclusionQueriesNV"));
    }
        dispatch_glGenOcclusionQueriesNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteOcclusionQueriesNV(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteOcclusionQueriesNV"));
    }
        dispatch_glDeleteOcclusionQueriesNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteOcclusionQueriesNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteOcclusionQueriesNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glDeleteOcclusionQueriesNV(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteOcclusionQueriesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteOcclusionQueriesNV"));
    }
        dispatch_glDeleteOcclusionQueriesNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsOcclusionQueryNV}(GLuint id) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public boolean glIsOcclusionQueryNV(int id)  {

    final long __addr_ = _pat._addressof_glIsOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsOcclusionQueryNV"));
    }
        return dispatch_glIsOcclusionQueryNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsOcclusionQueryNV}(GLuint id) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  private native boolean dispatch_glIsOcclusionQueryNV1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginOcclusionQueryNV}(GLuint id) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glBeginOcclusionQueryNV(int id)  {

    final long __addr_ = _pat._addressof_glBeginOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginOcclusionQueryNV"));
    }
        dispatch_glBeginOcclusionQueryNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginOcclusionQueryNV}(GLuint id) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  private native void dispatch_glBeginOcclusionQueryNV1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndOcclusionQueryNV}(void) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glEndOcclusionQueryNV()  {

    final long __addr_ = _pat._addressof_glEndOcclusionQueryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndOcclusionQueryNV"));
    }
        dispatch_glEndOcclusionQueryNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndOcclusionQueryNV}(void) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  private native void dispatch_glEndOcclusionQueryNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetOcclusionQueryivNV(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetOcclusionQueryivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryivNV"));
    }
        dispatch_glGetOcclusionQueryivNV1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetOcclusionQueryivNV1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryivNV}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glGetOcclusionQueryivNV(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetOcclusionQueryivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryivNV"));
    }
        dispatch_glGetOcclusionQueryivNV1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetOcclusionQueryuivNV(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetOcclusionQueryuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryuivNV"));
    }
        dispatch_glGetOcclusionQueryuivNV1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetOcclusionQueryuivNV1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetOcclusionQueryuivNV}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_occlusion_query</code><br>   */
  public void glGetOcclusionQueryuivNV(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetOcclusionQueryuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetOcclusionQueryuivNV"));
    }
        dispatch_glGetOcclusionQueryuivNV1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramBufferParametersfvNV(int target, int bindingIndex, int wordIndex, int count, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramBufferParametersfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersfvNV"));
    }
        dispatch_glProgramBufferParametersfvNV1(target, bindingIndex, wordIndex, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramBufferParametersfvNV1(int target, int bindingIndex, int wordIndex, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersfvNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>   */
  public void glProgramBufferParametersfvNV(int target, int bindingIndex, int wordIndex, int count, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramBufferParametersfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersfvNV"));
    }
        dispatch_glProgramBufferParametersfvNV1(target, bindingIndex, wordIndex, count, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramBufferParametersIivNV(int target, int bindingIndex, int wordIndex, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramBufferParametersIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIivNV"));
    }
        dispatch_glProgramBufferParametersIivNV1(target, bindingIndex, wordIndex, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramBufferParametersIivNV1(int target, int bindingIndex, int wordIndex, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>   */
  public void glProgramBufferParametersIivNV(int target, int bindingIndex, int wordIndex, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramBufferParametersIivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIivNV"));
    }
        dispatch_glProgramBufferParametersIivNV1(target, bindingIndex, wordIndex, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramBufferParametersIuivNV(int target, int bindingIndex, int wordIndex, int count, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glProgramBufferParametersIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIuivNV"));
    }
        dispatch_glProgramBufferParametersIuivNV1(target, bindingIndex, wordIndex, count, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramBufferParametersIuivNV1(int target, int bindingIndex, int wordIndex, int count, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBufferParametersIuivNV}(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint *  params) </code> <br>Part of <code>GL_NV_parameter_buffer_object</code><br>   */
  public void glProgramBufferParametersIuivNV(int target, int bindingIndex, int wordIndex, int count, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glProgramBufferParametersIuivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBufferParametersIuivNV"));
    }
        dispatch_glProgramBufferParametersIuivNV1(target, bindingIndex, wordIndex, count, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelDataRangeNV}(GLenum target, GLsizei length, const void *  pointer) </code> <br>Part of <code>GL_NV_pixel_data_range</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glPixelDataRangeNV(int target, int length, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glPixelDataRangeNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelDataRangeNV"));
    }
        dispatch_glPixelDataRangeNV0(target, length, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelDataRangeNV}(GLenum target, GLsizei length, const void *  pointer) </code> <br>Part of <code>GL_NV_pixel_data_range</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glPixelDataRangeNV0(int target, int length, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushPixelDataRangeNV}(GLenum target) </code> <br>Part of <code>GL_NV_pixel_data_range</code><br>   */
  public void glFlushPixelDataRangeNV(int target)  {

    final long __addr_ = _pat._addressof_glFlushPixelDataRangeNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushPixelDataRangeNV"));
    }
        dispatch_glFlushPixelDataRangeNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushPixelDataRangeNV}(GLenum target) </code> <br>Part of <code>GL_NV_pixel_data_range</code><br>   */
  private native void dispatch_glFlushPixelDataRangeNV1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartNV}(void) </code> <br>Part of <code>GL_NV_primitive_restart</code><br>   */
  public void glPrimitiveRestartNV()  {

    final long __addr_ = _pat._addressof_glPrimitiveRestartNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartNV"));
    }
        dispatch_glPrimitiveRestartNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartNV}(void) </code> <br>Part of <code>GL_NV_primitive_restart</code><br>   */
  private native void dispatch_glPrimitiveRestartNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndexNV}(GLuint index) </code> <br>Part of <code>GL_NV_primitive_restart</code><br>   */
  public void glPrimitiveRestartIndexNV(int index)  {

    final long __addr_ = _pat._addressof_glPrimitiveRestartIndexNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveRestartIndexNV"));
    }
        dispatch_glPrimitiveRestartIndexNV1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveRestartIndexNV}(GLuint index) </code> <br>Part of <code>GL_NV_primitive_restart</code><br>   */
  private native void dispatch_glPrimitiveRestartIndexNV1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFramebufferSampleLocationsfvNV(int target, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
    }
        dispatch_glFramebufferSampleLocationsfvNV1(target, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFramebufferSampleLocationsfvNV1(int target, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glFramebufferSampleLocationsfvNV(int target, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
    }
        dispatch_glFramebufferSampleLocationsfvNV1(target, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedFramebufferSampleLocationsfvNV(int framebuffer, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvNV1(framebuffer, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedFramebufferSampleLocationsfvNV1(int framebuffer, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glNamedFramebufferSampleLocationsfvNV(int framebuffer, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvNV1(framebuffer, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveDepthValuesNV}(void) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glResolveDepthValuesNV()  {

    final long __addr_ = _pat._addressof_glResolveDepthValuesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResolveDepthValuesNV"));
    }
        dispatch_glResolveDepthValuesNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveDepthValuesNV}(void) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  private native void dispatch_glResolveDepthValuesNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeBufferResidentNV}(GLenum target, GLenum access) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glMakeBufferResidentNV(int target, int access)  {

    final long __addr_ = _pat._addressof_glMakeBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeBufferResidentNV"));
    }
        dispatch_glMakeBufferResidentNV1(target, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeBufferResidentNV}(GLenum target, GLenum access) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glMakeBufferResidentNV1(int target, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeBufferNonResidentNV}(GLenum target) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glMakeBufferNonResidentNV(int target)  {

    final long __addr_ = _pat._addressof_glMakeBufferNonResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeBufferNonResidentNV"));
    }
        dispatch_glMakeBufferNonResidentNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeBufferNonResidentNV}(GLenum target) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glMakeBufferNonResidentNV1(int target, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBufferResidentNV}(GLenum target) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public boolean glIsBufferResidentNV(int target)  {

    final long __addr_ = _pat._addressof_glIsBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsBufferResidentNV"));
    }
        return dispatch_glIsBufferResidentNV1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBufferResidentNV}(GLenum target) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native boolean dispatch_glIsBufferResidentNV1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferResidentNV}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glMakeNamedBufferResidentNV(int buffer, int access)  {

    final long __addr_ = _pat._addressof_glMakeNamedBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeNamedBufferResidentNV"));
    }
        dispatch_glMakeNamedBufferResidentNV1(buffer, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferResidentNV}(GLuint buffer, GLenum access) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glMakeNamedBufferResidentNV1(int buffer, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferNonResidentNV}(GLuint buffer) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glMakeNamedBufferNonResidentNV(int buffer)  {

    final long __addr_ = _pat._addressof_glMakeNamedBufferNonResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMakeNamedBufferNonResidentNV"));
    }
        dispatch_glMakeNamedBufferNonResidentNV1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMakeNamedBufferNonResidentNV}(GLuint buffer) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glMakeNamedBufferNonResidentNV1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedBufferResidentNV}(GLuint buffer) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public boolean glIsNamedBufferResidentNV(int buffer)  {

    final long __addr_ = _pat._addressof_glIsNamedBufferResidentNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsNamedBufferResidentNV"));
    }
        return dispatch_glIsNamedBufferResidentNV1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsNamedBufferResidentNV}(GLuint buffer) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native boolean dispatch_glIsNamedBufferResidentNV1(int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameterui64vNV(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameterui64vNV"));
    }
        dispatch_glGetBufferParameterui64vNV1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameterui64vNV1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameterui64vNV}(GLenum target, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glGetBufferParameterui64vNV(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameterui64vNV"));
    }
        dispatch_glGetBufferParameterui64vNV1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetNamedBufferParameterui64vNV(int buffer, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetNamedBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterui64vNV"));
    }
        dispatch_glGetNamedBufferParameterui64vNV1(buffer, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetNamedBufferParameterui64vNV1(int buffer, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetNamedBufferParameterui64vNV}(GLuint buffer, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glGetNamedBufferParameterui64vNV(int buffer, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetNamedBufferParameterui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetNamedBufferParameterui64vNV"));
    }
        dispatch_glGetNamedBufferParameterui64vNV1(buffer, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetIntegerui64vNV(int value, LongBuffer result)  {

    final boolean result_is_direct = Buffers.isDirect(result);
    final long __addr_ = _pat._addressof_glGetIntegerui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64vNV"));
    }
        dispatch_glGetIntegerui64vNV1(value, result_is_direct ? result : Buffers.getArray(result), result_is_direct ? Buffers.getDirectBufferByteOffset(result) : Buffers.getIndirectBufferByteOffset(result), result_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetIntegerui64vNV1(int value, Object result, int result_byte_offset, boolean result_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerui64vNV}(GLenum value, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glGetIntegerui64vNV(int value, long[] result, int result_offset)  {

    if(result != null && result.length <= result_offset)
      throw new GLException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64vNV"));
    }
        dispatch_glGetIntegerui64vNV1(value, result, Buffers.SIZEOF_LONG * result_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64NV}(GLint location, GLuint64EXT value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glUniformui64NV(int location, long value)  {

    final long __addr_ = _pat._addressof_glUniformui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformui64NV"));
    }
        dispatch_glUniformui64NV1(location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64NV}(GLint location, GLuint64EXT value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glUniformui64NV1(int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glUniformui64vNV(int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformui64vNV"));
    }
        dispatch_glUniformui64vNV1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glUniformui64vNV1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformui64vNV}(GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glUniformui64vNV(int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformui64vNV"));
    }
        dispatch_glUniformui64vNV1(location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64NV}(GLuint program, GLint location, GLuint64EXT value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glProgramUniformui64NV(int program, int location, long value)  {

    final long __addr_ = _pat._addressof_glProgramUniformui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64NV"));
    }
        dispatch_glProgramUniformui64NV1(program, location, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64NV}(GLuint program, GLint location, GLuint64EXT value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  private native void dispatch_glProgramUniformui64NV1(int program, int location, long value, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glProgramUniformui64vNV(int program, int location, int count, LongBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64vNV"));
    }
        dispatch_glProgramUniformui64vNV1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>
      @param value a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glProgramUniformui64vNV1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformui64vNV}(GLuint program, GLint location, GLsizei count, const GLuint64EXT *  value) </code> <br>Part of <code>GL_NV_shader_buffer_load</code><br>   */
  public void glProgramUniformui64vNV(int program, int location, int count, long[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformui64vNV"));
    }
        dispatch_glProgramUniformui64vNV1(program, location, count, value, Buffers.SIZEOF_LONG * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBarrierNV}(void) </code> <br>Part of <code>GL_NV_texture_barrier</code><br>   */
  public void glTextureBarrierNV()  {

    final long __addr_ = _pat._addressof_glTextureBarrierNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureBarrierNV"));
    }
        dispatch_glTextureBarrierNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureBarrierNV}(void) </code> <br>Part of <code>GL_NV_texture_barrier</code><br>   */
  private native void dispatch_glTextureBarrierNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTexImage2DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTexImage2DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2DMultisampleCoverageNV"));
    }
        dispatch_glTexImage2DMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTexImage2DMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTexImage3DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTexImage3DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3DMultisampleCoverageNV"));
    }
        dispatch_glTexImage3DMultisampleCoverageNV1(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisampleCoverageNV}(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTexImage3DMultisampleCoverageNV1(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTextureImage2DMultisampleNV(int texture, int target, int samples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTextureImage2DMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DMultisampleNV"));
    }
        dispatch_glTextureImage2DMultisampleNV1(texture, target, samples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTextureImage2DMultisampleNV1(int texture, int target, int samples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTextureImage3DMultisampleNV(int texture, int target, int samples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTextureImage3DMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DMultisampleNV"));
    }
        dispatch_glTextureImage3DMultisampleNV1(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleNV}(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTextureImage3DMultisampleNV1(int texture, int target, int samples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTextureImage2DMultisampleCoverageNV(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTextureImage2DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage2DMultisampleCoverageNV"));
    }
        dispatch_glTextureImage2DMultisampleCoverageNV1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage2DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTextureImage2DMultisampleCoverageNV1(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  public void glTextureImage3DMultisampleCoverageNV(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations)  {

    final long __addr_ = _pat._addressof_glTextureImage3DMultisampleCoverageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureImage3DMultisampleCoverageNV"));
    }
        dispatch_glTextureImage3DMultisampleCoverageNV1(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureImage3DMultisampleCoverageNV}(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) </code> <br>Part of <code>GL_NV_texture_multisample</code><br>   */
  private native void dispatch_glTextureImage3DMultisampleCoverageNV1(int texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, boolean fixedSampleLocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTransformFeedbackNV}(GLenum target, GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glBindTransformFeedbackNV(int target, int id)  {

    final long __addr_ = _pat._addressof_glBindTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedbackNV"));
    }
        dispatch_glBindTransformFeedbackNV1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedbackNV}(GLenum target, GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  private native void dispatch_glBindTransformFeedbackNV1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacksNV(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacksNV"));
    }
        dispatch_glDeleteTransformFeedbacksNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacksNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacksNV}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glDeleteTransformFeedbacksNV(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacksNV"));
    }
        dispatch_glDeleteTransformFeedbacksNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacksNV(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacksNV"));
    }
        dispatch_glGenTransformFeedbacksNV1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacksNV1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacksNV}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glGenTransformFeedbacksNV(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenTransformFeedbacksNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacksNV"));
    }
        dispatch_glGenTransformFeedbacksNV1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedbackNV}(GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public boolean glIsTransformFeedbackNV(int id)  {

    final long __addr_ = _pat._addressof_glIsTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedbackNV"));
    }
        return dispatch_glIsTransformFeedbackNV1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedbackNV}(GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  private native boolean dispatch_glIsTransformFeedbackNV1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedbackNV}(void) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glPauseTransformFeedbackNV()  {

    final long __addr_ = _pat._addressof_glPauseTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedbackNV"));
    }
        dispatch_glPauseTransformFeedbackNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedbackNV}(void) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  private native void dispatch_glPauseTransformFeedbackNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedbackNV}(void) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glResumeTransformFeedbackNV()  {

    final long __addr_ = _pat._addressof_glResumeTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedbackNV"));
    }
        dispatch_glResumeTransformFeedbackNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedbackNV}(void) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  private native void dispatch_glResumeTransformFeedbackNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackNV}(GLenum mode, GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  public void glDrawTransformFeedbackNV(int mode, int id)  {

    final long __addr_ = _pat._addressof_glDrawTransformFeedbackNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTransformFeedbackNV"));
    }
        dispatch_glDrawTransformFeedbackNV1(mode, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTransformFeedbackNV}(GLenum mode, GLuint id) </code> <br>Part of <code>GL_NV_transform_feedback2</code><br>   */
  private native void dispatch_glDrawTransformFeedbackNV1(int mode, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUInitNV}(const void *  vdpDevice, const void *  getProcAddress) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpDevice a direct or array-backed {@link java.nio.Buffer}
      @param getProcAddress a direct or array-backed {@link java.nio.Buffer}   */
  public void glVDPAUInitNV(Buffer vdpDevice, Buffer getProcAddress)  {

    final boolean vdpDevice_is_direct = Buffers.isDirect(vdpDevice);
    final boolean getProcAddress_is_direct = Buffers.isDirect(getProcAddress);
    final long __addr_ = _pat._addressof_glVDPAUInitNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUInitNV"));
    }
        dispatch_glVDPAUInitNV1(vdpDevice_is_direct ? vdpDevice : Buffers.getArray(vdpDevice), vdpDevice_is_direct ? Buffers.getDirectBufferByteOffset(vdpDevice) : Buffers.getIndirectBufferByteOffset(vdpDevice), vdpDevice_is_direct, getProcAddress_is_direct ? getProcAddress : Buffers.getArray(getProcAddress), getProcAddress_is_direct ? Buffers.getDirectBufferByteOffset(getProcAddress) : Buffers.getIndirectBufferByteOffset(getProcAddress), getProcAddress_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUInitNV}(const void *  vdpDevice, const void *  getProcAddress) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpDevice a direct or array-backed {@link java.nio.Buffer}
      @param getProcAddress a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVDPAUInitNV1(Object vdpDevice, int vdpDevice_byte_offset, boolean vdpDevice_is_direct, Object getProcAddress, int getProcAddress_byte_offset, boolean getProcAddress_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUFiniNV}(void) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  public void glVDPAUFiniNV()  {

    final long __addr_ = _pat._addressof_glVDPAUFiniNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUFiniNV"));
    }
        dispatch_glVDPAUFiniNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUFiniNV}(void) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  private native void dispatch_glVDPAUFiniNV1(long procAddress);

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  public long glVDPAURegisterVideoSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, IntBuffer textureNames)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    final boolean textureNames_is_direct = Buffers.isDirect(textureNames);
    final long __addr_ = _pat._addressof_glVDPAURegisterVideoSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterVideoSurfaceNV"));
    }
        return dispatch_glVDPAURegisterVideoSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames_is_direct ? textureNames : Buffers.getArray(textureNames), textureNames_is_direct ? Buffers.getDirectBufferByteOffset(textureNames) : Buffers.getIndirectBufferByteOffset(textureNames), textureNames_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_glVDPAURegisterVideoSurfaceNV1(Object vdpSurface, int vdpSurface_byte_offset, boolean vdpSurface_is_direct, int target, int numTextureNames, Object textureNames, int textureNames_byte_offset, boolean textureNames_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterVideoSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}   */
  public long glVDPAURegisterVideoSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, int[] textureNames, int textureNames_offset)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    if(textureNames != null && textureNames.length <= textureNames_offset)
      throw new GLException("array offset argument \"textureNames_offset\" (" + textureNames_offset + ") equals or exceeds array length (" + textureNames.length + ")");
    final long __addr_ = _pat._addressof_glVDPAURegisterVideoSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterVideoSurfaceNV"));
    }
        return dispatch_glVDPAURegisterVideoSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames, Buffers.SIZEOF_INT * textureNames_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  public long glVDPAURegisterOutputSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, IntBuffer textureNames)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    final boolean textureNames_is_direct = Buffers.isDirect(textureNames);
    final long __addr_ = _pat._addressof_glVDPAURegisterOutputSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterOutputSurfaceNV"));
    }
        return dispatch_glVDPAURegisterOutputSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames_is_direct ? textureNames : Buffers.getArray(textureNames), textureNames_is_direct ? Buffers.getDirectBufferByteOffset(textureNames) : Buffers.getIndirectBufferByteOffset(textureNames), textureNames_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}
      @param textureNames a direct or array-backed {@link java.nio.IntBuffer}   */
  private native long dispatch_glVDPAURegisterOutputSurfaceNV1(Object vdpSurface, int vdpSurface_byte_offset, boolean vdpSurface_is_direct, int target, int numTextureNames, Object textureNames, int textureNames_byte_offset, boolean textureNames_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLvdpauSurfaceNV {@native glVDPAURegisterOutputSurfaceNV}(const void *  vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *  textureNames) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param vdpSurface a direct or array-backed {@link java.nio.Buffer}   */
  public long glVDPAURegisterOutputSurfaceNV(Buffer vdpSurface, int target, int numTextureNames, int[] textureNames, int textureNames_offset)  {

    final boolean vdpSurface_is_direct = Buffers.isDirect(vdpSurface);
    if(textureNames != null && textureNames.length <= textureNames_offset)
      throw new GLException("array offset argument \"textureNames_offset\" (" + textureNames_offset + ") equals or exceeds array length (" + textureNames.length + ")");
    final long __addr_ = _pat._addressof_glVDPAURegisterOutputSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAURegisterOutputSurfaceNV"));
    }
        return dispatch_glVDPAURegisterOutputSurfaceNV1(vdpSurface_is_direct ? vdpSurface : Buffers.getArray(vdpSurface), vdpSurface_is_direct ? Buffers.getDirectBufferByteOffset(vdpSurface) : Buffers.getIndirectBufferByteOffset(vdpSurface), vdpSurface_is_direct, target, numTextureNames, textureNames, Buffers.SIZEOF_INT * textureNames_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glVDPAUIsSurfaceNV}(GLvdpauSurfaceNV surface) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  public boolean glVDPAUIsSurfaceNV(long surface)  {

    final long __addr_ = _pat._addressof_glVDPAUIsSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUIsSurfaceNV"));
    }
        return dispatch_glVDPAUIsSurfaceNV1(surface, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glVDPAUIsSurfaceNV}(GLvdpauSurfaceNV surface) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  private native boolean dispatch_glVDPAUIsSurfaceNV1(long surface, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUUnregisterSurfaceNV}(GLvdpauSurfaceNV surface) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  public void glVDPAUUnregisterSurfaceNV(long surface)  {

    final long __addr_ = _pat._addressof_glVDPAUUnregisterSurfaceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUUnregisterSurfaceNV"));
    }
        dispatch_glVDPAUUnregisterSurfaceNV1(surface, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUUnregisterSurfaceNV}(GLvdpauSurfaceNV surface) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  private native void dispatch_glVDPAUUnregisterSurfaceNV1(long surface, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVDPAUGetSurfaceivNV(long surface, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glVDPAUGetSurfaceivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUGetSurfaceivNV"));
    }
        dispatch_glVDPAUGetSurfaceivNV1(surface, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVDPAUGetSurfaceivNV1(long surface, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUGetSurfaceivNV}(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  public void glVDPAUGetSurfaceivNV(long surface, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glVDPAUGetSurfaceivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUGetSurfaceivNV"));
    }
        dispatch_glVDPAUGetSurfaceivNV1(surface, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUSurfaceAccessNV}(GLvdpauSurfaceNV surface, GLenum access) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  public void glVDPAUSurfaceAccessNV(long surface, int access)  {

    final long __addr_ = _pat._addressof_glVDPAUSurfaceAccessNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUSurfaceAccessNV"));
    }
        dispatch_glVDPAUSurfaceAccessNV1(surface, access, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUSurfaceAccessNV}(GLvdpauSurfaceNV surface, GLenum access) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>   */
  private native void dispatch_glVDPAUSurfaceAccessNV1(long surface, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUMapSurfacesNV}(GLsizei numSurfaces, const GLvdpauSurfaceNV *  surfaces) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param surfaces a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glVDPAUMapSurfacesNV(int numSurfaces, PointerBuffer surfaces)  {

    if (!Buffers.isDirect(surfaces))
      throw new GLException("Argument \"surfaces\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVDPAUMapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUMapSurfacesNV"));
    }
        dispatch_glVDPAUMapSurfacesNV0(numSurfaces, surfaces != null ? surfaces.getBuffer() : null, Buffers.getDirectBufferByteOffset(surfaces), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUMapSurfacesNV}(GLsizei numSurfaces, const GLvdpauSurfaceNV *  surfaces) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param surfaces a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glVDPAUMapSurfacesNV0(int numSurfaces, Object surfaces, int surfaces_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVDPAUUnmapSurfacesNV}(GLsizei numSurface, const GLvdpauSurfaceNV *  surfaces) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param surfaces a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glVDPAUUnmapSurfacesNV(int numSurface, PointerBuffer surfaces)  {

    if (!Buffers.isDirect(surfaces))
      throw new GLException("Argument \"surfaces\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVDPAUUnmapSurfacesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVDPAUUnmapSurfacesNV"));
    }
        dispatch_glVDPAUUnmapSurfacesNV0(numSurface, surfaces != null ? surfaces.getBuffer() : null, Buffers.getDirectBufferByteOffset(surfaces), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVDPAUUnmapSurfacesNV}(GLsizei numSurface, const GLvdpauSurfaceNV *  surfaces) </code> <br>Part of <code>GL_NV_vdpau_interop</code><br>
      @param surfaces a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glVDPAUUnmapSurfacesNV0(int numSurface, Object surfaces, int surfaces_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64NV}(GLuint index, GLint64EXT x) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL1i64NV(int index, long x)  {

    final long __addr_ = _pat._addressof_glVertexAttribL1i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64NV"));
    }
        dispatch_glVertexAttribL1i64NV1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64NV}(GLuint index, GLint64EXT x) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL1i64NV1(int index, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64NV}(GLuint index, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL2i64NV(int index, long x, long y)  {

    final long __addr_ = _pat._addressof_glVertexAttribL2i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64NV"));
    }
        dispatch_glVertexAttribL2i64NV1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64NV}(GLuint index, GLint64EXT x, GLint64EXT y) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL2i64NV1(int index, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL3i64NV(int index, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glVertexAttribL3i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64NV"));
    }
        dispatch_glVertexAttribL3i64NV1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL3i64NV1(int index, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL4i64NV(int index, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glVertexAttribL4i64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64NV"));
    }
        dispatch_glVertexAttribL4i64NV1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64NV}(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL4i64NV1(int index, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL1i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64vNV"));
    }
        dispatch_glVertexAttribL1i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL1i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL1i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL1i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1i64vNV"));
    }
        dispatch_glVertexAttribL1i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL2i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64vNV"));
    }
        dispatch_glVertexAttribL2i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL2i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL2i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL2i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2i64vNV"));
    }
        dispatch_glVertexAttribL2i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL3i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64vNV"));
    }
        dispatch_glVertexAttribL3i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL3i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL3i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL3i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3i64vNV"));
    }
        dispatch_glVertexAttribL3i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL4i64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64vNV"));
    }
        dispatch_glVertexAttribL4i64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL4i64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4i64vNV}(GLuint index, const GLint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL4i64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL4i64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4i64vNV"));
    }
        dispatch_glVertexAttribL4i64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64NV}(GLuint index, GLuint64EXT x) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL1ui64NV(int index, long x)  {

    final long __addr_ = _pat._addressof_glVertexAttribL1ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64NV"));
    }
        dispatch_glVertexAttribL1ui64NV1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64NV}(GLuint index, GLuint64EXT x) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL1ui64NV1(int index, long x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL2ui64NV(int index, long x, long y)  {

    final long __addr_ = _pat._addressof_glVertexAttribL2ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64NV"));
    }
        dispatch_glVertexAttribL2ui64NV1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL2ui64NV1(int index, long x, long y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL3ui64NV(int index, long x, long y, long z)  {

    final long __addr_ = _pat._addressof_glVertexAttribL3ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64NV"));
    }
        dispatch_glVertexAttribL3ui64NV1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL3ui64NV1(int index, long x, long y, long z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL4ui64NV(int index, long x, long y, long z, long w)  {

    final long __addr_ = _pat._addressof_glVertexAttribL4ui64NV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64NV"));
    }
        dispatch_glVertexAttribL4ui64NV1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64NV}(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribL4ui64NV1(int index, long x, long y, long z, long w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL1ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vNV"));
    }
        dispatch_glVertexAttribL1ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL1ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL1ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL1ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL1ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL1ui64vNV"));
    }
        dispatch_glVertexAttribL1ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL2ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64vNV"));
    }
        dispatch_glVertexAttribL2ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL2ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL2ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL2ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL2ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL2ui64vNV"));
    }
        dispatch_glVertexAttribL2ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL3ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64vNV"));
    }
        dispatch_glVertexAttribL3ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL3ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL3ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL3ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL3ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL3ui64vNV"));
    }
        dispatch_glVertexAttribL3ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glVertexAttribL4ui64vNV(int index, LongBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribL4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64vNV"));
    }
        dispatch_glVertexAttribL4ui64vNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param v a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glVertexAttribL4ui64vNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribL4ui64vNV}(GLuint index, const GLuint64EXT *  v) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribL4ui64vNV(int index, long[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribL4ui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribL4ui64vNV"));
    }
        dispatch_glVertexAttribL4ui64vNV1(index, v, Buffers.SIZEOF_LONG * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexAttribLi64vNV(int index, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribLi64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLi64vNV"));
    }
        dispatch_glGetVertexAttribLi64vNV1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexAttribLi64vNV1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLi64vNV}(GLuint index, GLenum pname, GLint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glGetVertexAttribLi64vNV(int index, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribLi64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLi64vNV"));
    }
        dispatch_glGetVertexAttribLi64vNV1(index, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetVertexAttribLui64vNV(int index, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribLui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vNV"));
    }
        dispatch_glGetVertexAttribLui64vNV1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetVertexAttribLui64vNV1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribLui64vNV}(GLuint index, GLenum pname, GLuint64EXT *  params) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glGetVertexAttribLui64vNV(int index, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribLui64vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribLui64vNV"));
    }
        dispatch_glGetVertexAttribLui64vNV1(index, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  public void glVertexAttribLFormatNV(int index, int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glVertexAttribLFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribLFormatNV"));
    }
        dispatch_glVertexAttribLFormatNV1(index, size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribLFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_attrib_integer_64bit</code><br>   */
  private native void dispatch_glVertexAttribLFormatNV1(int index, int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferAddressRangeNV}(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glBufferAddressRangeNV(int pname, int index, long address, long length)  {

    final long __addr_ = _pat._addressof_glBufferAddressRangeNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferAddressRangeNV"));
    }
        dispatch_glBufferAddressRangeNV1(pname, index, address, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferAddressRangeNV}(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glBufferAddressRangeNV1(int pname, int index, long address, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glVertexFormatNV(int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glVertexFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexFormatNV"));
    }
        dispatch_glVertexFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glVertexFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glNormalFormatNV(int type, int stride)  {

    final long __addr_ = _pat._addressof_glNormalFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalFormatNV"));
    }
        dispatch_glNormalFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glNormalFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glColorFormatNV(int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glColorFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorFormatNV"));
    }
        dispatch_glColorFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glColorFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glIndexFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glIndexFormatNV(int type, int stride)  {

    final long __addr_ = _pat._addressof_glIndexFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIndexFormatNV"));
    }
        dispatch_glIndexFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glIndexFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glIndexFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glTexCoordFormatNV(int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glTexCoordFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordFormatNV"));
    }
        dispatch_glTexCoordFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glTexCoordFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glEdgeFlagFormatNV}(GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glEdgeFlagFormatNV(int stride)  {

    final long __addr_ = _pat._addressof_glEdgeFlagFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEdgeFlagFormatNV"));
    }
        dispatch_glEdgeFlagFormatNV1(stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEdgeFlagFormatNV}(GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glEdgeFlagFormatNV1(int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glSecondaryColorFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glSecondaryColorFormatNV(int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glSecondaryColorFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSecondaryColorFormatNV"));
    }
        dispatch_glSecondaryColorFormatNV1(size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSecondaryColorFormatNV}(GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glSecondaryColorFormatNV1(int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogCoordFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glFogCoordFormatNV(int type, int stride)  {

    final long __addr_ = _pat._addressof_glFogCoordFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogCoordFormatNV"));
    }
        dispatch_glFogCoordFormatNV1(type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogCoordFormatNV}(GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glFogCoordFormatNV1(int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribFormatNV}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glVertexAttribFormatNV(int index, int size, int type, boolean normalized, int stride)  {

    final long __addr_ = _pat._addressof_glVertexAttribFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribFormatNV"));
    }
        dispatch_glVertexAttribFormatNV1(index, size, type, normalized, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribFormatNV}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glVertexAttribFormatNV1(int index, int size, int type, boolean normalized, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glVertexAttribIFormatNV(int index, int size, int type, int stride)  {

    final long __addr_ = _pat._addressof_glVertexAttribIFormatNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIFormatNV"));
    }
        dispatch_glVertexAttribIFormatNV1(index, size, type, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormatNV}(GLuint index, GLint size, GLenum type, GLsizei stride) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  private native void dispatch_glVertexAttribIFormatNV1(int index, int size, int type, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetIntegerui64i_vNV(int value, int index, LongBuffer result)  {

    final boolean result_is_direct = Buffers.isDirect(result);
    final long __addr_ = _pat._addressof_glGetIntegerui64i_vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64i_vNV"));
    }
        dispatch_glGetIntegerui64i_vNV1(value, index, result_is_direct ? result : Buffers.getArray(result), result_is_direct ? Buffers.getDirectBufferByteOffset(result) : Buffers.getIndirectBufferByteOffset(result), result_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>
      @param result a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetIntegerui64i_vNV1(int value, int index, Object result, int result_byte_offset, boolean result_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerui64i_vNV}(GLenum value, GLuint index, GLuint64EXT *  result) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code><br>   */
  public void glGetIntegerui64i_vNV(int value, int index, long[] result, int result_offset)  {

    if(result != null && result.length <= result_offset)
      throw new GLException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerui64i_vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerui64i_vNV"));
    }
        dispatch_glGetIntegerui64i_vNV1(value, index, result, Buffers.SIZEOF_LONG * result_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iEXT}(GLuint index, GLint x) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI1iEXT(int index, int x)  {

    final long __addr_ = _pat._addressof_glVertexAttribI1iEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1iEXT"));
    }
        dispatch_glVertexAttribI1iEXT1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1iEXT}(GLuint index, GLint x) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI1iEXT1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iEXT}(GLuint index, GLint x, GLint y) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI2iEXT(int index, int x, int y)  {

    final long __addr_ = _pat._addressof_glVertexAttribI2iEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2iEXT"));
    }
        dispatch_glVertexAttribI2iEXT1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2iEXT}(GLuint index, GLint x, GLint y) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI2iEXT1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iEXT}(GLuint index, GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI3iEXT(int index, int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glVertexAttribI3iEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3iEXT"));
    }
        dispatch_glVertexAttribI3iEXT1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3iEXT}(GLuint index, GLint x, GLint y, GLint z) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI3iEXT1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iEXT}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4iEXT(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4iEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iEXT"));
    }
        dispatch_glVertexAttribI4iEXT1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iEXT}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI4iEXT1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiEXT}(GLuint index, GLuint x) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI1uiEXT(int index, int x)  {

    final long __addr_ = _pat._addressof_glVertexAttribI1uiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uiEXT"));
    }
        dispatch_glVertexAttribI1uiEXT1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uiEXT}(GLuint index, GLuint x) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI1uiEXT1(int index, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiEXT}(GLuint index, GLuint x, GLuint y) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI2uiEXT(int index, int x, int y)  {

    final long __addr_ = _pat._addressof_glVertexAttribI2uiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uiEXT"));
    }
        dispatch_glVertexAttribI2uiEXT1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uiEXT}(GLuint index, GLuint x, GLuint y) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI2uiEXT1(int index, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI3uiEXT(int index, int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glVertexAttribI3uiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uiEXT"));
    }
        dispatch_glVertexAttribI3uiEXT1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI3uiEXT1(int index, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4uiEXT(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4uiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiEXT"));
    }
        dispatch_glVertexAttribI4uiEXT1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiEXT}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  private native void dispatch_glVertexAttribI4uiEXT1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI1ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ivEXT"));
    }
        dispatch_glVertexAttribI1ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI1ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI1ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1ivEXT"));
    }
        dispatch_glVertexAttribI1ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI2ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ivEXT"));
    }
        dispatch_glVertexAttribI2ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI2ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI2ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2ivEXT"));
    }
        dispatch_glVertexAttribI2ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI3ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ivEXT"));
    }
        dispatch_glVertexAttribI3ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI3ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI3ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3ivEXT"));
    }
        dispatch_glVertexAttribI3ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4ivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ivEXT"));
    }
        dispatch_glVertexAttribI4ivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4ivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ivEXT}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4ivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4ivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ivEXT"));
    }
        dispatch_glVertexAttribI4ivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI1uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI1uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uivEXT"));
    }
        dispatch_glVertexAttribI1uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI1uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI1uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI1uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI1uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI1uivEXT"));
    }
        dispatch_glVertexAttribI1uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI2uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI2uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uivEXT"));
    }
        dispatch_glVertexAttribI2uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI2uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI2uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI2uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI2uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI2uivEXT"));
    }
        dispatch_glVertexAttribI2uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI3uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI3uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uivEXT"));
    }
        dispatch_glVertexAttribI3uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI3uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI3uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI3uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI3uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI3uivEXT"));
    }
        dispatch_glVertexAttribI3uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uivEXT(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uivEXT"));
    }
        dispatch_glVertexAttribI4uivEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uivEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uivEXT}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4uivEXT(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4uivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uivEXT"));
    }
        dispatch_glVertexAttribI4uivEXT1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4bvEXT(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4bvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bvEXT"));
    }
        dispatch_glVertexAttribI4bvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4bvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4bvEXT}(GLuint index, const GLbyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4bvEXT(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4bvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4bvEXT"));
    }
        dispatch_glVertexAttribI4bvEXT1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4svEXT(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4svEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4svEXT"));
    }
        dispatch_glVertexAttribI4svEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4svEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4svEXT}(GLuint index, const GLshort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4svEXT(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4svEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4svEXT"));
    }
        dispatch_glVertexAttribI4svEXT1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glVertexAttribI4ubvEXT(int index, ByteBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4ubvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubvEXT"));
    }
        dispatch_glVertexAttribI4ubvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glVertexAttribI4ubvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ubvEXT}(GLuint index, const GLubyte *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4ubvEXT(int index, byte[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4ubvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ubvEXT"));
    }
        dispatch_glVertexAttribI4ubvEXT1(index, v, v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glVertexAttribI4usvEXT(int index, ShortBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4usvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usvEXT"));
    }
        dispatch_glVertexAttribI4usvEXT1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param v a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glVertexAttribI4usvEXT1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4usvEXT}(GLuint index, const GLushort *  v) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glVertexAttribI4usvEXT(int index, short[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4usvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4usvEXT"));
    }
        dispatch_glVertexAttribI4usvEXT1(index, v, Buffers.SIZEOF_SHORT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointerEXT}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glVertexAttribIPointerEXT(int index, int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glVertexAttribIPointerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointerEXT"));
    }
        dispatch_glVertexAttribIPointerEXT1(index, size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointerEXT}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointerEXT1(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIivEXT(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIivEXT"));
    }
        dispatch_glGetVertexAttribIivEXT1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIivEXT1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIivEXT}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glGetVertexAttribIivEXT(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIivEXT"));
    }
        dispatch_glGetVertexAttribIivEXT1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuivEXT(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuivEXT"));
    }
        dispatch_glGetVertexAttribIuivEXT1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuivEXT1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuivEXT}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_NV_vertex_program4</code><br>   */
  public void glGetVertexAttribIuivEXT(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIuivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuivEXT"));
    }
        dispatch_glGetVertexAttribIuivEXT1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVideoCaptureNV}(GLuint video_capture_slot) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glBeginVideoCaptureNV(int video_capture_slot)  {

    final long __addr_ = _pat._addressof_glBeginVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginVideoCaptureNV"));
    }
        dispatch_glBeginVideoCaptureNV1(video_capture_slot, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginVideoCaptureNV}(GLuint video_capture_slot) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  private native void dispatch_glBeginVideoCaptureNV1(int video_capture_slot, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamBufferNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glBindVideoCaptureStreamBufferNV(int video_capture_slot, int stream, int frame_region, long offset)  {

    final long __addr_ = _pat._addressof_glBindVideoCaptureStreamBufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVideoCaptureStreamBufferNV"));
    }
        dispatch_glBindVideoCaptureStreamBufferNV1(video_capture_slot, stream, frame_region, offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamBufferNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  private native void dispatch_glBindVideoCaptureStreamBufferNV1(int video_capture_slot, int stream, int frame_region, long offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamTextureNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glBindVideoCaptureStreamTextureNV(int video_capture_slot, int stream, int frame_region, int target, int texture)  {

    final long __addr_ = _pat._addressof_glBindVideoCaptureStreamTextureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVideoCaptureStreamTextureNV"));
    }
        dispatch_glBindVideoCaptureStreamTextureNV1(video_capture_slot, stream, frame_region, target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVideoCaptureStreamTextureNV}(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  private native void dispatch_glBindVideoCaptureStreamTextureNV1(int video_capture_slot, int stream, int frame_region, int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndVideoCaptureNV}(GLuint video_capture_slot) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glEndVideoCaptureNV(int video_capture_slot)  {

    final long __addr_ = _pat._addressof_glEndVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndVideoCaptureNV"));
    }
        dispatch_glEndVideoCaptureNV1(video_capture_slot, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndVideoCaptureNV}(GLuint video_capture_slot) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  private native void dispatch_glEndVideoCaptureNV1(int video_capture_slot, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVideoCaptureivNV(int video_capture_slot, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVideoCaptureivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureivNV"));
    }
        dispatch_glGetVideoCaptureivNV1(video_capture_slot, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVideoCaptureivNV1(int video_capture_slot, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureivNV}(GLuint video_capture_slot, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glGetVideoCaptureivNV(int video_capture_slot, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVideoCaptureivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureivNV"));
    }
        dispatch_glGetVideoCaptureivNV1(video_capture_slot, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVideoCaptureStreamivNV(int video_capture_slot, int stream, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamivNV"));
    }
        dispatch_glGetVideoCaptureStreamivNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamivNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glGetVideoCaptureStreamivNV(int video_capture_slot, int stream, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamivNV"));
    }
        dispatch_glGetVideoCaptureStreamivNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVideoCaptureStreamfvNV(int video_capture_slot, int stream, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamfvNV"));
    }
        dispatch_glGetVideoCaptureStreamfvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamfvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glGetVideoCaptureStreamfvNV(int video_capture_slot, int stream, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamfvNV"));
    }
        dispatch_glGetVideoCaptureStreamfvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glGetVideoCaptureStreamdvNV(int video_capture_slot, int stream, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamdvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamdvNV"));
    }
        dispatch_glGetVideoCaptureStreamdvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glGetVideoCaptureStreamdvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVideoCaptureStreamdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glGetVideoCaptureStreamdvNV(int video_capture_slot, int stream, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVideoCaptureStreamdvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVideoCaptureStreamdvNV"));
    }
        dispatch_glGetVideoCaptureStreamdvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param sequence_num a direct or array-backed {@link java.nio.IntBuffer}
      @param capture_time a direct or array-backed {@link java.nio.LongBuffer}   */
  public int glVideoCaptureNV(int video_capture_slot, IntBuffer sequence_num, LongBuffer capture_time)  {

    final boolean sequence_num_is_direct = Buffers.isDirect(sequence_num);
    final boolean capture_time_is_direct = Buffers.isDirect(capture_time);
    final long __addr_ = _pat._addressof_glVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureNV"));
    }
        return dispatch_glVideoCaptureNV1(video_capture_slot, sequence_num_is_direct ? sequence_num : Buffers.getArray(sequence_num), sequence_num_is_direct ? Buffers.getDirectBufferByteOffset(sequence_num) : Buffers.getIndirectBufferByteOffset(sequence_num), sequence_num_is_direct, capture_time_is_direct ? capture_time : Buffers.getArray(capture_time), capture_time_is_direct ? Buffers.getDirectBufferByteOffset(capture_time) : Buffers.getIndirectBufferByteOffset(capture_time), capture_time_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param sequence_num a direct or array-backed {@link java.nio.IntBuffer}
      @param capture_time a direct or array-backed {@link java.nio.LongBuffer}   */
  private native int dispatch_glVideoCaptureNV1(int video_capture_slot, Object sequence_num, int sequence_num_byte_offset, boolean sequence_num_is_direct, Object capture_time, int capture_time_byte_offset, boolean capture_time_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glVideoCaptureNV}(GLuint video_capture_slot, GLuint *  sequence_num, GLuint64EXT *  capture_time) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public int glVideoCaptureNV(int video_capture_slot, int[] sequence_num, int sequence_num_offset, long[] capture_time, int capture_time_offset)  {

    if(sequence_num != null && sequence_num.length <= sequence_num_offset)
      throw new GLException("array offset argument \"sequence_num_offset\" (" + sequence_num_offset + ") equals or exceeds array length (" + sequence_num.length + ")");
    if(capture_time != null && capture_time.length <= capture_time_offset)
      throw new GLException("array offset argument \"capture_time_offset\" (" + capture_time_offset + ") equals or exceeds array length (" + capture_time.length + ")");
    final long __addr_ = _pat._addressof_glVideoCaptureNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureNV"));
    }
        return dispatch_glVideoCaptureNV1(video_capture_slot, sequence_num, Buffers.SIZEOF_INT * sequence_num_offset, false, capture_time, Buffers.SIZEOF_LONG * capture_time_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVideoCaptureStreamParameterivNV(int video_capture_slot, int stream, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterivNV"));
    }
        dispatch_glVideoCaptureStreamParameterivNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterivNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterivNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glVideoCaptureStreamParameterivNV(int video_capture_slot, int stream, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterivNV"));
    }
        dispatch_glVideoCaptureStreamParameterivNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVideoCaptureStreamParameterfvNV(int video_capture_slot, int stream, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterfvNV"));
    }
        dispatch_glVideoCaptureStreamParameterfvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterfvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterfvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glVideoCaptureStreamParameterfvNV(int video_capture_slot, int stream, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterfvNV"));
    }
        dispatch_glVideoCaptureStreamParameterfvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public void glVideoCaptureStreamParameterdvNV(int video_capture_slot, int stream, int pname, DoubleBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterdvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterdvNV"));
    }
        dispatch_glVideoCaptureStreamParameterdvNV1(video_capture_slot, stream, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>
      @param params a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private native void dispatch_glVideoCaptureStreamParameterdvNV1(int video_capture_slot, int stream, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVideoCaptureStreamParameterdvNV}(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *  params) </code> <br>Part of <code>GL_NV_video_capture</code><br>   */
  public void glVideoCaptureStreamParameterdvNV(int video_capture_slot, int stream, int pname, double[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glVideoCaptureStreamParameterdvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVideoCaptureStreamParameterdvNV"));
    }
        dispatch_glVideoCaptureStreamParameterdvNV1(video_capture_slot, stream, pname, params, Buffers.SIZEOF_DOUBLE * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureMultiviewOVR}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) </code> <br>Part of <code>GL_OVR_multiview</code><br>   */
  public void glFramebufferTextureMultiviewOVR(int target, int attachment, int texture, int level, int baseViewIndex, int numViews)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureMultiviewOVR;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureMultiviewOVR"));
    }
        dispatch_glFramebufferTextureMultiviewOVR1(target, attachment, texture, level, baseViewIndex, numViews, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureMultiviewOVR}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) </code> <br>Part of <code>GL_OVR_multiview</code><br>   */
  private native void dispatch_glFramebufferTextureMultiviewOVR1(int target, int attachment, int texture, int level, int baseViewIndex, int numViews, long procAddress);

  /** Entry point to C language function: <code> void {@native glHintPGI}(GLenum target, GLint mode) </code> <br>Part of <code>GL_PGI_misc_hints</code><br>   */
  public void glHintPGI(int target, int mode)  {

    final long __addr_ = _pat._addressof_glHintPGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHintPGI"));
    }
        dispatch_glHintPGI1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHintPGI}(GLenum target, GLint mode) </code> <br>Part of <code>GL_PGI_misc_hints</code><br>   */
  private native void dispatch_glHintPGI1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishTextureSUNX}(void) </code> <br>Part of <code>GL_SUNX_constant_data</code><br>   */
  public void glFinishTextureSUNX()  {

    final long __addr_ = _pat._addressof_glFinishTextureSUNX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinishTextureSUNX"));
    }
        dispatch_glFinishTextureSUNX1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishTextureSUNX}(void) </code> <br>Part of <code>GL_SUNX_constant_data</code><br>   */
  private native void dispatch_glFinishTextureSUNX1(long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
      private final GLProfile glProfile;
      private final GLContextImpl _context;
  
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
  
      @Override
      public final int getBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final GLBufferStorage getBufferStorage(int bufferName) {
          return bufferObjectTracker.getBufferStorage(bufferName);
      }
  
      @Override
      public final boolean isVBOArrayBound() {
          return checkArrayVBOBound(false);
      }
  
      @Override
      public final boolean isVBOElementArrayBound() {
          return checkElementVBOBound(false);
      }
  
      @Override
      public final GL getDownstreamGL() throws GLException {
          return null;
      }
  
      @Override
      public final GL getRootGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final boolean hasBasicFBOSupport() {
        return _context.hasBasicFBOSupport();
      }
  
      @Override
      public final boolean hasFullFBOSupport() {
        return _context.hasFullFBOSupport();
      }
  
      @Override
      public final int getMaxRenderbufferSamples() {
        return _context.getMaxRenderbufferSamples();
      }
  
      @Override
      public final boolean isTextureFormatBGRA8888Available() {
        return _context.isTextureFormatBGRA8888Available();
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
      @Override
      public final int getDefaultReadBuffer() {
        return _context.getDefaultReadBuffer();
      }
  
      private final GLStateTracker       glStateTracker;
  
      //
      // GLBufferObjectTracker Redirects
      //
      private final GLBufferObjectTracker bufferObjectTracker;
      private final GLBufferStateTracker bufferStateTracker;
  
      @Override
      public final void glBufferData(int target, long size, Buffer data, int usage)  {
          bufferObjectTracker.createBufferStorage(bufferStateTracker, this, 
                                                  target, size, data, usage, 0 /* immutableFlags */, 
                                                  glBufferDataDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
              public final void create(final int target, final long size, final Buffer data, final int mutableUsage) {
                  glBufferDataDelegate(target, size, data, mutableUsage);
              }
          };
  
      @Override
      public boolean glUnmapBuffer(int target)  {
          return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, target, glUnmapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch() {
              public final boolean unmap(final int target) {
                  return glUnmapBufferDelegate(target);
              }
          };
  
      @Override
      public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
        return mapBuffer(target, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBuffer(final int target, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, access, glMapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final int access) {
                  return glMapBufferDelegate(target, access);
              }
          };
  
      @Override
      public final ByteBuffer glMapBufferRange(int target, long offset, long length, int access)  {
        return mapBufferRange(target, offset, length, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBufferRange(final int target, final long offset, final long length, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, offset, length, access, glMapBufferRangeDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final long offset, final long length, final int access) {
                  return glMapBufferRangeDelegate(target, offset, length, access);
              }
          };
  
      private native ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  private final GL4bcProcAddressTable _pat;
  
  // Tracks glBegin/glEnd calls to determine whether it is legal to
  // query Vertex Buffer Object state
  private boolean inBeginEndPair;
  
  /* FIXME: refactor dependence on Java 2D / JOGL bridge
  
  // Tracks creation and destruction of server-side OpenGL objects when
  // the Java2D/OpenGL pipeline is enabled and it is using frame buffer
  // objects (FBOs) to do its rendering
  private GLObjectTracker tracker;
  
  public void setObjectTracker(GLObjectTracker tracker) {
    this.tracker = tracker;
  }
  
  */
  
  public GL4bcImpl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    this._pat = (GL4bcProcAddressTable)_context.getGLProcAddressTable();
    this.bufferObjectTracker = context.getBufferObjectTracker();
    this.bufferStateTracker = context.getBufferStateTracker();
    this.glStateTracker     = context.getGLStateTracker();
    this.glProfile = glp;
  }
  
  public final void finalizeInit() {
    haveARBPixelBufferObject  = isExtensionAvailable("GL_ARB_pixel_buffer_object");
    haveEXTPixelBufferObject  = isExtensionAvailable("GL_EXT_pixel_buffer_object");
    haveGL15                  = isExtensionAvailable("GL_VERSION_1_5");
    haveGL21                  = isExtensionAvailable("GL_VERSION_2_1");
    haveARBVertexBufferObject = isExtensionAvailable("GL_ARB_vertex_buffer_object");
    haveARBVertexArrayObject  = _context.getGLVersionNumber().compareTo(GLContext.Version3_0) >= 0 ||
                                isExtensionAvailable("GL_ARB_vertex_array_object");
  }
  
  private int[] imageSizeTemp = new int[1];
  
  private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
      return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
  }
  
  @Override
  public final boolean isGL4bc() {
      return _context.isGL4bc();
  }
  
  @Override
  public final boolean isGL4() {
      return _context.isGL4();
  }
  
  @Override
  public final boolean isGL3bc() {
      return _context.isGL3bc();
  }
  
  @Override
  public final boolean isGL3() {
      return _context.isGL3();
  }
  
  @Override
  public final boolean isGL2() {
      return _context.isGL2();
  }
    
  @Override
  public final boolean isGL2ES1() {
      return _context.isGL2ES1();
  }
  
  @Override
  public final boolean isGL2ES2() {
      return _context.isGL2ES2();
  }
  
  @Override
  public final boolean isGL2ES3() {
      return _context.isGL2ES3();
  }
  
  @Override
  public final boolean isGL3ES3() {
      return _context.isGL3ES3();
  }
  
  @Override
  public final boolean isGL4ES3() {
      return _context.isGL4ES3();
  }
  
  @Override
  public final boolean isGL4core() {
      return _context.isGL4core();
  }
  
  @Override
  public final boolean isGL3core() {
      return _context.isGL3core();
  }
  
  @Override
  public final boolean isGLcore() {
      return _context.isGLcore();
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return _context.isGLES2Compatible();
  }
  
  @Override
  public final boolean isGLES3Compatible() {
      return _context.isGLES3Compatible();
  }
  
  @Override
  public final boolean isGLES31Compatible() {
      return _context.isGLES31Compatible();
  }
  
  @Override
  public final boolean isGLES32Compatible() {
      return _context.isGLES32Compatible();
  }
  
  @Override
  public final boolean isGL2GL3() {
      return _context.isGL2GL3();
  }
  
  @Override
  public final boolean hasGLSL() {
      return _context.hasGLSL();
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      if(!isGL4bc()) {
          throw new GLException("Not a GL4bc implementation");
      }
      return this;
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      if(!isGL4()) {
          throw new GLException("Not a GL4 implementation");
      }
      return this;
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      if(!isGL3bc()) {
          throw new GLException("Not a GL3bc implementation");
      }
      return this;
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      if(!isGL3()) {
          throw new GLException("Not a GL3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      if(!isGL2()) {
          throw new GLException("Not a GL2 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      if(!isGL2ES1()) {
          throw new GLException("Not a GL2ES1 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      if(!isGL2ES2()) {
          throw new GLException("Not a GL2ES2 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2ES3 getGL2ES3() throws GLException {
      if(!isGL2ES3()) {
          throw new GLException("Not a GL2ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL3ES3 getGL3ES3() throws GLException {
      if(!isGL3ES3()) {
          throw new GLException("Not a GL3ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL4ES3 getGL4ES3() throws GLException {
      if(!isGL4ES3()) {
          throw new GLException("Not a GL4ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      if(!isGL2GL3()) {
          throw new GLException("Not a GL2GL3 implementation");
      }
      return this;
  }
  
  @Override
  public final boolean isGLES1() {
      return false;
  }
  
  @Override
  public final boolean isGLES2() {
      return false;
  }
  
  @Override
  public final boolean isGLES3() {
      return false;
  }
  
  @Override
  public final boolean isGLES() {
      return false;
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      throw new GLException("Not a GLES1 implementation");
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      throw new GLException("Not a GLES2 implementation");
  }
  
  @Override
  public final GLES3 getGLES3() throws GLException {
      throw new GLException("Not a GLES3 implementation");
  }
  
  @Override
  public final boolean isNPOTTextureAvailable() {
    return _context.isNPOTTextureAvailable();
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private boolean haveARBPixelBufferObject;
  private boolean haveEXTPixelBufferObject;
  private boolean haveGL15;
  private boolean haveGL21;
  private boolean haveARBVertexBufferObject;
  private boolean haveARBVertexArrayObject;
  
  private final boolean checkBufferObject(boolean extensionAvail,
                                          boolean allowVAO,
                                          boolean bound,
                                          int state,
                                          String kind, boolean throwException) {
    if ( inBeginEndPair ) {
      throw new GLException("May not call this between glBegin and glEnd");
    }
    if ( !extensionAvail ) {
      if ( !bound ) {
        return true;
      }
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if ( bound ) {
      if ( 0 != buffer ) {
          return true;
      }
      if ( allowVAO ) {
          buffer = bufferStateTracker.getBoundBufferObject(GL2ES3.GL_VERTEX_ARRAY_BINDING, this);
          if( 0 != buffer && _context.getDefaultVAO() != buffer ) {
              return true;
          }
      }
      if ( throwException ) {
          throw new GLException(kind + " must be bound to call this method");
      }
      return false;
    } else {
      if ( 0 == buffer ) {
          return true;
      }
      if ( throwException ) {
          throw new GLException(kind + " must be unbound to call this method");
      }
      return false;
    }
  }  
  
  private final void validateCPUSourcedAvail() {
      if(!_context.isCPUDataSourcingAvail()) {
          throw new GLException("CPU data sourcing n/a w/ "+_context);
      }
  }
  
  private final boolean checkArrayVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             false, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOBound(boolean throwException) { 
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             true, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             false, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOBound(boolean throwException) { 
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             true, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkIndirectVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             false, // bound
                             GL4ES3.GL_DRAW_INDIRECT_BUFFER,
                             "indirect vertex_buffer_object", throwException);
  }
  
  private final boolean checkIndirectVBOBound(boolean throwException) { 
    return checkBufferObject(haveGL15 || haveARBVertexBufferObject,
                             haveARBVertexArrayObject, // allowVAO
                             true, // bound
                             GL4ES3.GL_DRAW_INDIRECT_BUFFER,
                             "indirect vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOUnbound(boolean throwException) { 
    return checkBufferObject(haveGL21 || haveARBPixelBufferObject || haveEXTPixelBufferObject,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOBound(boolean throwException) { 
    return checkBufferObject(haveGL21 || haveARBPixelBufferObject || haveEXTPixelBufferObject,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOUnbound(boolean throwException) { 
    return checkBufferObject(haveGL21 || haveARBPixelBufferObject || haveEXTPixelBufferObject,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOBound(boolean throwException) { 
    return checkBufferObject(haveGL21 || haveARBPixelBufferObject || haveEXTPixelBufferObject,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  @Override
  public final boolean isPBOPackBound() {
      return checkPackPBOBound(false);
  }
  
  @Override
  public final boolean isPBOUnpackBound() {
      return checkUnpackPBOBound(false);
  }
  
  @Override
  public final void glVertexPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glColorPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  
  }
  @Override
  public final void glNormalPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.getComponentCount()!=3) {
      throw new GLException("Only 3 components per normal allowed");
    }
    if(array.isVBO()) {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glTexCoordPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  
  //
  // GLBufferObjectTracker Redirects
  //
  
  @Override
  public final void glNamedBufferData(int buffer, long size, Buffer data, int usage)  {
      bufferObjectTracker.createBufferStorage(this, 
                                              buffer, size, data, usage, 0 /* immutableFlags */,
                                              glNamedBufferDataDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glNamedBufferDataDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
          public final void create(final int buffer, final long size, final Buffer data, final int mutableUsage) {
              glNamedBufferDataDelegate(buffer, size, data, mutableUsage);
          }
      };
  
  @Override
  public final void glNamedBufferDataEXT(int buffer, long size, Buffer data, int usage)  {
      bufferObjectTracker.createBufferStorage(this, 
                                              buffer, size, data, usage, 0 /* immutableFlags */,
                                              glNamedBufferDataEXTDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glNamedBufferDataEXTDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
          public final void create(final int buffer, final long size, final Buffer data, final int mutableUsage) {
              glNamedBufferDataEXTDelegate(buffer, size, data, mutableUsage);
          }
      };
  
  @Override
  public final void glBufferStorage(int target, long size, Buffer data, int flags)  {
      bufferObjectTracker.createBufferStorage(bufferStateTracker, this, 
                                              target, size, data, 0 /* mutableUsage */, flags, 
                                              glBufferStorageDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferStorageDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
          public final void create(final int target, final long size, final Buffer data, final int immutableFlags) {
              glBufferStorageDelegate(target, size, data, immutableFlags);
          }
      };
  
  @Override
  public final void glNamedBufferStorage(int buffer, long size, Buffer data, int flags)  {
      bufferObjectTracker.createBufferStorage(this, 
                                              buffer, size, data, 0 /* mutableUsage */, flags,
                                              glNamedBufferStorageDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glNamedBufferStorageDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
          public final void create(final int buffer, final long size, final Buffer data, final int immutableFlags) {
              glNamedBufferStorageDelegate(buffer, size, data, immutableFlags);
          }
      };
  @Override
  public final void glNamedBufferStorageEXT(int buffer, long size, Buffer data, int flags)  {
      bufferObjectTracker.createBufferStorage(this, 
                                              buffer, size, data, 0 /* mutableUsage */, flags,
                                              glNamedBufferStorageEXTDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glNamedBufferStorageEXTDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
          public final void create(final int buffer, final long size, final Buffer data, final int immutableFlags) {
              glNamedBufferStorageEXTDelegate(buffer, size, data, immutableFlags);
          }
      };
  
  @Override
  public boolean glUnmapNamedBuffer(int buffer)  {
      return bufferObjectTracker.unmapBuffer(buffer, glUnmapNamedBufferDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapNamedBufferDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch() {
          public final boolean unmap(final int buffer) {
              return glUnmapNamedBufferDelegate(buffer);
          }
      };
  
  @Override
  public final java.nio.ByteBuffer glMapNamedBuffer(int bufferName, int access)  {
    return mapNamedBuffer(bufferName, access).getMappedBuffer();
  }
  @Override
  public final GLBufferStorage mapNamedBuffer(final int bufferName, final int access) {
    return bufferObjectTracker.mapBuffer(bufferName, access, glMapNamedBufferDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapNamedBufferDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
          public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
          public final long mapBuffer(final int bufferName, final int access) {
              return glMapNamedBufferDelegate(bufferName, access);
          }
      };
  
  @Override
  public final java.nio.ByteBuffer glMapNamedBufferEXT(int bufferName, int access)  {
    return mapNamedBufferEXT(bufferName, access).getMappedBuffer();
  }
  @Override
  public final GLBufferStorage mapNamedBufferEXT(final int bufferName, final int access) {
    return bufferObjectTracker.mapBuffer(bufferName, access, glMapNamedBufferEXTDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapNamedBufferEXTDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
          public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
          public final long mapBuffer(final int bufferName, final int access) {
              return glMapNamedBufferEXTDelegate(bufferName, access);
          }
      };
  
  @Override
  public final ByteBuffer glMapNamedBufferRange(int bufferName, long offset, long length, int access)  {
    return mapNamedBufferRange(bufferName, offset, length, access).getMappedBuffer();
  }
  @Override
  public final GLBufferStorage mapNamedBufferRange(final int bufferName, final long offset, final long length, final int access) {
    return bufferObjectTracker.mapBuffer(bufferName, offset, length, access, glMapNamedBufferRangeDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapNamedBufferRangeDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
          public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
          public final long mapBuffer(final int bufferName, final long offset, final long length, final int access) {
              return glMapNamedBufferRangeDelegate(bufferName, offset, length, access);
          }
      };
  
  @Override
  public final ByteBuffer glMapNamedBufferRangeEXT(int bufferName, long offset, long length, int access)  {
    return mapNamedBufferRangeEXT(bufferName, offset, length, access).getMappedBuffer();
  }
  @Override
  public final GLBufferStorage mapNamedBufferRangeEXT(final int bufferName, final long offset, final long length, final int access) {
    return bufferObjectTracker.mapBuffer(bufferName, offset, length, access, glMapNamedBufferRangeEXTDispatch);
  }
  private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapNamedBufferRangeEXTDispatch = 
      new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
          public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
          public final long mapBuffer(final int bufferName, final long offset, final long length, final int access) {
              return glMapNamedBufferRangeEXTDelegate(bufferName, offset, length, access);
          }
      };
  
    @Override
    public final void glVertexAttribPointer(GLArrayData array) {
      if(array.getComponentCount()==0) return;
      if(array.isVBO()) {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getVBOOffset());
      } else {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getBuffer());
      }
    }
  
    @Override
    public final void glUniform(GLUniformData data) {
      boolean done=false;
      if(data.isBuffer()) {
          Buffer buffer = data.getBuffer();
          if(data.isMatrix()) {
              if(buffer instanceof FloatBuffer) {
                  switch(data.columns()) {
                      case 2: glUniformMatrix2fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 3: glUniformMatrix3fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 4: glUniformMatrix4fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
              }
          } else {
              if(buffer instanceof IntBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 2: glUniform2iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 3: glUniform3iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 4: glUniform4iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                  }
              } else if(buffer instanceof FloatBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 2: glUniform2fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 3: glUniform3fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 4: glUniform4fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
              }
          }
      } else {
          Object obj = data.getObject();
          if(obj instanceof Integer) {
              glUniform1i(data.getLocation(), ((Integer)obj).intValue());
              done=true;
          } else if (obj instanceof Float) {
              glUniform1f(data.getLocation(), ((Float)obj).floatValue());
              done=true;
          }
          if(!done) {
              throw new GLException("glUniform atom only available for 1i and 1f");
          }
      }
    }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GL4bcImpl
