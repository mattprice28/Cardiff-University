/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:19:57 CEST 2015 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.ProcAddressTable;
import com.jogamp.common.util.SecurityUtil;

/**
 * This table is a cache of pointers to the dynamically-linkable C library.
 * @see ProcAddressTable
 */
public final class GLXExtProcAddressTable extends ProcAddressTable {


  public GLXExtProcAddressTable(){ super(); }

  public GLXExtProcAddressTable(com.jogamp.gluegen.runtime.FunctionAddressResolver resolver){ super(resolver); }

  /* pp */ long _addressof_glXGetProcAddress;
  /* pp */ long _addressof_glXGetProcAddressARB;
  /* pp */ long _addressof_glXCreateContextAttribsARB;
  /* pp */ long _addressof_glXGetGPUIDsAMD;
  /* pp */ long _addressof_glXGetGPUInfoAMD;
  /* pp */ long _addressof_glXGetContextGPUIDAMD;
  /* pp */ long _addressof_glXCreateAssociatedContextAMD;
  /* pp */ long _addressof_glXCreateAssociatedContextAttribsAMD;
  /* pp */ long _addressof_glXDeleteAssociatedContextAMD;
  /* pp */ long _addressof_glXMakeAssociatedContextCurrentAMD;
  /* pp */ long _addressof_glXGetCurrentAssociatedContextAMD;
  /* pp */ long _addressof_glXBlitContextFramebufferAMD;
  /* pp */ long _addressof_glXGetCurrentDisplayEXT;
  /* pp */ long _addressof_glXQueryContextInfoEXT;
  /* pp */ long _addressof_glXGetContextIDEXT;
  /* pp */ long _addressof_glXImportContextEXT;
  /* pp */ long _addressof_glXFreeContextEXT;
  /* pp */ long _addressof_glXSwapIntervalEXT;
  /* pp */ long _addressof_glXBindTexImageEXT;
  /* pp */ long _addressof_glXReleaseTexImageEXT;
  /* pp */ long _addressof_glXGetAGPOffsetMESA;
  /* pp */ long _addressof_glXCopySubBufferMESA;
  /* pp */ long _addressof_glXQueryCurrentRendererIntegerMESA;
  /* pp */ long _addressof_glXQueryCurrentRendererStringMESA;
  /* pp */ long _addressof_glXQueryRendererIntegerMESA;
  /* pp */ long _addressof_glXQueryRendererStringMESA;
  /* pp */ long _addressof_glXReleaseBuffersMESA;
  /* pp */ long _addressof_glXSet3DfxModeMESA;
  /* pp */ long _addressof_glXCopyBufferSubDataNV;
  /* pp */ long _addressof_glXNamedCopyBufferSubDataNV;
  /* pp */ long _addressof_glXCopyImageSubDataNV;
  /* pp */ long _addressof_glXDelayBeforeSwapNV;
  /* pp */ long _addressof_glXEnumerateVideoDevicesNV;
  /* pp */ long _addressof_glXBindVideoDeviceNV;
  /* pp */ long _addressof_glXJoinSwapGroupNV;
  /* pp */ long _addressof_glXBindSwapBarrierNV;
  /* pp */ long _addressof_glXQuerySwapGroupNV;
  /* pp */ long _addressof_glXQueryMaxSwapGroupsNV;
  /* pp */ long _addressof_glXQueryFrameCountNV;
  /* pp */ long _addressof_glXResetFrameCountNV;
  /* pp */ long _addressof_glXBindVideoCaptureDeviceNV;
  /* pp */ long _addressof_glXEnumerateVideoCaptureDevicesNV;
  /* pp */ long _addressof_glXLockVideoCaptureDeviceNV;
  /* pp */ long _addressof_glXQueryVideoCaptureDeviceNV;
  /* pp */ long _addressof_glXReleaseVideoCaptureDeviceNV;
  /* pp */ long _addressof_glXGetVideoDeviceNV;
  /* pp */ long _addressof_glXReleaseVideoDeviceNV;
  /* pp */ long _addressof_glXBindVideoImageNV;
  /* pp */ long _addressof_glXReleaseVideoImageNV;
  /* pp */ long _addressof_glXSendPbufferToVideoNV;
  /* pp */ long _addressof_glXGetVideoInfoNV;
  /* pp */ long _addressof_glXGetSyncValuesOML;
  /* pp */ long _addressof_glXGetMscRateOML;
  /* pp */ long _addressof_glXSwapBuffersMscOML;
  /* pp */ long _addressof_glXWaitForMscOML;
  /* pp */ long _addressof_glXWaitForSbcOML;
  /* pp */ long _addressof_glXBindSwapBarrierSGIX;
  /* pp */ long _addressof_glXQueryMaxSwapBarriersSGIX;
  /* pp */ long _addressof_glXJoinSwapGroupSGIX;
  /* pp */ long _addressof_glXBindChannelToWindowSGIX;
  /* pp */ long _addressof_glXChannelRectSGIX;
  /* pp */ long _addressof_glXQueryChannelRectSGIX;
  /* pp */ long _addressof_glXQueryChannelDeltasSGIX;
  /* pp */ long _addressof_glXChannelRectSyncSGIX;
  /* pp */ long _addressof_glXCushionSGI;
  /* pp */ long _addressof_glXMakeCurrentReadSGI;
  /* pp */ long _addressof_glXGetCurrentReadDrawableSGI;
  /* pp */ long _addressof_glXSwapIntervalSGI;
  /* pp */ long _addressof_glXGetVideoSyncSGI;
  /* pp */ long _addressof_glXWaitVideoSyncSGI;
  /* pp */ long _addressof_glXGetTransparentIndexSUN;
  @Override
  protected boolean isFunctionAvailableImpl(String functionNameUsr) throws IllegalArgumentException  {
    final String functionNameBase = com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeVEN(com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeARB(functionNameUsr, true), true);
    final String addressFieldNameBase = "_addressof_" + functionNameBase;
    final int funcNamePermNum = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutationNumber(functionNameBase);
    final java.lang.reflect.Field addressField = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<java.lang.reflect.Field>() {
        public final java.lang.reflect.Field run() {
            java.lang.reflect.Field addressField = null;
            for(int i = 0; i < funcNamePermNum; i++) {
                final String addressFieldName = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutation(addressFieldNameBase, i);
                try {
                    addressField = GLXExtProcAddressTable.class.getDeclaredField( addressFieldName );
                    addressField.setAccessible(true); // we need to read the protected value!
                    return addressField;
                } catch (NoSuchFieldException ex) { }
            }
            return null;
        } } );

    if(null==addressField) {
      // The user is calling a bogus function or one which is not
      // runtime linked
      throw new RuntimeException(
          "WARNING: Address field query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or address field is not a known " +
          "function");
    } 
    try {
      return 0 != addressField.getLong(this);
    } catch (Exception e) {
      throw new RuntimeException(
          "WARNING: Address query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or is not a known " +
          "function", e);
    }
  }
  @Override
  public long getAddressFor(String functionNameUsr) throws SecurityException, IllegalArgumentException {
    SecurityUtil.checkAllLinkPermission();
    final String functionNameBase = com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeVEN(com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeARB(functionNameUsr, true), true);
    final String addressFieldNameBase = "_addressof_" + functionNameBase;
    final int  funcNamePermNum = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutationNumber(functionNameBase);
    final java.lang.reflect.Field addressField = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<java.lang.reflect.Field>() {
        public final java.lang.reflect.Field run() {
            java.lang.reflect.Field addressField = null;
            for(int i = 0; i < funcNamePermNum; i++) {
                final String addressFieldName = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutation(addressFieldNameBase, i);
                try {
                    addressField = GLXExtProcAddressTable.class.getDeclaredField( addressFieldName );
                    addressField.setAccessible(true); // we need to read the protected value!
                    return addressField;
                } catch (NoSuchFieldException ex) { }
            }
            return null;
        } } );

    if(null==addressField) {
      // The user is calling a bogus function or one which is not
      // runtime linked
      throw new RuntimeException(
          "WARNING: Address field query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or address field is not a known " +
          "function");
    } 
    try {
      return addressField.getLong(this);
    } catch (Exception e) {
      throw new RuntimeException(
          "WARNING: Address query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or is not a known " +
          "function", e);
    }
  }
} // end of class GLXExtProcAddressTable
