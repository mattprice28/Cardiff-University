/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:19:45 CEST 2015 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

 /**
  * Provides access to the X11-specific OpenGL vendor extensions.
  * See {@link GLBase} for more information.
  */
public class GLX {

  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_BLUE_VALUE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_BLUE_VALUE = 0x27;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_ACCUM_ALPHA_SIZE = 0x11;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRUE_COLOR_EXT = 0x8002;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_ACCUM_RED_SIZE = 0xe;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_X_VISUAL_TYPE_EXT</code> - CType: int */
  public static final int GLX_X_VISUAL_TYPE = 0x22;
  /** <code>GLX_EXT_import_context</code> - CType: int */
  public static final int GLX_SHARE_CONTEXT_EXT = 0x800a;
  /** <code>GLX_EXT_import_context</code> - CType: int */
  public static final int GLX_SCREEN_EXT = 0x800c;
  /** <code>GLX_ARB_multisample</code> - CType: int */
  public static final int GLX_SAMPLE_BUFFERS_ARB = 0x186a0;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_RED_VALUE_EXT = 0x25;
  /** <code>GLX_ARB_create_context</code> - CType: int */
  public static final int GLX_CONTEXT_DEBUG_BIT_ARB = 0x1;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_STATIC_GRAY_EXT = 0x8007;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_X_VISUAL_TYPE_EXT = 0x22;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_STEREO = 0x6;
  /** <code>GLX_ARB_create_context</code> - CType: int */
  public static final int GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB = 0x2;
  /** <code>GLX_ARB_vertex_buffer_object</code> - CType: int */
  public static final int GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB = 0x2095;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_GREEN_SIZE = 0x9;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_INDEX_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_INDEX = 0x8009;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_INDEX_VALUE_EXT = 0x24;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_PSEUDO_COLOR_EXT</code> - CType: int */
  public static final int GLX_PSEUDO_COLOR = 0x8004;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_STATIC_COLOR_EXT = 0x8005;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_DOUBLEBUFFER = 0x5;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_TYPE_EXT = 0x23;
  /** <code>GLX_ARB_context_flush_control</code> - CType: int */
  public static final int GLX_CONTEXT_RELEASE_BEHAVIOR_ARB = 0x2097;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_DEPTH_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_DEPTH_BUFFER_BIT = 0x20;
  /** <code>GLX_ARB_create_context_profile</code> - CType: int */
  public static final int GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB = 0x2;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_WIDTH_SGIX</code> - CType: int */
  public static final int GLX_WIDTH = 0x801d;
  /** <code>GLX_EXT_stereo_tree</code> - CType: int */
  public static final int GLX_STEREO_NOTIFY_MASK_EXT = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_LARGEST_PBUFFER_SGIX</code> - CType: int */
  public static final int GLX_LARGEST_PBUFFER = 0x801c;
  /** <code>GLX_EXT_visual_rating</code> - CType: int */
  public static final int GLX_NON_CONFORMANT_VISUAL_EXT = 0x800d;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_HEIGHT_SGIX</code> - CType: int */
  public static final int GLX_HEIGHT = 0x801e;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_DIRECT_COLOR_EXT = 0x8003;
  /** <code>GLX_ARB_framebuffer_sRGB</code> - CType: int */
  public static final int GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB = 0x20b2;
  /** <code>GLX_EXT_visual_rating</code> - CType: int */
  public static final int GLX_VISUAL_CAVEAT_EXT = 0x20;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_BACK_LEFT_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_BACK_LEFT_BUFFER_BIT = 0x4;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_CONTEXT = 0x5;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_PBUFFER_HEIGHT = 0x8040;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_ATTRIBUTE = 0x2;
  /** <code>GLX_ARB_multisample</code> - CType: int */
  public static final int GLX_SAMPLES_ARB = 0x186a1;
  /** <code>GLX_VERSION_1_4</code>, <code>GLX_SGIS_multisample</code>, <code>GLX_ARB_multisample</code>, <code>GLX_3DFX_multisample</code><br>Alias for: <code>GLX_SAMPLE_BUFFERS_SGIS</code>, <code>GLX_SAMPLE_BUFFERS_ARB</code>, <code>GLX_SAMPLE_BUFFERS_3DFX</code> - CType: int */
  public static final int GLX_SAMPLE_BUFFERS = 0x186a0;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_WINDOW_BIT_SGIX</code> - CType: int */
  public static final int GLX_WINDOW_BIT = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_ALPHA_VALUE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE = 0x28;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_FBCONFIG_ID_SGIX</code> - CType: int */
  public static final int GLX_FBCONFIG_ID = 0x8013;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_INDEX_VALUE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_INDEX_VALUE = 0x24;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_PSEUDO_COLOR_EXT = 0x8004;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BLUE_SIZE = 0xa;
  /** <code>GLX_INTEL_swap_event</code> - CType: int */
  public static final int GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK = 0x4000000;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_PBUFFER_CLOBBER_MASK = 0x8000000;
  /** <code>GLX_ARB_create_context_robustness</code> - CType: int */
  public static final int GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB = 0x4;
  /** <code>GLX_ARB_robustness_application_isolation</code> - CType: int */
  public static final int GLX_CONTEXT_RESET_ISOLATION_BIT_ARB = 0x8;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_MAX_PBUFFER_WIDTH_SGIX</code> - CType: int */
  public static final int GLX_MAX_PBUFFER_WIDTH = 0x8016;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_RENDER_TYPE_SGIX</code> - CType: int */
  public static final int GLX_RENDER_TYPE = 0x8011;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_NONE_EXT = 0x8000;
  /** <code>GLX_ARB_create_context_profile</code> - CType: int */
  public static final int GLX_CONTEXT_CORE_PROFILE_BIT_ARB = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_NONE_EXT</code> - CType: int */
  public static final int GLX_NONE = 0x8000;
  /** <code>GLX_ARB_create_context</code> - CType: int */
  public static final int GLX_CONTEXT_MAJOR_VERSION_ARB = 0x2091;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_RGBA = 0x4;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_DEPTH_SIZE = 0xc;
  /** <code>GLX_ARB_create_context</code> - CType: int */
  public static final int GLX_CONTEXT_MINOR_VERSION_ARB = 0x2092;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_GREEN_VALUE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_GREEN_VALUE = 0x26;
  /** <code>GLX_VERSION_1_1</code> - CType: int */
  public static final int GLX_VENDOR = 0x1;
  /** <code>GLX_INTEL_swap_event</code> - CType: int */
  public static final int GLX_COPY_COMPLETE_INTEL = 0x8181;
  /** <code>GLX_ARB_create_context_robustness</code> - CType: int */
  public static final int GLX_NO_RESET_NOTIFICATION_ARB = 0x8261;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BUFFER_SIZE = 0x2;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_PBUFFER_SGIX</code> - CType: int */
  public static final int GLX_PBUFFER = 0x8023;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_FRONT_LEFT_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_FRONT_LEFT_BUFFER_BIT = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_import_context</code><br>Alias for: <code>GLX_SCREEN_EXT</code> - CType: int */
  public static final int GLX_SCREEN = 0x800c;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_TYPE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_TYPE = 0x23;
  /** <code>GLX_EXT_import_context</code> - CType: int */
  public static final int GLX_VISUAL_ID_EXT = 0x800b;
  /** <code>GLX_EXT_visual_rating</code> - CType: int */
  public static final int GLX_SLOW_VISUAL_EXT = 0x8001;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_ACCUM_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_ACCUM_BUFFER_BIT = 0x80;
  /** <code>GLX_VERSION_1_4</code>, <code>GLX_3DFX_multisample</code>, <code>GLX_ARB_multisample</code>, <code>GLX_SGIS_multisample</code><br>Alias for: <code>GLX_SAMPLES_3DFX</code>, <code>GLX_SAMPLES_ARB</code>, <code>GLX_SAMPLES_SGIS</code> - CType: int */
  public static final int GLX_SAMPLES = 0x186a1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_SAVED_SGIX</code> - CType: int */
  public static final int GLX_SAVED = 0x8021;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE_EXT = 0x28;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_FRONT_RIGHT_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_FRONT_RIGHT_BUFFER_BIT = 0x2;
  /** <code>GLX_ARB_context_flush_control</code> - CType: int */
  public static final int GLX_CONTEXT_RELEASE_BEHAVIOR_NONE_ARB = 0x0;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_COLOR_INDEX_TYPE_SGIX</code> - CType: int */
  public static final int GLX_COLOR_INDEX_TYPE = 0x8015;
  /** <code>GLX_EXT_swap_control</code> - CType: int */
  public static final int GLX_MAX_SWAP_INTERVAL_EXT = 0x20f2;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_MAX_PBUFFER_PIXELS_SGIX</code> - CType: int */
  public static final int GLX_MAX_PBUFFER_PIXELS = 0x8018;
  /** <code>GLX_ARB_create_context_robustness</code> - CType: int */
  public static final int GLX_LOSE_CONTEXT_ON_RESET_ARB = 0x8252;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_STENCIL_SIZE = 0xd;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_PBUFFER_WIDTH = 0x8041;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_RGBA_BIT_SGIX</code> - CType: int */
  public static final int GLX_RGBA_BIT = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_DIRECT_COLOR_EXT</code> - CType: int */
  public static final int GLX_DIRECT_COLOR = 0x8003;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_USE_GL = 0x1;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_RED_VALUE_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_RED_VALUE = 0x25;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_PBUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_PBUFFER_BIT = 0x4;
  /** <code>GLX_EXT_create_context_es_profile</code> - CType: int */
  public static final int GLX_CONTEXT_ES_PROFILE_BIT_EXT = 0x4;
  /** <code>GLX_EXT_fbconfig_packed_float</code> - CType: int */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT = 0x8;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_PRESERVED_CONTENTS_SGIX</code> - CType: int */
  public static final int GLX_PRESERVED_CONTENTS = 0x801b;
  /** <code>GLX_3DFX_multisample</code> - CType: int */
  public static final int GLX_SAMPLES_3DFX = 0x8051;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_NO_EXTENSION = 0x3;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_DAMAGED_SGIX</code> - CType: int */
  public static final int GLX_DAMAGED = 0x8020;
  /** <code>GLX_ARB_fbconfig_float</code> - CType: int */
  public static final int GLX_RGBA_FLOAT_TYPE_ARB = 0x20b9;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_GRAY_SCALE_EXT = 0x8006;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_PIXMAP_BIT_SGIX</code> - CType: int */
  public static final int GLX_PIXMAP_BIT = 0x2;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_STATIC_COLOR_EXT</code> - CType: int */
  public static final int GLX_STATIC_COLOR = 0x8005;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_BLUE_VALUE_EXT = 0x27;
  /** <code>GLX_INTEL_swap_event</code> - CType: int */
  public static final int GLX_FLIP_COMPLETE_INTEL = 0x8182;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_VISUAL = 0x4;
  /** <code>GLX_EXT_stereo_tree</code> - CType: int */
  public static final int GLX_STEREO_TREE_EXT = 0x20f5;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_GREEN_VALUE_EXT = 0x26;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_LEVEL = 0x3;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_GRAY_SCALE_EXT</code> - CType: int */
  public static final int GLX_GRAY_SCALE = 0x8006;
  /** <code>GLX_EXT_stereo_tree</code> - CType: int */
  public static final int GLX_STEREO_NOTIFY_EXT = 0x0;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_X_RENDERABLE_SGIX</code> - CType: int */
  public static final int GLX_X_RENDERABLE = 0x8012;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_BACK_RIGHT_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_BACK_RIGHT_BUFFER_BIT = 0x8;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_ENUM = 0x7;
  /** <code>GLX_EXT_framebuffer_sRGB</code> - CType: int */
  public static final int GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x20b2;
  /** <code>GLX_3DFX_multisample</code> - CType: int */
  public static final int GLX_SAMPLE_BUFFERS_3DFX = 0x8050;
  /** <code>GLX_EXT_swap_control_tear</code> - CType: int */
  public static final int GLX_LATE_SWAPS_TEAR_EXT = 0x20f3;
  /** <code>GLX_ARB_create_context_robustness</code> - CType: int */
  public static final int GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256;
  /** <code>GLX_EXT_fbconfig_packed_float</code> - CType: int */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT = 0x20b1;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_CONFIG_CAVEAT = 0x20;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_INDEX_EXT = 0x8009;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_COLOR_INDEX_BIT_SGIX</code> - CType: int */
  public static final int GLX_COLOR_INDEX_BIT = 0x2;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_EVENT_MASK_SGIX</code> - CType: int */
  public static final int GLX_EVENT_MASK = 0x801f;
  /** <code>GLX_EXT_swap_control</code> - CType: int */
  public static final int GLX_SWAP_INTERVAL_EXT = 0x20f1;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_SLOW_CONFIG = 0x8001;
  /** <code>GLX_EXT_buffer_age</code> - CType: int */
  public static final int GLX_BACK_BUFFER_AGE_EXT = 0x20f4;
  /** <code>GLX_VERSION_1_1</code> - CType: int */
  public static final int GLX_VERSION = 0x2;
  /** <code>GLX_EXT_visual_info</code> - CType: int */
  public static final int GLX_TRANSPARENT_RGB_EXT = 0x8008;
  /** <code>GLX_VERSION_1_3</code> - CType: long */
  public static final long GLX_DONT_CARE = 0xffffffffL;
  /** <code>GLX_ARB_create_context</code> - CType: int */
  public static final int GLX_CONTEXT_FLAGS_ARB = 0x2094;
  /** <code>GLX_VERSION_1_1</code> - CType: int */
  public static final int GLX_EXTENSIONS = 0x3;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_VALUE = 0x6;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_ACCUM_BLUE_SIZE = 0x10;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_STENCIL_BUFFER_BIT_SGIX</code> - CType: int */
  public static final int GLX_STENCIL_BUFFER_BIT = 0x40;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_ACCUM_GREEN_SIZE = 0xf;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_ALPHA_SIZE = 0xb;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_WINDOW_SGIX</code> - CType: int */
  public static final int GLX_WINDOW = 0x8022;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_AUX_BUFFERS_BIT_SGIX</code> - CType: int */
  public static final int GLX_AUX_BUFFERS_BIT = 0x10;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_import_context</code><br>Alias for: <code>GLX_VISUAL_ID_EXT</code> - CType: int */
  public static final int GLX_VISUAL_ID = 0x800b;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_RGBA_TYPE_SGIX</code> - CType: int */
  public static final int GLX_RGBA_TYPE = 0x8014;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>GLX_DRAWABLE_TYPE_SGIX</code> - CType: int */
  public static final int GLX_DRAWABLE_TYPE = 0x8010;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>GLX_MAX_PBUFFER_HEIGHT_SGIX</code> - CType: int */
  public static final int GLX_MAX_PBUFFER_HEIGHT = 0x8017;
  /** <code>GLX_ARB_create_context_profile</code> - CType: int */
  public static final int GLX_CONTEXT_PROFILE_MASK_ARB = 0x9126;
  /** <code>GLX_INTEL_swap_event</code> - CType: int */
  public static final int GLX_EXCHANGE_COMPLETE_INTEL = 0x8180;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_AUX_BUFFERS = 0x7;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_RED_SIZE = 0x8;
  /** <code>GLX_ARB_context_flush_control</code> - CType: int */
  public static final int GLX_CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB = 0x2098;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRUE_COLOR_EXT</code> - CType: int */
  public static final int GLX_TRUE_COLOR = 0x8002;
  /** <code>GLX_ARB_fbconfig_float</code> - CType: int */
  public static final int GLX_RGBA_FLOAT_BIT_ARB = 0x4;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_TRANSPARENT_RGB_EXT</code> - CType: int */
  public static final int GLX_TRANSPARENT_RGB = 0x8008;
  /** <code>GLX_VERSION_1_3</code>, <code>GLX_EXT_visual_info</code><br>Alias for: <code>GLX_STATIC_GRAY_EXT</code> - CType: int */
  public static final int GLX_STATIC_GRAY = 0x8007;
  /** <code>GLX_VERSION_1_0</code> - CType: int */
  public static final int GLX_BAD_SCREEN = 0x1;
  /** <code>GLX_EXT_create_context_es2_profile</code> - CType: int */
  public static final int GLX_CONTEXT_ES2_PROFILE_BIT_EXT = 0x4;
  /** <code>GLX_VERSION_1_3</code> - CType: int */
  public static final int GLX_NON_CONFORMANT_CONFIG = 0x800d;

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static long glXCreateContext(long dpy, XVisualInfo vis, long shareList, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateContext"));
    }
        return dispatch_glXCreateContext0(dpy, ((vis == null) ? null : vis.getBuffer()), shareList, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  private static native long dispatch_glXCreateContext0(long dpy, ByteBuffer vis, long shareList, boolean direct, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXDestroyContext(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDestroyContext"));
    }
        dispatch_glXDestroyContext0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXDestroyContext0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, GLXDrawable drawable, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static boolean glXMakeCurrent(long dpy, long drawable, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeCurrent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXMakeCurrent"));
    }
        return dispatch_glXMakeCurrent0(dpy, drawable, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, GLXDrawable drawable, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native boolean dispatch_glXMakeCurrent0(long dpy, long drawable, long ctx, long procAddress);

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXCopyContext(long dpy, long src, long dst, long mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCopyContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopyContext"));
    }
        dispatch_glXCopyContext0(dpy, src, dst, mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXCopyContext0(long dpy, long src, long dst, long mask, long procAddress);

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, GLXDrawable drawable) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXSwapBuffers(long dpy, long drawable)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapBuffers"));
    }
        dispatch_glXSwapBuffers0(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, GLXDrawable drawable) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXSwapBuffers0(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> GLXPixmap glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, Pixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_0</code>, <code>GLX_MESA_pixmap_colormap</code><br>Alias for: <code>glXCreateGLXPixmapMESA</code>   */
  public static long glXCreateGLXPixmap(long dpy, XVisualInfo visual, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateGLXPixmap"));
    }
        return dispatch_glXCreateGLXPixmap0(dpy, ((visual == null) ? null : visual.getBuffer()), pixmap, __addr_);
  }

  /** Entry point to C language function: <code> GLXPixmap glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, Pixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_0</code>, <code>GLX_MESA_pixmap_colormap</code><br>Alias for: <code>glXCreateGLXPixmapMESA</code>   */
  private static native long dispatch_glXCreateGLXPixmap0(long dpy, ByteBuffer visual, long pixmap, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, GLXPixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXDestroyGLXPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDestroyGLXPixmap"));
    }
        dispatch_glXDestroyGLXPixmap0(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, GLXPixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXDestroyGLXPixmap0(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param errorb a direct only {@link java.nio.IntBuffer}
      @param event a direct only {@link java.nio.IntBuffer}   */
  public static boolean glXQueryExtension(long dpy, IntBuffer errorb, IntBuffer event)  {

    if (!Buffers.isDirect(errorb))
      throw new GLException("Argument \"errorb\" is not a direct buffer");
    if (!Buffers.isDirect(event))
      throw new GLException("Argument \"event\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtension;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryExtension"));
    }
        return dispatch_glXQueryExtension0(dpy, errorb, Buffers.getDirectBufferByteOffset(errorb), event, Buffers.getDirectBufferByteOffset(event), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param errorb a direct only {@link java.nio.IntBuffer}
      @param event a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryExtension0(long dpy, Object errorb, int errorb_byte_offset, Object event, int event_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param maj a direct only {@link java.nio.IntBuffer}
      @param min a direct only {@link java.nio.IntBuffer}   */
  public static boolean glXQueryVersion(long dpy, IntBuffer maj, IntBuffer min)  {

    if (!Buffers.isDirect(maj))
      throw new GLException("Argument \"maj\" is not a direct buffer");
    if (!Buffers.isDirect(min))
      throw new GLException("Argument \"min\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryVersion;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryVersion"));
    }
        return dispatch_glXQueryVersion0(dpy, maj, Buffers.getDirectBufferByteOffset(maj), min, Buffers.getDirectBufferByteOffset(min), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param maj a direct only {@link java.nio.IntBuffer}
      @param min a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryVersion0(long dpy, Object maj, int maj_byte_offset, Object min, int min_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static boolean glXIsDirect(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXIsDirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXIsDirect"));
    }
        return dispatch_glXIsDirect0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native boolean dispatch_glXIsDirect0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXGetConfig(long dpy, XVisualInfo visual, int attrib, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetConfig;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetConfig"));
    }
        return dispatch_glXGetConfig0(dpy, ((visual == null) ? null : visual.getBuffer()), attrib, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetConfig0(long dpy, ByteBuffer visual, int attrib, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static long glXGetCurrentContext()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentContext"));
    }
        return dispatch_glXGetCurrentContext0(__addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native long dispatch_glXGetCurrentContext0(long procAddress);

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentDrawable(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static long glXGetCurrentDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDrawable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentDrawable"));
    }
        return dispatch_glXGetCurrentDrawable0(__addr_);
  }

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentDrawable(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native long dispatch_glXGetCurrentDrawable0(long procAddress);

  /** Entry point to C language function: <code> void glXWaitGL(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXWaitGL()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitGL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitGL"));
    }
        dispatch_glXWaitGL0(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitGL(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXWaitGL0(long procAddress);

  /** Entry point to C language function: <code> void glXWaitX(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXWaitX()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitX"));
    }
        dispatch_glXWaitX0(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitX(void) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXWaitX0(long procAddress);

  /** Entry point to C language function: <code> void glXUseXFont(Font font, int first, int count, int list) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  public static void glXUseXFont(long font, int first, int count, int list)  {

    final long __addr_ = glxProcAddressTable._addressof_glXUseXFont;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXUseXFont"));
    }
        dispatch_glXUseXFont0(font, first, count, list, __addr_);
  }

  /** Entry point to C language function: <code> void glXUseXFont(Font font, int first, int count, int list) </code> <br>Part of <code>GLX_VERSION_1_0</code><br>   */
  static private native void dispatch_glXUseXFont0(long font, int first, int count, int list, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  public static String glXQueryExtensionsString(long dpy, int screen)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtensionsString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryExtensionsString"));
    }
        return dispatch_glXQueryExtensionsString0(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  static private native String dispatch_glXQueryExtensionsString0(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  public static String glXQueryServerString(long dpy, int screen, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryServerString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryServerString"));
    }
        return dispatch_glXQueryServerString0(dpy, screen, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  static private native String dispatch_glXQueryServerString0(long dpy, int screen, int name, long procAddress);

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  public static String glXGetClientString(long dpy, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetClientString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetClientString"));
    }
        return dispatch_glXGetClientString0(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name) </code> <br>Part of <code>GLX_VERSION_1_1</code><br>   */
  static private native String dispatch_glXGetClientString0(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void) </code> <br>Part of <code>GLX_VERSION_1_2</code>, <code>GLX_EXT_import_context</code><br>Alias for: <code>glXGetCurrentDisplayEXT</code>   */
  public static long glXGetCurrentDisplay()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentDisplay"));
    }
        return dispatch_glXGetCurrentDisplay0(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void) </code> <br>Part of <code>GLX_VERSION_1_2</code>, <code>GLX_EXT_import_context</code><br>Alias for: <code>glXGetCurrentDisplayEXT</code>   */
  static private native long dispatch_glXGetCurrentDisplay0(long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procName) </code> <br>Part of <code>GLX_VERSION_1_4</code>, <code>GLX_ARB_get_proc_address</code><br>Alias for: <code>glXGetProcAddressARB</code>   */
  public static long glXGetProcAddress(String procName)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddress"));
    }
        return dispatch_glXGetProcAddress0(procName, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procName) </code> <br>Part of <code>GLX_VERSION_1_4</code>, <code>GLX_ARB_get_proc_address</code><br>Alias for: <code>glXGetProcAddressARB</code>   */
  static private native long dispatch_glXGetProcAddress0(String procName, long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName) </code> <br>Part of <code>GLX_ARB_get_proc_address</code><br>   */
  public static long glXGetProcAddressARB(String procName)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddressARB"));
    }
        return dispatch_glXGetProcAddressARB0(procName, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName) </code> <br>Part of <code>GLX_ARB_get_proc_address</code><br>   */
  static private native long dispatch_glXGetProcAddressARB0(String procName, long procAddress);

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>glXGetFBConfigAttribSGIX</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXGetFBConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetFBConfigAttrib"));
    }
        return dispatch_glXGetFBConfigAttrib0(dpy, config, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_fbconfig</code><br>Alias for: <code>glXGetFBConfigAttribSGIX</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetFBConfigAttrib0(long dpy, long config, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXWindow glXCreateWindow(Display *  dpy, GLXFBConfig config, Window win, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreateWindow(long dpy, long config, long win, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreateWindow;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateWindow"));
    }
        return dispatch_glXCreateWindow0(dpy, config, win, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> GLXWindow glXCreateWindow(Display *  dpy, GLXFBConfig config, Window win, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreateWindow0(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, GLXWindow win) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  public static void glXDestroyWindow(long dpy, long win)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyWindow;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDestroyWindow"));
    }
        dispatch_glXDestroyWindow0(dpy, win, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, GLXWindow win) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  static private native void dispatch_glXDestroyWindow0(long dpy, long win, long procAddress);

  /** Entry point to C language function: <code> GLXPixmap glXCreatePixmap(Display *  dpy, GLXFBConfig config, Pixmap pixmap, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreatePixmap(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePixmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreatePixmap"));
    }
        return dispatch_glXCreatePixmap0(dpy, config, pixmap, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> GLXPixmap glXCreatePixmap(Display *  dpy, GLXFBConfig config, Pixmap pixmap, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePixmap0(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, GLXPixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  public static void glXDestroyPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPixmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDestroyPixmap"));
    }
        dispatch_glXDestroyPixmap0(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, GLXPixmap pixmap) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  static private native void dispatch_glXDestroyPixmap0(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> GLXPbuffer glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreatePbuffer(long dpy, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreatePbuffer"));
    }
        return dispatch_glXCreatePbuffer0(dpy, config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> GLXPbuffer glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attrib_list) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePbuffer0(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, GLXPbuffer pbuf) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  public static void glXDestroyPbuffer(long dpy, long pbuf)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDestroyPbuffer"));
    }
        dispatch_glXDestroyPbuffer0(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, GLXPbuffer pbuf) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  static private native void dispatch_glXDestroyPbuffer0(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, GLXDrawable draw, int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static void glXQueryDrawable(long dpy, long draw, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryDrawable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryDrawable"));
    }
        dispatch_glXQueryDrawable0(dpy, draw, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, GLXDrawable draw, int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native void dispatch_glXQueryDrawable0(long dpy, long draw, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  public static long glXCreateNewContext(long dpy, long config, int render_type, long share_list, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateNewContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateNewContext"));
    }
        return dispatch_glXCreateNewContext0(dpy, config, render_type, share_list, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  static private native long dispatch_glXCreateNewContext0(long dpy, long config, int render_type, long share_list, boolean direct, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  public static boolean glXMakeContextCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXMakeContextCurrent"));
    }
        return dispatch_glXMakeContextCurrent0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>   */
  static private native boolean dispatch_glXMakeContextCurrent0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentReadDrawable(void) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGI_make_current_read</code><br>Alias for: <code>glXGetCurrentReadDrawableSGI</code>   */
  public static long glXGetCurrentReadDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentReadDrawable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentReadDrawable"));
    }
        return dispatch_glXGetCurrentReadDrawable0(__addr_);
  }

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentReadDrawable(void) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGI_make_current_read</code><br>Alias for: <code>glXGetCurrentReadDrawableSGI</code>   */
  static private native long dispatch_glXGetCurrentReadDrawable0(long procAddress);

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryContext;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryContext"));
    }
        return dispatch_glXQueryContext0(dpy, ctx, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value) </code> <br>Part of <code>GLX_VERSION_1_3</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXQueryContext0(long dpy, long ctx, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, GLXDrawable draw, unsigned long event_mask) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>glXSelectEventSGIX</code>   */
  public static void glXSelectEvent(long dpy, long draw, long event_mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSelectEvent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSelectEvent"));
    }
        dispatch_glXSelectEvent0(dpy, draw, event_mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, GLXDrawable draw, unsigned long event_mask) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>glXSelectEventSGIX</code>   */
  static private native void dispatch_glXSelectEvent0(long dpy, long draw, long event_mask, long procAddress);

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, GLXDrawable draw, unsigned long *  event_mask) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>glXGetSelectedEventSGIX</code>
      @param event_mask a direct only {@link java.nio.LongBuffer}   */
  public static void glXGetSelectedEvent(long dpy, long draw, LongBuffer event_mask)  {

    if (!Buffers.isDirect(event_mask))
      throw new GLException("Argument \"event_mask\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetSelectedEvent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetSelectedEvent"));
    }
        dispatch_glXGetSelectedEvent0(dpy, draw, event_mask, Buffers.getDirectBufferByteOffset(event_mask), __addr_);
  }

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, GLXDrawable draw, unsigned long *  event_mask) </code> <br>Part of <code>GLX_VERSION_1_3</code>, <code>GLX_SGIX_pbuffer</code><br>Alias for: <code>glXGetSelectedEventSGIX</code>
      @param event_mask a direct only {@link java.nio.LongBuffer}   */
  private static native void dispatch_glXGetSelectedEvent0(long dpy, long draw, Object event_mask, int event_mask_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, GLXDrawable drawable, int interval) </code> <br>Part of <code>GLX_EXT_swap_control</code><br>   */
  public static void glXSwapIntervalEXT(long dpy, long drawable, int interval)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapIntervalEXT"));
    }
        dispatch_glXSwapIntervalEXT0(dpy, drawable, interval, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, GLXDrawable drawable, int interval) </code> <br>Part of <code>GLX_EXT_swap_control</code><br>   */
  static private native void dispatch_glXSwapIntervalEXT0(long dpy, long drawable, int interval, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static GLXProcAddressTable glxProcAddressTable = new GLXProcAddressTable(new GLProcAddressResolver());
 public  static GLXProcAddressTable getGLXProcAddressTable() { return glxProcAddressTable; }
  
    /** 
     * Returns the GLX error value, i.e. 0 for no error. In case of an error values.get(values.getPosition()) contains the attributes index causing the error.
     * <p>
     * Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_3</code>
     * </p>
     */
    public static int glXGetFBConfigAttributes(long dpy, long config, IntBuffer attributes, IntBuffer values) {
      if( attributes == null || values == null ) {
          throw new RuntimeException("arrays buffers are null");
      }
      if( !Buffers.isDirect(attributes) || !Buffers.isDirect(values) ) {
          throw new RuntimeException("arrays buffers are not direct");
      }
      if( attributes.remaining() > values.remaining() ) {
          throw new RuntimeException("not enough values "+values+" for attributes "+attributes);
      }
      final long __addr = glxProcAddressTable._addressof_glXGetFBConfigAttrib;
      return dispatch_glXGetFBConfigAttributes(dpy, config, attributes.remaining(), attributes, Buffers.getDirectBufferByteOffset(attributes), 
                                               values, Buffers.getDirectBufferByteOffset(values), __addr);
    }
    private static native int dispatch_glXGetFBConfigAttributes(long dpy, long config, int attributeCount, Object attributes, int attributes_byte_offset, Object values, int valuesOffset, long procAddr);
  
    /** Interface to C language function: <br> - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    public static XVisualInfo glXGetVisualFromFBConfig(long dpy, long config)
    {
      final long __addr_ = glxProcAddressTable._addressof_glXGetVisualFromFBConfig;
      if (__addr_ == 0) {
          throw new GLException("Method \"glXGetVisualFromFBConfig\" not available");
      }
      final java.nio.ByteBuffer _res = dispatch_glXGetVisualFromFBConfig(dpy, config, __addr_);
      if (_res == null) return null;
      return XVisualInfo.create(Buffers.nativeOrder(_res));
    }
  
    /** Entry point to C language function: - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    private static native java.nio.ByteBuffer dispatch_glXGetVisualFromFBConfig(long dpy, long config, long procAddr);
  
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code> <br>Part of CORE FUNC
        @param attribList a direct only {@link java.nio.IntBuffer}
        @param nitems a direct only {@link java.nio.IntBuffer}   */
    public static PointerBuffer glXChooseFBConfig(long dpy, int screen, IntBuffer attribList, IntBuffer nitems)  {
  
      if (!Buffers.isDirect(attribList))
        throw new GLException("Argument \"attribList\" is not a direct buffer");
      if (!Buffers.isDirect(nitems))
        throw new GLException("Argument \"nitems\" is not a direct buffer");
      final long __addr_ = glxProcAddressTable._addressof_glXChooseFBConfig;
      if (__addr_ == 0) {
        throw new GLException("Method \"glXChooseFBConfig\" not available");
      }
      final ByteBuffer _res = dispatch_glXChooseFBConfig(dpy, screen, attribList, Buffers.getDirectBufferByteOffset(attribList), nitems, Buffers.getDirectBufferByteOffset(nitems), __addr_);
      if (_res == null) return null;
      return PointerBuffer.wrap(Buffers.nativeOrder(_res));
    }
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code> <br>Part of CORE FUNC
        @param attribList a direct only {@link java.nio.IntBuffer}
        @param nitems a direct only {@link java.nio.IntBuffer}   */
    private static native ByteBuffer dispatch_glXChooseFBConfig(long dpy, int screen, Object attribList, int attribList_byte_offset, Object nitems, int nitems_byte_offset, long procAddress);
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_VERSION_1_3</code>
        @param nelements a direct only {@link java.nio.IntBuffer}   */
    public static PointerBuffer glXGetFBConfigs(long dpy, int screen, IntBuffer nelements)  {
  
      if (!Buffers.isDirect(nelements))
        throw new GLException("Argument \"nelements\" is not a direct buffer");
      final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigs;
      if (__addr_ == 0) {
        throw new GLException(String.format("Method \"%s\" not available", "glXGetFBConfigs"));
      }
      final ByteBuffer _res = dispatch_glXGetFBConfigs(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
      if (_res == null) return null;
      return PointerBuffer.wrap(Buffers.nativeOrder(_res));
    }
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_VERSION_1_3</code>
        @param nelements a direct only {@link java.nio.IntBuffer}   */
    private static native ByteBuffer dispatch_glXGetFBConfigs(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);
  
  
    /** Entry point to C language function: <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
        @param attribList a direct only {@link java.nio.IntBuffer}   */
    public static XVisualInfo glXChooseVisual(long dpy, int screen, IntBuffer attribList)  {
  
      if (!Buffers.isDirect(attribList))
        throw new GLException("Argument \"attribList\" is not a direct buffer");
      final long __addr_ = glxProcAddressTable._addressof_glXChooseVisual;
      if (__addr_ == 0) {
        throw new GLException("Method \"glXChooseVisual\" not available");
      }
      final ByteBuffer _res = dispatch_glXChooseVisual(dpy, screen, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
      if (_res == null) return null;
      return XVisualInfo.create(Buffers.nativeOrder(_res));
    }
  
    /** Entry point to C language function: <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
        @param attribList a direct only {@link java.nio.IntBuffer}   */
    private static native ByteBuffer dispatch_glXChooseVisual(long dpy, int screen, Object attribList, int attribList_byte_offset, long procAddress);
  
  static long glXGetProcAddress(long glXGetProcAddressHandle, java.lang.String procname)
  {
    if (glXGetProcAddressHandle == 0) {
      throw new GLException("Passed null pointer for method \"glXGetProcAddress\"");
    }
    return dispatch_glXGetProcAddress0(procname, glXGetProcAddressHandle);
  }
  // ---- End CustomJavaCode .cfg declarations

  private static native boolean initializeImpl();


  private static native int getCStringLengthImpl(final long pString);


  static {
    if( !initializeImpl() ) {
      throw new RuntimeException("Initialization failure");
    }
  }



} // end of class GLX
