/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:19:57 CEST 2015 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLXExtImpl implements GLXExt{
  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procName) </code> <br>Part of <code>GLX_VERSION_1_4</code>, <code>GLX_ARB_get_proc_address</code><br>Alias for: <code>glXGetProcAddressARB</code>   */
  public long glXGetProcAddress(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddress"));
    }
        return dispatch_glXGetProcAddress0(procName, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procName) </code> <br>Part of <code>GLX_VERSION_1_4</code>, <code>GLX_ARB_get_proc_address</code><br>Alias for: <code>glXGetProcAddressARB</code>   */
  private native long dispatch_glXGetProcAddress0(String procName, long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName) </code> <br>Part of <code>GLX_ARB_get_proc_address</code><br>   */
  public long glXGetProcAddressARB(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddressARB"));
    }
        return dispatch_glXGetProcAddressARB0(procName, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *  procName) </code> <br>Part of <code>GLX_ARB_get_proc_address</code><br>   */
  private native long dispatch_glXGetProcAddressARB0(String procName, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list) </code> <br>Part of <code>GLX_ARB_create_context</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long glXCreateContextAttribsARB(long dpy, long config, long share_context, boolean direct, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateContextAttribsARB"));
    }
        return dispatch_glXCreateContextAttribsARB0(dpy, config, share_context, direct, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list) </code> <br>Part of <code>GLX_ARB_create_context</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_glXCreateContextAttribsARB0(long dpy, long config, long share_context, boolean direct, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetGPUIDsAMD(unsigned int maxCount, unsigned int *  ids) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  public int glXGetGPUIDsAMD(int maxCount, IntBuffer ids)  {

    if (!Buffers.isDirect(ids))
      throw new GLException("Argument \"ids\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetGPUIDsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetGPUIDsAMD"));
    }
        return dispatch_glXGetGPUIDsAMD0(maxCount, ids, Buffers.getDirectBufferByteOffset(ids), __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetGPUIDsAMD(unsigned int maxCount, unsigned int *  ids) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetGPUIDsAMD0(int maxCount, Object ids, int ids_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetGPUInfoAMD(unsigned int id, int property, GLenum dataType, unsigned int size, void *  data) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param data a direct only {@link java.nio.Buffer}   */
  public int glXGetGPUInfoAMD(int id, int property, int dataType, int size, Buffer data)  {

    if (!Buffers.isDirect(data))
      throw new GLException("Argument \"data\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetGPUInfoAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetGPUInfoAMD"));
    }
        return dispatch_glXGetGPUInfoAMD0(id, property, dataType, size, data, Buffers.getDirectBufferByteOffset(data), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetGPUInfoAMD(unsigned int id, int property, GLenum dataType, unsigned int size, void *  data) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param data a direct only {@link java.nio.Buffer}   */
  private native int dispatch_glXGetGPUInfoAMD0(int id, int property, int dataType, int size, Object data, int data_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetContextGPUIDAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public int glXGetContextGPUIDAMD(long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetContextGPUIDAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetContextGPUIDAMD"));
    }
        return dispatch_glXGetContextGPUIDAMD0(ctx, __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetContextGPUIDAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native int dispatch_glXGetContextGPUIDAMD0(long ctx, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateAssociatedContextAMD(unsigned int id, GLXContext share_list) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public long glXCreateAssociatedContextAMD(int id, long share_list)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateAssociatedContextAMD"));
    }
        return dispatch_glXCreateAssociatedContextAMD0(id, share_list, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateAssociatedContextAMD(unsigned int id, GLXContext share_list) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native long dispatch_glXCreateAssociatedContextAMD0(int id, long share_list, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateAssociatedContextAttribsAMD(unsigned int id, GLXContext share_context, const int *  attribList) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long glXCreateAssociatedContextAttribsAMD(int id, long share_context, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateAssociatedContextAttribsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateAssociatedContextAttribsAMD"));
    }
        return dispatch_glXCreateAssociatedContextAttribsAMD0(id, share_context, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateAssociatedContextAttribsAMD(unsigned int id, GLXContext share_context, const int *  attribList) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_glXCreateAssociatedContextAttribsAMD0(int id, long share_context, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXDeleteAssociatedContextAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public boolean glXDeleteAssociatedContextAMD(long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXDeleteAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDeleteAssociatedContextAMD"));
    }
        return dispatch_glXDeleteAssociatedContextAMD0(ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXDeleteAssociatedContextAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native boolean dispatch_glXDeleteAssociatedContextAMD0(long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeAssociatedContextCurrentAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public boolean glXMakeAssociatedContextCurrentAMD(long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXMakeAssociatedContextCurrentAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXMakeAssociatedContextCurrentAMD"));
    }
        return dispatch_glXMakeAssociatedContextCurrentAMD0(ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeAssociatedContextCurrentAMD(GLXContext ctx) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native boolean dispatch_glXMakeAssociatedContextCurrentAMD0(long ctx, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXGetCurrentAssociatedContextAMD(void) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public long glXGetCurrentAssociatedContextAMD()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentAssociatedContextAMD"));
    }
        return dispatch_glXGetCurrentAssociatedContextAMD0(__addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXGetCurrentAssociatedContextAMD(void) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native long dispatch_glXGetCurrentAssociatedContextAMD0(long procAddress);

  /** Entry point to C language function: <code> void glXBlitContextFramebufferAMD(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  public void glXBlitContextFramebufferAMD(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBlitContextFramebufferAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBlitContextFramebufferAMD"));
    }
        dispatch_glXBlitContextFramebufferAMD0(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void glXBlitContextFramebufferAMD(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GLX_AMD_gpu_association</code><br>   */
  private native void dispatch_glXBlitContextFramebufferAMD0(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  public long glXGetCurrentDisplayEXT()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentDisplayEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentDisplayEXT"));
    }
        return dispatch_glXGetCurrentDisplayEXT0(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  private native long dispatch_glXGetCurrentDisplayEXT0(long procAddress);

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value) </code> <br>Part of <code>GLX_EXT_import_context</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryContextInfoEXT(long dpy, long context, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryContextInfoEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryContextInfoEXT"));
    }
        return dispatch_glXQueryContextInfoEXT0(dpy, context, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value) </code> <br>Part of <code>GLX_EXT_import_context</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryContextInfoEXT0(long dpy, long context, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContextID glXGetContextIDEXT(const GLXContext context) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  public long glXGetContextIDEXT(long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetContextIDEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetContextIDEXT"));
    }
        return dispatch_glXGetContextIDEXT0(context, __addr_);
  }

  /** Entry point to C language function: <code> GLXContextID glXGetContextIDEXT(const GLXContext context) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  private native long dispatch_glXGetContextIDEXT0(long context, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, GLXContextID contextID) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  public long glXImportContextEXT(long dpy, long contextID)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXImportContextEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXImportContextEXT"));
    }
        return dispatch_glXImportContextEXT0(dpy, contextID, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, GLXContextID contextID) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  private native long dispatch_glXImportContextEXT0(long dpy, long contextID, long procAddress);

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  public void glXFreeContextEXT(long dpy, long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeContextEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXFreeContextEXT"));
    }
        dispatch_glXFreeContextEXT0(dpy, context, __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context) </code> <br>Part of <code>GLX_EXT_import_context</code><br>   */
  private native void dispatch_glXFreeContextEXT0(long dpy, long context, long procAddress);

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, GLXDrawable drawable, int interval) </code> <br>Part of <code>GLX_EXT_swap_control</code><br>   */
  public void glXSwapIntervalEXT(long dpy, long drawable, int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapIntervalEXT"));
    }
        dispatch_glXSwapIntervalEXT0(dpy, drawable, interval, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, GLXDrawable drawable, int interval) </code> <br>Part of <code>GLX_EXT_swap_control</code><br>   */
  private native void dispatch_glXSwapIntervalEXT0(long dpy, long drawable, int interval, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, GLXDrawable drawable, int buffer, const int *  attrib_list) </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindTexImageEXT"));
    }
        dispatch_glXBindTexImageEXT0(dpy, drawable, buffer, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, GLXDrawable drawable, int buffer, const int *  attrib_list) </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native void dispatch_glXBindTexImageEXT0(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, GLXDrawable drawable, int buffer) </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code><br>   */
  public void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseTexImageEXT"));
    }
        dispatch_glXReleaseTexImageEXT0(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, GLXDrawable drawable, int buffer) </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code><br>   */
  private native void dispatch_glXReleaseTexImageEXT0(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer) </code> <br>Part of <code>GLX_MESA_agp_offset</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public int glXGetAGPOffsetMESA(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetAGPOffsetMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetAGPOffsetMESA"));
    }
        return dispatch_glXGetAGPOffsetMESA0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer) </code> <br>Part of <code>GLX_MESA_agp_offset</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native int dispatch_glXGetAGPOffsetMESA0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, GLXDrawable drawable, int x, int y, int width, int height) </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code><br>   */
  public void glXCopySubBufferMESA(long dpy, long drawable, int x, int y, int width, int height)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopySubBufferMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopySubBufferMESA"));
    }
        dispatch_glXCopySubBufferMESA0(dpy, drawable, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, GLXDrawable drawable, int x, int y, int width, int height) </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code><br>   */
  private native void dispatch_glXCopySubBufferMESA0(long dpy, long drawable, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryCurrentRendererIntegerMESA(int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryCurrentRendererIntegerMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryCurrentRendererIntegerMESA"));
    }
        return dispatch_glXQueryCurrentRendererIntegerMESA0(attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryCurrentRendererIntegerMESA0(int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryCurrentRendererStringMESA(int attribute) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>   */
  public ByteBuffer glXQueryCurrentRendererStringMESA(int attribute)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryCurrentRendererStringMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryCurrentRendererStringMESA"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXQueryCurrentRendererStringMESA0(attribute, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> const char *  glXQueryCurrentRendererStringMESA(int attribute) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>   */
  private native ByteBuffer dispatch_glXQueryCurrentRendererStringMESA0(int attribute, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryRendererIntegerMESA(Display *  dpy, int screen, int renderer, int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryRendererIntegerMESA(long dpy, int screen, int renderer, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryRendererIntegerMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryRendererIntegerMESA"));
    }
        return dispatch_glXQueryRendererIntegerMESA0(dpy, screen, renderer, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryRendererIntegerMESA(Display *  dpy, int screen, int renderer, int attribute, unsigned int *  value) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryRendererIntegerMESA0(long dpy, int screen, int renderer, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryRendererStringMESA(Display *  dpy, int screen, int renderer, int attribute) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>   */
  public ByteBuffer glXQueryRendererStringMESA(long dpy, int screen, int renderer, int attribute)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryRendererStringMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryRendererStringMESA"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXQueryRendererStringMESA0(dpy, screen, renderer, attribute, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> const char *  glXQueryRendererStringMESA(Display *  dpy, int screen, int renderer, int attribute) </code> <br>Part of <code>GLX_MESA_query_renderer</code><br>   */
  private native ByteBuffer dispatch_glXQueryRendererStringMESA0(long dpy, int screen, int renderer, int attribute, long procAddress);

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, GLXDrawable drawable) </code> <br>Part of <code>GLX_MESA_release_buffers</code><br>   */
  public boolean glXReleaseBuffersMESA(long dpy, long drawable)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseBuffersMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseBuffersMESA"));
    }
        return dispatch_glXReleaseBuffersMESA0(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, GLXDrawable drawable) </code> <br>Part of <code>GLX_MESA_release_buffers</code><br>   */
  private native boolean dispatch_glXReleaseBuffersMESA0(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int mode) </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code><br>   */
  public boolean glXSet3DfxModeMESA(int mode)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSet3DfxModeMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSet3DfxModeMESA"));
    }
        return dispatch_glXSet3DfxModeMESA0(mode, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int mode) </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code><br>   */
  private native boolean dispatch_glXSet3DfxModeMESA0(int mode, long procAddress);

  /** Entry point to C language function: <code> void glXCopyBufferSubDataNV(Display *  dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GLX_NV_copy_buffer</code><br>   */
  public void glXCopyBufferSubDataNV(long dpy, long readCtx, long writeCtx, int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopyBufferSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopyBufferSubDataNV"));
    }
        dispatch_glXCopyBufferSubDataNV0(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyBufferSubDataNV(Display *  dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GLX_NV_copy_buffer</code><br>   */
  private native void dispatch_glXCopyBufferSubDataNV0(long dpy, long readCtx, long writeCtx, int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void glXNamedCopyBufferSubDataNV(Display *  dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GLX_NV_copy_buffer</code><br>   */
  public void glXNamedCopyBufferSubDataNV(long dpy, long readCtx, long writeCtx, int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXNamedCopyBufferSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXNamedCopyBufferSubDataNV"));
    }
        dispatch_glXNamedCopyBufferSubDataNV0(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void glXNamedCopyBufferSubDataNV(Display *  dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GLX_NV_copy_buffer</code><br>   */
  private native void dispatch_glXNamedCopyBufferSubDataNV0(long dpy, long readCtx, long writeCtx, int readBuffer, int writeBuffer, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void glXCopyImageSubDataNV(Display *  dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GLX_NV_copy_image</code><br>   */
  public void glXCopyImageSubDataNV(long dpy, long srcCtx, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long dstCtx, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopyImageSubDataNV"));
    }
        dispatch_glXCopyImageSubDataNV0(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyImageSubDataNV(Display *  dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GLX_NV_copy_image</code><br>   */
  private native void dispatch_glXCopyImageSubDataNV0(long dpy, long srcCtx, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long dstCtx, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> Bool glXDelayBeforeSwapNV(Display *  dpy, GLXDrawable drawable, GLfloat seconds) </code> <br>Part of <code>GLX_NV_delay_before_swap</code><br>   */
  public boolean glXDelayBeforeSwapNV(long dpy, long drawable, float seconds)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXDelayBeforeSwapNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXDelayBeforeSwapNV"));
    }
        return dispatch_glXDelayBeforeSwapNV0(dpy, drawable, seconds, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXDelayBeforeSwapNV(Display *  dpy, GLXDrawable drawable, GLfloat seconds) </code> <br>Part of <code>GLX_NV_delay_before_swap</code><br>   */
  private native boolean dispatch_glXDelayBeforeSwapNV0(long dpy, long drawable, float seconds, long procAddress);

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements) </code> <br>Part of <code>GLX_NV_present_video</code><br>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public IntBuffer glXEnumerateVideoDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXEnumerateVideoDevicesNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoDevicesNV0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res.asIntBuffer();
  }

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements) </code> <br>Part of <code>GLX_NV_present_video</code><br>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoDevicesNV0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list) </code> <br>Part of <code>GLX_NV_present_video</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public int glXBindVideoDeviceNV(long dpy, int video_slot, int video_device, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoDeviceNV"));
    }
        return dispatch_glXBindVideoDeviceNV0(dpy, video_slot, video_device, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list) </code> <br>Part of <code>GLX_NV_present_video</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXBindVideoDeviceNV0(long dpy, int video_slot, int video_device, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, GLXDrawable drawable, GLuint group) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  public boolean glXJoinSwapGroupNV(long dpy, long drawable, int group)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXJoinSwapGroupNV"));
    }
        return dispatch_glXJoinSwapGroupNV0(dpy, drawable, group, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, GLXDrawable drawable, GLuint group) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  private native boolean dispatch_glXJoinSwapGroupNV0(long dpy, long drawable, int group, long procAddress);

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  public boolean glXBindSwapBarrierNV(long dpy, int group, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindSwapBarrierNV"));
    }
        return dispatch_glXBindSwapBarrierNV0(dpy, group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  private native boolean dispatch_glXBindSwapBarrierNV0(long dpy, int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, GLXDrawable drawable, GLuint *  group, GLuint *  barrier) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQuerySwapGroupNV(long dpy, long drawable, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQuerySwapGroupNV"));
    }
        return dispatch_glXQuerySwapGroupNV0(dpy, drawable, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, GLXDrawable drawable, GLuint *  group, GLuint *  barrier) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQuerySwapGroupNV0(long dpy, long drawable, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapGroupsNV(long dpy, int screen, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryMaxSwapGroupsNV"));
    }
        return dispatch_glXQueryMaxSwapGroupsNV0(dpy, screen, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapGroupsNV0(long dpy, int screen, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryFrameCountNV(long dpy, int screen, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryFrameCountNV"));
    }
        return dispatch_glXQueryFrameCountNV0(dpy, screen, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count) </code> <br>Part of <code>GLX_NV_swap_group</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryFrameCountNV0(long dpy, int screen, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  public boolean glXResetFrameCountNV(long dpy, int screen)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXResetFrameCountNV"));
    }
        return dispatch_glXResetFrameCountNV0(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen) </code> <br>Part of <code>GLX_NV_swap_group</code><br>   */
  private native boolean dispatch_glXResetFrameCountNV0(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoCaptureDeviceNV(Display *  dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  public int glXBindVideoCaptureDeviceNV(long dpy, int video_capture_slot, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoCaptureDeviceNV"));
    }
        return dispatch_glXBindVideoCaptureDeviceNV0(dpy, video_capture_slot, device, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoCaptureDeviceNV(Display *  dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  private native int dispatch_glXBindVideoCaptureDeviceNV0(long dpy, int video_capture_slot, long device, long procAddress);

  /** Entry point to C language function: <code> GLXVideoCaptureDeviceNV *  glXEnumerateVideoCaptureDevicesNV(Display *  dpy, int screen, int *  nelements) </code> <br>Part of <code>GLX_NV_video_capture</code><br>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public PointerBuffer glXEnumerateVideoCaptureDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoCaptureDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXEnumerateVideoCaptureDevicesNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoCaptureDevicesNV0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> GLXVideoCaptureDeviceNV *  glXEnumerateVideoCaptureDevicesNV(Display *  dpy, int screen, int *  nelements) </code> <br>Part of <code>GLX_NV_video_capture</code><br>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoCaptureDevicesNV0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXLockVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  public void glXLockVideoCaptureDeviceNV(long dpy, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXLockVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXLockVideoCaptureDeviceNV"));
    }
        dispatch_glXLockVideoCaptureDeviceNV0(dpy, device, __addr_);
  }

  /** Entry point to C language function: <code> void glXLockVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  private native void dispatch_glXLockVideoCaptureDeviceNV0(long dpy, long device, long procAddress);

  /** Entry point to C language function: <code> int glXQueryVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device, int attribute, int *  value) </code> <br>Part of <code>GLX_NV_video_capture</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryVideoCaptureDeviceNV(long dpy, long device, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryVideoCaptureDeviceNV"));
    }
        return dispatch_glXQueryVideoCaptureDeviceNV0(dpy, device, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device, int attribute, int *  value) </code> <br>Part of <code>GLX_NV_video_capture</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryVideoCaptureDeviceNV0(long dpy, long device, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  public void glXReleaseVideoCaptureDeviceNV(long dpy, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoCaptureDeviceNV"));
    }
        dispatch_glXReleaseVideoCaptureDeviceNV0(dpy, device, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseVideoCaptureDeviceNV(Display *  dpy, GLXVideoCaptureDeviceNV device) </code> <br>Part of <code>GLX_NV_video_capture</code><br>   */
  private native void dispatch_glXReleaseVideoCaptureDeviceNV0(long dpy, long device, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoDeviceNV(long dpy, int screen, int numVideoDevices, IntBuffer pVideoDevice)  {

    if (!Buffers.isDirect(pVideoDevice))
      throw new GLException("Argument \"pVideoDevice\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoDeviceNV"));
    }
        return dispatch_glXGetVideoDeviceNV0(dpy, screen, numVideoDevices, pVideoDevice, Buffers.getDirectBufferByteOffset(pVideoDevice), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoDeviceNV0(long dpy, int screen, int numVideoDevices, Object pVideoDevice, int pVideoDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  public int glXReleaseVideoDeviceNV(long dpy, int screen, int VideoDevice)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoDeviceNV"));
    }
        return dispatch_glXReleaseVideoDeviceNV0(dpy, screen, VideoDevice, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  private native int dispatch_glXReleaseVideoDeviceNV0(long dpy, int screen, int VideoDevice, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  public int glXBindVideoImageNV(long dpy, int VideoDevice, long pbuf, int iVideoBuffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoImageNV"));
    }
        return dispatch_glXBindVideoImageNV0(dpy, VideoDevice, pbuf, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  private native int dispatch_glXBindVideoImageNV0(long dpy, int VideoDevice, long pbuf, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, GLXPbuffer pbuf) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  public int glXReleaseVideoImageNV(long dpy, long pbuf)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoImageNV"));
    }
        return dispatch_glXReleaseVideoImageNV0(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, GLXPbuffer pbuf) </code> <br>Part of <code>GLX_NV_video_out</code><br>   */
  private native int dispatch_glXReleaseVideoImageNV0(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  public int glXSendPbufferToVideoNV(long dpy, long pbuf, int iBufferType, LongBuffer pulCounterPbuffer, boolean bBlock)  {

    if (!Buffers.isDirect(pulCounterPbuffer))
      throw new GLException("Argument \"pulCounterPbuffer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSendPbufferToVideoNV"));
    }
        return dispatch_glXSendPbufferToVideoNV0(dpy, pbuf, iBufferType, pulCounterPbuffer, Buffers.getDirectBufferByteOffset(pulCounterPbuffer), bBlock, __addr_);
  }

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXSendPbufferToVideoNV0(long dpy, long pbuf, int iBufferType, Object pulCounterPbuffer, int pulCounterPbuffer_byte_offset, boolean bBlock, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  public int glXGetVideoInfoNV(long dpy, int screen, int VideoDevice, LongBuffer pulCounterOutputPbuffer, LongBuffer pulCounterOutputVideo)  {

    if (!Buffers.isDirect(pulCounterOutputPbuffer))
      throw new GLException("Argument \"pulCounterOutputPbuffer\" is not a direct buffer");
    if (!Buffers.isDirect(pulCounterOutputVideo))
      throw new GLException("Argument \"pulCounterOutputVideo\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoInfoNV"));
    }
        return dispatch_glXGetVideoInfoNV0(dpy, screen, VideoDevice, pulCounterOutputPbuffer, Buffers.getDirectBufferByteOffset(pulCounterOutputPbuffer), pulCounterOutputVideo, Buffers.getDirectBufferByteOffset(pulCounterOutputVideo), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo) </code> <br>Part of <code>GLX_NV_video_out</code><br>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetVideoInfoNV0(long dpy, int screen, int VideoDevice, Object pulCounterOutputPbuffer, int pulCounterOutputPbuffer_byte_offset, Object pulCounterOutputVideo, int pulCounterOutputVideo_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, GLXDrawable drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXGetSyncValuesOML(long dpy, long drawable, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetSyncValuesOML"));
    }
        return dispatch_glXGetSyncValuesOML0(dpy, drawable, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, GLXDrawable drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXGetSyncValuesOML0(long dpy, long drawable, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, GLXDrawable drawable, int32_t *  numerator, int32_t *  denominator) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param numerator a direct only {@link java.nio.IntBuffer}
      @param denominator a direct only {@link java.nio.IntBuffer}   */
  public boolean glXGetMscRateOML(long dpy, long drawable, IntBuffer numerator, IntBuffer denominator)  {

    if (!Buffers.isDirect(numerator))
      throw new GLException("Argument \"numerator\" is not a direct buffer");
    if (!Buffers.isDirect(denominator))
      throw new GLException("Argument \"denominator\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetMscRateOML"));
    }
        return dispatch_glXGetMscRateOML0(dpy, drawable, numerator, Buffers.getDirectBufferByteOffset(numerator), denominator, Buffers.getDirectBufferByteOffset(denominator), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, GLXDrawable drawable, int32_t *  numerator, int32_t *  denominator) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param numerator a direct only {@link java.nio.IntBuffer}
      @param denominator a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXGetMscRateOML0(long dpy, long drawable, Object numerator, int numerator_byte_offset, Object denominator, int denominator_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder) </code> <br>Part of <code>GLX_OML_sync_control</code><br>   */
  public long glXSwapBuffersMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapBuffersMscOML"));
    }
        return dispatch_glXSwapBuffersMscOML0(dpy, drawable, target_msc, divisor, remainder, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder) </code> <br>Part of <code>GLX_OML_sync_control</code><br>   */
  private native long dispatch_glXSwapBuffersMscOML0(long dpy, long drawable, long target_msc, long divisor, long remainder, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitForMscOML"));
    }
        return dispatch_glXWaitForMscOML0(dpy, drawable, target_msc, divisor, remainder, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForMscOML0(long dpy, long drawable, long target_msc, long divisor, long remainder, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitForSbcOML"));
    }
        return dispatch_glXWaitForSbcOML0(dpy, drawable, target_sbc, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc) </code> <br>Part of <code>GLX_OML_sync_control</code><br>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForSbcOML0(long dpy, long drawable, long target_sbc, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, GLXDrawable drawable, int barrier) </code> <br>Part of <code>GLX_SGIX_swap_barrier</code><br>   */
  public void glXBindSwapBarrierSGIX(long dpy, long drawable, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindSwapBarrierSGIX"));
    }
        dispatch_glXBindSwapBarrierSGIX0(dpy, drawable, barrier, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, GLXDrawable drawable, int barrier) </code> <br>Part of <code>GLX_SGIX_swap_barrier</code><br>   */
  private native void dispatch_glXBindSwapBarrierSGIX0(long dpy, long drawable, int barrier, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max) </code> <br>Part of <code>GLX_SGIX_swap_barrier</code><br>
      @param max a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapBarriersSGIX(long dpy, int screen, IntBuffer max)  {

    if (!Buffers.isDirect(max))
      throw new GLException("Argument \"max\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapBarriersSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryMaxSwapBarriersSGIX"));
    }
        return dispatch_glXQueryMaxSwapBarriersSGIX0(dpy, screen, max, Buffers.getDirectBufferByteOffset(max), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max) </code> <br>Part of <code>GLX_SGIX_swap_barrier</code><br>
      @param max a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapBarriersSGIX0(long dpy, int screen, Object max, int max_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, GLXDrawable drawable, GLXDrawable member) </code> <br>Part of <code>GLX_SGIX_swap_group</code><br>   */
  public void glXJoinSwapGroupSGIX(long dpy, long drawable, long member)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXJoinSwapGroupSGIX"));
    }
        dispatch_glXJoinSwapGroupSGIX0(dpy, drawable, member, __addr_);
  }

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, GLXDrawable drawable, GLXDrawable member) </code> <br>Part of <code>GLX_SGIX_swap_group</code><br>   */
  private native void dispatch_glXJoinSwapGroupSGIX0(long dpy, long drawable, long member, long procAddress);

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, Window window) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  public int glXBindChannelToWindowSGIX(long display, int screen, int channel, long window)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindChannelToWindowSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindChannelToWindowSGIX"));
    }
        return dispatch_glXBindChannelToWindowSGIX0(display, screen, channel, window, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, Window window) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  private native int dispatch_glXBindChannelToWindowSGIX0(long display, int screen, int channel, long window, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  public int glXChannelRectSGIX(long display, int screen, int channel, int x, int y, int w, int h)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXChannelRectSGIX"));
    }
        return dispatch_glXChannelRectSGIX0(display, screen, channel, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  private native int dispatch_glXChannelRectSGIX0(long display, int screen, int channel, int x, int y, int w, int h, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>
      @param dx a direct only {@link java.nio.IntBuffer}
      @param dy a direct only {@link java.nio.IntBuffer}
      @param dw a direct only {@link java.nio.IntBuffer}
      @param dh a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelRectSGIX(long display, int screen, int channel, IntBuffer dx, IntBuffer dy, IntBuffer dw, IntBuffer dh)  {

    if (!Buffers.isDirect(dx))
      throw new GLException("Argument \"dx\" is not a direct buffer");
    if (!Buffers.isDirect(dy))
      throw new GLException("Argument \"dy\" is not a direct buffer");
    if (!Buffers.isDirect(dw))
      throw new GLException("Argument \"dw\" is not a direct buffer");
    if (!Buffers.isDirect(dh))
      throw new GLException("Argument \"dh\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryChannelRectSGIX"));
    }
        return dispatch_glXQueryChannelRectSGIX0(display, screen, channel, dx, Buffers.getDirectBufferByteOffset(dx), dy, Buffers.getDirectBufferByteOffset(dy), dw, Buffers.getDirectBufferByteOffset(dw), dh, Buffers.getDirectBufferByteOffset(dh), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>
      @param dx a direct only {@link java.nio.IntBuffer}
      @param dy a direct only {@link java.nio.IntBuffer}
      @param dw a direct only {@link java.nio.IntBuffer}
      @param dh a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelRectSGIX0(long display, int screen, int channel, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object dw, int dw_byte_offset, Object dh, int dh_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  x, int *  y, int *  w, int *  h) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>
      @param x a direct only {@link java.nio.IntBuffer}
      @param y a direct only {@link java.nio.IntBuffer}
      @param w a direct only {@link java.nio.IntBuffer}
      @param h a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelDeltasSGIX(long display, int screen, int channel, IntBuffer x, IntBuffer y, IntBuffer w, IntBuffer h)  {

    if (!Buffers.isDirect(x))
      throw new GLException("Argument \"x\" is not a direct buffer");
    if (!Buffers.isDirect(y))
      throw new GLException("Argument \"y\" is not a direct buffer");
    if (!Buffers.isDirect(w))
      throw new GLException("Argument \"w\" is not a direct buffer");
    if (!Buffers.isDirect(h))
      throw new GLException("Argument \"h\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelDeltasSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryChannelDeltasSGIX"));
    }
        return dispatch_glXQueryChannelDeltasSGIX0(display, screen, channel, x, Buffers.getDirectBufferByteOffset(x), y, Buffers.getDirectBufferByteOffset(y), w, Buffers.getDirectBufferByteOffset(w), h, Buffers.getDirectBufferByteOffset(h), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  x, int *  y, int *  w, int *  h) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>
      @param x a direct only {@link java.nio.IntBuffer}
      @param y a direct only {@link java.nio.IntBuffer}
      @param w a direct only {@link java.nio.IntBuffer}
      @param h a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelDeltasSGIX0(long display, int screen, int channel, Object x, int x_byte_offset, Object y, int y_byte_offset, Object w, int w_byte_offset, Object h, int h_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  public int glXChannelRectSyncSGIX(long display, int screen, int channel, int synctype)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSyncSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXChannelRectSyncSGIX"));
    }
        return dispatch_glXChannelRectSyncSGIX0(display, screen, channel, synctype, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype) </code> <br>Part of <code>GLX_SGIX_video_resize</code><br>   */
  private native int dispatch_glXChannelRectSyncSGIX0(long display, int screen, int channel, int synctype, long procAddress);

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, Window window, float cushion) </code> <br>Part of <code>GLX_SGI_cushion</code><br>   */
  public void glXCushionSGI(long dpy, long window, float cushion)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCushionSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCushionSGI"));
    }
        dispatch_glXCushionSGI0(dpy, window, cushion, __addr_);
  }

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, Window window, float cushion) </code> <br>Part of <code>GLX_SGI_cushion</code><br>   */
  private native void dispatch_glXCushionSGI0(long dpy, long window, float cushion, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) </code> <br>Part of <code>GLX_SGI_make_current_read</code><br>   */
  public boolean glXMakeCurrentReadSGI(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXMakeCurrentReadSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXMakeCurrentReadSGI"));
    }
        return dispatch_glXMakeCurrentReadSGI0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) </code> <br>Part of <code>GLX_SGI_make_current_read</code><br>   */
  private native boolean dispatch_glXMakeCurrentReadSGI0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentReadDrawableSGI(void) </code> <br>Part of <code>GLX_SGI_make_current_read</code><br>   */
  public long glXGetCurrentReadDrawableSGI()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentReadDrawableSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentReadDrawableSGI"));
    }
        return dispatch_glXGetCurrentReadDrawableSGI0(__addr_);
  }

  /** Entry point to C language function: <code> GLXDrawable glXGetCurrentReadDrawableSGI(void) </code> <br>Part of <code>GLX_SGI_make_current_read</code><br>   */
  private native long dispatch_glXGetCurrentReadDrawableSGI0(long procAddress);

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval) </code> <br>Part of <code>GLX_SGI_swap_control</code><br>   */
  public int glXSwapIntervalSGI(int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapIntervalSGI"));
    }
        return dispatch_glXSwapIntervalSGI0(interval, __addr_);
  }

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval) </code> <br>Part of <code>GLX_SGI_swap_control</code><br>   */
  private native int dispatch_glXSwapIntervalSGI0(int interval, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  count) </code> <br>Part of <code>GLX_SGI_video_sync</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoSyncSGI(IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoSyncSGI"));
    }
        return dispatch_glXGetVideoSyncSGI0(count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  count) </code> <br>Part of <code>GLX_SGI_video_sync</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoSyncSGI0(Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count) </code> <br>Part of <code>GLX_SGI_video_sync</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public int glXWaitVideoSyncSGI(int divisor, int remainder, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitVideoSyncSGI"));
    }
        return dispatch_glXWaitVideoSyncSGI0(divisor, remainder, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count) </code> <br>Part of <code>GLX_SGI_video_sync</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXWaitVideoSyncSGI0(int divisor, int remainder, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, Window overlay, Window underlay, long *  pTransparentIndex) </code> <br>Part of <code>GLX_SUN_get_transparent_index</code><br>
      @param pTransparentIndex a direct only {@link java.nio.LongBuffer}   */
  public int glXGetTransparentIndexSUN(long dpy, long overlay, long underlay, LongBuffer pTransparentIndex)  {

    if (!Buffers.isDirect(pTransparentIndex))
      throw new GLException("Argument \"pTransparentIndex\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetTransparentIndexSUN;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetTransparentIndexSUN"));
    }
        return dispatch_glXGetTransparentIndexSUN0(dpy, overlay, underlay, pTransparentIndex, Buffers.getDirectBufferByteOffset(pTransparentIndex), __addr_);
  }

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, Window overlay, Window underlay, long *  pTransparentIndex) </code> <br>Part of <code>GLX_SUN_get_transparent_index</code><br>
      @param pTransparentIndex a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetTransparentIndexSUN0(long dpy, long overlay, long underlay, Object pTransparentIndex, int pTransparentIndex_byte_offset, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public GLXExtImpl(X11GLXContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private X11GLXContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLXExtImpl
