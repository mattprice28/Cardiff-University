/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:18:11 CEST 2015 ----! */

package jogamp.opengl.es3;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.opengl.GLBase;
import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2ES2;
import com.jogamp.opengl.GL2ES3;
import com.jogamp.opengl.GL3ES3;
import com.jogamp.opengl.GL4ES3;
import com.jogamp.opengl.GLES3;
import com.jogamp.opengl.GLArrayData;
import com.jogamp.opengl.GLUniformData;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import java.io.PrintStream;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLES3Impl implements GLBase, GL, GL2ES2, GLES2, GL2ES3, GL3ES3, GL4ES3, GLES3{
  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = _pat._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveTexture"));
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  private native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glAttachShader(int program, int shader)  {

    final long __addr_ = _pat._addressof_glAttachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAttachShader"));
    }
        dispatch_glAttachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glAttachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glBindAttribLocationARB</code>   */
  public void glBindAttribLocation(int program, int index, String name)  {

    final long __addr_ = _pat._addressof_glBindAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindAttribLocation"));
    }
        dispatch_glBindAttribLocation1(program, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glBindAttribLocationARB</code>   */
  private native void dispatch_glBindAttribLocation1(int program, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = _pat._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffer"));
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = _pat._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFramebuffer"));
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindRenderbuffer"));
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  private native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = _pat._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTexture"));
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  private native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_blend_color</code><br>Alias for: <code>glBlendColorEXT</code>   */
  public void glBlendColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glBlendColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendColor"));
    }
        dispatch_glBlendColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_blend_color</code><br>Alias for: <code>glBlendColorEXT</code>   */
  private native void dispatch_glBlendColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquation"));
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  private native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparate"));
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  private native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = _pat._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunc"));
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  public void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparate"));
    }
        dispatch_glBlendFuncSeparate1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  private native void dispatch_glBlendFuncSeparate1(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glBufferDataDelegate(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferData"));
    }
        dispatch_glBufferDataDelegate1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const void *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glBufferDataDelegate1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferSubData"));
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const void *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = _pat._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckFramebufferStatus"));
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  private native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClear(int mask)  {

    final long __addr_ = _pat._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClear"));
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColor"));
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat d) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  public void glClearDepthf(float d)  {

    final long __addr_ = _pat._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepthf"));
    }
        dispatch_glClearDepthf1(d, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat d) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  private native void dispatch_glClearDepthf1(float d, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearStencil(int s)  {

    final long __addr_ = _pat._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearStencil"));
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = _pat._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMask"));
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glCompileShaderARB</code>   */
  public void glCompileShader(int shader)  {

    final long __addr_ = _pat._addressof_glCompileShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShader"));
    }
        dispatch_glCompileShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glCompileShaderARB</code>   */
  private native void dispatch_glCompileShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = _pat._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage2D"));
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  private native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage2D"));
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  private native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public int glCreateProgram()  {

    final long __addr_ = _pat._addressof_glCreateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgram"));
    }
        return dispatch_glCreateProgram1(__addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native int dispatch_glCreateProgram1(long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public int glCreateShader(int type)  {

    final long __addr_ = _pat._addressof_glCreateShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShader"));
    }
        return dispatch_glCreateShader1(type, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native int dispatch_glCreateShader1(int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glCullFace(int mode)  {

    final long __addr_ = _pat._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullFace"));
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers);
    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers, buffers_offset);
    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDeleteProgram(int program)  {

    final long __addr_ = _pat._addressof_glDeleteProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgram"));
    }
        dispatch_glDeleteProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDeleteProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDeleteShader(int shader)  {

    final long __addr_ = _pat._addressof_glDeleteShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteShader"));
    }
        dispatch_glDeleteShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDeleteShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = _pat._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthFunc"));
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = _pat._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthMask"));
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat n, GLfloat f) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  public void glDepthRangef(float n, float f)  {

    final long __addr_ = _pat._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangef"));
    }
        dispatch_glDepthRangef1(n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat n, GLfloat f) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  private native void dispatch_glDepthRangef1(float n, float f, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glDetachShader(int program, int shader)  {

    final long __addr_ = _pat._addressof_glDetachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDetachShader"));
    }
        dispatch_glDetachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glDetachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDisable(int cap)  {

    final long __addr_ = _pat._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisable"));
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glDisableVertexAttribArrayARB</code>   */
  public void glDisableVertexAttribArray(int index)  {

    final long __addr_ = _pat._addressof_glDisableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArray"));
    }
        dispatch_glDisableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glDisableVertexAttribArrayARB</code>   */
  private native void dispatch_glDisableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = _pat._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArrays"));
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  private native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glEnable(int cap)  {

    final long __addr_ = _pat._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnable"));
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glEnableVertexAttribArrayARB</code>   */
  public void glEnableVertexAttribArray(int index)  {

    final long __addr_ = _pat._addressof_glEnableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArray"));
    }
        dispatch_glEnableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glEnableVertexAttribArrayARB</code>   */
  private native void dispatch_glEnableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFinish()  {

    final long __addr_ = _pat._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinish"));
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFlush()  {

    final long __addr_ = _pat._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlush"));
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferRenderbuffer"));
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  private native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2D"));
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  private native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = _pat._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrontFace"));
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = _pat._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateMipmap"));
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  private native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveAttrib(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveAttrib1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetActiveAttribARB</code>   */
  public void glGetActiveAttrib(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniform(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniform1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetActiveUniformARB</code>   */
  public void glGetActiveUniform(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedShaders(int program, int maxCount, IntBuffer count, IntBuffer shaders)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final long __addr_ = _pat._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedShaders1(int program, int maxCount, Object count, int count_byte_offset, boolean count_is_direct, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxCount, GLsizei *  count, GLuint *  shaders) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetAttachedShaders(int program, int maxCount, int[] count, int count_offset, int[] shaders, int shaders_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final long __addr_ = _pat._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxCount, count, Buffers.SIZEOF_INT * count_offset, false, shaders, Buffers.SIZEOF_INT * shaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetAttribLocationARB</code>   */
  public int glGetAttribLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttribLocation"));
    }
        return dispatch_glGetAttribLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_shader</code><br>Alias for: <code>glGetAttribLocationARB</code>   */
  private native int dispatch_glGetAttribLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetBooleanv(int pname, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public int glGetError()  {

    final long __addr_ = _pat._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetError"));
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  data) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  data) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  data) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetFloatv(int pname, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer data)  {

    if ( glStateTracker.getInt(pname, data, data_offset) ) { return; }
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetIntegerv(int pname, int[] data, int data_offset)  {

    if ( glStateTracker.getInt(pname, data, data_offset) ) { return; }
    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetProgramivARB</code>, <code>glGetProgramivNV</code>   */
  public void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramInfoLog(int program, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramInfoLog1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetProgramInfoLog(int program, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderInfoLog(int shader, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderInfoLog1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glGetShaderInfoLog(int shader, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    final long __addr_ = _pat._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if(range != null && range.length <= range_offset)
      throw new GLException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new GLException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSource(int shader, int bufSize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = _pat._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSource1(int shader, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufSize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetShaderSourceARB</code>   */
  public void glGetShaderSource(int shader, int bufSize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = _pat._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = _pat._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetString"));
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformfvARB</code>   */
  public void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformivARB</code>   */
  public void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformLocationARB</code>   */
  public int glGetUniformLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetUniformLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocation"));
    }
        return dispatch_glGetUniformLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glGetUniformLocationARB</code>   */
  private native int dispatch_glGetUniformLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glGetVertexAttribfvARB</code>, <code>glGetVertexAttribfvNV</code>   */
  public void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glGetVertexAttribivNV</code>, <code>glGetVertexAttribivARB</code>   */
  public void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = _pat._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHint"));
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  private native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = _pat._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsBuffer"));
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  private native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = _pat._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabled"));
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = _pat._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsFramebuffer"));
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  private native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glIsProgramARB</code>, <code>glIsProgramNV</code>   */
  public boolean glIsProgram(int program)  {

    final long __addr_ = _pat._addressof_glIsProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgram"));
    }
        return dispatch_glIsProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_ARB_fragment_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glIsProgramARB</code>, <code>glIsProgramNV</code>   */
  private native boolean dispatch_glIsProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = _pat._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsRenderbuffer"));
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  private native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public boolean glIsShader(int shader)  {

    final long __addr_ = _pat._addressof_glIsShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsShader"));
    }
        return dispatch_glIsShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native boolean dispatch_glIsShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = _pat._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTexture"));
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  private native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLineWidth(float width)  {

    final long __addr_ = _pat._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineWidth"));
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glLinkProgramARB</code>   */
  public void glLinkProgram(int program)  {

    final long __addr_ = _pat._addressof_glLinkProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLinkProgram"));
    }
        dispatch_glLinkProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glLinkProgramARB</code>   */
  private native void dispatch_glLinkProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPixelStorei(int pname, int param)  {

    glStateTracker.setInt(pname, param);
    final long __addr_ = _pat._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelStorei"));
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = _pat._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffset"));
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  private native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  public void glReleaseShaderCompiler()  {

    if ( !_context.isGLES2Compatible() ) {
    return;
    }
    final long __addr_ = _pat._addressof_glReleaseShaderCompiler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReleaseShaderCompiler"));
    }
        dispatch_glReleaseShaderCompiler1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>   */
  private native void dispatch_glReleaseShaderCompiler1(long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorage"));
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  private native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = _pat._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleCoverage"));
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  private native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissor"));
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, IntBuffer shaders, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(count, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glShaderBinary1(int count, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryformat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei count, const GLuint *  shaders, GLenum binaryformat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code><br>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int count, int[] shaders, int shaders_offset, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(count, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSource(int shader, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSource1(int shader, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glShaderSourceARB</code>   */
  public void glShaderSource(int shader, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = _pat._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFunc"));
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilFuncSeparateATI</code>   */
  public void glStencilFuncSeparate(int face, int func, int ref, int mask)  {

    final long __addr_ = _pat._addressof_glStencilFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFuncSeparate"));
    }
        dispatch_glStencilFuncSeparate1(face, func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilFuncSeparateATI</code>   */
  private native void dispatch_glStencilFuncSeparate1(int face, int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = _pat._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMask"));
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glStencilMaskSeparate(int face, int mask)  {

    final long __addr_ = _pat._addressof_glStencilMaskSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMaskSeparate"));
    }
        dispatch_glStencilMaskSeparate1(face, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glStencilMaskSeparate1(int face, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = _pat._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOp"));
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilOpSeparateATI</code>   */
  public void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass)  {

    final long __addr_ = _pat._addressof_glStencilOpSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOpSeparate"));
    }
        dispatch_glStencilOpSeparate1(face, sfail, dpfail, dppass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ATI_separate_stencil</code><br>Alias for: <code>glStencilOpSeparateATI</code>   */
  private native void dispatch_glStencilOpSeparate1(int face, int sfail, int dpfail, int dppass, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterf"));
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteri"));
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fARB</code>   */
  public void glUniform1f(int location, float v0)  {

    final long __addr_ = _pat._addressof_glUniform1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1f"));
    }
        dispatch_glUniform1f1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fARB</code>   */
  private native void dispatch_glUniform1f1(int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1fvARB</code>   */
  public void glUniform1fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1iARB</code>   */
  public void glUniform1i(int location, int v0)  {

    final long __addr_ = _pat._addressof_glUniform1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i"));
    }
        dispatch_glUniform1i1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint v0) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1iARB</code>   */
  private native void dispatch_glUniform1i1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform1ivARB</code>   */
  public void glUniform1iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fARB</code>   */
  public void glUniform2f(int location, float v0, float v1)  {

    final long __addr_ = _pat._addressof_glUniform2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2f"));
    }
        dispatch_glUniform2f1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fARB</code>   */
  private native void dispatch_glUniform2f1(int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2fvARB</code>   */
  public void glUniform2fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2iARB</code>   */
  public void glUniform2i(int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glUniform2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i"));
    }
        dispatch_glUniform2i1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2iARB</code>   */
  private native void dispatch_glUniform2i1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform2ivARB</code>   */
  public void glUniform2iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fARB</code>   */
  public void glUniform3f(int location, float v0, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glUniform3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3f"));
    }
        dispatch_glUniform3f1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fARB</code>   */
  private native void dispatch_glUniform3f1(int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3fvARB</code>   */
  public void glUniform3fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3iARB</code>   */
  public void glUniform3i(int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glUniform3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i"));
    }
        dispatch_glUniform3i1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3iARB</code>   */
  private native void dispatch_glUniform3i1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform3ivARB</code>   */
  public void glUniform3iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fARB</code>   */
  public void glUniform4f(int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = _pat._addressof_glUniform4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4f"));
    }
        dispatch_glUniform4f1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fARB</code>   */
  private native void dispatch_glUniform4f1(int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fv(int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4fvARB</code>   */
  public void glUniform4fv(int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4iARB</code>   */
  public void glUniform4i(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glUniform4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i"));
    }
        dispatch_glUniform4i1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4iARB</code>   */
  private native void dispatch_glUniform4i1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4iv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4iv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniform4ivARB</code>   */
  public void glUniform4iv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix2fvARB</code>   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix3fvARB</code>   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glUniformMatrix4fvARB</code>   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  public void glUseProgram(int program)  {

    final long __addr_ = _pat._addressof_glUseProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgram"));
    }
        dispatch_glUseProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code><br>   */
  private native void dispatch_glUseProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glValidateProgramARB</code>   */
  public void glValidateProgram(int program)  {

    final long __addr_ = _pat._addressof_glValidateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgram"));
    }
        dispatch_glValidateProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_shader_objects</code><br>Alias for: <code>glValidateProgramARB</code>   */
  private native void dispatch_glValidateProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1fARB</code>, <code>glVertexAttrib1fNV</code>   */
  public void glVertexAttrib1f(int index, float x)  {

    final long __addr_ = _pat._addressof_glVertexAttrib1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1f"));
    }
        dispatch_glVertexAttrib1f1(index, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint index, GLfloat x) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib1fARB</code>, <code>glVertexAttrib1fNV</code>   */
  private native void dispatch_glVertexAttrib1f1(int index, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib1fvNV</code>, <code>glVertexAttrib1fvARB</code>   */
  public void glVertexAttrib1fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fARB</code>, <code>glVertexAttrib2fNV</code>   */
  public void glVertexAttrib2f(int index, float x, float y)  {

    final long __addr_ = _pat._addressof_glVertexAttrib2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2f"));
    }
        dispatch_glVertexAttrib2f1(index, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint index, GLfloat x, GLfloat y) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fARB</code>, <code>glVertexAttrib2fNV</code>   */
  private native void dispatch_glVertexAttrib2f1(int index, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib2fvARB</code>, <code>glVertexAttrib2fvNV</code>   */
  public void glVertexAttrib2fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3fARB</code>, <code>glVertexAttrib3fNV</code>   */
  public void glVertexAttrib3f(int index, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glVertexAttrib3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3f"));
    }
        dispatch_glVertexAttrib3f1(index, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint index, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttrib3fARB</code>, <code>glVertexAttrib3fNV</code>   */
  private native void dispatch_glVertexAttrib3f1(int index, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib3fvNV</code>, <code>glVertexAttrib3fvARB</code>   */
  public void glVertexAttrib3fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fNV</code>, <code>glVertexAttrib4fARB</code>   */
  public void glVertexAttrib4f(int index, float x, float y, float z, float w)  {

    final long __addr_ = _pat._addressof_glVertexAttrib4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4f"));
    }
        dispatch_glVertexAttrib4f1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fNV</code>, <code>glVertexAttrib4fARB</code>   */
  private native void dispatch_glVertexAttrib4f1(int index, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fv(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_NV_vertex_program</code>, <code>GL_ARB_vertex_program</code><br>Alias for: <code>glVertexAttrib4fvNV</code>, <code>glVertexAttrib4fvARB</code>   */
  public void glVertexAttrib4fv(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(index, size, type, normalized, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointer0(int index, int size, int type, boolean normalized, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>   */
  public void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(index, size, type, normalized, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_ARB_vertex_program</code>, <code>GL_NV_vertex_program</code><br>Alias for: <code>glVertexAttribPointerARB</code>, <code>glVertexAttribPointerNV</code>   */
  private native void dispatch_glVertexAttribPointer0(int index, int size, int type, boolean normalized, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewport"));
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum src) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_read_buffer</code><br>Alias for: <code>glReadBufferNV</code>   */
  public void glReadBuffer(int src)  {

    final long __addr_ = _pat._addressof_glReadBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBuffer"));
    }
        dispatch_glReadBuffer1(src, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum src) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_read_buffer</code><br>Alias for: <code>glReadBufferNV</code>   */
  private native void dispatch_glReadBuffer1(int src, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_draw_range_elements</code><br>Alias for: <code>glDrawRangeElementsEXT</code>   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexImage3DOES</code>, <code>glTexImage3DEXT</code>   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, depth, false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *  pixels) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_texture_3D</code>, <code>GL_EXT_texture3D</code><br>Alias for: <code>glTexSubImage3DOES</code>, <code>glTexSubImage3DEXT</code>   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_copy_texture</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCopyTexSubImage3DEXT</code>, <code>glCopyTexSubImage3DOES</code>   */
  public void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage3D"));
    }
        dispatch_glCopyTexSubImage3D1(target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_2</code>, <code>GL_EXT_copy_texture</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCopyTexSubImage3DEXT</code>, <code>glCopyTexSubImage3DOES</code>   */
  private native void dispatch_glCopyTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexImage3DARB</code>, <code>glCompressedTexImage3DOES</code>   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_texture_compression</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glCompressedTexSubImage3DARB</code>, <code>glCompressedTexSubImage3DOES</code>   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGenQueriesEXT</code>, <code>glGenQueriesARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGenQueriesEXT</code>, <code>glGenQueriesARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGenQueriesEXT</code>, <code>glGenQueriesARB</code>   */
  public void glGenQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glDeleteQueriesEXT</code>, <code>glDeleteQueriesARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glDeleteQueriesEXT</code>, <code>glDeleteQueriesARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glDeleteQueriesEXT</code>, <code>glDeleteQueriesARB</code>   */
  public void glDeleteQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glIsQueryEXT</code>, <code>glIsQueryARB</code>   */
  public boolean glIsQuery(int id)  {

    final long __addr_ = _pat._addressof_glIsQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsQuery"));
    }
        return dispatch_glIsQuery1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glIsQueryEXT</code>, <code>glIsQueryARB</code>   */
  private native boolean dispatch_glIsQuery1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glBeginQueryARB</code>, <code>glBeginQueryEXT</code>   */
  public void glBeginQuery(int target, int id)  {

    final long __addr_ = _pat._addressof_glBeginQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginQuery"));
    }
        dispatch_glBeginQuery1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glBeginQueryARB</code>, <code>glBeginQueryEXT</code>   */
  private native void dispatch_glBeginQuery1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glEndQueryEXT</code>, <code>glEndQueryARB</code>   */
  public void glEndQuery(int target)  {

    final long __addr_ = _pat._addressof_glEndQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndQuery"));
    }
        dispatch_glEndQuery1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glEndQueryEXT</code>, <code>glEndQueryARB</code>   */
  private native void dispatch_glEndQuery1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryivEXT</code>, <code>glGetQueryivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryivEXT</code>, <code>glGetQueryivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryivEXT</code>, <code>glGetQueryivARB</code>   */
  public void glGetQueryiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryObjectuivEXT</code>, <code>glGetQueryObjectuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectuiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryObjectuivEXT</code>, <code>glGetQueryObjectuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectuiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_ARB_occlusion_query</code><br>Alias for: <code>glGetQueryObjectuivEXT</code>, <code>glGetQueryObjectuivARB</code>   */
  public void glGetQueryObjectuiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private boolean glUnmapBufferDelegate(int target)  {

    final long __addr_ = _pat._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapBuffer"));
    }
        return dispatch_glUnmapBufferDelegate1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private native boolean dispatch_glUnmapBufferDelegate1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersEXT</code>, <code>glDrawBuffersARB</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffers(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = _pat._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersEXT</code>, <code>glDrawBuffersARB</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffers1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_EXT_draw_buffers</code>, <code>GL_ARB_draw_buffers</code>, <code>GL_NV_draw_buffers</code>, <code>GL_ATI_draw_buffers</code><br>Alias for: <code>glDrawBuffersEXT</code>, <code>glDrawBuffersARB</code>, <code>glDrawBuffersNV</code>, <code>glDrawBuffersATI</code>   */
  public void glDrawBuffers(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = _pat._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x3fvNV</code>   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x2fvNV</code>   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix2x4fvNV</code>   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x2fvNV</code>   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix3x4fvNV</code>   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>, <code>GL_NV_non_square_matrices</code><br>Alias for: <code>glUniformMatrix4x3fvNV</code>   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_framebuffer_blit</code>, <code>GL_EXT_framebuffer_blit</code>, <code>GL_ANGLE_framebuffer_blit</code><br>Alias for: <code>glBlitFramebufferNV</code>, <code>glBlitFramebufferEXT</code>, <code>glBlitFramebufferANGLE</code>   */
  public void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _pat._addressof_glBlitFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebuffer"));
    }
        dispatch_glBlitFramebuffer1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_framebuffer_blit</code>, <code>GL_EXT_framebuffer_blit</code>, <code>GL_ANGLE_framebuffer_blit</code><br>Alias for: <code>glBlitFramebufferNV</code>, <code>glBlitFramebufferEXT</code>, <code>glBlitFramebufferANGLE</code>   */
  private native void dispatch_glBlitFramebuffer1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  public void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisample"));
    }
        dispatch_glRenderbufferStorageMultisample1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  private native void dispatch_glRenderbufferStorageMultisample1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_array</code>, <code>GL_NV_geometry_program4</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureLayerEXT</code>, <code>glFramebufferTextureLayerARB</code>   */
  public void glFramebufferTextureLayer(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureLayer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayer"));
    }
        dispatch_glFramebufferTextureLayer1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_array</code>, <code>GL_NV_geometry_program4</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureLayerEXT</code>, <code>glFramebufferTextureLayerARB</code>   */
  private native void dispatch_glFramebufferTextureLayer1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private long glMapBufferRangeDelegate(int target, long offset, long length, int access)  {

    final long __addr_ = _pat._addressof_glMapBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBufferRange"));
    }
        return dispatch_glMapBufferRangeDelegate1(target, offset, length, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private native long dispatch_glMapBufferRangeDelegate1(int target, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  public void glFlushMappedBufferRange(int target, long offset, long length)  {

    final long __addr_ = _pat._addressof_glFlushMappedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedBufferRange"));
    }
        dispatch_glFlushMappedBufferRange1(target, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  private native void dispatch_glFlushMappedBufferRange1(int target, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glBindVertexArrayAPPLE</code>, <code>glBindVertexArrayOES</code>   */
  public void glBindVertexArray(int array)  {

    final long __addr_ = _pat._addressof_glBindVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArray"));
    }
        dispatch_glBindVertexArray1(array, __addr_);
    bufferStateTracker.setBoundBufferObject(GL2GL3.GL_VERTEX_ARRAY_BINDING, array);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glBindVertexArrayAPPLE</code>, <code>glBindVertexArrayOES</code>   */
  private native void dispatch_glBindVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glDeleteVertexArraysAPPLE</code>, <code>glDeleteVertexArraysOES</code>   */
  public void glDeleteVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_vertex_array_object</code>, <code>GL_OES_vertex_array_object</code><br>Alias for: <code>glGenVertexArraysAPPLE</code>, <code>glGenVertexArraysOES</code>   */
  public void glGenVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_vertex_array_object</code>, <code>GL_APPLE_vertex_array_object</code><br>Alias for: <code>glIsVertexArrayOES</code>, <code>glIsVertexArrayAPPLE</code>   */
  public boolean glIsVertexArray(int array)  {

    final long __addr_ = _pat._addressof_glIsVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArray"));
    }
        return dispatch_glIsVertexArray1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array) </code> <br>Part of <code>GL_ARB_vertex_array_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_vertex_array_object</code>, <code>GL_APPLE_vertex_array_object</code><br>Alias for: <code>glIsVertexArrayOES</code>, <code>glIsVertexArrayAPPLE</code>   */
  private native boolean dispatch_glIsVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_v(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_multiview_draw_buffers</code><br>Alias for: <code>glGetIntegeri_vEXT</code>   */
  public void glGetIntegeri_v(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glBeginTransformFeedbackEXT</code>, <code>glBeginTransformFeedbackNV</code>   */
  public void glBeginTransformFeedback(int primitiveMode)  {

    final long __addr_ = _pat._addressof_glBeginTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginTransformFeedback"));
    }
        dispatch_glBeginTransformFeedback1(primitiveMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glBeginTransformFeedbackEXT</code>, <code>glBeginTransformFeedbackNV</code>   */
  private native void dispatch_glBeginTransformFeedback1(int primitiveMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glEndTransformFeedbackNV</code>, <code>glEndTransformFeedbackEXT</code>   */
  public void glEndTransformFeedback()  {

    final long __addr_ = _pat._addressof_glEndTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTransformFeedback"));
    }
        dispatch_glEndTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glEndTransformFeedbackNV</code>, <code>glEndTransformFeedbackEXT</code>   */
  private native void dispatch_glEndTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferRangeNV</code>, <code>glBindBufferRangeEXT</code>   */
  public void glBindBufferRange(int target, int index, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glBindBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferRange"));
    }
        dispatch_glBindBufferRange1(target, index, buffer, offset, size, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferRangeNV</code>, <code>glBindBufferRangeEXT</code>   */
  private native void dispatch_glBindBufferRange1(int target, int index, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferBaseNV</code>, <code>glBindBufferBaseEXT</code>   */
  public void glBindBufferBase(int target, int index, int buffer)  {

    final long __addr_ = _pat._addressof_glBindBufferBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferBase"));
    }
        dispatch_glBindBufferBase1(target, index, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glBindBufferBaseNV</code>, <code>glBindBufferBaseEXT</code>   */
  private native void dispatch_glBindBufferBase1(int target, int index, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glTransformFeedbackVaryingsEXT</code>, <code>glTransformFeedbackVaryingsNV</code>   */
  public void glTransformFeedbackVaryings(int program, int count, String[] varyings, int bufferMode)  {

    final long __addr_ = _pat._addressof_glTransformFeedbackVaryings;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackVaryings"));
    }
        dispatch_glTransformFeedbackVaryings1(program, count, varyings, bufferMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_transform_feedback</code>, <code>GL_NV_transform_feedback</code><br>Alias for: <code>glTransformFeedbackVaryingsEXT</code>, <code>glTransformFeedbackVaryingsNV</code>   */
  private native void dispatch_glTransformFeedbackVaryings1(int program, int count, String[] varyings, int bufferMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTransformFeedbackVarying1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_transform_feedback</code>, <code>GL_EXT_transform_feedback</code><br>Alias for: <code>glGetTransformFeedbackVaryingNV</code>, <code>glGetTransformFeedbackVaryingEXT</code>   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const void *  pointer) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribIPointerEXT</code>   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIivEXT</code>   */
  public void glGetVertexAttribIiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glGetVertexAttribIuivEXT</code>   */
  public void glGetVertexAttribIuiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4iEXT</code>   */
  public void glVertexAttribI4i(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4i"));
    }
        dispatch_glVertexAttribI4i1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4iEXT</code>   */
  private native void dispatch_glVertexAttribI4i1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uiEXT</code>   */
  public void glVertexAttribI4ui(int index, int x, int y, int z, int w)  {

    final long __addr_ = _pat._addressof_glVertexAttribI4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ui"));
    }
        dispatch_glVertexAttribI4ui1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uiEXT</code>   */
  private native void dispatch_glVertexAttribI4ui1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4ivEXT</code>   */
  public void glVertexAttribI4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_vertex_program4</code><br>Alias for: <code>glVertexAttribI4uivEXT</code>   */
  public void glVertexAttribI4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformuiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformuiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetUniformuivEXT</code>   */
  public void glGetUniformuiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetFragDataLocationEXT</code>   */
  public int glGetFragDataLocation(int program, String name)  {

    final long __addr_ = _pat._addressof_glGetFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataLocation"));
    }
        return dispatch_glGetFragDataLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glGetFragDataLocationEXT</code>   */
  private native int dispatch_glGetFragDataLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uiEXT</code>   */
  public void glUniform1ui(int location, int v0)  {

    final long __addr_ = _pat._addressof_glUniform1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui"));
    }
        dispatch_glUniform1ui1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uiEXT</code>   */
  private native void dispatch_glUniform1ui1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uiEXT</code>   */
  public void glUniform2ui(int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glUniform2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui"));
    }
        dispatch_glUniform2ui1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uiEXT</code>   */
  private native void dispatch_glUniform2ui1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uiEXT</code>   */
  public void glUniform3ui(int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glUniform3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui"));
    }
        dispatch_glUniform3ui1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uiEXT</code>   */
  private native void dispatch_glUniform3ui1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uiEXT</code>   */
  public void glUniform4ui(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glUniform4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui"));
    }
        dispatch_glUniform4ui1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uiEXT</code>   */
  private native void dispatch_glUniform4ui1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform1uivEXT</code>   */
  public void glUniform1uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform2uivEXT</code>   */
  public void glUniform2uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform3uivEXT</code>   */
  public void glUniform3uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_gpu_shader4</code><br>Alias for: <code>glUniform4uivEXT</code>   */
  public void glUniform4uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferuiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferuiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferuiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClearBufferfv(int buffer, int drawbuffer, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClearBufferfv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferfv(int buffer, int drawbuffer, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glClearBufferfi(int buffer, int drawbuffer, float depth, int stencil)  {

    final long __addr_ = _pat._addressof_glClearBufferfi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfi"));
    }
        dispatch_glClearBufferfi1(buffer, drawbuffer, depth, stencil, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  private native void dispatch_glClearBufferfi1(int buffer, int drawbuffer, float depth, int stencil, long procAddress);

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  public String glGetStringi(int name, int index)  {

    final long __addr_ = _pat._addressof_glGetStringi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetStringi"));
    }
        return dispatch_glGetStringi1(name, index, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code><br>   */
  private native String dispatch_glGetStringi1(int name, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_NV_copy_buffer</code><br>Alias for: <code>glCopyBufferSubDataNV</code>   */
  public void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _pat._addressof_glCopyBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyBufferSubData"));
    }
        dispatch_glCopyBufferSubData1(readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_NV_copy_buffer</code><br>Alias for: <code>glCopyBufferSubDataNV</code>   */
  private native void dispatch_glCopyBufferSubData1(int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, IntBuffer uniformIndices)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final long __addr_ = _pat._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformIndices1(int program, int uniformCount, String[] uniformNames, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, int[] uniformIndices, int uniformIndices_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    final long __addr_ = _pat._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformsiv(int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformsiv1(int program, int uniformCount, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformsiv(int program, int uniformCount, int[] uniformIndices, int uniformIndices_offset, int pname, int[] params, int params_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public int glGetUniformBlockIndex(int program, String uniformBlockName)  {

    final long __addr_ = _pat._addressof_glGetUniformBlockIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBlockIndex"));
    }
        return dispatch_glGetUniformBlockIndex1(program, uniformBlockName, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  private native int dispatch_glGetUniformBlockIndex1(int program, String uniformBlockName, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformBlockiv1(int program, int uniformBlockIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, IntBuffer length, ByteBuffer uniformBlockName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformBlockName_is_direct = Buffers.isDirect(uniformBlockName);
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformBlockName_is_direct ? uniformBlockName : Buffers.getArray(uniformBlockName), uniformBlockName_is_direct ? Buffers.getDirectBufferByteOffset(uniformBlockName) : Buffers.getIndirectBufferByteOffset(uniformBlockName), uniformBlockName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformBlockName1(int program, int uniformBlockIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformBlockName, int uniformBlockName_byte_offset, boolean uniformBlockName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, int[] length, int length_offset, byte[] uniformBlockName, int uniformBlockName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformBlockName != null && uniformBlockName.length <= uniformBlockName_offset)
      throw new GLException("array offset argument \"uniformBlockName_offset\" (" + uniformBlockName_offset + ") equals or exceeds array length (" + uniformBlockName.length + ")");
    final long __addr_ = _pat._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformBlockName, uniformBlockName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  public void glUniformBlockBinding(int program, int uniformBlockIndex, int uniformBlockBinding)  {

    final long __addr_ = _pat._addressof_glUniformBlockBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformBlockBinding"));
    }
        dispatch_glUniformBlockBinding1(program, uniformBlockIndex, uniformBlockBinding, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) </code> <br>Part of <code>GL_ARB_uniform_buffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code><br>   */
  private native void dispatch_glUniformBlockBinding1(int program, int uniformBlockIndex, int uniformBlockBinding, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_NV_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code><br>Alias for: <code>glDrawArraysInstancedARB</code>, <code>glDrawArraysInstancedEXT</code>, <code>glDrawArraysInstancedNV</code>, <code>glDrawArraysInstancedANGLE</code>   */
  public void glDrawArraysInstanced(int mode, int first, int count, int instancecount)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstanced"));
    }
        dispatch_glDrawArraysInstanced1(mode, first, count, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_NV_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code><br>Alias for: <code>glDrawArraysInstancedARB</code>, <code>glDrawArraysInstancedEXT</code>, <code>glDrawArraysInstancedNV</code>, <code>glDrawArraysInstancedANGLE</code>   */
  private native void dispatch_glDrawArraysInstanced1(int mode, int first, int count, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstanced(int mode, int count, int type, Buffer indices, int instancecount)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>   */
  public void glDrawElementsInstanced(int mode, int count, int type, long indices_buffer_offset, int instancecount)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_buffer_offset, instancecount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>, <code>GL_ARB_draw_instanced</code>, <code>GL_EXT_draw_instanced</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_NV_draw_instanced</code><br>Alias for: <code>glDrawElementsInstancedARB</code>, <code>glDrawElementsInstancedEXT</code>, <code>glDrawElementsInstancedANGLE</code>, <code>glDrawElementsInstancedNV</code>   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, long indices_buffer_offset, int instancecount, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glFenceSyncAPPLE</code>   */
  public long glFenceSync(int condition, int flags)  {

    final long __addr_ = _pat._addressof_glFenceSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFenceSync"));
    }
        return dispatch_glFenceSync1(condition, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glFenceSyncAPPLE</code>   */
  private native long dispatch_glFenceSync1(int condition, int flags, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glIsSyncAPPLE</code>   */
  public boolean glIsSync(long sync)  {

    final long __addr_ = _pat._addressof_glIsSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSync"));
    }
        return dispatch_glIsSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glIsSyncAPPLE</code>   */
  private native boolean dispatch_glIsSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glDeleteSyncAPPLE</code>   */
  public void glDeleteSync(long sync)  {

    final long __addr_ = _pat._addressof_glDeleteSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSync"));
    }
        dispatch_glDeleteSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glDeleteSyncAPPLE</code>   */
  private native void dispatch_glDeleteSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glClientWaitSyncAPPLE</code>   */
  public int glClientWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = _pat._addressof_glClientWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientWaitSync"));
    }
        return dispatch_glClientWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glClientWaitSyncAPPLE</code>   */
  private native int dispatch_glClientWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glWaitSyncAPPLE</code>   */
  public void glWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = _pat._addressof_glWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWaitSync"));
    }
        dispatch_glWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glWaitSyncAPPLE</code>   */
  private native void dispatch_glWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64v(int pname, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64v1(int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetInteger64vAPPLE</code>   */
  public void glGetInteger64v(int pname, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSynciv(long sync, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = _pat._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSynciv1(long sync, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>, <code>GL_ARB_sync</code>, <code>GL_APPLE_sync</code><br>Alias for: <code>glGetSyncivAPPLE</code>   */
  public void glGetSynciv(long sync, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = _pat._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64i_v(int target, int index, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64i_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glGetInteger64i_v(int target, int index, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameteri64v(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameteri64v1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glGetBufferParameteri64v(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGenSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = _pat._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glDeleteSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public boolean glIsSampler(int sampler)  {

    final long __addr_ = _pat._addressof_glIsSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSampler"));
    }
        return dispatch_glIsSampler1(sampler, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native boolean dispatch_glIsSampler1(int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glBindSampler(int unit, int sampler)  {

    final long __addr_ = _pat._addressof_glBindSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindSampler"));
    }
        dispatch_glBindSampler1(unit, sampler, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glBindSampler1(int unit, int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameteri(int sampler, int pname, int param)  {

    final long __addr_ = _pat._addressof_glSamplerParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteri"));
    }
        dispatch_glSamplerParameteri1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glSamplerParameteri1(int sampler, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameteriv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameteriv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameteriv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameterf(int sampler, int pname, float param)  {

    final long __addr_ = _pat._addressof_glSamplerParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterf"));
    }
        dispatch_glSamplerParameterf1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  private native void dispatch_glSamplerParameterf1(int sampler, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSamplerParameterfv(int sampler, int pname, FloatBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSamplerParameterfv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glSamplerParameterfv(int sampler, int pname, float[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param, Buffers.SIZEOF_FLOAT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameteriv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameteriv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGetSamplerParameteriv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetSamplerParameterfv(int sampler, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetSamplerParameterfv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code><br>   */
  public void glGetSamplerParameterfv(int sampler, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_NV_instanced_arrays</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_EXT_instanced_arrays</code>, <code>GL_ARB_instanced_arrays</code><br>Alias for: <code>glVertexAttribDivisorNV</code>, <code>glVertexAttribDivisorANGLE</code>, <code>glVertexAttribDivisorEXT</code>, <code>glVertexAttribDivisorARB</code>   */
  public void glVertexAttribDivisor(int index, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexAttribDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisor"));
    }
        dispatch_glVertexAttribDivisor1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_VERSION_3_3</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_NV_instanced_arrays</code>, <code>GL_ANGLE_instanced_arrays</code>, <code>GL_EXT_instanced_arrays</code>, <code>GL_ARB_instanced_arrays</code><br>Alias for: <code>glVertexAttribDivisorNV</code>, <code>glVertexAttribDivisorANGLE</code>, <code>glVertexAttribDivisorEXT</code>, <code>glVertexAttribDivisorARB</code>   */
  private native void dispatch_glVertexAttribDivisor1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glBindTransformFeedbackNV</code>   */
  public void glBindTransformFeedback(int target, int id)  {

    final long __addr_ = _pat._addressof_glBindTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedback"));
    }
        dispatch_glBindTransformFeedback1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glBindTransformFeedbackNV</code>   */
  private native void dispatch_glBindTransformFeedback1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glDeleteTransformFeedbacksNV</code>   */
  public void glDeleteTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glGenTransformFeedbacksNV</code>   */
  public void glGenTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glIsTransformFeedbackNV</code>   */
  public boolean glIsTransformFeedback(int id)  {

    final long __addr_ = _pat._addressof_glIsTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedback"));
    }
        return dispatch_glIsTransformFeedback1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glIsTransformFeedbackNV</code>   */
  private native boolean dispatch_glIsTransformFeedback1(int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glPauseTransformFeedbackNV</code>   */
  public void glPauseTransformFeedback()  {

    final long __addr_ = _pat._addressof_glPauseTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedback"));
    }
        dispatch_glPauseTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glPauseTransformFeedbackNV</code>   */
  private native void dispatch_glPauseTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glResumeTransformFeedbackNV</code>   */
  public void glResumeTransformFeedback()  {

    final long __addr_ = _pat._addressof_glResumeTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedback"));
    }
        dispatch_glResumeTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void) </code> <br>Part of <code>GL_ARB_transform_feedback2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_NV_transform_feedback2</code><br>Alias for: <code>glResumeTransformFeedbackNV</code>   */
  private native void dispatch_glResumeTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, IntBuffer length, IntBuffer binaryFormat, Buffer binary)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean binaryFormat_is_direct = Buffers.isDirect(binaryFormat);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, binaryFormat_is_direct ? binaryFormat : Buffers.getArray(binaryFormat), binaryFormat_is_direct ? Buffers.getDirectBufferByteOffset(binaryFormat) : Buffers.getIndirectBufferByteOffset(binaryFormat), binaryFormat_is_direct, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramBinary1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object binaryFormat, int binaryFormat_byte_offset, boolean binaryFormat_is_direct, Object binary, int binary_byte_offset, boolean binary_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, void *  binary) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glGetProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, int[] length, int length_offset, int[] binaryFormat, int binaryFormat_offset, Buffer binary)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(binaryFormat != null && binaryFormat.length <= binaryFormat_offset)
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + binaryFormat_offset + ") equals or exceeds array length (" + binaryFormat.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, binaryFormat, Buffers.SIZEOF_INT * binaryFormat_offset, false, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glProgramBinary(int program, int binaryFormat, Buffer binary, int length)  {

    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = _pat._addressof_glProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBinary"));
    }
        dispatch_glProgramBinary1(program, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const void *  binary, GLsizei length) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_get_program_binary</code><br>Alias for: <code>glProgramBinaryOES</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glProgramBinary1(int program, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_geometry_shader4</code>, <code>GL_EXT_separate_shader_objects</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glProgramParameteriEXT</code>, <code>glProgramParameteriARB</code>   */
  public void glProgramParameteri(int program, int pname, int value)  {

    final long __addr_ = _pat._addressof_glProgramParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteri"));
    }
        dispatch_glProgramParameteri1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_get_program_binary</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_geometry_shader4</code>, <code>GL_EXT_separate_shader_objects</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glProgramParameteriEXT</code>, <code>glProgramParameteriARB</code>   */
  private native void dispatch_glProgramParameteri1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateFramebuffer(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, IntBuffer attachments, int x, int y, int width, int height)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateSubFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_invalidate_subdata</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset, int x, int y, int width, int height)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2D"));
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  private native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3D"));
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  private native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInternalformativ1(int target, int internalformat, int pname, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code><br>   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchCompute}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glDispatchCompute(int num_groups_x, int num_groups_y, int num_groups_z)  {

    final long __addr_ = _pat._addressof_glDispatchCompute;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDispatchCompute"));
    }
        dispatch_glDispatchCompute1(num_groups_x, num_groups_y, num_groups_z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchCompute}(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glDispatchCompute1(int num_groups_x, int num_groups_y, int num_groups_z, long procAddress);

  /** Entry point to C language function: <code> void {@native glDispatchComputeIndirect}(GLintptr indirect) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glDispatchComputeIndirect(long indirect)  {

    final long __addr_ = _pat._addressof_glDispatchComputeIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDispatchComputeIndirect"));
    }
        dispatch_glDispatchComputeIndirect1(indirect, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDispatchComputeIndirect}(GLintptr indirect) </code> <br>Part of <code>GL_ARB_compute_shader</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glDispatchComputeIndirect1(long indirect, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawArraysIndirect(int mode, Buffer indirect)  {

    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(indirect, 1);
    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
    }
        dispatch_glDrawArraysIndirect1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawArraysIndirect1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glDrawArraysIndirect(int mode, long indirect_buffer_offset)  {

    checkIndirectVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawArraysIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysIndirect"));
    }
        dispatch_glDrawArraysIndirect1(mode, indirect_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysIndirect}(GLenum mode, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glDrawArraysIndirect1(int mode, long indirect_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsIndirect(int mode, int type, Buffer indirect)  {

    checkIndirectVBOUnbound(true);
    Buffers.rangeCheck(indirect, 1);
    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
    }
        dispatch_glDrawElementsIndirect1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsIndirect1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>   */
  public void glDrawElementsIndirect(int mode, int type, long indirect_buffer_offset)  {

    checkIndirectVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsIndirect;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsIndirect"));
    }
        dispatch_glDrawElementsIndirect1(mode, type, indirect_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsIndirect}(GLenum mode, GLenum type, const void *  indirect) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_draw_indirect</code>, <code>GL_VERSION_4_0</code><br>   */
  private native void dispatch_glDrawElementsIndirect1(int mode, int type, long indirect_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glFramebufferParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glFramebufferParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferParameteri"));
    }
        dispatch_glFramebufferParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glFramebufferParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
    }
        dispatch_glGetFramebufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_framebuffer_no_attachments</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_direct_state_access</code><br>Alias for: <code>glGetFramebufferParameterivEXT</code>   */
  public void glGetFramebufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferParameteriv"));
    }
        dispatch_glGetFramebufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramInterfaceiv(int program, int programInterface, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramInterfaceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
    }
        dispatch_glGetProgramInterfaceiv1(program, programInterface, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramInterfaceiv1(int program, int programInterface, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInterfaceiv}(GLuint program, GLenum programInterface, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramInterfaceiv(int program, int programInterface, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramInterfaceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInterfaceiv"));
    }
        dispatch_glGetProgramInterfaceiv1(program, programInterface, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceIndex(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
    }
        return dispatch_glGetProgramResourceIndex1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceIndex1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetProgramResourceIndex}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public int glGetProgramResourceIndex(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceIndex"));
    }
        return dispatch_glGetProgramResourceIndex1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramResourceName(int program, int programInterface, int index, int bufSize, IntBuffer length, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
    }
        dispatch_glGetProgramResourceName1(program, programInterface, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramResourceName1(int program, int programInterface, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramResourceName}(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *  length, GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramResourceName(int program, int programInterface, int index, int bufSize, int[] length, int length_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceName"));
    }
        dispatch_glGetProgramResourceName1(program, programInterface, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param props a direct or array-backed {@link java.nio.IntBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramResourceiv(int program, int programInterface, int index, int propCount, IntBuffer props, int bufSize, IntBuffer length, IntBuffer params)  {

    final boolean props_is_direct = Buffers.isDirect(props);
    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramResourceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
    }
        dispatch_glGetProgramResourceiv1(program, programInterface, index, propCount, props_is_direct ? props : Buffers.getArray(props), props_is_direct ? Buffers.getDirectBufferByteOffset(props) : Buffers.getIndirectBufferByteOffset(props), props_is_direct, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param props a direct or array-backed {@link java.nio.IntBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramResourceiv1(int program, int programInterface, int index, int propCount, Object props, int props_byte_offset, boolean props_is_direct, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramResourceiv}(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *  props, GLsizei bufSize, GLsizei *  length, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public void glGetProgramResourceiv(int program, int programInterface, int index, int propCount, int[] props, int props_offset, int bufSize, int[] length, int length_offset, int[] params, int params_offset)  {

    if(props != null && props.length <= props_offset)
      throw new GLException("array offset argument \"props_offset\" (" + props_offset + ") equals or exceeds array length (" + props.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceiv"));
    }
        dispatch_glGetProgramResourceiv1(program, programInterface, index, propCount, props, Buffers.SIZEOF_INT * props_offset, false, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceLocation(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
    }
        return dispatch_glGetProgramResourceLocation1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceLocation1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocation}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_program_interface_query</code><br>   */
  public int glGetProgramResourceLocation(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocation"));
    }
        return dispatch_glGetProgramResourceLocation1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glUseProgramStagesEXT</code>   */
  public void glUseProgramStages(int pipeline, int stages, int program)  {

    final long __addr_ = _pat._addressof_glUseProgramStages;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgramStages"));
    }
        dispatch_glUseProgramStages1(pipeline, stages, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgramStages}(GLuint pipeline, GLbitfield stages, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glUseProgramStagesEXT</code>   */
  private native void dispatch_glUseProgramStages1(int pipeline, int stages, int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glActiveShaderProgramEXT</code>   */
  public void glActiveShaderProgram(int pipeline, int program)  {

    final long __addr_ = _pat._addressof_glActiveShaderProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveShaderProgram"));
    }
        dispatch_glActiveShaderProgram1(pipeline, program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveShaderProgram}(GLuint pipeline, GLuint program) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glActiveShaderProgramEXT</code>   */
  private native void dispatch_glActiveShaderProgram1(int pipeline, int program, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar * const  *  strings) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glCreateShaderProgramvEXT</code>   */
  public int glCreateShaderProgramv(int type, int count, String[] strings)  {

    final long __addr_ = _pat._addressof_glCreateShaderProgramv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShaderProgramv"));
    }
        return dispatch_glCreateShaderProgramv1(type, count, strings, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShaderProgramv}(GLenum type, GLsizei count, const GLchar * const  *  strings) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glCreateShaderProgramvEXT</code>   */
  private native int dispatch_glCreateShaderProgramv1(int type, int count, String[] strings, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glBindProgramPipelineEXT</code>   */
  public void glBindProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glBindProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindProgramPipeline"));
    }
        dispatch_glBindProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glBindProgramPipelineEXT</code>   */
  private native void dispatch_glBindProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = _pat._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteProgramPipelines}(GLsizei n, const GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glDeleteProgramPipelinesEXT</code>   */
  public void glDeleteProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = _pat._addressof_glDeleteProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgramPipelines"));
    }
        dispatch_glDeleteProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenProgramPipelines(int n, IntBuffer pipelines)  {

    final boolean pipelines_is_direct = Buffers.isDirect(pipelines);
    final long __addr_ = _pat._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
    }
        dispatch_glGenProgramPipelines1(n, pipelines_is_direct ? pipelines : Buffers.getArray(pipelines), pipelines_is_direct ? Buffers.getDirectBufferByteOffset(pipelines) : Buffers.getIndirectBufferByteOffset(pipelines), pipelines_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>
      @param pipelines a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenProgramPipelines1(int n, Object pipelines, int pipelines_byte_offset, boolean pipelines_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenProgramPipelines}(GLsizei n, GLuint *  pipelines) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGenProgramPipelinesEXT</code>   */
  public void glGenProgramPipelines(int n, int[] pipelines, int pipelines_offset)  {

    if(pipelines != null && pipelines.length <= pipelines_offset)
      throw new GLException("array offset argument \"pipelines_offset\" (" + pipelines_offset + ") equals or exceeds array length (" + pipelines.length + ")");
    final long __addr_ = _pat._addressof_glGenProgramPipelines;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenProgramPipelines"));
    }
        dispatch_glGenProgramPipelines1(n, pipelines, Buffers.SIZEOF_INT * pipelines_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glIsProgramPipelineEXT</code>   */
  public boolean glIsProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glIsProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgramPipeline"));
    }
        return dispatch_glIsProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glIsProgramPipelineEXT</code>   */
  private native boolean dispatch_glIsProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramPipelineiv(int pipeline, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramPipelineiv1(int pipeline, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineiv}(GLuint pipeline, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineivEXT</code>   */
  public void glGetProgramPipelineiv(int pipeline, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramPipelineiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineiv"));
    }
        dispatch_glGetProgramPipelineiv1(pipeline, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1iEXT</code>   */
  public void glProgramUniform1i(int program, int location, int v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1i"));
    }
        dispatch_glProgramUniform1i1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1i}(GLuint program, GLint location, GLint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1iEXT</code>   */
  private native void dispatch_glProgramUniform1i1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2iEXT</code>   */
  public void glProgramUniform2i(int program, int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2i"));
    }
        dispatch_glProgramUniform2i1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2i}(GLuint program, GLint location, GLint v0, GLint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2iEXT</code>   */
  private native void dispatch_glProgramUniform2i1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3iEXT</code>   */
  public void glProgramUniform3i(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3i"));
    }
        dispatch_glProgramUniform3i1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3iEXT</code>   */
  private native void dispatch_glProgramUniform3i1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4iEXT</code>   */
  public void glProgramUniform4i(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4i"));
    }
        dispatch_glProgramUniform4i1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4i}(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4iEXT</code>   */
  private native void dispatch_glProgramUniform4i1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uiEXT</code>   */
  public void glProgramUniform1ui(int program, int location, int v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1ui"));
    }
        dispatch_glProgramUniform1ui1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1ui}(GLuint program, GLint location, GLuint v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uiEXT</code>   */
  private native void dispatch_glProgramUniform1ui1(int program, int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uiEXT</code>   */
  public void glProgramUniform2ui(int program, int location, int v0, int v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2ui"));
    }
        dispatch_glProgramUniform2ui1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2ui}(GLuint program, GLint location, GLuint v0, GLuint v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uiEXT</code>   */
  private native void dispatch_glProgramUniform2ui1(int program, int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uiEXT</code>   */
  public void glProgramUniform3ui(int program, int location, int v0, int v1, int v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3ui"));
    }
        dispatch_glProgramUniform3ui1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uiEXT</code>   */
  private native void dispatch_glProgramUniform3ui1(int program, int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uiEXT</code>   */
  public void glProgramUniform4ui(int program, int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4ui"));
    }
        dispatch_glProgramUniform4ui1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4ui}(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uiEXT</code>   */
  private native void dispatch_glProgramUniform4ui1(int program, int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fEXT</code>   */
  public void glProgramUniform1f(int program, int location, float v0)  {

    final long __addr_ = _pat._addressof_glProgramUniform1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1f"));
    }
        dispatch_glProgramUniform1f1(program, location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1f}(GLuint program, GLint location, GLfloat v0) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fEXT</code>   */
  private native void dispatch_glProgramUniform1f1(int program, int location, float v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fEXT</code>   */
  public void glProgramUniform2f(int program, int location, float v0, float v1)  {

    final long __addr_ = _pat._addressof_glProgramUniform2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2f"));
    }
        dispatch_glProgramUniform2f1(program, location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2f}(GLuint program, GLint location, GLfloat v0, GLfloat v1) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fEXT</code>   */
  private native void dispatch_glProgramUniform2f1(int program, int location, float v0, float v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fEXT</code>   */
  public void glProgramUniform3f(int program, int location, float v0, float v1, float v2)  {

    final long __addr_ = _pat._addressof_glProgramUniform3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3f"));
    }
        dispatch_glProgramUniform3f1(program, location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fEXT</code>   */
  private native void dispatch_glProgramUniform3f1(int program, int location, float v0, float v1, float v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fEXT</code>   */
  public void glProgramUniform4f(int program, int location, float v0, float v1, float v2, float v3)  {

    final long __addr_ = _pat._addressof_glProgramUniform4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4f"));
    }
        dispatch_glProgramUniform4f1(program, location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4f}(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fEXT</code>   */
  private native void dispatch_glProgramUniform4f1(int program, int location, float v0, float v1, float v2, float v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
    }
        dispatch_glProgramUniform1iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1ivEXT</code>   */
  public void glProgramUniform1iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1iv"));
    }
        dispatch_glProgramUniform1iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
    }
        dispatch_glProgramUniform2iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2ivEXT</code>   */
  public void glProgramUniform2iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2iv"));
    }
        dispatch_glProgramUniform2iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
    }
        dispatch_glProgramUniform3iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3ivEXT</code>   */
  public void glProgramUniform3iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3iv"));
    }
        dispatch_glProgramUniform3iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4iv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
    }
        dispatch_glProgramUniform4iv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4iv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4iv}(GLuint program, GLint location, GLsizei count, const GLint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4ivEXT</code>   */
  public void glProgramUniform4iv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4iv"));
    }
        dispatch_glProgramUniform4iv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform1uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform1uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1uivEXT</code>   */
  public void glProgramUniform1uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1uiv"));
    }
        dispatch_glProgramUniform1uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform2uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform2uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2uivEXT</code>   */
  public void glProgramUniform2uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2uiv"));
    }
        dispatch_glProgramUniform2uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform3uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform3uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3uivEXT</code>   */
  public void glProgramUniform3uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3uiv"));
    }
        dispatch_glProgramUniform3uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glProgramUniform4uiv(int program, int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glProgramUniform4uiv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4uiv}(GLuint program, GLint location, GLsizei count, const GLuint *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4uivEXT</code>   */
  public void glProgramUniform4uiv(int program, int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4uiv"));
    }
        dispatch_glProgramUniform4uiv1(program, location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform1fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
    }
        dispatch_glProgramUniform1fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform1fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform1fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform1fvEXT</code>   */
  public void glProgramUniform1fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform1fv"));
    }
        dispatch_glProgramUniform1fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform2fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
    }
        dispatch_glProgramUniform2fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform2fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform2fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform2fvEXT</code>   */
  public void glProgramUniform2fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform2fv"));
    }
        dispatch_glProgramUniform2fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform3fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
    }
        dispatch_glProgramUniform3fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform3fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform3fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform3fvEXT</code>   */
  public void glProgramUniform3fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform3fv"));
    }
        dispatch_glProgramUniform3fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniform4fv(int program, int location, int count, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
    }
        dispatch_glProgramUniform4fv1(program, location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniform4fv1(int program, int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniform4fv}(GLuint program, GLint location, GLsizei count, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniform4fvEXT</code>   */
  public void glProgramUniform4fv(int program, int location, int count, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniform4fv"));
    }
        dispatch_glProgramUniform4fv1(program, location, count, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2fvEXT</code>   */
  public void glProgramUniformMatrix2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2fv"));
    }
        dispatch_glProgramUniformMatrix2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3fvEXT</code>   */
  public void glProgramUniformMatrix3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3fv"));
    }
        dispatch_glProgramUniformMatrix3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4fvEXT</code>   */
  public void glProgramUniformMatrix4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4fv"));
    }
        dispatch_glProgramUniformMatrix4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x3fvEXT</code>   */
  public void glProgramUniformMatrix2x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x3fv"));
    }
        dispatch_glProgramUniformMatrix2x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x2fvEXT</code>   */
  public void glProgramUniformMatrix3x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x2fv"));
    }
        dispatch_glProgramUniformMatrix3x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix2x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix2x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix2x4fvEXT</code>   */
  public void glProgramUniformMatrix2x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix2x4fv"));
    }
        dispatch_glProgramUniformMatrix2x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x2fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x2fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x2fvEXT</code>   */
  public void glProgramUniformMatrix4x2fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x2fv"));
    }
        dispatch_glProgramUniformMatrix4x2fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix3x4fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix3x4fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix3x4fvEXT</code>   */
  public void glProgramUniformMatrix3x4fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix3x4fv"));
    }
        dispatch_glProgramUniformMatrix3x4fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glProgramUniformMatrix4x3fv1(int program, int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramUniformMatrix4x3fv}(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_direct_state_access</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glProgramUniformMatrix4x3fvEXT</code>   */
  public void glProgramUniformMatrix4x3fv(int program, int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glProgramUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramUniformMatrix4x3fv"));
    }
        dispatch_glProgramUniformMatrix4x3fv1(program, location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glValidateProgramPipelineEXT</code>   */
  public void glValidateProgramPipeline(int pipeline)  {

    final long __addr_ = _pat._addressof_glValidateProgramPipeline;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgramPipeline"));
    }
        dispatch_glValidateProgramPipeline1(pipeline, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgramPipeline}(GLuint pipeline) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glValidateProgramPipelineEXT</code>   */
  private native void dispatch_glValidateProgramPipeline1(int pipeline, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, IntBuffer length, ByteBuffer infoLog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infoLog_is_direct = Buffers.isDirect(infoLog);
    final long __addr_ = _pat._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infoLog_is_direct ? infoLog : Buffers.getArray(infoLog), infoLog_is_direct ? Buffers.getDirectBufferByteOffset(infoLog) : Buffers.getIndirectBufferByteOffset(infoLog), infoLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infoLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramPipelineInfoLog1(int pipeline, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object infoLog, int infoLog_byte_offset, boolean infoLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramPipelineInfoLog}(GLuint pipeline, GLsizei bufSize, GLsizei *  length, GLchar *  infoLog) </code> <br>Part of <code>GL_ARB_separate_shader_objects</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_1</code>, <code>GL_EXT_separate_shader_objects</code><br>Alias for: <code>glGetProgramPipelineInfoLogEXT</code>   */
  public void glGetProgramPipelineInfoLog(int pipeline, int bufSize, int[] length, int length_offset, byte[] infoLog, int infoLog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infoLog != null && infoLog.length <= infoLog_offset)
      throw new GLException("array offset argument \"infoLog_offset\" (" + infoLog_offset + ") equals or exceeds array length (" + infoLog.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramPipelineInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramPipelineInfoLog"));
    }
        dispatch_glGetProgramPipelineInfoLog1(pipeline, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, infoLog, infoLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glBindImageTextureEXT</code>   */
  public void glBindImageTexture(int unit, int texture, int level, boolean layered, int layer, int access, int format)  {

    final long __addr_ = _pat._addressof_glBindImageTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindImageTexture"));
    }
        dispatch_glBindImageTexture1(unit, texture, level, layered, layer, access, format, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindImageTexture}(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glBindImageTextureEXT</code>   */
  private native void dispatch_glBindImageTexture1(int unit, int texture, int level, boolean layered, int layer, int access, int format, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleani_v(int target, int index, ByteBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
    }
        dispatch_glGetBooleani_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>
      @param data a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleani_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleani_v}(GLenum target, GLuint index, GLboolean *  data) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_3_0</code><br>   */
  public void glGetBooleani_v(int target, int index, byte[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleani_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleani_v"));
    }
        dispatch_glGetBooleani_v1(target, index, data, data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glMemoryBarrierEXT</code>   */
  public void glMemoryBarrier(int barriers)  {

    final long __addr_ = _pat._addressof_glMemoryBarrier;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrier"));
    }
        dispatch_glMemoryBarrier1(barriers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrier}(GLbitfield barriers) </code> <br>Part of <code>GL_ARB_shader_image_load_store</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_shader_image_load_store</code><br>Alias for: <code>glMemoryBarrierEXT</code>   */
  private native void dispatch_glMemoryBarrier1(int barriers, long procAddress);

  /** Entry point to C language function: <code> void {@native glMemoryBarrierByRegion}(GLbitfield barriers) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_1</code><br>   */
  public void glMemoryBarrierByRegion(int barriers)  {

    final long __addr_ = _pat._addressof_glMemoryBarrierByRegion;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMemoryBarrierByRegion"));
    }
        dispatch_glMemoryBarrierByRegion1(barriers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMemoryBarrierByRegion}(GLbitfield barriers) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_1</code><br>   */
  private native void dispatch_glMemoryBarrierByRegion1(int barriers, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  public void glTexStorage2DMultisample(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexStorage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2DMultisample"));
    }
        dispatch_glTexStorage2DMultisample1(target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_storage_multisample</code>, <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code><br>   */
  private native void dispatch_glTexStorage2DMultisample1(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMultisamplefv(int pname, int index, FloatBuffer val)  {

    final boolean val_is_direct = Buffers.isDirect(val);
    final long __addr_ = _pat._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
    }
        dispatch_glGetMultisamplefv1(pname, index, val_is_direct ? val : Buffers.getArray(val), val_is_direct ? Buffers.getDirectBufferByteOffset(val) : Buffers.getIndirectBufferByteOffset(val), val_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>
      @param val a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMultisamplefv1(int pname, int index, Object val, int val_byte_offset, boolean val_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMultisamplefv}(GLenum pname, GLuint index, GLfloat *  val) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code>, <code>GL_NV_explicit_multisample</code><br>Alias for: <code>glGetMultisamplefvNV</code>   */
  public void glGetMultisamplefv(int pname, int index, float[] val, int val_offset)  {

    if(val != null && val.length <= val_offset)
      throw new GLException("array offset argument \"val_offset\" (" + val_offset + ") equals or exceeds array length (" + val.length + ")");
    final long __addr_ = _pat._addressof_glGetMultisamplefv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMultisamplefv"));
    }
        dispatch_glGetMultisamplefv1(pname, index, val, Buffers.SIZEOF_FLOAT * val_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint maskNumber, GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glSampleMaski(int maskNumber, int mask)  {

    final long __addr_ = _pat._addressof_glSampleMaski;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleMaski"));
    }
        dispatch_glSampleMaski1(maskNumber, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleMaski}(GLuint maskNumber, GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glSampleMaski1(int maskNumber, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexLevelParameteriv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameteriv}(GLenum target, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexLevelParameteriv(int target, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexLevelParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameteriv"));
    }
        dispatch_glGetTexLevelParameteriv1(target, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexLevelParameterfv1(int target, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexLevelParameterfv}(GLenum target, GLint level, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexLevelParameterfv(int target, int level, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexLevelParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexLevelParameterfv"));
    }
        dispatch_glGetTexLevelParameterfv1(target, level, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexBuffer}(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glBindVertexBuffer(int bindingindex, int buffer, long offset, int stride)  {

    final long __addr_ = _pat._addressof_glBindVertexBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexBuffer"));
    }
        dispatch_glBindVertexBuffer1(bindingindex, buffer, offset, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexBuffer}(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glBindVertexBuffer1(int bindingindex, int buffer, long offset, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribFormat}(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribFormatNV</code>   */
  public void glVertexAttribFormat(int attribindex, int size, int type, boolean normalized, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexAttribFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribFormat"));
    }
        dispatch_glVertexAttribFormat1(attribindex, size, type, normalized, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribFormat}(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribFormatNV</code>   */
  private native void dispatch_glVertexAttribFormat1(int attribindex, int size, int type, boolean normalized, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribIFormatNV</code>   */
  public void glVertexAttribIFormat(int attribindex, int size, int type, int relativeoffset)  {

    final long __addr_ = _pat._addressof_glVertexAttribIFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIFormat"));
    }
        dispatch_glVertexAttribIFormat1(attribindex, size, type, relativeoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIFormat}(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code>, <code>GL_NV_vertex_buffer_unified_memory</code><br>Alias for: <code>glVertexAttribIFormatNV</code>   */
  private native void dispatch_glVertexAttribIFormat1(int attribindex, int size, int type, int relativeoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribBinding}(GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexAttribBinding(int attribindex, int bindingindex)  {

    final long __addr_ = _pat._addressof_glVertexAttribBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribBinding"));
    }
        dispatch_glVertexAttribBinding1(attribindex, bindingindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribBinding}(GLuint attribindex, GLuint bindingindex) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexAttribBinding1(int attribindex, int bindingindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexBindingDivisor}(GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  public void glVertexBindingDivisor(int bindingindex, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexBindingDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexBindingDivisor"));
    }
        dispatch_glVertexBindingDivisor1(bindingindex, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexBindingDivisor}(GLuint bindingindex, GLuint divisor) </code> <br>Part of <code>GL_ES_VERSION_3_1</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_vertex_attrib_binding</code><br>   */
  private native void dispatch_glVertexBindingDivisor1(int bindingindex, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendBarrier}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_blend_equation_advanced</code>, <code>GL_NV_blend_equation_advanced</code><br>Alias for: <code>glBlendBarrierKHR</code>, <code>glBlendBarrierNV</code>   */
  public void glBlendBarrier()  {

    final long __addr_ = _pat._addressof_glBlendBarrier;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendBarrier"));
    }
        dispatch_glBlendBarrier1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendBarrier}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_blend_equation_advanced</code>, <code>GL_NV_blend_equation_advanced</code><br>Alias for: <code>glBlendBarrierKHR</code>, <code>glBlendBarrierNV</code>   */
  private native void dispatch_glBlendBarrier1(long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyImageSubData}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) </code> <br>Part of <code>GL_ARB_copy_image</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_NV_copy_image</code>, <code>GL_EXT_copy_image</code>, <code>GL_OES_copy_image</code><br>Alias for: <code>glCopyImageSubDataNV</code>, <code>glCopyImageSubDataEXT</code>, <code>glCopyImageSubDataOES</code>   */
  public void glCopyImageSubData(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)  {

    final long __addr_ = _pat._addressof_glCopyImageSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyImageSubData"));
    }
        dispatch_glCopyImageSubData1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyImageSubData}(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) </code> <br>Part of <code>GL_ARB_copy_image</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_NV_copy_image</code>, <code>GL_EXT_copy_image</code>, <code>GL_OES_copy_image</code><br>Alias for: <code>glCopyImageSubDataNV</code>, <code>glCopyImageSubDataEXT</code>, <code>glCopyImageSubDataOES</code>   */
  private native void dispatch_glCopyImageSubData1(int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageControl(int source, int type, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = _pat._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageControl1(int source, int type, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>, <code>GL_ARB_debug_output</code><br>Alias for: <code>glDebugMessageControlKHR</code>, <code>glDebugMessageControlARB</code>   */
  public void glDebugMessageControl(int source, int type, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = _pat._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code>, <code>GL_AMD_debug_output</code><br>Alias for: <code>glDebugMessageInsertARB</code>, <code>glDebugMessageInsertKHR</code>, <code>glDebugMessageInsertAMD</code>   */
  public void glDebugMessageInsert(int source, int type, int id, int severity, int length, String buf)  {

    final long __addr_ = _pat._addressof_glDebugMessageInsert;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsert"));
    }
        dispatch_glDebugMessageInsert1(source, type, id, severity, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code>, <code>GL_AMD_debug_output</code><br>Alias for: <code>glDebugMessageInsertARB</code>, <code>glDebugMessageInsertKHR</code>, <code>glDebugMessageInsertAMD</code>   */
  private native void dispatch_glDebugMessageInsert1(int source, int type, int id, int severity, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLog(int count, int bufSize, IntBuffer sources, IntBuffer types, IntBuffer ids, IntBuffer severities, IntBuffer lengths, ByteBuffer messageLog)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final boolean types_is_direct = Buffers.isDirect(types);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean messageLog_is_direct = Buffers.isDirect(messageLog);
    final long __addr_ = _pat._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufSize, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, types_is_direct ? types : Buffers.getArray(types), types_is_direct ? Buffers.getDirectBufferByteOffset(types) : Buffers.getIndirectBufferByteOffset(types), types_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, messageLog_is_direct ? messageLog : Buffers.getArray(messageLog), messageLog_is_direct ? Buffers.getDirectBufferByteOffset(messageLog) : Buffers.getIndirectBufferByteOffset(messageLog), messageLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLog1(int count, int bufSize, Object sources, int sources_byte_offset, boolean sources_is_direct, Object types, int types_byte_offset, boolean types_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object messageLog, int messageLog_byte_offset, boolean messageLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufSize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_AMD_debug_output</code>, <code>GL_ARB_debug_output</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetDebugMessageLogAMD</code>, <code>glGetDebugMessageLogARB</code>, <code>glGetDebugMessageLogKHR</code>   */
  public int glGetDebugMessageLog(int count, int bufSize, int[] sources, int sources_offset, int[] types, int types_offset, int[] ids, int ids_offset, int[] severities, int severities_offset, int[] lengths, int lengths_offset, byte[] messageLog, int messageLog_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new GLException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    if(types != null && types.length <= types_offset)
      throw new GLException("array offset argument \"types_offset\" (" + types_offset + ") equals or exceeds array length (" + types.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(messageLog != null && messageLog.length <= messageLog_offset)
      throw new GLException("array offset argument \"messageLog_offset\" (" + messageLog_offset + ") equals or exceeds array length (" + messageLog.length + ")");
    final long __addr_ = _pat._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufSize, sources, Buffers.SIZEOF_INT * sources_offset, false, types, Buffers.SIZEOF_INT * types_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, messageLog, messageLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPushDebugGroup(int source, int id, int length, ByteBuffer message)  {

    final boolean message_is_direct = Buffers.isDirect(message);
    final long __addr_ = _pat._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPushDebugGroup1(int source, int id, int length, Object message, int message_byte_offset, boolean message_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPushDebugGroupKHR</code>   */
  public void glPushDebugGroup(int source, int id, int length, byte[] message, int message_offset)  {

    if(message != null && message.length <= message_offset)
      throw new GLException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
    final long __addr_ = _pat._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message, message_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPopDebugGroupKHR</code>   */
  public void glPopDebugGroup()  {

    final long __addr_ = _pat._addressof_glPopDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopDebugGroup"));
    }
        dispatch_glPopDebugGroup1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glPopDebugGroupKHR</code>   */
  private native void dispatch_glPopDebugGroup1(long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectLabel(int identifier, int name, int length, ByteBuffer label)  {

    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectLabel1(int identifier, int name, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectLabelKHR</code>   */
  public void glObjectLabel(int identifier, int name, int length, byte[] label, int label_offset)  {

    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectLabel1(int identifier, int name, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_EXT_debug_label</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectLabelEXT</code>, <code>glGetObjectLabelKHR</code>   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = _pat._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_debug</code>, <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code><br>Alias for: <code>glGetObjectPtrLabelKHR</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = _pat._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_viewport_array</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glEnableiNV</code>, <code>glEnableiOES</code>, <code>glEnableiEXT</code>   */
  public void glEnablei(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnablei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnablei"));
    }
        dispatch_glEnablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_NV_viewport_array</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glEnableiNV</code>, <code>glEnableiOES</code>, <code>glEnableiEXT</code>   */
  private native void dispatch_glEnablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glDisableiOES</code>, <code>glDisableiNV</code>, <code>glDisableiEXT</code>   */
  public void glDisablei(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisablei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisablei"));
    }
        dispatch_glDisablei1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisablei}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glDisableiOES</code>, <code>glDisableiNV</code>, <code>glDisableiEXT</code>   */
  private native void dispatch_glDisablei1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationi}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code><br>Alias for: <code>glBlendEquationiOES</code>, <code>glBlendEquationiEXT</code>, <code>glBlendEquationiARB</code>   */
  public void glBlendEquationi(int buf, int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquationi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationi"));
    }
        dispatch_glBlendEquationi1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationi}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code><br>Alias for: <code>glBlendEquationiOES</code>, <code>glBlendEquationiEXT</code>, <code>glBlendEquationiARB</code>   */
  private native void dispatch_glBlendEquationi1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparatei}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationSeparateiEXT</code>, <code>glBlendEquationSeparateiARB</code>, <code>glBlendEquationSeparateiOES</code>   */
  public void glBlendEquationSeparatei(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparatei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparatei"));
    }
        dispatch_glBlendEquationSeparatei1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparatei}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendEquationSeparateiEXT</code>, <code>glBlendEquationSeparateiARB</code>, <code>glBlendEquationSeparateiOES</code>   */
  private native void dispatch_glBlendEquationSeparatei1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunci}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendFunciARB</code>, <code>glBlendFunciEXT</code>, <code>glBlendFunciOES</code>   */
  public void glBlendFunci(int buf, int src, int dst)  {

    final long __addr_ = _pat._addressof_glBlendFunci;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunci"));
    }
        dispatch_glBlendFunci1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunci}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_draw_buffers_blend</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glBlendFunciARB</code>, <code>glBlendFunciEXT</code>, <code>glBlendFunciOES</code>   */
  private native void dispatch_glBlendFunci1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparatei}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code><br>Alias for: <code>glBlendFuncSeparateiOES</code>, <code>glBlendFuncSeparateiEXT</code>, <code>glBlendFuncSeparateiARB</code>   */
  public void glBlendFuncSeparatei(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparatei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparatei"));
    }
        dispatch_glBlendFuncSeparatei1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparatei}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_ARB_draw_buffers_blend</code><br>Alias for: <code>glBlendFuncSeparateiOES</code>, <code>glBlendFuncSeparateiEXT</code>, <code>glBlendFuncSeparateiARB</code>   */
  private native void dispatch_glBlendFuncSeparatei1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glColorMaskiEXT</code>, <code>glColorMaskiOES</code>   */
  public void glColorMaski(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = _pat._addressof_glColorMaski;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaski"));
    }
        dispatch_glColorMaski1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaski}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_draw_buffers_indexed</code>, <code>GL_OES_draw_buffers_indexed</code><br>Alias for: <code>glColorMaskiEXT</code>, <code>glColorMaskiOES</code>   */
  private native void dispatch_glColorMaski1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glIsEnablediOES</code>, <code>glIsEnablediNV</code>, <code>glIsEnablediEXT</code>   */
  public boolean glIsEnabledi(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnabledi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabledi"));
    }
        return dispatch_glIsEnabledi1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabledi}(GLenum target, GLuint index) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_draw_buffers_indexed</code>, <code>GL_NV_viewport_array</code>, <code>GL_EXT_draw_buffers_indexed</code><br>Alias for: <code>glIsEnablediOES</code>, <code>glIsEnablediNV</code>, <code>glIsEnablediEXT</code>   */
  private native boolean dispatch_glIsEnabledi1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsBaseVertex(int mode, int count, int type, Buffer indices, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
    }
        dispatch_glDrawElementsBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>   */
  public void glDrawElementsBaseVertex(int mode, int count, int type, long indices_buffer_offset, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertex"));
    }
        dispatch_glDrawElementsBaseVertex1(mode, count, type, indices_buffer_offset, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsBaseVertexEXT</code>, <code>glDrawElementsBaseVertexOES</code>   */
  private native void dispatch_glDrawElementsBaseVertex1(int mode, int count, int type, long indices_buffer_offset, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, Buffer indices, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
    }
        dispatch_glDrawRangeElementsBaseVertex1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElementsBaseVertex1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>   */
  public void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, long indices_buffer_offset, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertex"));
    }
        dispatch_glDrawRangeElementsBaseVertex1(mode, start, end, count, type, indices_buffer_offset, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertex}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_EXT_draw_elements_base_vertex</code>, <code>GL_OES_draw_elements_base_vertex</code><br>Alias for: <code>glDrawRangeElementsBaseVertexEXT</code>, <code>glDrawRangeElementsBaseVertexOES</code>   */
  private native void dispatch_glDrawRangeElementsBaseVertex1(int mode, int start, int end, int count, int type, long indices_buffer_offset, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertex(int mode, int count, int type, Buffer indices, int instancecount, int basevertex)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
    }
        dispatch_glDrawElementsInstancedBaseVertex1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertex1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>   */
  public void glDrawElementsInstancedBaseVertex(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertex"));
    }
        dispatch_glDrawElementsInstancedBaseVertex1(mode, count, type, indices_buffer_offset, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertex}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_ARB_draw_elements_base_vertex</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_draw_elements_base_vertex</code>, <code>GL_EXT_draw_elements_base_vertex</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexOES</code>, <code>glDrawElementsInstancedBaseVertexEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseVertex1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_geometry_shader</code>, <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureOES</code>, <code>glFramebufferTextureEXT</code>, <code>glFramebufferTextureARB</code>   */
  public void glFramebufferTexture(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture"));
    }
        dispatch_glFramebufferTexture1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_2</code>, <code>GL_OES_geometry_shader</code>, <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code>, <code>GL_ARB_geometry_shader4</code><br>Alias for: <code>glFramebufferTextureOES</code>, <code>glFramebufferTextureEXT</code>, <code>glFramebufferTextureARB</code>   */
  private native void dispatch_glFramebufferTexture1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBox}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_OES_primitive_bounding_box</code>, <code>GL_EXT_primitive_bounding_box</code>, <code>GL_ARB_ES3_2_compatibility</code><br>Alias for: <code>glPrimitiveBoundingBoxOES</code>, <code>glPrimitiveBoundingBoxEXT</code>, <code>glPrimitiveBoundingBoxARB</code>   */
  public void glPrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)  {

    final long __addr_ = _pat._addressof_glPrimitiveBoundingBox;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveBoundingBox"));
    }
        dispatch_glPrimitiveBoundingBox1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBox}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_OES_primitive_bounding_box</code>, <code>GL_EXT_primitive_bounding_box</code>, <code>GL_ARB_ES3_2_compatibility</code><br>Alias for: <code>glPrimitiveBoundingBoxOES</code>, <code>glPrimitiveBoundingBoxEXT</code>, <code>glPrimitiveBoundingBoxARB</code>   */
  private native void dispatch_glPrimitiveBoundingBox1(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = _pat._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetGraphicsResetStatus"));
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  private native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsEXT</code>, <code>glReadnPixelsARB</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadnPixels"));
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsEXT</code>, <code>glReadnPixelsARB</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, GLfloat *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformuiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformuiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformuiv}(GLuint program, GLint location, GLsizei bufSize, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_5</code>, <code>GL_KHR_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformuivKHR</code>, <code>glGetnUniformuivARB</code>   */
  public void glGetnUniformuiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformuiv"));
    }
        dispatch_glGetnUniformuiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShading}(GLfloat value) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_sample_shading</code>, <code>GL_ARB_sample_shading</code><br>Alias for: <code>glMinSampleShadingOES</code>, <code>glMinSampleShadingARB</code>   */
  public void glMinSampleShading(float value)  {

    final long __addr_ = _pat._addressof_glMinSampleShading;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMinSampleShading"));
    }
        dispatch_glMinSampleShading1(value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShading}(GLfloat value) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_sample_shading</code>, <code>GL_ARB_sample_shading</code><br>Alias for: <code>glMinSampleShadingOES</code>, <code>glMinSampleShadingARB</code>   */
  private native void dispatch_glMinSampleShading1(float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_tessellation_shader</code>, <code>GL_EXT_tessellation_shader</code><br>Alias for: <code>glPatchParameteriOES</code>, <code>glPatchParameteriEXT</code>   */
  public void glPatchParameteri(int pname, int value)  {

    final long __addr_ = _pat._addressof_glPatchParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameteri"));
    }
        dispatch_glPatchParameteri1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteri}(GLenum pname, GLint value) </code> <br>Part of <code>GL_ARB_tessellation_shader</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_0</code>, <code>GL_OES_tessellation_shader</code>, <code>GL_EXT_tessellation_shader</code><br>Alias for: <code>glPatchParameteriOES</code>, <code>glPatchParameteriEXT</code>   */
  private native void dispatch_glPatchParameteri1(int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
    }
        dispatch_glTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIiv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glTexParameterIivOES</code>, <code>glTexParameterIivEXT</code>   */
  public void glTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIiv"));
    }
        dispatch_glTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
    }
        dispatch_glTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterIuiv}(GLenum target, GLenum pname, const GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glTexParameterIuivEXT</code>, <code>glTexParameterIuivOES</code>   */
  public void glTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterIuiv"));
    }
        dispatch_glTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
    }
        dispatch_glGetTexParameterIiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIiv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIivOES</code>, <code>glGetTexParameterIivEXT</code>   */
  public void glGetTexParameterIiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIiv"));
    }
        dispatch_glGetTexParameterIiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterIuiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterIuiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterIuiv}(GLenum target, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_integer</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetTexParameterIuivOES</code>, <code>glGetTexParameterIuivEXT</code>   */
  public void glGetTexParameterIuiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterIuiv"));
    }
        dispatch_glGetTexParameterIuiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIiv}(GLuint sampler, GLenum pname, const GLint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIivEXT</code>, <code>glSamplerParameterIivOES</code>   */
  public void glSamplerParameterIiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIiv"));
    }
        dispatch_glSamplerParameterIiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameterIuiv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = _pat._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameterIuiv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterIuiv}(GLuint sampler, GLenum pname, const GLuint *  param) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glSamplerParameterIuivEXT</code>, <code>glSamplerParameterIuivOES</code>   */
  public void glSamplerParameterIuiv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = _pat._addressof_glSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterIuiv"));
    }
        dispatch_glSamplerParameterIuiv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIiv}(GLuint sampler, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_texture_border_clamp</code>, <code>GL_OES_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIivEXT</code>, <code>glGetSamplerParameterIivOES</code>   */
  public void glGetSamplerParameterIiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIiv"));
    }
        dispatch_glGetSamplerParameterIiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameterIuiv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterIuiv}(GLuint sampler, GLenum pname, GLuint *  params) </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_3</code>, <code>GL_OES_texture_border_clamp</code>, <code>GL_EXT_texture_border_clamp</code><br>Alias for: <code>glGetSamplerParameterIuivOES</code>, <code>glGetSamplerParameterIuivEXT</code>   */
  public void glGetSamplerParameterIuiv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetSamplerParameterIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterIuiv"));
    }
        dispatch_glGetSamplerParameterIuiv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBuffer}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_1</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code>, <code>GL_ARB_texture_buffer_object</code><br>Alias for: <code>glTexBufferOES</code>, <code>glTexBufferEXT</code>, <code>glTexBufferARB</code>   */
  public void glTexBuffer(int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTexBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBuffer"));
    }
        dispatch_glTexBuffer1(target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBuffer}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_3_1</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code>, <code>GL_ARB_texture_buffer_object</code><br>Alias for: <code>glTexBufferOES</code>, <code>glTexBufferEXT</code>, <code>glTexBufferARB</code>   */
  private native void dispatch_glTexBuffer1(int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferRange}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_buffer_range</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code><br>Alias for: <code>glTexBufferRangeOES</code>, <code>glTexBufferRangeEXT</code>   */
  public void glTexBufferRange(int target, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTexBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferRange"));
    }
        dispatch_glTexBufferRange1(target, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferRange}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_buffer_range</code>, <code>GL_OES_texture_buffer</code>, <code>GL_EXT_texture_buffer</code><br>Alias for: <code>glTexBufferRangeOES</code>, <code>glTexBufferRangeEXT</code>   */
  private native void dispatch_glTexBufferRange1(int target, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_VERSION_4_3</code>, <code>GL_OES_texture_storage_multisample_2d_array</code><br>Alias for: <code>glTexStorage3DMultisampleOES</code>   */
  public void glTexStorage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexStorage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3DMultisample"));
    }
        dispatch_glTexStorage3DMultisample1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ES_VERSION_3_2</code>, <code>GL_ARB_texture_storage_multisample</code>, <code>GL_VERSION_4_3</code>, <code>GL_OES_texture_storage_multisample_2d_array</code><br>Alias for: <code>glTexStorage3DMultisampleOES</code>   */
  private native void dispatch_glTexStorage3DMultisample1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage1D"));
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  private native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1DEXT"));
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DEXT"));
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DEXT"));
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glTexImage2DMultisample(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexImage2DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2DMultisample"));
    }
        dispatch_glTexImage2DMultisample1(target, samples, internalformat, width, height, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glTexImage2DMultisample1(int target, int samples, int internalformat, int width, int height, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  public void glTexImage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexImage3DMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3DMultisample"));
    }
        dispatch_glTexImage3DMultisample1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3DMultisample}(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_ARB_texture_multisample</code>, <code>GL_VERSION_3_2</code><br>   */
  private native void dispatch_glTexImage3DMultisample1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  public void glEGLImageTargetTexture2DOES(int target, long image)  {

    final long __addr_ = _pat._addressof_glEGLImageTargetTexture2DOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetTexture2DOES"));
    }
        dispatch_glEGLImageTargetTexture2DOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  private native void dispatch_glEGLImageTargetTexture2DOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  public void glEGLImageTargetRenderbufferStorageOES(int target, long image)  {

    final long __addr_ = _pat._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetRenderbufferStorageOES"));
    }
        dispatch_glEGLImageTargetRenderbufferStorageOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  private native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableiOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glEnableiOES(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnableiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableiOES"));
    }
        dispatch_glEnableiOES1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableiOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glEnableiOES1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableiOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glDisableiOES(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisableiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableiOES"));
    }
        dispatch_glDisableiOES1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableiOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glDisableiOES1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationiOES}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glBlendEquationiOES(int buf, int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquationiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationiOES"));
    }
        dispatch_glBlendEquationiOES1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationiOES}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendEquationiOES1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiOES}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glBlendEquationSeparateiOES(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparateiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparateiOES"));
    }
        dispatch_glBlendEquationSeparateiOES1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiOES}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendEquationSeparateiOES1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunciOES}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glBlendFunciOES(int buf, int src, int dst)  {

    final long __addr_ = _pat._addressof_glBlendFunciOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunciOES"));
    }
        dispatch_glBlendFunciOES1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunciOES}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendFunciOES1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiOES}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glBlendFuncSeparateiOES(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparateiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateiOES"));
    }
        dispatch_glBlendFuncSeparateiOES1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiOES}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendFuncSeparateiOES1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaskiOES}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public void glColorMaskiOES(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = _pat._addressof_glColorMaskiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaskiOES"));
    }
        dispatch_glColorMaskiOES1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaskiOES}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native void dispatch_glColorMaskiOES1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  public boolean glIsEnablediOES(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnablediOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnablediOES"));
    }
        return dispatch_glIsEnablediOES1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediOES}(GLenum target, GLuint index) </code> <br>Part of <code>GL_OES_draw_buffers_indexed</code><br>   */
  private native boolean dispatch_glIsEnablediOES1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertexOES}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsBaseVertexOES(int mode, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertexOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertexOES"));
    }
        dispatch_glDrawElementsBaseVertexOES1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertexOES}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsBaseVertexOES1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertexOES}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElementsBaseVertexOES(int mode, int start, int end, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertexOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertexOES"));
    }
        dispatch_glDrawRangeElementsBaseVertexOES1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertexOES}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElementsBaseVertexOES1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexOES}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertexOES(int mode, int count, int type, Buffer indices, int instancecount, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexOES"));
    }
        dispatch_glDrawElementsInstancedBaseVertexOES1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexOES}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertexOES1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexOES}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiDrawElementsBaseVertexOES(int mode, IntBuffer count, int type, PointerBuffer indices, int primcount, IntBuffer basevertex)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final boolean basevertex_is_direct = Buffers.isDirect(basevertex);
    final long __addr_ = _pat._addressof_glMultiDrawElementsBaseVertexOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertexOES"));
    }
        dispatch_glMultiDrawElementsBaseVertexOES1(mode, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex_is_direct ? basevertex : Buffers.getArray(basevertex), basevertex_is_direct ? Buffers.getDirectBufferByteOffset(basevertex) : Buffers.getIndirectBufferByteOffset(basevertex), basevertex_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexOES}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiDrawElementsBaseVertexOES1(int mode, Object count, int count_byte_offset, boolean count_is_direct, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, Object basevertex, int basevertex_byte_offset, boolean basevertex_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexOES}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_OES_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glMultiDrawElementsBaseVertexOES(int mode, int[] count, int count_offset, int type, PointerBuffer indices, int primcount, int[] basevertex, int basevertex_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final boolean indices_is_direct = Buffers.isDirect(indices);
    if(basevertex != null && basevertex.length <= basevertex_offset)
      throw new GLException("array offset argument \"basevertex_offset\" (" + basevertex_offset + ") equals or exceeds array length (" + basevertex.length + ")");
    final long __addr_ = _pat._addressof_glMultiDrawElementsBaseVertexOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertexOES"));
    }
        dispatch_glMultiDrawElementsBaseVertexOES1(mode, count, Buffers.SIZEOF_INT * count_offset, false, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex, Buffers.SIZEOF_INT * basevertex_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureOES}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_OES_geometry_shader</code><br>   */
  public void glFramebufferTextureOES(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureOES"));
    }
        dispatch_glFramebufferTextureOES1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureOES}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_OES_geometry_shader</code><br>   */
  private native void dispatch_glFramebufferTextureOES1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private long glMapBufferDelegate(int target, int access)  {

    final long __addr_ = _pat._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBuffer"));
    }
        return dispatch_glMapBufferDelegate1(target, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private native long dispatch_glMapBufferDelegate1(int target, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBoxOES}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_OES_primitive_bounding_box</code><br>   */
  public void glPrimitiveBoundingBoxOES(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)  {

    final long __addr_ = _pat._addressof_glPrimitiveBoundingBoxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveBoundingBoxOES"));
    }
        dispatch_glPrimitiveBoundingBoxOES1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBoxOES}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_OES_primitive_bounding_box</code><br>   */
  private native void dispatch_glPrimitiveBoundingBoxOES1(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW, long procAddress);

  /** Entry point to C language function: <code> void {@native glMinSampleShadingOES}(GLfloat value) </code> <br>Part of <code>GL_OES_sample_shading</code><br>   */
  public void glMinSampleShadingOES(float value)  {

    final long __addr_ = _pat._addressof_glMinSampleShadingOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMinSampleShadingOES"));
    }
        dispatch_glMinSampleShadingOES1(value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMinSampleShadingOES}(GLfloat value) </code> <br>Part of <code>GL_OES_sample_shading</code><br>   */
  private native void dispatch_glMinSampleShadingOES1(float value, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameteriOES}(GLenum pname, GLint value) </code> <br>Part of <code>GL_OES_tessellation_shader</code><br>   */
  public void glPatchParameteriOES(int pname, int value)  {

    final long __addr_ = _pat._addressof_glPatchParameteriOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameteriOES"));
    }
        dispatch_glPatchParameteriOES1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteriOES}(GLenum pname, GLint value) </code> <br>Part of <code>GL_OES_tessellation_shader</code><br>   */
  private native void dispatch_glPatchParameteriOES1(int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glFramebufferTexture3DEXT</code>, <code>glFramebufferTexture3DOES</code>   */
  public void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture3D"));
    }
        dispatch_glFramebufferTexture3D1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_texture_3D</code><br>Alias for: <code>glFramebufferTexture3DEXT</code>, <code>glFramebufferTexture3DOES</code>   */
  private native void dispatch_glFramebufferTexture3D1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferOES}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_OES_texture_buffer</code><br>   */
  public void glTexBufferOES(int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTexBufferOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferOES"));
    }
        dispatch_glTexBufferOES1(target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferOES}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_OES_texture_buffer</code><br>   */
  private native void dispatch_glTexBufferOES1(int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferRangeOES}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_OES_texture_buffer</code><br>   */
  public void glTexBufferRangeOES(int target, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTexBufferRangeOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferRangeOES"));
    }
        dispatch_glTexBufferRangeOES1(target, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferRangeOES}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_OES_texture_buffer</code><br>   */
  private native void dispatch_glTexBufferRangeOES1(int target, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisampleOES}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_OES_texture_storage_multisample_2d_array</code><br>   */
  public void glTexStorage3DMultisampleOES(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glTexStorage3DMultisampleOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3DMultisampleOES"));
    }
        dispatch_glTexStorage3DMultisampleOES1(target, samples, internalformat, width, height, depth, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3DMultisampleOES}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_OES_texture_storage_multisample_2d_array</code><br>   */
  private native void dispatch_glTexStorage3DMultisampleOES1(int target, int samples, int internalformat, int width, int height, int depth, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureView}(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_view</code>, <code>GL_OES_texture_view</code>, <code>GL_EXT_texture_view</code><br>Alias for: <code>glTextureViewOES</code>, <code>glTextureViewEXT</code>   */
  public void glTextureView(int texture, int target, int origtexture, int internalformat, int minlevel, int numlevels, int minlayer, int numlayers)  {

    final long __addr_ = _pat._addressof_glTextureView;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureView"));
    }
        dispatch_glTextureView1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureView}(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_ARB_texture_view</code>, <code>GL_OES_texture_view</code>, <code>GL_EXT_texture_view</code><br>Alias for: <code>glTextureViewOES</code>, <code>glTextureViewEXT</code>   */
  private native void dispatch_glTextureView1(int texture, int target, int origtexture, int internalformat, int minlevel, int numlevels, int minlayer, int numlayers, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glBindVertexArrayOES(int array)  {

    final long __addr_ = _pat._addressof_glBindVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArrayOES"));
    }
        dispatch_glBindVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  private native void dispatch_glBindVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glDeleteVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glGenVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public boolean glIsVertexArrayOES(int array)  {

    final long __addr_ = _pat._addressof_glIsVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArrayOES"));
    }
        return dispatch_glIsVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  private native boolean dispatch_glIsVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code><br>   */
  public void glBlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _pat._addressof_glBlitFramebufferANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebufferANGLE"));
    }
        dispatch_glBlitFramebufferANGLE1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code><br>   */
  private native void dispatch_glBlitFramebufferANGLE1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedANGLE}(GLenum mode, GLint first, GLsizei count, GLsizei primcount) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>   */
  public void glDrawArraysInstancedANGLE(int mode, int first, int count, int primcount)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstancedANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedANGLE"));
    }
        dispatch_glDrawArraysInstancedANGLE1(mode, first, count, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedANGLE}(GLenum mode, GLint first, GLsizei count, GLsizei primcount) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>   */
  private native void dispatch_glDrawArraysInstancedANGLE1(int mode, int first, int count, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedANGLE}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedANGLE(int mode, int count, int type, Buffer indices, int primcount)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedANGLE"));
    }
        dispatch_glDrawElementsInstancedANGLE1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedANGLE}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedANGLE1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorANGLE}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>   */
  public void glVertexAttribDivisorANGLE(int index, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexAttribDivisorANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisorANGLE"));
    }
        dispatch_glVertexAttribDivisorANGLE1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorANGLE}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code><br>   */
  private native void dispatch_glVertexAttribDivisorANGLE1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTranslatedShaderSourceANGLE(int shader, int bufsize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = _pat._addressof_glGetTranslatedShaderSourceANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTranslatedShaderSourceANGLE"));
    }
        dispatch_glGetTranslatedShaderSourceANGLE1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTranslatedShaderSourceANGLE1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source) </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code><br>   */
  public void glGetTranslatedShaderSourceANGLE(int shader, int bufsize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = _pat._addressof_glGetTranslatedShaderSourceANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTranslatedShaderSourceANGLE"));
    }
        dispatch_glGetTranslatedShaderSourceANGLE1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code><br>   */
  public void glCopyTextureLevelsAPPLE(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount)  {

    final long __addr_ = _pat._addressof_glCopyTextureLevelsAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureLevelsAPPLE"));
    }
        dispatch_glCopyTextureLevelsAPPLE1(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code><br>   */
  private native void dispatch_glCopyTextureLevelsAPPLE1(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebuffer}(void) </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code><br>Alias for: <code>glResolveMultisampleFramebufferAPPLE</code>   */
  public void glResolveMultisampleFramebuffer()  {

    final long __addr_ = _pat._addressof_glResolveMultisampleFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResolveMultisampleFramebuffer"));
    }
        dispatch_glResolveMultisampleFramebuffer1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebuffer}(void) </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code><br>Alias for: <code>glResolveMultisampleFramebufferAPPLE</code>   */
  private native void dispatch_glResolveMultisampleFramebuffer1(long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawArraysInstancedBaseInstanceEXT</code>   */
  public void glDrawArraysInstancedBaseInstance(int mode, int first, int count, int instancecount, int baseinstance)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedBaseInstance"));
    }
        dispatch_glDrawArraysInstancedBaseInstance1(mode, first, count, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedBaseInstance}(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawArraysInstancedBaseInstanceEXT</code>   */
  private native void dispatch_glDrawArraysInstancedBaseInstance1(int mode, int first, int count, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseInstance(int mode, int count, int type, Buffer indices, int instancecount, int baseinstance)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>   */
  public void glDrawElementsInstancedBaseInstance(int mode, int count, int type, long indices_buffer_offset, int instancecount, int baseinstance)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseInstance1(mode, count, type, indices_buffer_offset, instancecount, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseInstanceEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseInstance1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, Buffer indices, int instancecount, int basevertex, int baseinstance)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>   */
  public void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, int baseinstance)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexBaseInstance;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexBaseInstance"));
    }
        dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(mode, count, type, indices_buffer_offset, instancecount, basevertex, baseinstance, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexBaseInstance}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) </code> <br>Part of <code>GL_ARB_base_instance</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_base_instance</code><br>Alias for: <code>glDrawElementsInstancedBaseVertexBaseInstanceEXT</code>   */
  private native void dispatch_glDrawElementsInstancedBaseVertexBaseInstance1(int mode, int count, int type, long indices_buffer_offset, int instancecount, int basevertex, int baseinstance, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexedEXT}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glBindFragDataLocationIndexedEXT(int program, int colorNumber, int index, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glBindFragDataLocationIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationIndexedEXT"));
    }
        dispatch_glBindFragDataLocationIndexedEXT1(program, colorNumber, index, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexedEXT}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glBindFragDataLocationIndexedEXT1(int program, int colorNumber, int index, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationIndexedEXT}(GLuint program, GLuint colorNumber, GLuint index, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>   */
  public void glBindFragDataLocationIndexedEXT(int program, int colorNumber, int index, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glBindFragDataLocationIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationIndexedEXT"));
    }
        dispatch_glBindFragDataLocationIndexedEXT1(program, colorNumber, index, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationEXT}(GLuint program, GLuint color, const GLchar *  name) </code> <br>Part of <code>GL_EXT_gpu_shader4</code>, <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glBindFragDataLocationEXT(int program, int color, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glBindFragDataLocationEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationEXT"));
    }
        dispatch_glBindFragDataLocationEXT1(program, color, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationEXT}(GLuint program, GLuint color, const GLchar *  name) </code> <br>Part of <code>GL_EXT_gpu_shader4</code>, <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glBindFragDataLocationEXT1(int program, int color, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFragDataLocationEXT}(GLuint program, GLuint color, const GLchar *  name) </code> <br>Part of <code>GL_EXT_gpu_shader4</code>, <code>GL_EXT_blend_func_extended</code><br>   */
  public void glBindFragDataLocationEXT(int program, int color, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glBindFragDataLocationEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFragDataLocationEXT"));
    }
        dispatch_glBindFragDataLocationEXT1(program, color, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndexEXT}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetProgramResourceLocationIndexEXT(int program, int programInterface, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetProgramResourceLocationIndexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndexEXT"));
    }
        return dispatch_glGetProgramResourceLocationIndexEXT1(program, programInterface, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndexEXT}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetProgramResourceLocationIndexEXT1(int program, int programInterface, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetProgramResourceLocationIndexEXT}(GLuint program, GLenum programInterface, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>   */
  public int glGetProgramResourceLocationIndexEXT(int program, int programInterface, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetProgramResourceLocationIndexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramResourceLocationIndexEXT"));
    }
        return dispatch_glGetProgramResourceLocationIndexEXT1(program, programInterface, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndexEXT}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetFragDataIndexEXT(int program, ByteBuffer name)  {

    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = _pat._addressof_glGetFragDataIndexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataIndexEXT"));
    }
        return dispatch_glGetFragDataIndexEXT1(program, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndexEXT}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetFragDataIndexEXT1(int program, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLint {@native glGetFragDataIndexEXT}(GLuint program, const GLchar *  name) </code> <br>Part of <code>GL_EXT_blend_func_extended</code><br>   */
  public int glGetFragDataIndexEXT(int program, byte[] name, int name_offset)  {

    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = _pat._addressof_glGetFragDataIndexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataIndexEXT"));
    }
        return dispatch_glGetFragDataIndexEXT1(program, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferStorageEXT}(GLenum target, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_EXT_buffer_storage</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferStorageEXT(int target, long size, Buffer data, int flags)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferStorageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferStorageEXT"));
    }
        dispatch_glBufferStorageEXT1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, flags, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferStorageEXT}(GLenum target, GLsizeiptr size, const void *  data, GLbitfield flags) </code> <br>Part of <code>GL_EXT_buffer_storage</code><br>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferStorageEXT1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDiscardFramebufferEXT1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glQueryCounterEXT</code>   */
  public void glQueryCounter(int id, int target)  {

    final long __addr_ = _pat._addressof_glQueryCounter;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryCounter"));
    }
        dispatch_glQueryCounter1(id, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounter}(GLuint id, GLenum target) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glQueryCounterEXT</code>   */
  private native void dispatch_glQueryCounter1(int id, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
    }
        dispatch_glGetQueryObjectiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectiv}(GLuint id, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ARB_occlusion_query</code>, <code>GL_EXT_disjoint_timer_query</code><br>Alias for: <code>glGetQueryObjectivARB</code>, <code>glGetQueryObjectivEXT</code>   */
  public void glGetQueryObjectiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectiv"));
    }
        dispatch_glGetQueryObjectiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64v}(GLuint id, GLenum pname, GLint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjecti64vEXT</code>   */
  public void glGetQueryObjecti64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjecti64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64v"));
    }
        dispatch_glGetQueryObjecti64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64v(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64v1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64v}(GLuint id, GLenum pname, GLuint64 *  params) </code> <br>Part of <code>GL_ARB_timer_query</code>, <code>GL_VERSION_3_3</code>, <code>GL_EXT_disjoint_timer_query</code>, <code>GL_EXT_timer_query</code><br>Alias for: <code>glGetQueryObjectui64vEXT</code>   */
  public void glGetQueryObjectui64v(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetQueryObjectui64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64v"));
    }
        dispatch_glGetQueryObjectui64v1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableiEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glEnableiEXT(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnableiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableiEXT"));
    }
        dispatch_glEnableiEXT1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableiEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glEnableiEXT1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableiEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glDisableiEXT(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisableiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableiEXT"));
    }
        dispatch_glDisableiEXT1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableiEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glDisableiEXT1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationiEXT}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glBlendEquationiEXT(int buf, int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquationiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationiEXT"));
    }
        dispatch_glBlendEquationiEXT1(buf, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationiEXT}(GLuint buf, GLenum mode) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendEquationiEXT1(int buf, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiEXT}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glBlendEquationSeparateiEXT(int buf, int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparateiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparateiEXT"));
    }
        dispatch_glBlendEquationSeparateiEXT1(buf, modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparateiEXT}(GLuint buf, GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendEquationSeparateiEXT1(int buf, int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunciEXT}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glBlendFunciEXT(int buf, int src, int dst)  {

    final long __addr_ = _pat._addressof_glBlendFunciEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunciEXT"));
    }
        dispatch_glBlendFunciEXT1(buf, src, dst, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunciEXT}(GLuint buf, GLenum src, GLenum dst) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendFunciEXT1(int buf, int src, int dst, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiEXT}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glBlendFuncSeparateiEXT(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparateiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparateiEXT"));
    }
        dispatch_glBlendFuncSeparateiEXT1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparateiEXT}(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glBlendFuncSeparateiEXT1(int buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMaskiEXT}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public void glColorMaskiEXT(int index, boolean r, boolean g, boolean b, boolean a)  {

    final long __addr_ = _pat._addressof_glColorMaskiEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMaskiEXT"));
    }
        dispatch_glColorMaskiEXT1(index, r, g, b, a, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMaskiEXT}(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native void dispatch_glColorMaskiEXT1(int index, boolean r, boolean g, boolean b, boolean a, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  public boolean glIsEnablediEXT(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnablediEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnablediEXT"));
    }
        return dispatch_glIsEnablediEXT1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediEXT}(GLenum target, GLuint index) </code> <br>Part of <code>GL_EXT_draw_buffers_indexed</code><br>   */
  private native boolean dispatch_glIsEnablediEXT1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertexEXT}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsBaseVertexEXT(int mode, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsBaseVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsBaseVertexEXT"));
    }
        dispatch_glDrawElementsBaseVertexEXT1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsBaseVertexEXT}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsBaseVertexEXT1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertexEXT}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElementsBaseVertexEXT(int mode, int start, int end, int count, int type, Buffer indices, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawRangeElementsBaseVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElementsBaseVertexEXT"));
    }
        dispatch_glDrawRangeElementsBaseVertexEXT1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElementsBaseVertexEXT}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *  indices, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElementsBaseVertexEXT1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexEXT}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedBaseVertexEXT(int mode, int count, int type, Buffer indices, int instancecount, int basevertex)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedBaseVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedBaseVertexEXT"));
    }
        dispatch_glDrawElementsInstancedBaseVertexEXT1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instancecount, basevertex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedBaseVertexEXT}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei instancecount, GLint basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedBaseVertexEXT1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instancecount, int basevertex, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexEXT}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultiDrawElementsBaseVertexEXT(int mode, IntBuffer count, int type, PointerBuffer indices, int primcount, IntBuffer basevertex)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final boolean basevertex_is_direct = Buffers.isDirect(basevertex);
    final long __addr_ = _pat._addressof_glMultiDrawElementsBaseVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertexEXT"));
    }
        dispatch_glMultiDrawElementsBaseVertexEXT1(mode, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex_is_direct ? basevertex : Buffers.getArray(basevertex), basevertex_is_direct ? Buffers.getDirectBufferByteOffset(basevertex) : Buffers.getIndirectBufferByteOffset(basevertex), basevertex_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexEXT}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param basevertex a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultiDrawElementsBaseVertexEXT1(int mode, Object count, int count_byte_offset, boolean count_is_direct, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, Object basevertex, int basevertex_byte_offset, boolean basevertex_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsBaseVertexEXT}(GLenum mode, const GLsizei *  count, GLenum type, const void * const  *  indices, GLsizei primcount, const GLint *  basevertex) </code> <br>Part of <code>GL_EXT_draw_elements_base_vertex</code><br>
      @param indices a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glMultiDrawElementsBaseVertexEXT(int mode, int[] count, int count_offset, int type, PointerBuffer indices, int primcount, int[] basevertex, int basevertex_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    final boolean indices_is_direct = Buffers.isDirect(indices);
    if(basevertex != null && basevertex.length <= basevertex_offset)
      throw new GLException("array offset argument \"basevertex_offset\" (" + basevertex_offset + ") equals or exceeds array length (" + basevertex.length + ")");
    final long __addr_ = _pat._addressof_glMultiDrawElementsBaseVertexEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsBaseVertexEXT"));
    }
        dispatch_glMultiDrawElementsBaseVertexEXT1(mode, count, Buffers.SIZEOF_INT * count_offset, false, type, indices_is_direct ? ( indices != null ? indices.getBuffer() : null ) : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, basevertex, Buffers.SIZEOF_INT * basevertex_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code><br>   */
  public void glFramebufferTextureEXT(int target, int attachment, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureEXT"));
    }
        dispatch_glFramebufferTextureEXT1(target, attachment, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureEXT}(GLenum target, GLenum attachment, GLuint texture, GLint level) </code> <br>Part of <code>GL_NV_geometry_program4</code>, <code>GL_EXT_geometry_shader</code><br>   */
  private native void dispatch_glFramebufferTextureEXT1(int target, int attachment, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectEXT}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_EXT_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawArraysIndirectEXT(int mode, Buffer indirect, int drawcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawArraysIndirectEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawArraysIndirectEXT"));
    }
        dispatch_glMultiDrawArraysIndirectEXT1(mode, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawArraysIndirectEXT}(GLenum mode, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_EXT_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawArraysIndirectEXT1(int mode, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectEXT}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_EXT_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  public void glMultiDrawElementsIndirectEXT(int mode, int type, Buffer indirect, int drawcount, int stride)  {

    final boolean indirect_is_direct = Buffers.isDirect(indirect);
    final long __addr_ = _pat._addressof_glMultiDrawElementsIndirectEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiDrawElementsIndirectEXT"));
    }
        dispatch_glMultiDrawElementsIndirectEXT1(mode, type, indirect_is_direct ? indirect : Buffers.getArray(indirect), indirect_is_direct ? Buffers.getDirectBufferByteOffset(indirect) : Buffers.getIndirectBufferByteOffset(indirect), indirect_is_direct, drawcount, stride, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiDrawElementsIndirectEXT}(GLenum mode, GLenum type, const void *  indirect, GLsizei drawcount, GLsizei stride) </code> <br>Part of <code>GL_EXT_multi_draw_indirect</code><br>
      @param indirect a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMultiDrawElementsIndirectEXT1(int mode, int type, Object indirect, int indirect_byte_offset, boolean indirect_is_direct, int drawcount, int stride, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleEXT}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code><br>   */
  public void glRenderbufferStorageMultisampleEXT(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleEXT"));
    }
        dispatch_glRenderbufferStorageMultisampleEXT1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleEXT}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleEXT1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code><br>   */
  public void glFramebufferTexture2DMultisampleEXT(int target, int attachment, int textarget, int texture, int level, int samples)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleEXT"));
    }
        dispatch_glFramebufferTexture2DMultisampleEXT1(target, attachment, textarget, texture, level, samples, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glFramebufferTexture2DMultisampleEXT1(int target, int attachment, int textarget, int texture, int level, int samples, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBufferIndexedEXT}(GLenum src, GLint index) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>   */
  public void glReadBufferIndexedEXT(int src, int index)  {

    final long __addr_ = _pat._addressof_glReadBufferIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBufferIndexedEXT"));
    }
        dispatch_glReadBufferIndexedEXT1(src, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferIndexedEXT}(GLenum src, GLint index) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>   */
  private native void dispatch_glReadBufferIndexedEXT1(int src, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>
      @param location a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffersIndexedEXT(int n, IntBuffer location, IntBuffer indices)  {

    final boolean location_is_direct = Buffers.isDirect(location);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawBuffersIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersIndexedEXT"));
    }
        dispatch_glDrawBuffersIndexedEXT1(n, location_is_direct ? location : Buffers.getArray(location), location_is_direct ? Buffers.getDirectBufferByteOffset(location) : Buffers.getIndirectBufferByteOffset(location), location_is_direct, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>
      @param location a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffersIndexedEXT1(int n, Object location, int location_byte_offset, boolean location_is_direct, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>   */
  public void glDrawBuffersIndexedEXT(int n, int[] location, int location_offset, int[] indices, int indices_offset)  {

    if(location != null && location.length <= location_offset)
      throw new GLException("array offset argument \"location_offset\" (" + location_offset + ") equals or exceeds array length (" + location.length + ")");
    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = _pat._addressof_glDrawBuffersIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersIndexedEXT"));
    }
        dispatch_glDrawBuffersIndexedEXT1(n, location, Buffers.SIZEOF_INT * location_offset, false, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_vEXT(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_vEXT"));
    }
        dispatch_glGetIntegeri_vEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_vEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data) </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code><br>   */
  public void glGetIntegeri_vEXT(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_vEXT"));
    }
        dispatch_glGetIntegeri_vEXT1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBoxEXT}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_EXT_primitive_bounding_box</code><br>   */
  public void glPrimitiveBoundingBoxEXT(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)  {

    final long __addr_ = _pat._addressof_glPrimitiveBoundingBoxEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPrimitiveBoundingBoxEXT"));
    }
        dispatch_glPrimitiveBoundingBoxEXT1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPrimitiveBoundingBoxEXT}(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) </code> <br>Part of <code>GL_EXT_primitive_bounding_box</code><br>   */
  private native void dispatch_glPrimitiveBoundingBoxEXT1(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW, long procAddress);

  /** Entry point to C language function: <code> void {@native glRasterSamplesEXT}(GLuint samples, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_EXT_raster_multisample</code><br>   */
  public void glRasterSamplesEXT(int samples, boolean fixedsamplelocations)  {

    final long __addr_ = _pat._addressof_glRasterSamplesEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRasterSamplesEXT"));
    }
        dispatch_glRasterSamplesEXT1(samples, fixedsamplelocations, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRasterSamplesEXT}(GLuint samples, GLboolean fixedsamplelocations) </code> <br>Part of <code>GL_EXT_raster_multisample</code><br>   */
  private native void dispatch_glRasterSamplesEXT1(int samples, boolean fixedsamplelocations, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexPageCommitmentEXT}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_EXT_sparse_texture</code><br>   */
  public void glTexPageCommitmentEXT(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit)  {

    final long __addr_ = _pat._addressof_glTexPageCommitmentEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexPageCommitmentEXT"));
    }
        dispatch_glTexPageCommitmentEXT1(target, level, xoffset, yoffset, zoffset, width, height, depth, commit, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexPageCommitmentEXT}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) </code> <br>Part of <code>GL_EXT_sparse_texture</code><br>   */
  private native void dispatch_glTexPageCommitmentEXT1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, boolean commit, long procAddress);

  /** Entry point to C language function: <code> void {@native glPatchParameteriEXT}(GLenum pname, GLint value) </code> <br>Part of <code>GL_EXT_tessellation_shader</code><br>   */
  public void glPatchParameteriEXT(int pname, int value)  {

    final long __addr_ = _pat._addressof_glPatchParameteriEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPatchParameteriEXT"));
    }
        dispatch_glPatchParameteriEXT1(pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPatchParameteriEXT}(GLenum pname, GLint value) </code> <br>Part of <code>GL_EXT_tessellation_shader</code><br>   */
  private native void dispatch_glPatchParameteriEXT1(int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferEXT}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code><br>   */
  public void glTexBufferEXT(int target, int internalformat, int buffer)  {

    final long __addr_ = _pat._addressof_glTexBufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferEXT"));
    }
        dispatch_glTexBufferEXT1(target, internalformat, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferEXT}(GLenum target, GLenum internalformat, GLuint buffer) </code> <br>Part of <code>GL_EXT_texture_buffer</code>, <code>GL_EXT_texture_buffer_object</code><br>   */
  private native void dispatch_glTexBufferEXT1(int target, int internalformat, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexBufferRangeEXT}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_texture_buffer</code><br>   */
  public void glTexBufferRangeEXT(int target, int internalformat, int buffer, long offset, long size)  {

    final long __addr_ = _pat._addressof_glTexBufferRangeEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexBufferRangeEXT"));
    }
        dispatch_glTexBufferRangeEXT1(target, internalformat, buffer, offset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexBufferRangeEXT}(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) </code> <br>Part of <code>GL_EXT_texture_buffer</code><br>   */
  private native void dispatch_glTexBufferRangeEXT1(int target, int internalformat, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  public void glRenderbufferStorageMultisampleIMG(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleIMG"));
    }
        dispatch_glRenderbufferStorageMultisampleIMG1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleIMG1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  public void glFramebufferTexture2DMultisampleIMG(int target, int attachment, int textarget, int texture, int level, int samples)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2DMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleIMG"));
    }
        dispatch_glFramebufferTexture2DMultisampleIMG1(target, attachment, textarget, texture, level, samples, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glFramebufferTexture2DMultisampleIMG1(int target, int attachment, int textarget, int texture, int level, int samples, long procAddress);

  /** Entry point to C language function: <code> void {@native glApplyFramebufferAttachmentCMAAINTEL}(void) </code> <br>Part of <code>GL_INTEL_framebuffer_CMAA</code><br>   */
  public void glApplyFramebufferAttachmentCMAAINTEL()  {

    final long __addr_ = _pat._addressof_glApplyFramebufferAttachmentCMAAINTEL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glApplyFramebufferAttachmentCMAAINTEL"));
    }
        dispatch_glApplyFramebufferAttachmentCMAAINTEL1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glApplyFramebufferAttachmentCMAAINTEL}(void) </code> <br>Part of <code>GL_INTEL_framebuffer_CMAA</code><br>   */
  private native void dispatch_glApplyFramebufferAttachmentCMAAINTEL1(long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glBeginConditionalRenderNV</code>   */
  public void glBeginConditionalRender(int id, int mode)  {

    final long __addr_ = _pat._addressof_glBeginConditionalRender;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginConditionalRender"));
    }
        dispatch_glBeginConditionalRender1(id, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginConditionalRender}(GLuint id, GLenum mode) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glBeginConditionalRenderNV</code>   */
  private native void dispatch_glBeginConditionalRender1(int id, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glEndConditionalRenderNV</code>   */
  public void glEndConditionalRender()  {

    final long __addr_ = _pat._addressof_glEndConditionalRender;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndConditionalRender"));
    }
        dispatch_glEndConditionalRender1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndConditionalRender}(void) </code> <br>Part of <code>GL_VERSION_3_0</code>, <code>GL_NV_conditional_render</code><br>Alias for: <code>glEndConditionalRenderNV</code>   */
  private native void dispatch_glEndConditionalRender1(long procAddress);

  /** Entry point to C language function: <code> void {@native glSubpixelPrecisionBiasNV}(GLuint xbits, GLuint ybits) </code> <br>Part of <code>GL_NV_conservative_raster</code><br>   */
  public void glSubpixelPrecisionBiasNV(int xbits, int ybits)  {

    final long __addr_ = _pat._addressof_glSubpixelPrecisionBiasNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSubpixelPrecisionBiasNV"));
    }
        dispatch_glSubpixelPrecisionBiasNV1(xbits, ybits, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSubpixelPrecisionBiasNV}(GLuint xbits, GLuint ybits) </code> <br>Part of <code>GL_NV_conservative_raster</code><br>   */
  private native void dispatch_glSubpixelPrecisionBiasNV1(int xbits, int ybits, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyBufferSubDataNV}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_NV_copy_buffer</code><br>   */
  public void glCopyBufferSubDataNV(int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = _pat._addressof_glCopyBufferSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyBufferSubDataNV"));
    }
        dispatch_glCopyBufferSubDataNV1(readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubDataNV}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) </code> <br>Part of <code>GL_NV_copy_buffer</code><br>   */
  private native void dispatch_glCopyBufferSubDataNV1(int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask) </code> <br>Part of <code>GL_NV_coverage_sample</code><br>   */
  public void glCoverageMaskNV(boolean mask)  {

    final long __addr_ = _pat._addressof_glCoverageMaskNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageMaskNV"));
    }
        dispatch_glCoverageMaskNV1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask) </code> <br>Part of <code>GL_NV_coverage_sample</code><br>   */
  private native void dispatch_glCoverageMaskNV1(boolean mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation) </code> <br>Part of <code>GL_NV_coverage_sample</code><br>   */
  public void glCoverageOperationNV(int operation)  {

    final long __addr_ = _pat._addressof_glCoverageOperationNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageOperationNV"));
    }
        dispatch_glCoverageOperationNV1(operation, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation) </code> <br>Part of <code>GL_NV_coverage_sample</code><br>   */
  private native void dispatch_glCoverageOperationNV1(int operation, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedNV}(GLenum mode, GLint first, GLsizei count, GLsizei primcount) </code> <br>Part of <code>GL_NV_draw_instanced</code><br>   */
  public void glDrawArraysInstancedNV(int mode, int first, int count, int primcount)  {

    final long __addr_ = _pat._addressof_glDrawArraysInstancedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedNV"));
    }
        dispatch_glDrawArraysInstancedNV1(mode, first, count, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedNV}(GLenum mode, GLint first, GLsizei count, GLsizei primcount) </code> <br>Part of <code>GL_NV_draw_instanced</code><br>   */
  private native void dispatch_glDrawArraysInstancedNV1(int mode, int first, int count, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedNV}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount) </code> <br>Part of <code>GL_NV_draw_instanced</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedNV(int mode, int count, int type, Buffer indices, int primcount)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElementsInstancedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedNV"));
    }
        dispatch_glDrawElementsInstancedNV1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedNV}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount) </code> <br>Part of <code>GL_NV_draw_instanced</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedNV1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glFragmentCoverageColorNV}(GLuint color) </code> <br>Part of <code>GL_NV_fragment_coverage_to_color</code><br>   */
  public void glFragmentCoverageColorNV(int color)  {

    final long __addr_ = _pat._addressof_glFragmentCoverageColorNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFragmentCoverageColorNV"));
    }
        dispatch_glFragmentCoverageColorNV1(color, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFragmentCoverageColorNV}(GLuint color) </code> <br>Part of <code>GL_NV_fragment_coverage_to_color</code><br>   */
  private native void dispatch_glFragmentCoverageColorNV1(int color, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebufferNV}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_NV_framebuffer_blit</code><br>   */
  public void glBlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _pat._addressof_glBlitFramebufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebufferNV"));
    }
        dispatch_glBlitFramebufferNV1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebufferNV}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>GL_NV_framebuffer_blit</code><br>   */
  private native void dispatch_glBlitFramebufferNV1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glCoverageModulationTableNV(int n, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
    }
        dispatch_glCoverageModulationTableNV1(n, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glCoverageModulationTableNV1(int n, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageModulationTableNV}(GLsizei n, const GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glCoverageModulationTableNV(int n, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationTableNV"));
    }
        dispatch_glCoverageModulationTableNV1(n, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetCoverageModulationTableNV(int bufsize, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glGetCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
    }
        dispatch_glGetCoverageModulationTableNV1(bufsize, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetCoverageModulationTableNV1(int bufsize, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetCoverageModulationTableNV}(GLsizei bufsize, GLfloat *  v) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glGetCoverageModulationTableNV(int bufsize, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glGetCoverageModulationTableNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetCoverageModulationTableNV"));
    }
        dispatch_glGetCoverageModulationTableNV1(bufsize, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationNV}(GLenum components) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  public void glCoverageModulationNV(int components)  {

    final long __addr_ = _pat._addressof_glCoverageModulationNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageModulationNV"));
    }
        dispatch_glCoverageModulationNV1(components, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageModulationNV}(GLenum components) </code> <br>Part of <code>GL_NV_framebuffer_mixed_samples</code><br>   */
  private native void dispatch_glCoverageModulationNV1(int components, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleNV}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_framebuffer_multisample</code><br>   */
  public void glRenderbufferStorageMultisampleNV(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleNV"));
    }
        dispatch_glRenderbufferStorageMultisampleNV1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleNV}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_framebuffer_multisample</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleNV1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorNV}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_NV_instanced_arrays</code><br>   */
  public void glVertexAttribDivisorNV(int index, int divisor)  {

    final long __addr_ = _pat._addressof_glVertexAttribDivisorNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisorNV"));
    }
        dispatch_glVertexAttribDivisorNV1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorNV}(GLuint index, GLuint divisor) </code> <br>Part of <code>GL_NV_instanced_arrays</code><br>   */
  private native void dispatch_glVertexAttribDivisorNV1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x3fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fvNV"));
    }
        dispatch_glUniformMatrix2x3fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x3fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix2x3fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x3fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fvNV"));
    }
        dispatch_glUniformMatrix2x3fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x2fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fvNV"));
    }
        dispatch_glUniformMatrix3x2fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x2fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix3x2fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x2fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fvNV"));
    }
        dispatch_glUniformMatrix3x2fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x4fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fvNV"));
    }
        dispatch_glUniformMatrix2x4fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x4fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix2x4fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix2x4fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fvNV"));
    }
        dispatch_glUniformMatrix2x4fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x2fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fvNV"));
    }
        dispatch_glUniformMatrix4x2fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x2fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix4x2fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x2fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fvNV"));
    }
        dispatch_glUniformMatrix4x2fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x4fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fvNV"));
    }
        dispatch_glUniformMatrix3x4fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x4fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix3x4fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix3x4fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fvNV"));
    }
        dispatch_glUniformMatrix3x4fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x3fvNV(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fvNV"));
    }
        dispatch_glUniformMatrix4x3fvNV1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x3fvNV1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fvNV}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value) </code> <br>Part of <code>GL_NV_non_square_matrices</code><br>   */
  public void glUniformMatrix4x3fvNV(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = _pat._addressof_glUniformMatrix4x3fvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fvNV"));
    }
        dispatch_glUniformMatrix4x3fvNV1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonModeNV}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_NV_polygon_mode</code><br>   */
  public void glPolygonModeNV(int face, int mode)  {

    final long __addr_ = _pat._addressof_glPolygonModeNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonModeNV"));
    }
        dispatch_glPolygonModeNV1(face, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonModeNV}(GLenum face, GLenum mode) </code> <br>Part of <code>GL_NV_polygon_mode</code><br>   */
  private native void dispatch_glPolygonModeNV1(int face, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode) </code> <br>Part of <code>GL_NV_read_buffer</code><br>   */
  public void glReadBufferNV(int mode)  {

    final long __addr_ = _pat._addressof_glReadBufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBufferNV"));
    }
        dispatch_glReadBufferNV1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode) </code> <br>Part of <code>GL_NV_read_buffer</code><br>   */
  private native void dispatch_glReadBufferNV1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFramebufferSampleLocationsfvNV(int target, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
    }
        dispatch_glFramebufferSampleLocationsfvNV1(target, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFramebufferSampleLocationsfvNV1(int target, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferSampleLocationsfvNV}(GLenum target, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glFramebufferSampleLocationsfvNV(int target, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferSampleLocationsfvNV"));
    }
        dispatch_glFramebufferSampleLocationsfvNV1(target, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glNamedFramebufferSampleLocationsfvNV(int framebuffer, int start, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvNV1(framebuffer, start, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glNamedFramebufferSampleLocationsfvNV1(int framebuffer, int start, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glNamedFramebufferSampleLocationsfvNV}(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glNamedFramebufferSampleLocationsfvNV(int framebuffer, int start, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glNamedFramebufferSampleLocationsfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNamedFramebufferSampleLocationsfvNV"));
    }
        dispatch_glNamedFramebufferSampleLocationsfvNV1(framebuffer, start, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveDepthValuesNV}(void) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  public void glResolveDepthValuesNV()  {

    final long __addr_ = _pat._addressof_glResolveDepthValuesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResolveDepthValuesNV"));
    }
        dispatch_glResolveDepthValuesNV1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveDepthValuesNV}(void) </code> <br>Part of <code>GL_NV_sample_locations</code><br>   */
  private native void dispatch_glResolveDepthValuesNV1(long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportArrayvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportArrayvNV(int first, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glViewportArrayvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayvNV"));
    }
        dispatch_glViewportArrayvNV1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportArrayvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportArrayvNV1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportArrayvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glViewportArrayvNV(int first, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glViewportArrayvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportArrayvNV"));
    }
        dispatch_glViewportArrayvNV1(first, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedfNV}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glViewportIndexedfNV(int index, float x, float y, float w, float h)  {

    final long __addr_ = _pat._addressof_glViewportIndexedfNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfNV"));
    }
        dispatch_glViewportIndexedfNV1(index, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedfNV}(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native void dispatch_glViewportIndexedfNV1(int index, float x, float y, float w, float h, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfvNV}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glViewportIndexedfvNV(int index, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glViewportIndexedfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfvNV"));
    }
        dispatch_glViewportIndexedfvNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewportIndexedfvNV}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glViewportIndexedfvNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewportIndexedfvNV}(GLuint index, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glViewportIndexedfvNV(int index, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glViewportIndexedfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewportIndexedfvNV"));
    }
        dispatch_glViewportIndexedfvNV1(index, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorArrayvNV}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorArrayvNV(int first, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glScissorArrayvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayvNV"));
    }
        dispatch_glScissorArrayvNV1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorArrayvNV}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorArrayvNV1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorArrayvNV}(GLuint first, GLsizei count, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glScissorArrayvNV(int first, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glScissorArrayvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorArrayvNV"));
    }
        dispatch_glScissorArrayvNV1(first, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexedNV}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glScissorIndexedNV(int index, int left, int bottom, int width, int height)  {

    final long __addr_ = _pat._addressof_glScissorIndexedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedNV"));
    }
        dispatch_glScissorIndexedNV1(index, left, bottom, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexedNV}(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native void dispatch_glScissorIndexedNV1(int index, int left, int bottom, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedvNV}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glScissorIndexedvNV(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glScissorIndexedvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedvNV"));
    }
        dispatch_glScissorIndexedvNV1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissorIndexedvNV}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glScissorIndexedvNV1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissorIndexedvNV}(GLuint index, const GLint *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glScissorIndexedvNV(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glScissorIndexedvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissorIndexedvNV"));
    }
        dispatch_glScissorIndexedvNV1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayfvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glDepthRangeArrayfvNV(int first, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = _pat._addressof_glDepthRangeArrayfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayfvNV"));
    }
        dispatch_glDepthRangeArrayfvNV1(first, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayfvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glDepthRangeArrayfvNV1(int first, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangeArrayfvNV}(GLuint first, GLsizei count, const GLfloat *  v) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glDepthRangeArrayfvNV(int first, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = _pat._addressof_glDepthRangeArrayfvNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeArrayfvNV"));
    }
        dispatch_glDepthRangeArrayfvNV1(first, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexedfNV}(GLuint index, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glDepthRangeIndexedfNV(int index, float n, float f)  {

    final long __addr_ = _pat._addressof_glDepthRangeIndexedfNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangeIndexedfNV"));
    }
        dispatch_glDepthRangeIndexedfNV1(index, n, f, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangeIndexedfNV}(GLuint index, GLfloat n, GLfloat f) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native void dispatch_glDepthRangeIndexedfNV1(int index, float n, float f, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_vNV}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloati_vNV(int target, int index, FloatBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glGetFloati_vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vNV"));
    }
        dispatch_glGetFloati_vNV1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloati_vNV}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_NV_viewport_array</code><br>
      @param data a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloati_vNV1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloati_vNV}(GLenum target, GLuint index, GLfloat *  data) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glGetFloati_vNV(int target, int index, float[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = _pat._addressof_glGetFloati_vNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloati_vNV"));
    }
        dispatch_glGetFloati_vNV1(target, index, data, Buffers.SIZEOF_FLOAT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableiNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glEnableiNV(int target, int index)  {

    final long __addr_ = _pat._addressof_glEnableiNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableiNV"));
    }
        dispatch_glEnableiNV1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableiNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native void dispatch_glEnableiNV1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableiNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public void glDisableiNV(int target, int index)  {

    final long __addr_ = _pat._addressof_glDisableiNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableiNV"));
    }
        dispatch_glDisableiNV1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableiNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native void dispatch_glDisableiNV1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  public boolean glIsEnablediNV(int target, int index)  {

    final long __addr_ = _pat._addressof_glIsEnablediNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnablediNV"));
    }
        return dispatch_glIsEnablediNV1(target, index, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnablediNV}(GLenum target, GLuint index) </code> <br>Part of <code>GL_NV_viewport_array</code><br>   */
  private native boolean dispatch_glIsEnablediNV1(int target, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureMultiviewOVR}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) </code> <br>Part of <code>GL_OVR_multiview</code><br>   */
  public void glFramebufferTextureMultiviewOVR(int target, int attachment, int texture, int level, int baseViewIndex, int numViews)  {

    final long __addr_ = _pat._addressof_glFramebufferTextureMultiviewOVR;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureMultiviewOVR"));
    }
        dispatch_glFramebufferTextureMultiviewOVR1(target, attachment, texture, level, baseViewIndex, numViews, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureMultiviewOVR}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) </code> <br>Part of <code>GL_OVR_multiview</code><br>   */
  private native void dispatch_glFramebufferTextureMultiviewOVR1(int target, int attachment, int texture, int level, int baseViewIndex, int numViews, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_QCOM_alpha_test</code><br>   */
  public void glAlphaFuncQCOM(int func, float ref)  {

    final long __addr_ = _pat._addressof_glAlphaFuncQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAlphaFuncQCOM"));
    }
        dispatch_glAlphaFuncQCOM1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_QCOM_alpha_test</code><br>   */
  private native void dispatch_glAlphaFuncQCOM1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetDriverControlsQCOM(IntBuffer num, int size, IntBuffer driverControls)  {

    final boolean num_is_direct = Buffers.isDirect(num);
    final boolean driverControls_is_direct = Buffers.isDirect(driverControls);
    final long __addr_ = _pat._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num_is_direct ? num : Buffers.getArray(num), num_is_direct ? Buffers.getDirectBufferByteOffset(num) : Buffers.getIndirectBufferByteOffset(num), num_is_direct, size, driverControls_is_direct ? driverControls : Buffers.getArray(driverControls), driverControls_is_direct ? Buffers.getDirectBufferByteOffset(driverControls) : Buffers.getIndirectBufferByteOffset(driverControls), driverControls_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetDriverControlsQCOM1(Object num, int num_byte_offset, boolean num_is_direct, int size, Object driverControls, int driverControls_byte_offset, boolean driverControls_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glGetDriverControlsQCOM(int[] num, int num_offset, int size, int[] driverControls, int driverControls_offset)  {

    if(num != null && num.length <= num_offset)
      throw new GLException("array offset argument \"num_offset\" (" + num_offset + ") equals or exceeds array length (" + num.length + ")");
    if(driverControls != null && driverControls.length <= driverControls_offset)
      throw new GLException("array offset argument \"driverControls_offset\" (" + driverControls_offset + ") equals or exceeds array length (" + driverControls.length + ")");
    final long __addr_ = _pat._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num, Buffers.SIZEOF_INT * num_offset, false, size, driverControls, Buffers.SIZEOF_INT * driverControls_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, IntBuffer length, ByteBuffer driverControlString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean driverControlString_is_direct = Buffers.isDirect(driverControlString);
    final long __addr_ = _pat._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, driverControlString_is_direct ? driverControlString : Buffers.getArray(driverControlString), driverControlString_is_direct ? Buffers.getDirectBufferByteOffset(driverControlString) : Buffers.getIndirectBufferByteOffset(driverControlString), driverControlString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetDriverControlStringQCOM1(int driverControl, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object driverControlString, int driverControlString_byte_offset, boolean driverControlString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, int[] length, int length_offset, byte[] driverControlString, int driverControlString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(driverControlString != null && driverControlString.length <= driverControlString_offset)
      throw new GLException("array offset argument \"driverControlString_offset\" (" + driverControlString_offset + ") equals or exceeds array length (" + driverControlString.length + ")");
    final long __addr_ = _pat._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, driverControlString, driverControlString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glEnableDriverControlQCOM(int driverControl)  {

    final long __addr_ = _pat._addressof_glEnableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableDriverControlQCOM"));
    }
        dispatch_glEnableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  private native void dispatch_glEnableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glDisableDriverControlQCOM(int driverControl)  {

    final long __addr_ = _pat._addressof_glDisableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableDriverControlQCOM"));
    }
        dispatch_glDisableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  private native void dispatch_glDisableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexturesQCOM(IntBuffer textures, int maxTextures, IntBuffer numTextures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean numTextures_is_direct = Buffers.isDirect(numTextures);
    final long __addr_ = _pat._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, maxTextures, numTextures_is_direct ? numTextures : Buffers.getArray(numTextures), numTextures_is_direct ? Buffers.getDirectBufferByteOffset(numTextures) : Buffers.getIndirectBufferByteOffset(numTextures), numTextures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexturesQCOM1(Object textures, int textures_byte_offset, boolean textures_is_direct, int maxTextures, Object numTextures, int numTextures_byte_offset, boolean numTextures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetTexturesQCOM(int[] textures, int textures_offset, int maxTextures, int[] numTextures, int numTextures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(numTextures != null && numTextures.length <= numTextures_offset)
      throw new GLException("array offset argument \"numTextures_offset\" (" + numTextures_offset + ") equals or exceeds array length (" + numTextures.length + ")");
    final long __addr_ = _pat._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures, Buffers.SIZEOF_INT * textures_offset, false, maxTextures, numTextures, Buffers.SIZEOF_INT * numTextures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetBuffersQCOM(IntBuffer buffers, int maxBuffers, IntBuffer numBuffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean numBuffers_is_direct = Buffers.isDirect(numBuffers);
    final long __addr_ = _pat._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, maxBuffers, numBuffers_is_direct ? numBuffers : Buffers.getArray(numBuffers), numBuffers_is_direct ? Buffers.getDirectBufferByteOffset(numBuffers) : Buffers.getIndirectBufferByteOffset(numBuffers), numBuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetBuffersQCOM1(Object buffers, int buffers_byte_offset, boolean buffers_is_direct, int maxBuffers, Object numBuffers, int numBuffers_byte_offset, boolean numBuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetBuffersQCOM(int[] buffers, int buffers_offset, int maxBuffers, int[] numBuffers, int numBuffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    if(numBuffers != null && numBuffers.length <= numBuffers_offset)
      throw new GLException("array offset argument \"numBuffers_offset\" (" + numBuffers_offset + ") equals or exceeds array length (" + numBuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers, Buffers.SIZEOF_INT * buffers_offset, false, maxBuffers, numBuffers, Buffers.SIZEOF_INT * numBuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetRenderbuffersQCOM(IntBuffer renderbuffers, int maxRenderbuffers, IntBuffer numRenderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final boolean numRenderbuffers_is_direct = Buffers.isDirect(numRenderbuffers);
    final long __addr_ = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, maxRenderbuffers, numRenderbuffers_is_direct ? numRenderbuffers : Buffers.getArray(numRenderbuffers), numRenderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(numRenderbuffers) : Buffers.getIndirectBufferByteOffset(numRenderbuffers), numRenderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetRenderbuffersQCOM1(Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, int maxRenderbuffers, Object numRenderbuffers, int numRenderbuffers_byte_offset, boolean numRenderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetRenderbuffersQCOM(int[] renderbuffers, int renderbuffers_offset, int maxRenderbuffers, int[] numRenderbuffers, int numRenderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    if(numRenderbuffers != null && numRenderbuffers.length <= numRenderbuffers_offset)
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + numRenderbuffers_offset + ") equals or exceeds array length (" + numRenderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, maxRenderbuffers, numRenderbuffers, Buffers.SIZEOF_INT * numRenderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetFramebuffersQCOM(IntBuffer framebuffers, int maxFramebuffers, IntBuffer numFramebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final boolean numFramebuffers_is_direct = Buffers.isDirect(numFramebuffers);
    final long __addr_ = _pat._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, maxFramebuffers, numFramebuffers_is_direct ? numFramebuffers : Buffers.getArray(numFramebuffers), numFramebuffers_is_direct ? Buffers.getDirectBufferByteOffset(numFramebuffers) : Buffers.getIndirectBufferByteOffset(numFramebuffers), numFramebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetFramebuffersQCOM1(Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, int maxFramebuffers, Object numFramebuffers, int numFramebuffers_byte_offset, boolean numFramebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetFramebuffersQCOM(int[] framebuffers, int framebuffers_offset, int maxFramebuffers, int[] numFramebuffers, int numFramebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    if(numFramebuffers != null && numFramebuffers.length <= numFramebuffers_offset)
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + numFramebuffers_offset + ") equals or exceeds array length (" + numFramebuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, maxFramebuffers, numFramebuffers, Buffers.SIZEOF_INT * numFramebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int texture, int face, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glExtTexObjectStateOverrideiQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtTexObjectStateOverrideiQCOM"));
    }
        dispatch_glExtTexObjectStateOverrideiQCOM1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  private native void dispatch_glExtTexObjectStateOverrideiQCOM1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *  texels) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  public void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer texels)  {

    final boolean texels_is_direct = Buffers.isDirect(texels);
    final long __addr_ = _pat._addressof_glExtGetTexSubImageQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexSubImageQCOM"));
    }
        dispatch_glExtGetTexSubImageQCOM1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels_is_direct ? texels : Buffers.getArray(texels), texels_is_direct ? Buffers.getDirectBufferByteOffset(texels) : Buffers.getIndirectBufferByteOffset(texels), texels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *  texels) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glExtGetTexSubImageQCOM1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object texels, int texels_byte_offset, boolean texels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, void *  *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glExtGetBufferPointervQCOM(int target, PointerBuffer params)  {

    if (!Buffers.isDirect(params))
      throw new GLException("Argument \"params\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glExtGetBufferPointervQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBufferPointervQCOM"));
    }
        dispatch_glExtGetBufferPointervQCOM0(target, params != null ? params.getBuffer() : null, Buffers.getDirectBufferByteOffset(params), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, void *  *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glExtGetBufferPointervQCOM0(int target, Object params, int params_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetShadersQCOM(IntBuffer shaders, int maxShaders, IntBuffer numShaders)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean numShaders_is_direct = Buffers.isDirect(numShaders);
    final long __addr_ = _pat._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, maxShaders, numShaders_is_direct ? numShaders : Buffers.getArray(numShaders), numShaders_is_direct ? Buffers.getDirectBufferByteOffset(numShaders) : Buffers.getIndirectBufferByteOffset(numShaders), numShaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetShadersQCOM1(Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int maxShaders, Object numShaders, int numShaders_byte_offset, boolean numShaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetShadersQCOM(int[] shaders, int shaders_offset, int maxShaders, int[] numShaders, int numShaders_offset)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    if(numShaders != null && numShaders.length <= numShaders_offset)
      throw new GLException("array offset argument \"numShaders_offset\" (" + numShaders_offset + ") equals or exceeds array length (" + numShaders.length + ")");
    final long __addr_ = _pat._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders, Buffers.SIZEOF_INT * shaders_offset, false, maxShaders, numShaders, Buffers.SIZEOF_INT * numShaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramsQCOM(IntBuffer programs, int maxPrograms, IntBuffer numPrograms)  {

    final boolean programs_is_direct = Buffers.isDirect(programs);
    final boolean numPrograms_is_direct = Buffers.isDirect(numPrograms);
    final long __addr_ = _pat._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, maxPrograms, numPrograms_is_direct ? numPrograms : Buffers.getArray(numPrograms), numPrograms_is_direct ? Buffers.getDirectBufferByteOffset(numPrograms) : Buffers.getIndirectBufferByteOffset(numPrograms), numPrograms_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramsQCOM1(Object programs, int programs_byte_offset, boolean programs_is_direct, int maxPrograms, Object numPrograms, int numPrograms_byte_offset, boolean numPrograms_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetProgramsQCOM(int[] programs, int programs_offset, int maxPrograms, int[] numPrograms, int numPrograms_offset)  {

    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    if(numPrograms != null && numPrograms.length <= numPrograms_offset)
      throw new GLException("array offset argument \"numPrograms_offset\" (" + numPrograms_offset + ") equals or exceeds array length (" + numPrograms.length + ")");
    final long __addr_ = _pat._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs, Buffers.SIZEOF_INT * programs_offset, false, maxPrograms, numPrograms, Buffers.SIZEOF_INT * numPrograms_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public boolean glExtIsProgramBinaryQCOM(int program)  {

    final long __addr_ = _pat._addressof_glExtIsProgramBinaryQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtIsProgramBinaryQCOM"));
    }
        return dispatch_glExtIsProgramBinaryQCOM1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  private native boolean dispatch_glExtIsProgramBinaryQCOM1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, ByteBuffer source, IntBuffer length)  {

    final boolean source_is_direct = Buffers.isDirect(source);
    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int program, int shadertype, Object source, int source_byte_offset, boolean source_is_direct, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, byte[] source, int source_offset, int[] length, int length_offset)  {

    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source, source_offset, false, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  public void glStartTilingQCOM(int x, int y, int width, int height, int preserveMask)  {

    final long __addr_ = _pat._addressof_glStartTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStartTilingQCOM"));
    }
        dispatch_glStartTilingQCOM1(x, y, width, height, preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  private native void dispatch_glStartTilingQCOM1(int x, int y, int width, int height, int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  public void glEndTilingQCOM(int preserveMask)  {

    final long __addr_ = _pat._addressof_glEndTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTilingQCOM"));
    }
        dispatch_glEndTilingQCOM1(preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  private native void dispatch_glEndTilingQCOM1(int preserveMask, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
 private static final int data_offset = 0; // just a helper for JavaPrologue ..
      private final GLProfile glProfile;
      private final GLContextImpl _context;
  
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
  
      @Override
      public final int getBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final GLBufferStorage getBufferStorage(int bufferName) {
          return bufferObjectTracker.getBufferStorage(bufferName);
      }
  
      @Override
      public final boolean isVBOArrayBound() {
          return checkArrayVBOBound(false);
      }
  
      @Override
      public final boolean isVBOElementArrayBound() {
          return checkElementVBOBound(false);
      }
  
      @Override
      public final GL getDownstreamGL() throws GLException {
          return null;
      }
  
      @Override
      public final GL getRootGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final boolean hasBasicFBOSupport() {
        return _context.hasBasicFBOSupport();
      }
  
      @Override
      public final boolean hasFullFBOSupport() {
        return _context.hasFullFBOSupport();
      }
  
      @Override
      public final int getMaxRenderbufferSamples() {
        return _context.getMaxRenderbufferSamples();
      }
  
      @Override
      public final boolean isTextureFormatBGRA8888Available() {
        return _context.isTextureFormatBGRA8888Available();
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
      @Override
      public final int getDefaultReadBuffer() {
        return _context.getDefaultReadBuffer();
      }
  
      private final GLStateTracker       glStateTracker;
  
      //
      // GLBufferObjectTracker Redirects
      //
      private final GLBufferObjectTracker bufferObjectTracker;
      private final GLBufferStateTracker bufferStateTracker;
  
      @Override
      public final void glBufferData(int target, long size, Buffer data, int usage)  {
          bufferObjectTracker.createBufferStorage(bufferStateTracker, this, 
                                                  target, size, data, usage, 0 /* immutableFlags */, 
                                                  glBufferDataDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
              public final void create(final int target, final long size, final Buffer data, final int mutableUsage) {
                  glBufferDataDelegate(target, size, data, mutableUsage);
              }
          };
  
      @Override
      public boolean glUnmapBuffer(int target)  {
          return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, target, glUnmapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch() {
              public final boolean unmap(final int target) {
                  return glUnmapBufferDelegate(target);
              }
          };
  
      @Override
      public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
        return mapBuffer(target, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBuffer(final int target, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, access, glMapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final int access) {
                  return glMapBufferDelegate(target, access);
              }
          };
  
      @Override
      public final ByteBuffer glMapBufferRange(int target, long offset, long length, int access)  {
        return mapBufferRange(target, offset, length, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBufferRange(final int target, final long offset, final long length, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, offset, length, access, glMapBufferRangeDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final long offset, final long length, final int access) {
                  return glMapBufferRangeDelegate(target, offset, length, access);
              }
          };
  
      private native ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  private final GLES3ProcAddressTable _pat;
  
  public GLES3Impl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    this._pat = (GLES3ProcAddressTable)_context.getGLProcAddressTable();
    this.bufferObjectTracker = context.getBufferObjectTracker();
    this.bufferStateTracker = context.getBufferStateTracker();
    this.glStateTracker     = context.getGLStateTracker();
    this.glProfile = glp;
    this._isES3 = glp.getImplName() == GLProfile.GLES3;
  }
  
  public final void finalizeInit() {
  }
  
  
  private int[] imageSizeTemp = new int[1];
  
  private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
      return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
  }
  
  @Override
  public final boolean isGL4bc() {
      return false;
  }
  
  @Override
  public final boolean isGL4() {
      return false;
  }
  
  @Override
  public final boolean isGL3bc() {
      return false;
  }
  
  @Override
  public final boolean isGL3() {
      return false;
  }
  
  public final boolean isGL2() {
      return false;
  }
  
  @Override
  public final boolean isGLES1() {
      return false;
  }
  
  @Override
  public final boolean isGLES2() {
      return true;
  }
  
  @Override
  public final boolean isGLES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGLES() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES1() {
      return false;
  }
  
  @Override
  public final boolean isGL2ES2() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL3ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL4ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL4core() {
      return false;
  }
  
  @Override
  public final boolean isGL3core() {
      return false;
  }
  
  @Override
  public final boolean isGLcore() {
      return true;
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return true;
  }
  
  @Override
  public final boolean isGLES3Compatible() {
      return _isES3;
  }
  
  @Override
  public final boolean isGLES31Compatible() {
      return _context.isGLES31Compatible();
  }
  
  @Override
  public final boolean isGLES32Compatible() {
      return _context.isGLES32Compatible();
  }
  
  @Override
  public final boolean isGL2GL3() {
      return false;
  }
  
  @Override
  public final boolean hasGLSL() {
      return true;
  }
  
  @Override
  public boolean isNPOTTextureAvailable() {
    return true;
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      throw new GLException("Not a GL4bc implementation");
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      throw new GLException("Not a GL4 implementation");
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      throw new GLException("Not a GL3bc implementation");
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      throw new GLException("Not a GL3 implementation");
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      throw new GLException("Not a GL2 implementation");
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      throw new GLException("Not a GLES1 implementation");
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      return this;
  }
  
  @Override
  public final GLES3 getGLES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GLES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      throw new GLException("Not a GL2ES1 implementation");
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES3 getGL2ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL2ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL3ES3 getGL3ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL3ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL4ES3 getGL4ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL4ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      throw new GLException("Not a GL2GL3 implementation");
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final boolean _isES3;
  
  private final boolean checkBufferObject(boolean extensionAvail,
                                          boolean allowVAO,
                                          boolean bound,
                                          int state,
                                          String kind, boolean throwException) {
    if ( !extensionAvail ) {
      if ( !bound ) {
        return true;
      }
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if ( bound ) {
      if ( 0 != buffer ) {
          return true;
      }
      if ( allowVAO ) {
          buffer = bufferStateTracker.getBoundBufferObject(GL2ES3.GL_VERTEX_ARRAY_BINDING, this);
          if( 0 != buffer && _context.getDefaultVAO() != buffer ) {
              return true;
          }
      }
      if ( throwException ) {
          throw new GLException(kind + " must be bound to call this method");
      }
      return false;
    } else {
      if ( 0 == buffer ) {
          return true;
      }
      if ( throwException ) {
          throw new GLException(kind + " must be unbound to call this method");
      }
      return false;
    }
  }  
  
  private final void validateCPUSourcedAvail() {
      if(!_context.isCPUDataSourcingAvail()) {
          throw new GLException("CPU data sourcing n/a w/ "+_context);
      }
  }
  
  private final boolean checkArrayVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             false, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOBound(boolean throwException) { 
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             true, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             false, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOBound(boolean throwException) { 
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             true, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkIndirectVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             false, // bound
                             GL4ES3.GL_DRAW_INDIRECT_BUFFER,
                             "indirect vertex_buffer_object", throwException);
  }
  
  private final boolean checkIndirectVBOBound(boolean throwException) { 
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             true, // bound
                             GL4ES3.GL_DRAW_INDIRECT_BUFFER,
                             "indirect vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOUnbound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOBound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOUnbound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOBound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  @Override
  public final boolean isPBOPackBound() {
      return checkPackPBOBound(false);
  }
  
  @Override
  public final boolean isPBOUnpackBound() {
      return checkUnpackPBOBound(false);
  }
  
  @Override
  public final void glClearDepth(double depth) {
      glClearDepthf((float)depth); 
  }
  
  @Override
  public final void glDepthRange(double zNear, double zFar) {
      glDepthRangef((float)zNear, (float)zFar); 
  }
  
    @Override
    public final void glVertexAttribPointer(GLArrayData array) {
      if(array.getComponentCount()==0) return;
      if(array.isVBO()) {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getVBOOffset());
      } else {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getBuffer());
      }
    }
  
    @Override
    public final void glUniform(GLUniformData data) {
      boolean done=false;
      if(data.isBuffer()) {
          Buffer buffer = data.getBuffer();
          if(data.isMatrix()) {
              if(buffer instanceof FloatBuffer) {
                  switch(data.columns()) {
                      case 2: glUniformMatrix2fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 3: glUniformMatrix3fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 4: glUniformMatrix4fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
              }
          } else {
              if(buffer instanceof IntBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 2: glUniform2iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 3: glUniform3iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 4: glUniform4iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                  }
              } else if(buffer instanceof FloatBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 2: glUniform2fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 3: glUniform3fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 4: glUniform4fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
              }
          }
      } else {
          Object obj = data.getObject();
          if(obj instanceof Integer) {
              glUniform1i(data.getLocation(), ((Integer)obj).intValue());
              done=true;
          } else if (obj instanceof Float) {
              glUniform1f(data.getLocation(), ((Float)obj).floatValue());
              done=true;
          }
          if(!done) {
              throw new GLException("glUniform atom only available for 1i and 1f");
          }
      }
    }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLES3Impl
