/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:19:32 CEST 2015 ----! */

package jogamp.opengl.egl;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.opengl.egl.EGLExt;
import com.jogamp.opengl.egl.EGLClientPixmapHI;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class EGLExtImpl implements EGLExt{
  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public boolean eglChooseConfig(long dpy, IntBuffer attrib_list, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglChooseConfig"));
    }
        return dispatch_eglChooseConfig0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglChooseConfig0(long dpy, Object attrib_list, int attrib_list_byte_offset, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglCopyBuffers(long dpy, long surface, long target)  {

    final long __addr_ = _table._addressof_eglCopyBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCopyBuffers"));
    }
        return dispatch_eglCopyBuffers0(dpy, surface, target, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglCopyBuffers0(long dpy, long surface, long target, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateContext(long dpy, long config, long share_context, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateContext"));
    }
        return dispatch_eglCreateContext0(dpy, config, share_context, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateContext0(long dpy, long config, long share_context, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePbufferSurface(long dpy, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePbufferSurface"));
    }
        return dispatch_eglCreatePbufferSurface0(dpy, config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePbufferSurface0(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code>, <code>EGL_HI_clientpixmap</code><br>Alias for: <code>eglCreatePixmapSurfaceHI</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePixmapSurface(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePixmapSurface"));
    }
        return dispatch_eglCreatePixmapSurface0(dpy, config, pixmap, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code>, <code>EGL_HI_clientpixmap</code><br>Alias for: <code>eglCreatePixmapSurfaceHI</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePixmapSurface0(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateWindowSurface(long dpy, long config, long win, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateWindowSurface"));
    }
        return dispatch_eglCreateWindowSurface0(dpy, config, win, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateWindowSurface0(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglDestroyContext(long dpy, long ctx)  {

    final long __addr_ = _table._addressof_eglDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyContext"));
    }
        return dispatch_eglDestroyContext0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglDestroyContext0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglDestroySurface(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglDestroySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySurface"));
    }
        return dispatch_eglDestroySurface0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglDestroySurface0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetConfigAttrib"));
    }
        return dispatch_eglGetConfigAttrib0(dpy, config, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetConfigAttrib0(long dpy, long config, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetConfigs"));
    }
        return dispatch_eglGetConfigs0(dpy, configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetConfigs0(long dpy, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public long eglGetCurrentDisplay()  {

    final long __addr_ = _table._addressof_eglGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentDisplay"));
    }
        return dispatch_eglGetCurrentDisplay0(__addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native long dispatch_eglGetCurrentDisplay0(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public long eglGetCurrentSurface(int readdraw)  {

    final long __addr_ = _table._addressof_eglGetCurrentSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentSurface"));
    }
        return dispatch_eglGetCurrentSurface0(readdraw, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native long dispatch_eglGetCurrentSurface0(int readdraw, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public long eglGetDisplay(long display_id)  {

    final long __addr_ = _table._addressof_eglGetDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetDisplay"));
    }
        return dispatch_eglGetDisplay0(display_id, __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native long dispatch_eglGetDisplay0(long display_id, long procAddress);

  /** Entry point to C language function: <code> EGLint eglGetError(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public int eglGetError()  {

    final long __addr_ = _table._addressof_eglGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetError"));
    }
        return dispatch_eglGetError0(__addr_);
  }

  /** Entry point to C language function: <code> EGLint eglGetError(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native int dispatch_eglGetError0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  public boolean eglInitialize(long dpy, IntBuffer major, IntBuffer minor)  {

    if (!Buffers.isDirect(major))
      throw new RuntimeException("Argument \"major\" is not a direct buffer");
    if (!Buffers.isDirect(minor))
      throw new RuntimeException("Argument \"minor\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglInitialize"));
    }
        return dispatch_eglInitialize0(dpy, major, Buffers.getDirectBufferByteOffset(major), minor, Buffers.getDirectBufferByteOffset(minor), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglInitialize0(long dpy, Object major, int major_byte_offset, Object minor, int minor_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglMakeCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _table._addressof_eglMakeCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglMakeCurrent"));
    }
        return dispatch_eglMakeCurrent0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglMakeCurrent0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryContext"));
    }
        return dispatch_eglQueryContext0(dpy, ctx, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQueryContext0(long dpy, long ctx, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public String eglQueryString(long dpy, int name)  {

    final long __addr_ = _table._addressof_eglQueryString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryString"));
    }
        return dispatch_eglQueryString0(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native String dispatch_eglQueryString0(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglQuerySurface(long dpy, long surface, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQuerySurface"));
    }
        return dispatch_eglQuerySurface0(dpy, surface, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQuerySurface0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglSwapBuffers(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglSwapBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffers"));
    }
        return dispatch_eglSwapBuffers0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglSwapBuffers0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglTerminate(long dpy)  {

    final long __addr_ = _table._addressof_eglTerminate;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglTerminate"));
    }
        return dispatch_eglTerminate0(dpy, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglTerminate0(long dpy, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglWaitGL()  {

    final long __addr_ = _table._addressof_eglWaitGL;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitGL"));
    }
        return dispatch_eglWaitGL0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglWaitGL0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  public boolean eglWaitNative(int engine)  {

    final long __addr_ = _table._addressof_eglWaitNative;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitNative"));
    }
        return dispatch_eglWaitNative0(engine, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine) </code> <br>Part of <code>EGL_VERSION_1_0</code><br>   */
  private native boolean dispatch_eglWaitNative0(int engine, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public boolean eglBindTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglBindTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglBindTexImage"));
    }
        return dispatch_eglBindTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  private native boolean dispatch_eglBindTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public boolean eglReleaseTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglReleaseTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglReleaseTexImage"));
    }
        return dispatch_eglReleaseTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  private native boolean dispatch_eglReleaseTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public boolean eglSurfaceAttrib(long dpy, long surface, int attribute, int value)  {

    final long __addr_ = _table._addressof_eglSurfaceAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSurfaceAttrib"));
    }
        return dispatch_eglSurfaceAttrib0(dpy, surface, attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  private native boolean dispatch_eglSurfaceAttrib0(long dpy, long surface, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  public boolean eglSwapInterval(long dpy, int interval)  {

    final long __addr_ = _table._addressof_eglSwapInterval;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapInterval"));
    }
        return dispatch_eglSwapInterval0(dpy, interval, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval) </code> <br>Part of <code>EGL_VERSION_1_1</code><br>   */
  private native boolean dispatch_eglSwapInterval0(long dpy, int interval, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public boolean eglBindAPI(int api)  {

    final long __addr_ = _table._addressof_eglBindAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglBindAPI"));
    }
        return dispatch_eglBindAPI0(api, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  private native boolean dispatch_eglBindAPI0(int api, long procAddress);

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public int eglQueryAPI()  {

    final long __addr_ = _table._addressof_eglQueryAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryAPI"));
    }
        return dispatch_eglQueryAPI0(__addr_);
  }

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  private native int dispatch_eglQueryAPI0(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePbufferFromClientBuffer(long dpy, int buftype, Buffer buffer, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferFromClientBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePbufferFromClientBuffer"));
    }
        return dispatch_eglCreatePbufferFromClientBuffer0(dpy, buftype, buffer, Buffers.getDirectBufferByteOffset(buffer), config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePbufferFromClientBuffer0(long dpy, int buftype, Object buffer, int buffer_byte_offset, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public boolean eglReleaseThread()  {

    final long __addr_ = _table._addressof_eglReleaseThread;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglReleaseThread"));
    }
        return dispatch_eglReleaseThread0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  private native boolean dispatch_eglReleaseThread0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  public boolean eglWaitClient()  {

    final long __addr_ = _table._addressof_eglWaitClient;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitClient"));
    }
        return dispatch_eglWaitClient0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void) </code> <br>Part of <code>EGL_VERSION_1_2</code><br>   */
  private native boolean dispatch_eglWaitClient0(long procAddress);

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void) </code> <br>Part of <code>EGL_VERSION_1_4</code><br>   */
  public long eglGetCurrentContext()  {

    final long __addr_ = _table._addressof_eglGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetCurrentContext"));
    }
        return dispatch_eglGetCurrentContext0(__addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void) </code> <br>Part of <code>EGL_VERSION_1_4</code><br>   */
  private native long dispatch_eglGetCurrentContext0(long procAddress);

  /** Entry point to C language function: <code> EGLSync eglCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglCreateSyncKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public ByteBuffer eglCreateSync(long dpy, int type, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateSync"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateSync0(dpy, type, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLSync eglCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglCreateSyncKHR</code>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native ByteBuffer dispatch_eglCreateSync0(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySync(EGLDisplay dpy, EGLSync sync) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglDestroySyncKHR</code>, <code>eglDestroySyncNV</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroySync(long dpy, Buffer sync)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglDestroySync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySync"));
    }
        return dispatch_eglDestroySync0(dpy, sync, Buffers.getDirectBufferByteOffset(sync), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySync(EGLDisplay dpy, EGLSync sync) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglDestroySyncKHR</code>, <code>eglDestroySyncNV</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroySync0(long dpy, Object sync, int sync_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglClientWaitSyncKHR</code>, <code>eglClientWaitSyncNV</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public int eglClientWaitSync(long dpy, Buffer sync, int flags, long timeout)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglClientWaitSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSync"));
    }
        return dispatch_eglClientWaitSync0(dpy, sync, Buffers.getDirectBufferByteOffset(sync), flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_fence_sync</code>, <code>EGL_NV_sync</code><br>Alias for: <code>eglClientWaitSyncKHR</code>, <code>eglClientWaitSyncNV</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglClientWaitSync0(long dpy, Object sync, int sync_byte_offset, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglGetSyncAttribNV</code>, <code>eglGetSyncAttribKHR</code>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglGetSyncAttrib(long dpy, Buffer sync, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetSyncAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttrib"));
    }
        return dispatch_eglGetSyncAttrib0(dpy, sync, Buffers.getDirectBufferByteOffset(sync), attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_NV_sync</code>, <code>EGL_KHR_fence_sync</code><br>Alias for: <code>eglGetSyncAttribNV</code>, <code>eglGetSyncAttribKHR</code>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglGetSyncAttrib0(long dpy, Object sync, int sync_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLImage eglCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglCreateImageKHR</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public ByteBuffer eglCreateImage(long dpy, long ctx, int target, Buffer buffer, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateImage"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateImage0(dpy, ctx, target, buffer, Buffers.getDirectBufferByteOffset(buffer), attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLImage eglCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglCreateImageKHR</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native ByteBuffer dispatch_eglCreateImage0(long dpy, long ctx, int target, Object buffer, int buffer_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImage(EGLDisplay dpy, EGLImage image) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglDestroyImageKHR</code>
      @param image a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroyImage(long dpy, Buffer image)  {

    if (!Buffers.isDirect(image))
      throw new RuntimeException("Argument \"image\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglDestroyImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyImage"));
    }
        return dispatch_eglDestroyImage0(dpy, image, Buffers.getDirectBufferByteOffset(image), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImage(EGLDisplay dpy, EGLImage image) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_image</code><br>Alias for: <code>eglDestroyImageKHR</code>
      @param image a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroyImage0(long dpy, Object image, int image_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplay(EGLenum platform, void *  native_display, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglGetPlatformDisplayEXT</code>
      @param native_display a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public long eglGetPlatformDisplay(int platform, Buffer native_display, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(native_display))
      throw new RuntimeException("Argument \"native_display\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetPlatformDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetPlatformDisplay"));
    }
        return dispatch_eglGetPlatformDisplay0(platform, native_display, Buffers.getDirectBufferByteOffset(native_display), attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplay(EGLenum platform, void *  native_display, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglGetPlatformDisplayEXT</code>
      @param native_display a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native long dispatch_eglGetPlatformDisplay0(int platform, Object native_display, int native_display_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformWindowSurfaceEXT</code>
      @param native_window a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public long eglCreatePlatformWindowSurface(long dpy, long config, Buffer native_window, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(native_window))
      throw new RuntimeException("Argument \"native_window\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformWindowSurface"));
    }
        return dispatch_eglCreatePlatformWindowSurface0(dpy, config, native_window, Buffers.getDirectBufferByteOffset(native_window), attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformWindowSurfaceEXT</code>
      @param native_window a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native long dispatch_eglCreatePlatformWindowSurface0(long dpy, long config, Object native_window, int native_window_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformPixmapSurfaceEXT</code>
      @param native_pixmap a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public long eglCreatePlatformPixmapSurface(long dpy, long config, Buffer native_pixmap, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(native_pixmap))
      throw new RuntimeException("Argument \"native_pixmap\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformPixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformPixmapSurface"));
    }
        return dispatch_eglCreatePlatformPixmapSurface0(dpy, config, native_pixmap, Buffers.getDirectBufferByteOffset(native_pixmap), attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLAttrib *  attrib_list) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_EXT_platform_base</code><br>Alias for: <code>eglCreatePlatformPixmapSurfaceEXT</code>
      @param native_pixmap a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native long dispatch_eglCreatePlatformPixmapSurface0(long dpy, long config, Object native_pixmap, int native_pixmap_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_wait_sync</code><br>Alias for: <code>eglWaitSyncKHR</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglWaitSync(long dpy, Buffer sync, int flags)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglWaitSync;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitSync"));
    }
        return dispatch_eglWaitSync0(dpy, sync, Buffers.getDirectBufferByteOffset(sync), flags, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags) </code> <br>Part of <code>EGL_VERSION_1_5</code>, <code>EGL_KHR_wait_sync</code><br>Alias for: <code>eglWaitSyncKHR</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglWaitSync0(long dpy, Object sync, int sync_byte_offset, int flags, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSync64KHR(EGLDisplay dpy, EGLenum type, const EGLAttribKHR *  attrib_list) </code> <br>Part of <code>EGL_KHR_cl_event2</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public long eglCreateSync64KHR(long dpy, int type, PointerBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateSync64KHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateSync64KHR"));
    }
        return dispatch_eglCreateSync64KHR0(dpy, type, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSync64KHR(EGLDisplay dpy, EGLenum type, const EGLAttribKHR *  attrib_list) </code> <br>Part of <code>EGL_KHR_cl_event2</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native long dispatch_eglCreateSync64KHR0(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryDebugKHR(EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_KHR_debug</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryDebugKHR(int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryDebugKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryDebugKHR"));
    }
        return dispatch_eglQueryDebugKHR0(attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryDebugKHR(EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_KHR_debug</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryDebugKHR0(int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLint eglLabelObjectKHR(EGLDisplay display, EGLenum objectType, EGLObjectKHR object, EGLLabelKHR label) </code> <br>Part of <code>EGL_KHR_debug</code><br>
      @param object a direct only {@link java.nio.Buffer}
      @param label a direct only {@link java.nio.Buffer}   */
  public int eglLabelObjectKHR(long display, int objectType, Buffer object, Buffer label)  {

    if (!Buffers.isDirect(object))
      throw new RuntimeException("Argument \"object\" is not a direct buffer");
    if (!Buffers.isDirect(label))
      throw new RuntimeException("Argument \"label\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglLabelObjectKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglLabelObjectKHR"));
    }
        return dispatch_eglLabelObjectKHR0(display, objectType, object, Buffers.getDirectBufferByteOffset(object), label, Buffers.getDirectBufferByteOffset(label), __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglLabelObjectKHR(EGLDisplay display, EGLenum objectType, EGLObjectKHR object, EGLLabelKHR label) </code> <br>Part of <code>EGL_KHR_debug</code><br>
      @param object a direct only {@link java.nio.Buffer}
      @param label a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglLabelObjectKHR0(long display, int objectType, Object object, int object_byte_offset, Object label, int label_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateSyncKHR(long dpy, int type, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateSyncKHR"));
    }
        return dispatch_eglCreateSyncKHR0(dpy, type, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateSyncKHR0(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>   */
  public boolean eglDestroySyncKHR(long dpy, long sync)  {

    final long __addr_ = _table._addressof_eglDestroySyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySyncKHR"));
    }
        return dispatch_eglDestroySyncKHR0(dpy, sync, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>   */
  private native boolean dispatch_eglDestroySyncKHR0(long dpy, long sync, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>   */
  public int eglClientWaitSyncKHR(long dpy, long sync, int flags, long timeout)  {

    final long __addr_ = _table._addressof_eglClientWaitSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSyncKHR"));
    }
        return dispatch_eglClientWaitSyncKHR0(dpy, sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>   */
  private native int dispatch_eglClientWaitSyncKHR0(long dpy, long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribKHR(long dpy, long sync, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetSyncAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttribKHR"));
    }
        return dispatch_eglGetSyncAttribKHR0(dpy, sync, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_KHR_fence_sync</code><br>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribKHR0(long dpy, long sync, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_image</code><br>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateImageKHR(long dpy, long ctx, int target, Buffer buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateImageKHR"));
    }
        return dispatch_eglCreateImageKHR0(dpy, ctx, target, buffer, Buffers.getDirectBufferByteOffset(buffer), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_image</code><br>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateImageKHR0(long dpy, long ctx, int target, Object buffer, int buffer_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) </code> <br>Part of <code>EGL_KHR_image</code><br>   */
  public boolean eglDestroyImageKHR(long dpy, long image)  {

    final long __addr_ = _table._addressof_eglDestroyImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyImageKHR"));
    }
        return dispatch_eglDestroyImageKHR0(dpy, image, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) </code> <br>Part of <code>EGL_KHR_image</code><br>   */
  private native boolean dispatch_eglDestroyImageKHR0(long dpy, long image, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_lock_surface</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public boolean eglLockSurfaceKHR(long dpy, long surface, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglLockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglLockSurfaceKHR"));
    }
        return dispatch_eglLockSurfaceKHR0(dpy, surface, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_lock_surface</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglLockSurfaceKHR0(long dpy, long surface, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_KHR_lock_surface</code><br>   */
  public boolean eglUnlockSurfaceKHR(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglUnlockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglUnlockSurfaceKHR"));
    }
        return dispatch_eglUnlockSurfaceKHR0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface) </code> <br>Part of <code>EGL_KHR_lock_surface</code><br>   */
  private native boolean dispatch_eglUnlockSurfaceKHR0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface64KHR(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLAttribKHR *  value) </code> <br>Part of <code>EGL_KHR_lock_surface3</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQuerySurface64KHR(long dpy, long surface, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQuerySurface64KHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQuerySurface64KHR"));
    }
        return dispatch_eglQuerySurface64KHR0(dpy, surface, attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface64KHR(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLAttribKHR *  value) </code> <br>Part of <code>EGL_KHR_lock_surface3</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQuerySurface64KHR0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_KHR_partial_update</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSetDamageRegionKHR(long dpy, long surface, IntBuffer rects, int n_rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSetDamageRegionKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSetDamageRegionKHR"));
    }
        return dispatch_eglSetDamageRegionKHR0(dpy, surface, rects, Buffers.getDirectBufferByteOffset(rects), n_rects, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_KHR_partial_update</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSetDamageRegionKHR0(long dpy, long surface, Object rects, int rects_byte_offset, int n_rects, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) </code> <br>Part of <code>EGL_KHR_reusable_sync</code><br>   */
  public boolean eglSignalSyncKHR(long dpy, long sync, int mode)  {

    final long __addr_ = _table._addressof_eglSignalSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSignalSyncKHR"));
    }
        return dispatch_eglSignalSyncKHR0(dpy, sync, mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) </code> <br>Part of <code>EGL_KHR_reusable_sync</code><br>   */
  private native boolean dispatch_eglSignalSyncKHR0(long dpy, long sync, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public ByteBuffer eglCreateStreamKHR(long dpy, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamKHR"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateStreamKHR0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_eglCreateStreamKHR0(long dpy, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroyStreamKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglDestroyStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyStreamKHR"));
    }
        return dispatch_eglDestroyStreamKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroyStreamKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamAttribKHR(long dpy, Buffer stream, int attribute, int value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglStreamAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamAttribKHR"));
    }
        return dispatch_eglStreamAttribKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamAttribKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint *  value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglQueryStreamKHR(long dpy, Buffer stream, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamKHR"));
    }
        return dispatch_eglQueryStreamKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint *  value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQueryStreamKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR *  value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  public boolean eglQueryStreamu64KHR(long dpy, Buffer stream, int attribute, LongBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryStreamu64KHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamu64KHR"));
    }
        return dispatch_eglQueryStreamu64KHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR *  value) </code> <br>Part of <code>EGL_KHR_stream</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_eglQueryStreamu64KHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerGLTextureExternalKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglStreamConsumerGLTextureExternalKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerGLTextureExternalKHR"));
    }
        return dispatch_eglStreamConsumerGLTextureExternalKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerGLTextureExternalKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerAcquireKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglStreamConsumerAcquireKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerAcquireKHR"));
    }
        return dispatch_eglStreamConsumerAcquireKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerAcquireKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerReleaseKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglStreamConsumerReleaseKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerReleaseKHR"));
    }
        return dispatch_eglStreamConsumerReleaseKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerReleaseKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  public int eglGetStreamFileDescriptorKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetStreamFileDescriptorKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetStreamFileDescriptorKHR"));
    }
        return dispatch_eglGetStreamFileDescriptorKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLStreamKHR stream) </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code><br>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglGetStreamFileDescriptorKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor) </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code><br>   */
  public ByteBuffer eglCreateStreamFromFileDescriptorKHR(long dpy, int file_descriptor)  {

    final long __addr_ = _table._addressof_eglCreateStreamFromFileDescriptorKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamFromFileDescriptorKHR"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateStreamFromFileDescriptorKHR0(dpy, file_descriptor, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor) </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code><br>   */
  private native ByteBuffer dispatch_eglCreateStreamFromFileDescriptorKHR0(long dpy, int file_descriptor, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR *  value) </code> <br>Part of <code>EGL_KHR_stream_fifo</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  public boolean eglQueryStreamTimeKHR(long dpy, Buffer stream, int attribute, LongBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryStreamTimeKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamTimeKHR"));
    }
        return dispatch_eglQueryStreamTimeKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR *  value) </code> <br>Part of <code>EGL_KHR_stream_fifo</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_eglQueryStreamTimeKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_stream_producer_eglsurface</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateStreamProducerSurfaceKHR(long dpy, long config, Buffer stream, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateStreamProducerSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamProducerSurfaceKHR"));
    }
        return dispatch_eglCreateStreamProducerSurfaceKHR0(dpy, config, stream, Buffers.getDirectBufferByteOffset(stream), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_KHR_stream_producer_eglsurface</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateStreamProducerSurfaceKHR0(long dpy, long config, Object stream, int stream_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_KHR_swap_buffers_with_damage</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSwapBuffersWithDamageKHR(long dpy, long surface, IntBuffer rects, int n_rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSwapBuffersWithDamageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffersWithDamageKHR"));
    }
        return dispatch_eglSwapBuffersWithDamageKHR0(dpy, surface, rects, Buffers.getDirectBufferByteOffset(rects), n_rects, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_KHR_swap_buffers_with_damage</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSwapBuffersWithDamageKHR0(long dpy, long surface, Object rects, int rects_byte_offset, int n_rects, long procAddress);

  /** Entry point to C language function: <code> EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) </code> <br>Part of <code>EGL_KHR_wait_sync</code><br>   */
  public int eglWaitSyncKHR(long dpy, long sync, int flags)  {

    final long __addr_ = _table._addressof_eglWaitSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitSyncKHR"));
    }
        return dispatch_eglWaitSyncKHR0(dpy, sync, flags, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) </code> <br>Part of <code>EGL_KHR_wait_sync</code><br>   */
  private native int dispatch_eglWaitSyncKHR0(long dpy, long sync, int flags, long procAddress);

  /** Entry point to C language function: <code> EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync) </code> <br>Part of <code>EGL_ANDROID_native_fence_sync</code><br>   */
  public int eglDupNativeFenceFDANDROID(long dpy, long sync)  {

    final long __addr_ = _table._addressof_eglDupNativeFenceFDANDROID;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDupNativeFenceFDANDROID"));
    }
        return dispatch_eglDupNativeFenceFDANDROID0(dpy, sync, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync) </code> <br>Part of <code>EGL_ANDROID_native_fence_sync</code><br>   */
  private native int dispatch_eglDupNativeFenceFDANDROID0(long dpy, long sync, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void *  *  value) </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQuerySurfacePointerANGLE(long dpy, long surface, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQuerySurfacePointerANGLE;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQuerySurfacePointerANGLE"));
    }
        return dispatch_eglQuerySurfacePointerANGLE0(dpy, surface, attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void *  *  value) </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQuerySurfacePointerANGLE0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryDeviceAttribEXT(EGLDeviceEXT device, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param device a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryDeviceAttribEXT(Buffer device, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(device))
      throw new RuntimeException("Argument \"device\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryDeviceAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryDeviceAttribEXT"));
    }
        return dispatch_eglQueryDeviceAttribEXT0(device, Buffers.getDirectBufferByteOffset(device), attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryDeviceAttribEXT(EGLDeviceEXT device, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param device a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryDeviceAttribEXT0(Object device, int device_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryDeviceStringEXT(EGLDeviceEXT device, EGLint name) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param device a direct only {@link java.nio.Buffer}   */
  public ByteBuffer eglQueryDeviceStringEXT(Buffer device, int name)  {

    if (!Buffers.isDirect(device))
      throw new RuntimeException("Argument \"device\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryDeviceStringEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryDeviceStringEXT"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglQueryDeviceStringEXT0(device, Buffers.getDirectBufferByteOffset(device), name, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> const char *  eglQueryDeviceStringEXT(EGLDeviceEXT device, EGLint name) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param device a direct only {@link java.nio.Buffer}   */
  private native ByteBuffer dispatch_eglQueryDeviceStringEXT0(Object device, int device_byte_offset, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryDevicesEXT(EGLint max_devices, EGLDeviceEXT *  devices, EGLint *  num_devices) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param devices a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_devices a direct only {@link java.nio.IntBuffer}   */
  public boolean eglQueryDevicesEXT(int max_devices, PointerBuffer devices, IntBuffer num_devices)  {

    if (!Buffers.isDirect(devices))
      throw new RuntimeException("Argument \"devices\" is not a direct buffer");
    if (!Buffers.isDirect(num_devices))
      throw new RuntimeException("Argument \"num_devices\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryDevicesEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryDevicesEXT"));
    }
        return dispatch_eglQueryDevicesEXT0(max_devices, devices != null ? devices.getBuffer() : null, Buffers.getDirectBufferByteOffset(devices), num_devices, Buffers.getDirectBufferByteOffset(num_devices), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryDevicesEXT(EGLint max_devices, EGLDeviceEXT *  devices, EGLint *  num_devices) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param devices a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_devices a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQueryDevicesEXT0(int max_devices, Object devices, int devices_byte_offset, Object num_devices, int num_devices_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryDisplayAttribEXT(EGLDisplay dpy, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryDisplayAttribEXT(long dpy, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryDisplayAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryDisplayAttribEXT"));
    }
        return dispatch_eglQueryDisplayAttribEXT0(dpy, attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryDisplayAttribEXT(EGLDisplay dpy, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_device_base</code><br>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryDisplayAttribEXT0(long dpy, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetOutputLayersEXT(EGLDisplay dpy, const EGLAttrib *  attrib_list, EGLOutputLayerEXT *  layers, EGLint max_layers, EGLint *  num_layers) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param layers a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_layers a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetOutputLayersEXT(long dpy, PointerBuffer attrib_list, PointerBuffer layers, int max_layers, IntBuffer num_layers)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    if (!Buffers.isDirect(layers))
      throw new RuntimeException("Argument \"layers\" is not a direct buffer");
    if (!Buffers.isDirect(num_layers))
      throw new RuntimeException("Argument \"num_layers\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetOutputLayersEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetOutputLayersEXT"));
    }
        return dispatch_eglGetOutputLayersEXT0(dpy, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), layers != null ? layers.getBuffer() : null, Buffers.getDirectBufferByteOffset(layers), max_layers, num_layers, Buffers.getDirectBufferByteOffset(num_layers), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetOutputLayersEXT(EGLDisplay dpy, const EGLAttrib *  attrib_list, EGLOutputLayerEXT *  layers, EGLint max_layers, EGLint *  num_layers) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param layers a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_layers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetOutputLayersEXT0(long dpy, Object attrib_list, int attrib_list_byte_offset, Object layers, int layers_byte_offset, int max_layers, Object num_layers, int num_layers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetOutputPortsEXT(EGLDisplay dpy, const EGLAttrib *  attrib_list, EGLOutputPortEXT *  ports, EGLint max_ports, EGLint *  num_ports) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param ports a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_ports a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetOutputPortsEXT(long dpy, PointerBuffer attrib_list, PointerBuffer ports, int max_ports, IntBuffer num_ports)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    if (!Buffers.isDirect(ports))
      throw new RuntimeException("Argument \"ports\" is not a direct buffer");
    if (!Buffers.isDirect(num_ports))
      throw new RuntimeException("Argument \"num_ports\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetOutputPortsEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetOutputPortsEXT"));
    }
        return dispatch_eglGetOutputPortsEXT0(dpy, attrib_list != null ? attrib_list.getBuffer() : null, Buffers.getDirectBufferByteOffset(attrib_list), ports != null ? ports.getBuffer() : null, Buffers.getDirectBufferByteOffset(ports), max_ports, num_ports, Buffers.getDirectBufferByteOffset(num_ports), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetOutputPortsEXT(EGLDisplay dpy, const EGLAttrib *  attrib_list, EGLOutputPortEXT *  ports, EGLint max_ports, EGLint *  num_ports) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param attrib_list a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param ports a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_ports a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetOutputPortsEXT0(long dpy, Object attrib_list, int attrib_list_byte_offset, Object ports, int ports_byte_offset, int max_ports, Object num_ports, int num_ports_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}   */
  public boolean eglOutputLayerAttribEXT(long dpy, Buffer layer, int attribute, long value)  {

    if (!Buffers.isDirect(layer))
      throw new RuntimeException("Argument \"layer\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglOutputLayerAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglOutputLayerAttribEXT"));
    }
        return dispatch_eglOutputLayerAttribEXT0(dpy, layer, Buffers.getDirectBufferByteOffset(layer), attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglOutputLayerAttribEXT0(long dpy, Object layer, int layer_byte_offset, int attribute, long value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryOutputLayerAttribEXT(long dpy, Buffer layer, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(layer))
      throw new RuntimeException("Argument \"layer\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryOutputLayerAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryOutputLayerAttribEXT"));
    }
        return dispatch_eglQueryOutputLayerAttribEXT0(dpy, layer, Buffers.getDirectBufferByteOffset(layer), attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryOutputLayerAttribEXT0(long dpy, Object layer, int layer_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryOutputLayerStringEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint name) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}   */
  public ByteBuffer eglQueryOutputLayerStringEXT(long dpy, Buffer layer, int name)  {

    if (!Buffers.isDirect(layer))
      throw new RuntimeException("Argument \"layer\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryOutputLayerStringEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryOutputLayerStringEXT"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglQueryOutputLayerStringEXT0(dpy, layer, Buffers.getDirectBufferByteOffset(layer), name, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> const char *  eglQueryOutputLayerStringEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint name) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param layer a direct only {@link java.nio.Buffer}   */
  private native ByteBuffer dispatch_eglQueryOutputLayerStringEXT0(long dpy, Object layer, int layer_byte_offset, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}   */
  public boolean eglOutputPortAttribEXT(long dpy, Buffer port, int attribute, long value)  {

    if (!Buffers.isDirect(port))
      throw new RuntimeException("Argument \"port\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglOutputPortAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglOutputPortAttribEXT"));
    }
        return dispatch_eglOutputPortAttribEXT0(dpy, port, Buffers.getDirectBufferByteOffset(port), attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglOutputPortAttribEXT0(long dpy, Object port, int port_byte_offset, int attribute, long value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryOutputPortAttribEXT(long dpy, Buffer port, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(port))
      throw new RuntimeException("Argument \"port\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryOutputPortAttribEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryOutputPortAttribEXT"));
    }
        return dispatch_eglQueryOutputPortAttribEXT0(dpy, port, Buffers.getDirectBufferByteOffset(port), attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib *  value) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryOutputPortAttribEXT0(long dpy, Object port, int port_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryOutputPortStringEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint name) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}   */
  public ByteBuffer eglQueryOutputPortStringEXT(long dpy, Buffer port, int name)  {

    if (!Buffers.isDirect(port))
      throw new RuntimeException("Argument \"port\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryOutputPortStringEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryOutputPortStringEXT"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglQueryOutputPortStringEXT0(dpy, port, Buffers.getDirectBufferByteOffset(port), name, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> const char *  eglQueryOutputPortStringEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint name) </code> <br>Part of <code>EGL_EXT_output_base</code><br>
      @param port a direct only {@link java.nio.Buffer}   */
  private native ByteBuffer dispatch_eglQueryOutputPortStringEXT0(long dpy, Object port, int port_byte_offset, int name, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplayEXT(EGLenum platform, void *  native_display, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_display a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglGetPlatformDisplayEXT(int platform, Buffer native_display, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(native_display))
      throw new RuntimeException("Argument \"native_display\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetPlatformDisplayEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetPlatformDisplayEXT"));
    }
        return dispatch_eglGetPlatformDisplayEXT0(platform, native_display, Buffers.getDirectBufferByteOffset(native_display), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetPlatformDisplayEXT(EGLenum platform, void *  native_display, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_display a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglGetPlatformDisplayEXT0(int platform, Object native_display, int native_display_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurfaceEXT(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_window a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePlatformWindowSurfaceEXT(long dpy, long config, Buffer native_window, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(native_window))
      throw new RuntimeException("Argument \"native_window\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformWindowSurfaceEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformWindowSurfaceEXT"));
    }
        return dispatch_eglCreatePlatformWindowSurfaceEXT0(dpy, config, native_window, Buffers.getDirectBufferByteOffset(native_window), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformWindowSurfaceEXT(EGLDisplay dpy, EGLConfig config, void *  native_window, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_window a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePlatformWindowSurfaceEXT0(long dpy, long config, Object native_window, int native_window_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurfaceEXT(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_pixmap a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreatePlatformPixmapSurfaceEXT(long dpy, long config, Buffer native_pixmap, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(native_pixmap))
      throw new RuntimeException("Argument \"native_pixmap\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePlatformPixmapSurfaceEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePlatformPixmapSurfaceEXT"));
    }
        return dispatch_eglCreatePlatformPixmapSurfaceEXT0(dpy, config, native_pixmap, Buffers.getDirectBufferByteOffset(native_pixmap), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePlatformPixmapSurfaceEXT(EGLDisplay dpy, EGLConfig config, void *  native_pixmap, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_EXT_platform_base</code><br>
      @param native_pixmap a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreatePlatformPixmapSurfaceEXT0(long dpy, long config, Object native_pixmap, int native_pixmap_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerOutputEXT(EGLDisplay dpy, EGLStreamKHR stream, EGLOutputLayerEXT layer) </code> <br>Part of <code>EGL_EXT_stream_consumer_egloutput</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param layer a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerOutputEXT(long dpy, Buffer stream, Buffer layer)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(layer))
      throw new RuntimeException("Argument \"layer\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglStreamConsumerOutputEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerOutputEXT"));
    }
        return dispatch_eglStreamConsumerOutputEXT0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), layer, Buffers.getDirectBufferByteOffset(layer), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerOutputEXT(EGLDisplay dpy, EGLStreamKHR stream, EGLOutputLayerEXT layer) </code> <br>Part of <code>EGL_EXT_stream_consumer_egloutput</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param layer a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerOutputEXT0(long dpy, Object stream, int stream_byte_offset, Object layer, int layer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageEXT(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_EXT_swap_buffers_with_damage</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSwapBuffersWithDamageEXT(long dpy, long surface, IntBuffer rects, int n_rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSwapBuffersWithDamageEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffersWithDamageEXT"));
    }
        return dispatch_eglSwapBuffersWithDamageEXT0(dpy, surface, rects, Buffers.getDirectBufferByteOffset(rects), n_rects, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageEXT(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects) </code> <br>Part of <code>EGL_EXT_swap_buffers_with_damage</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSwapBuffersWithDamageEXT0(long dpy, long surface, Object rects, int rects_byte_offset, int n_rects, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI *  pixmap) </code> <br>Part of <code>EGL_HI_clientpixmap</code><br>   */
  public long eglCreatePixmapSurfaceHI(long dpy, long config, EGLClientPixmapHI pixmap)  {

    final long __addr_ = _table._addressof_eglCreatePixmapSurfaceHI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePixmapSurfaceHI"));
    }
        return dispatch_eglCreatePixmapSurfaceHI0(dpy, config, ((pixmap == null) ? null : pixmap.getBuffer()), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI *  pixmap) </code> <br>Part of <code>EGL_HI_clientpixmap</code><br>   */
  private native long dispatch_eglCreatePixmapSurfaceHI0(long dpy, long config, ByteBuffer pixmap, long procAddress);

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_MESA_drm_image</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateDRMImageMESA(long dpy, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateDRMImageMESA"));
    }
        return dispatch_eglCreateDRMImageMESA0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_MESA_drm_image</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateDRMImageMESA0(long dpy, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride) </code> <br>Part of <code>EGL_MESA_drm_image</code><br>
      @param name a direct only {@link java.nio.IntBuffer}
      @param handle a direct only {@link java.nio.IntBuffer}
      @param stride a direct only {@link java.nio.IntBuffer}   */
  public boolean eglExportDRMImageMESA(long dpy, long image, IntBuffer name, IntBuffer handle, IntBuffer stride)  {

    if (!Buffers.isDirect(name))
      throw new RuntimeException("Argument \"name\" is not a direct buffer");
    if (!Buffers.isDirect(handle))
      throw new RuntimeException("Argument \"handle\" is not a direct buffer");
    if (!Buffers.isDirect(stride))
      throw new RuntimeException("Argument \"stride\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglExportDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglExportDRMImageMESA"));
    }
        return dispatch_eglExportDRMImageMESA0(dpy, image, name, Buffers.getDirectBufferByteOffset(name), handle, Buffers.getDirectBufferByteOffset(handle), stride, Buffers.getDirectBufferByteOffset(stride), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride) </code> <br>Part of <code>EGL_MESA_drm_image</code><br>
      @param name a direct only {@link java.nio.IntBuffer}
      @param handle a direct only {@link java.nio.IntBuffer}
      @param stride a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglExportDRMImageMESA0(long dpy, long image, Object name, int name_byte_offset, Object handle, int handle_byte_offset, Object stride, int stride_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDMABUFImageQueryMESA(EGLDisplay dpy, EGLImageKHR image, int *  fourcc, int *  num_planes, EGLuint64KHR *  modifiers) </code> <br>Part of <code>EGL_MESA_image_dma_buf_export</code><br>
      @param fourcc a direct only {@link java.nio.IntBuffer}
      @param num_planes a direct only {@link java.nio.IntBuffer}
      @param modifiers a direct only {@link java.nio.LongBuffer}   */
  public boolean eglExportDMABUFImageQueryMESA(long dpy, long image, IntBuffer fourcc, IntBuffer num_planes, LongBuffer modifiers)  {

    if (!Buffers.isDirect(fourcc))
      throw new RuntimeException("Argument \"fourcc\" is not a direct buffer");
    if (!Buffers.isDirect(num_planes))
      throw new RuntimeException("Argument \"num_planes\" is not a direct buffer");
    if (!Buffers.isDirect(modifiers))
      throw new RuntimeException("Argument \"modifiers\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglExportDMABUFImageQueryMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglExportDMABUFImageQueryMESA"));
    }
        return dispatch_eglExportDMABUFImageQueryMESA0(dpy, image, fourcc, Buffers.getDirectBufferByteOffset(fourcc), num_planes, Buffers.getDirectBufferByteOffset(num_planes), modifiers, Buffers.getDirectBufferByteOffset(modifiers), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglExportDMABUFImageQueryMESA(EGLDisplay dpy, EGLImageKHR image, int *  fourcc, int *  num_planes, EGLuint64KHR *  modifiers) </code> <br>Part of <code>EGL_MESA_image_dma_buf_export</code><br>
      @param fourcc a direct only {@link java.nio.IntBuffer}
      @param num_planes a direct only {@link java.nio.IntBuffer}
      @param modifiers a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_eglExportDMABUFImageQueryMESA0(long dpy, long image, Object fourcc, int fourcc_byte_offset, Object num_planes, int num_planes_byte_offset, Object modifiers, int modifiers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDMABUFImageMESA(EGLDisplay dpy, EGLImageKHR image, int *  fds, EGLint *  strides, EGLint *  offsets) </code> <br>Part of <code>EGL_MESA_image_dma_buf_export</code><br>
      @param fds a direct only {@link java.nio.IntBuffer}
      @param strides a direct only {@link java.nio.IntBuffer}
      @param offsets a direct only {@link java.nio.IntBuffer}   */
  public boolean eglExportDMABUFImageMESA(long dpy, long image, IntBuffer fds, IntBuffer strides, IntBuffer offsets)  {

    if (!Buffers.isDirect(fds))
      throw new RuntimeException("Argument \"fds\" is not a direct buffer");
    if (!Buffers.isDirect(strides))
      throw new RuntimeException("Argument \"strides\" is not a direct buffer");
    if (!Buffers.isDirect(offsets))
      throw new RuntimeException("Argument \"offsets\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglExportDMABUFImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglExportDMABUFImageMESA"));
    }
        return dispatch_eglExportDMABUFImageMESA0(dpy, image, fds, Buffers.getDirectBufferByteOffset(fds), strides, Buffers.getDirectBufferByteOffset(strides), offsets, Buffers.getDirectBufferByteOffset(offsets), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglExportDMABUFImageMESA(EGLDisplay dpy, EGLImageKHR image, int *  fds, EGLint *  strides, EGLint *  offsets) </code> <br>Part of <code>EGL_MESA_image_dma_buf_export</code><br>
      @param fds a direct only {@link java.nio.IntBuffer}
      @param strides a direct only {@link java.nio.IntBuffer}
      @param offsets a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglExportDMABUFImageMESA0(long dpy, long image, Object fds, int fds_byte_offset, Object strides, int strides_byte_offset, Object offsets, int offsets_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *  rects) </code> <br>Part of <code>EGL_NOK_swap_region</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSwapBuffersRegionNOK(long dpy, long surface, int numRects, IntBuffer rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSwapBuffersRegionNOK;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffersRegionNOK"));
    }
        return dispatch_eglSwapBuffersRegionNOK0(dpy, surface, numRects, rects, Buffers.getDirectBufferByteOffset(rects), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *  rects) </code> <br>Part of <code>EGL_NOK_swap_region</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSwapBuffersRegionNOK0(long dpy, long surface, int numRects, Object rects, int rects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersRegion2NOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *  rects) </code> <br>Part of <code>EGL_NOK_swap_region2</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSwapBuffersRegion2NOK(long dpy, long surface, int numRects, IntBuffer rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSwapBuffersRegion2NOK;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffersRegion2NOK"));
    }
        return dispatch_eglSwapBuffersRegion2NOK0(dpy, surface, numRects, rects, Buffers.getDirectBufferByteOffset(rects), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersRegion2NOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint *  rects) </code> <br>Part of <code>EGL_NOK_swap_region2</code><br>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSwapBuffersRegion2NOK0(long dpy, long surface, int numRects, Object rects, int rects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeDisplayNV(EGLDisplay dpy, EGLNativeDisplayType *  display_id) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param display_id a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativeDisplayNV(long dpy, PointerBuffer display_id)  {

    if (!Buffers.isDirect(display_id))
      throw new RuntimeException("Argument \"display_id\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryNativeDisplayNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativeDisplayNV"));
    }
        return dispatch_eglQueryNativeDisplayNV0(dpy, display_id != null ? display_id.getBuffer() : null, Buffers.getDirectBufferByteOffset(display_id), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeDisplayNV(EGLDisplay dpy, EGLNativeDisplayType *  display_id) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param display_id a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativeDisplayNV0(long dpy, Object display_id, int display_id_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeWindowNV(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *  window) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param window a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativeWindowNV(long dpy, long surf, PointerBuffer window)  {

    if (!Buffers.isDirect(window))
      throw new RuntimeException("Argument \"window\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryNativeWindowNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativeWindowNV"));
    }
        return dispatch_eglQueryNativeWindowNV0(dpy, surf, window != null ? window.getBuffer() : null, Buffers.getDirectBufferByteOffset(window), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeWindowNV(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *  window) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param window a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativeWindowNV0(long dpy, long surf, Object window, int window_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativePixmapNV(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *  pixmap) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param pixmap a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativePixmapNV(long dpy, long surf, PointerBuffer pixmap)  {

    if (!Buffers.isDirect(pixmap))
      throw new RuntimeException("Argument \"pixmap\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryNativePixmapNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativePixmapNV"));
    }
        return dispatch_eglQueryNativePixmapNV0(dpy, surf, pixmap != null ? pixmap.getBuffer() : null, Buffers.getDirectBufferByteOffset(pixmap), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativePixmapNV(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *  pixmap) </code> <br>Part of <code>EGL_NV_native_query</code><br>
      @param pixmap a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativePixmapNV0(long dpy, long surf, Object pixmap, int pixmap_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) </code> <br>Part of <code>EGL_NV_post_sub_buffer</code><br>   */
  public boolean eglPostSubBufferNV(long dpy, long surface, int x, int y, int width, int height)  {

    final long __addr_ = _table._addressof_eglPostSubBufferNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglPostSubBufferNV"));
    }
        return dispatch_eglPostSubBufferNV0(dpy, surface, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) </code> <br>Part of <code>EGL_NV_post_sub_buffer</code><br>   */
  private native boolean dispatch_eglPostSubBufferNV0(long dpy, long surface, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateStreamSyncNV(EGLDisplay dpy, EGLStreamKHR stream, EGLenum type, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_NV_stream_sync</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateStreamSyncNV(long dpy, Buffer stream, int type, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateStreamSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamSyncNV"));
    }
        return dispatch_eglCreateStreamSyncNV0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), type, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateStreamSyncNV(EGLDisplay dpy, EGLStreamKHR stream, EGLenum type, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_NV_stream_sync</code><br>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateStreamSyncNV0(long dpy, Object stream, int stream_byte_offset, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSyncNV eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public ByteBuffer eglCreateFenceSyncNV(long dpy, int condition, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateFenceSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateFenceSyncNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateFenceSyncNV0(dpy, condition, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLSyncNV eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_eglCreateFenceSyncNV0(long dpy, int condition, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLSyncNV sync) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroySyncNV(Buffer sync)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglDestroySyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySyncNV"));
    }
        return dispatch_eglDestroySyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLSyncNV sync) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroySyncNV0(Object sync, int sync_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLSyncNV sync) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglFenceNV(Buffer sync)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglFenceNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglFenceNV"));
    }
        return dispatch_eglFenceNV0(sync, Buffers.getDirectBufferByteOffset(sync), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLSyncNV sync) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglFenceNV0(Object sync, int sync_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  public int eglClientWaitSyncNV(Buffer sync, int flags, long timeout)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglClientWaitSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSyncNV"));
    }
        return dispatch_eglClientWaitSyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglClientWaitSyncNV0(Object sync, int sync_byte_offset, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglSignalSyncNV(Buffer sync, int mode)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglSignalSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSignalSyncNV"));
    }
        return dispatch_eglSignalSyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglSignalSyncNV0(Object sync, int sync_byte_offset, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribNV(Buffer sync, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetSyncAttribNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttribNV"));
    }
        return dispatch_eglGetSyncAttribNV0(sync, Buffers.getDirectBufferByteOffset(sync), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint *  value) </code> <br>Part of <code>EGL_NV_sync</code><br>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribNV0(Object sync, int sync_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLuint64NV eglGetSystemTimeFrequencyNV(void) </code> <br>Part of <code>EGL_NV_system_time</code><br>   */
  public long eglGetSystemTimeFrequencyNV()  {

    final long __addr_ = _table._addressof_eglGetSystemTimeFrequencyNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSystemTimeFrequencyNV"));
    }
        return dispatch_eglGetSystemTimeFrequencyNV0(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64NV eglGetSystemTimeFrequencyNV(void) </code> <br>Part of <code>EGL_NV_system_time</code><br>   */
  private native long dispatch_eglGetSystemTimeFrequencyNV0(long procAddress);

  /** Entry point to C language function: <code> EGLuint64NV eglGetSystemTimeNV(void) </code> <br>Part of <code>EGL_NV_system_time</code><br>   */
  public long eglGetSystemTimeNV()  {

    final long __addr_ = _table._addressof_eglGetSystemTimeNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSystemTimeNV"));
    }
        return dispatch_eglGetSystemTimeNV0(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64NV eglGetSystemTimeNV(void) </code> <br>Part of <code>EGL_NV_system_time</code><br>   */
  private native long dispatch_eglGetSystemTimeNV0(long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public EGLExtImpl(EGLContext context, EGLExtProcAddressTable table) {
    this._context = context; 
    this._table = table; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private final EGLContext _context;
  private final EGLExtProcAddressTable _table;
  final EGLExtProcAddressTable getProcAdressTable() { return _table; }
  // ---- End CustomJavaCode .cfg declarations

} // end of class EGLExtImpl
