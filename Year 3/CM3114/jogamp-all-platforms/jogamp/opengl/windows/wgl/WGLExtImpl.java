/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:20:16 CEST 2015 ----! */

package jogamp.opengl.windows.wgl;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class WGLExtImpl implements WGLExt{
  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  public long wglCreateBufferRegionARB(long hDC, int iLayerPlane, int uType)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateBufferRegionARB"));
    }
        return dispatch_wglCreateBufferRegionARB0(hDC, iLayerPlane, uType, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  private native long dispatch_wglCreateBufferRegionARB0(long hDC, int iLayerPlane, int uType, long procAddress);

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  public void wglDeleteBufferRegionARB(long hRegion)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDeleteBufferRegionARB"));
    }
        dispatch_wglDeleteBufferRegionARB0(hRegion, __addr_);
  }

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  private native void dispatch_wglDeleteBufferRegionARB0(long hRegion, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  public boolean wglSaveBufferRegionARB(long hRegion, int x, int y, int width, int height)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSaveBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSaveBufferRegionARB"));
    }
        return dispatch_wglSaveBufferRegionARB0(hRegion, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  private native boolean dispatch_wglSaveBufferRegionARB0(long hRegion, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  public boolean wglRestoreBufferRegionARB(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglRestoreBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglRestoreBufferRegionARB"));
    }
        return dispatch_wglRestoreBufferRegionARB0(hRegion, x, y, width, height, xSrc, ySrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc) </code> <br>Part of <code>WGL_ARB_buffer_region</code><br>   */
  private native boolean dispatch_wglRestoreBufferRegionARB0(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc, long procAddress);

  /** Entry point to C language function: <code> HGLRC wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *  attribList) </code> <br>Part of <code>WGL_ARB_create_context</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreateContextAttribsARB(long hDC, long hShareContext, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateContextAttribsARB"));
    }
        return dispatch_wglCreateContextAttribsARB0(hDC, hShareContext, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> HGLRC wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *  attribList) </code> <br>Part of <code>WGL_ARB_create_context</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateContextAttribsARB0(long hDC, long hShareContext, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  wglGetExtensionsStringARB(HDC hdc) </code> <br>Part of <code>WGL_ARB_extensions_string</code><br>   */
  public String wglGetExtensionsStringARB(long hdc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetExtensionsStringARB"));
    }
        return dispatch_wglGetExtensionsStringARB0(hdc, __addr_);
  }

  /** Entry point to C language function: <code> const char *  wglGetExtensionsStringARB(HDC hdc) </code> <br>Part of <code>WGL_ARB_extensions_string</code><br>   */
  private native String dispatch_wglGetExtensionsStringARB0(long hdc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrent(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) </code> <br>Part of <code>WGL_ARB_make_current_read</code>, <code>WGL_EXT_make_current_read</code><br>Alias for: <code>wglMakeContextCurrentARB</code>, <code>wglMakeContextCurrentEXT</code>   */
  public boolean wglMakeContextCurrent(long hDrawDC, long hReadDC, long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglMakeContextCurrent"));
    }
        return dispatch_wglMakeContextCurrent0(hDrawDC, hReadDC, hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrent(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) </code> <br>Part of <code>WGL_ARB_make_current_read</code>, <code>WGL_EXT_make_current_read</code><br>Alias for: <code>wglMakeContextCurrentARB</code>, <code>wglMakeContextCurrentEXT</code>   */
  private native boolean dispatch_wglMakeContextCurrent0(long hDrawDC, long hReadDC, long hglrc, long procAddress);

  /** Entry point to C language function: <code> HDC wglGetCurrentReadDC(void) </code> <br>Part of <code>WGL_ARB_make_current_read</code>, <code>WGL_EXT_make_current_read</code><br>Alias for: <code>wglGetCurrentReadDCARB</code>, <code>wglGetCurrentReadDCEXT</code>   */
  public long wglGetCurrentReadDC()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentReadDC;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetCurrentReadDC"));
    }
        return dispatch_wglGetCurrentReadDC0(__addr_);
  }

  /** Entry point to C language function: <code> HDC wglGetCurrentReadDC(void) </code> <br>Part of <code>WGL_ARB_make_current_read</code>, <code>WGL_EXT_make_current_read</code><br>Alias for: <code>wglGetCurrentReadDCARB</code>, <code>wglGetCurrentReadDCEXT</code>   */
  private native long dispatch_wglGetCurrentReadDC0(long procAddress);

  /** Entry point to C language function: <code> HPBUFFERARB wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferARB(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreatePbufferARB"));
    }
        return dispatch_wglCreatePbufferARB0(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> HPBUFFERARB wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferARB0(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HDC wglGetPbufferDCARB(HPBUFFERARB hPbuffer) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  public long wglGetPbufferDCARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPbufferDCARB"));
    }
        return dispatch_wglGetPbufferDCARB0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HDC wglGetPbufferDCARB(HPBUFFERARB hPbuffer) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  private native long dispatch_wglGetPbufferDCARB0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  public int wglReleasePbufferDCARB(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleasePbufferDCARB"));
    }
        return dispatch_wglReleasePbufferDCARB0(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  private native int dispatch_wglReleasePbufferDCARB0(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HPBUFFERARB hPbuffer) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  public boolean wglDestroyPbufferARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyPbufferARB"));
    }
        return dispatch_wglDestroyPbufferARB0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HPBUFFERARB hPbuffer) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>   */
  private native boolean dispatch_wglDestroyPbufferARB0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferARB(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryPbufferARB"));
    }
        return dispatch_wglQueryPbufferARB0(hPbuffer, iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_ARB_pbuffer</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferARB0(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(piValues))
      throw new GLException("Argument \"piValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribivARB"));
    }
        return dispatch_wglGetPixelFormatAttribivARB0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), piValues, Buffers.getDirectBufferByteOffset(piValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivARB0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object piValues, int piValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(pfValues))
      throw new GLException("Argument \"pfValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribfvARB"));
    }
        return dispatch_wglGetPixelFormatAttribfvARB0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), pfValues, Buffers.getDirectBufferByteOffset(pfValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvARB0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object pfValues, int pfValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HDC hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatARB(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    if (!Buffers.isDirect(piAttribIList))
      throw new GLException("Argument \"piAttribIList\" is not a direct buffer");
    if (!Buffers.isDirect(pfAttribFList))
      throw new GLException("Argument \"pfAttribFList\" is not a direct buffer");
    if (!Buffers.isDirect(piFormats))
      throw new GLException("Argument \"piFormats\" is not a direct buffer");
    if (!Buffers.isDirect(nNumFormats))
      throw new GLException("Argument \"nNumFormats\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglChoosePixelFormatARB"));
    }
        return dispatch_wglChoosePixelFormatARB0(hdc, piAttribIList, Buffers.getDirectBufferByteOffset(piAttribIList), pfAttribFList, Buffers.getDirectBufferByteOffset(pfAttribFList), nMaxFormats, piFormats, Buffers.getDirectBufferByteOffset(piFormats), nNumFormats, Buffers.getDirectBufferByteOffset(nNumFormats), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HDC hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats) </code> <br>Part of <code>WGL_ARB_pixel_format</code><br>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatARB0(long hdc, Object piAttribIList, int piAttribIList_byte_offset, Object pfAttribFList, int pfAttribFList_byte_offset, int nMaxFormats, Object piFormats, int piFormats_byte_offset, Object nNumFormats, int nNumFormats_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>   */
  public boolean wglBindTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindTexImageARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindTexImageARB"));
    }
        return dispatch_wglBindTexImageARB0(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>   */
  private native boolean dispatch_wglBindTexImageARB0(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>   */
  public boolean wglReleaseTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseTexImageARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleaseTexImageARB"));
    }
        return dispatch_wglReleaseTexImageARB0(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>   */
  private native boolean dispatch_wglReleaseTexImageARB0(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *  piAttribList) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public boolean wglSetPbufferAttribARB(long hPbuffer, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetPbufferAttribARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSetPbufferAttribARB"));
    }
        return dispatch_wglSetPbufferAttribARB0(hPbuffer, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *  piAttribList) </code> <br>Part of <code>WGL_ARB_render_texture</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglSetPbufferAttribARB0(long hPbuffer, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetStereoEmitterState3DL(HDC hDC, UINT uState) </code> <br>Part of <code>WGL_3DL_stereo_control</code><br>   */
  public boolean wglSetStereoEmitterState3DL(long hDC, int uState)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetStereoEmitterState3DL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSetStereoEmitterState3DL"));
    }
        return dispatch_wglSetStereoEmitterState3DL0(hDC, uState, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetStereoEmitterState3DL(HDC hDC, UINT uState) </code> <br>Part of <code>WGL_3DL_stereo_control</code><br>   */
  private native boolean dispatch_wglSetStereoEmitterState3DL0(long hDC, int uState, long procAddress);

  /** Entry point to C language function: <code> UINT wglGetGPUIDsAMD(UINT maxCount, UINT *  ids) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  public int wglGetGPUIDsAMD(int maxCount, IntBuffer ids)  {

    if (!Buffers.isDirect(ids))
      throw new GLException("Argument \"ids\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetGPUIDsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetGPUIDsAMD"));
    }
        return dispatch_wglGetGPUIDsAMD0(maxCount, ids, Buffers.getDirectBufferByteOffset(ids), __addr_);
  }

  /** Entry point to C language function: <code> UINT wglGetGPUIDsAMD(UINT maxCount, UINT *  ids) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_wglGetGPUIDsAMD0(int maxCount, Object ids, int ids_byte_offset, long procAddress);

  /** Entry point to C language function: <code> INT wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *  data) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param data a direct only {@link java.nio.Buffer}   */
  public int wglGetGPUInfoAMD(int id, int property, int dataType, int size, Buffer data)  {

    if (!Buffers.isDirect(data))
      throw new GLException("Argument \"data\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetGPUInfoAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetGPUInfoAMD"));
    }
        return dispatch_wglGetGPUInfoAMD0(id, property, dataType, size, data, Buffers.getDirectBufferByteOffset(data), __addr_);
  }

  /** Entry point to C language function: <code> INT wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *  data) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param data a direct only {@link java.nio.Buffer}   */
  private native int dispatch_wglGetGPUInfoAMD0(int id, int property, int dataType, int size, Object data, int data_byte_offset, long procAddress);

  /** Entry point to C language function: <code> UINT wglGetContextGPUIDAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public int wglGetContextGPUIDAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetContextGPUIDAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetContextGPUIDAMD"));
    }
        return dispatch_wglGetContextGPUIDAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> UINT wglGetContextGPUIDAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native int dispatch_wglGetContextGPUIDAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> HGLRC wglCreateAssociatedContextAMD(UINT id) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public long wglCreateAssociatedContextAMD(int id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateAssociatedContextAMD"));
    }
        return dispatch_wglCreateAssociatedContextAMD0(id, __addr_);
  }

  /** Entry point to C language function: <code> HGLRC wglCreateAssociatedContextAMD(UINT id) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native long dispatch_wglCreateAssociatedContextAMD0(int id, long procAddress);

  /** Entry point to C language function: <code> HGLRC wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *  attribList) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreateAssociatedContextAttribsAMD(int id, long hShareContext, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateAssociatedContextAttribsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateAssociatedContextAttribsAMD"));
    }
        return dispatch_wglCreateAssociatedContextAttribsAMD0(id, hShareContext, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> HGLRC wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *  attribList) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateAssociatedContextAttribsAMD0(int id, long hShareContext, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDeleteAssociatedContextAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public boolean wglDeleteAssociatedContextAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDeleteAssociatedContextAMD"));
    }
        return dispatch_wglDeleteAssociatedContextAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDeleteAssociatedContextAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native boolean dispatch_wglDeleteAssociatedContextAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglMakeAssociatedContextCurrentAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public boolean wglMakeAssociatedContextCurrentAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeAssociatedContextCurrentAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglMakeAssociatedContextCurrentAMD"));
    }
        return dispatch_wglMakeAssociatedContextCurrentAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeAssociatedContextCurrentAMD(HGLRC hglrc) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native boolean dispatch_wglMakeAssociatedContextCurrentAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> HGLRC wglGetCurrentAssociatedContextAMD(void) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public long wglGetCurrentAssociatedContextAMD()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetCurrentAssociatedContextAMD"));
    }
        return dispatch_wglGetCurrentAssociatedContextAMD0(__addr_);
  }

  /** Entry point to C language function: <code> HGLRC wglGetCurrentAssociatedContextAMD(void) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native long dispatch_wglGetCurrentAssociatedContextAMD0(long procAddress);

  /** Entry point to C language function: <code> void wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  public void wglBlitContextFramebufferAMD(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBlitContextFramebufferAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBlitContextFramebufferAMD"));
    }
        dispatch_wglBlitContextFramebufferAMD0(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) </code> <br>Part of <code>WGL_AMD_gpu_association</code><br>   */
  private native void dispatch_wglBlitContextFramebufferAMD0(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  public boolean wglCreateDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateDisplayColorTableEXT"));
    }
        return dispatch_wglCreateDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  private native boolean dispatch_wglCreateDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>
      @param table a direct only {@link java.nio.ShortBuffer}   */
  public boolean wglLoadDisplayColorTableEXT(ShortBuffer table, int length)  {

    if (!Buffers.isDirect(table))
      throw new GLException("Argument \"table\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLoadDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglLoadDisplayColorTableEXT"));
    }
        return dispatch_wglLoadDisplayColorTableEXT0(table, Buffers.getDirectBufferByteOffset(table), length, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>
      @param table a direct only {@link java.nio.ShortBuffer}   */
  private native boolean dispatch_wglLoadDisplayColorTableEXT0(Object table, int table_byte_offset, int length, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  public boolean wglBindDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindDisplayColorTableEXT"));
    }
        return dispatch_wglBindDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  private native boolean dispatch_wglBindDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  public void wglDestroyDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyDisplayColorTableEXT"));
    }
        dispatch_wglDestroyDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort id) </code> <br>Part of <code>WGL_EXT_display_color_table</code><br>   */
  private native void dispatch_wglDestroyDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> const char *  wglGetExtensionsStringEXT(void) </code> <br>Part of <code>WGL_EXT_extensions_string</code><br>   */
  public String wglGetExtensionsStringEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetExtensionsStringEXT"));
    }
        return dispatch_wglGetExtensionsStringEXT0(__addr_);
  }

  /** Entry point to C language function: <code> const char *  wglGetExtensionsStringEXT(void) </code> <br>Part of <code>WGL_EXT_extensions_string</code><br>   */
  private native String dispatch_wglGetExtensionsStringEXT0(long procAddress);

  /** Entry point to C language function: <code> HPBUFFEREXT wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferEXT(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreatePbufferEXT"));
    }
        return dispatch_wglCreatePbufferEXT0(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> HPBUFFEREXT wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferEXT0(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HDC wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  public long wglGetPbufferDCEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPbufferDCEXT"));
    }
        return dispatch_wglGetPbufferDCEXT0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HDC wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  private native long dispatch_wglGetPbufferDCEXT0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  public int wglReleasePbufferDCEXT(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleasePbufferDCEXT"));
    }
        return dispatch_wglReleasePbufferDCEXT0(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  private native int dispatch_wglReleasePbufferDCEXT0(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  public boolean wglDestroyPbufferEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyPbufferEXT"));
    }
        return dispatch_wglDestroyPbufferEXT0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>   */
  private native boolean dispatch_wglDestroyPbufferEXT0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferEXT(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryPbufferEXT"));
    }
        return dispatch_wglQueryPbufferEXT0(hPbuffer, iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_EXT_pbuffer</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferEXT0(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(piValues))
      throw new GLException("Argument \"piValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribivEXT"));
    }
        return dispatch_wglGetPixelFormatAttribivEXT0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), piValues, Buffers.getDirectBufferByteOffset(piValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivEXT0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object piValues, int piValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(pfValues))
      throw new GLException("Argument \"pfValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribfvEXT"));
    }
        return dispatch_wglGetPixelFormatAttribfvEXT0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), pfValues, Buffers.getDirectBufferByteOffset(pfValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvEXT0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object pfValues, int pfValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HDC hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatEXT(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    if (!Buffers.isDirect(piAttribIList))
      throw new GLException("Argument \"piAttribIList\" is not a direct buffer");
    if (!Buffers.isDirect(pfAttribFList))
      throw new GLException("Argument \"pfAttribFList\" is not a direct buffer");
    if (!Buffers.isDirect(piFormats))
      throw new GLException("Argument \"piFormats\" is not a direct buffer");
    if (!Buffers.isDirect(nNumFormats))
      throw new GLException("Argument \"nNumFormats\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglChoosePixelFormatEXT"));
    }
        return dispatch_wglChoosePixelFormatEXT0(hdc, piAttribIList, Buffers.getDirectBufferByteOffset(piAttribIList), pfAttribFList, Buffers.getDirectBufferByteOffset(pfAttribFList), nMaxFormats, piFormats, Buffers.getDirectBufferByteOffset(piFormats), nNumFormats, Buffers.getDirectBufferByteOffset(nNumFormats), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HDC hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats) </code> <br>Part of <code>WGL_EXT_pixel_format</code><br>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatEXT0(long hdc, Object piAttribIList, int piAttribIList_byte_offset, Object pfAttribFList, int pfAttribFList_byte_offset, int nMaxFormats, Object piFormats, int piFormats_byte_offset, Object nNumFormats, int nNumFormats_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval) </code> <br>Part of <code>WGL_EXT_swap_control</code><br>   */
  public boolean wglSwapIntervalEXT(int interval)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSwapIntervalEXT"));
    }
        return dispatch_wglSwapIntervalEXT0(interval, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval) </code> <br>Part of <code>WGL_EXT_swap_control</code><br>   */
  private native boolean dispatch_wglSwapIntervalEXT0(int interval, long procAddress);

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void) </code> <br>Part of <code>WGL_EXT_swap_control</code><br>   */
  public int wglGetSwapIntervalEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetSwapIntervalEXT"));
    }
        return dispatch_wglGetSwapIntervalEXT0(__addr_);
  }

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void) </code> <br>Part of <code>WGL_EXT_swap_control</code><br>   */
  private native int dispatch_wglGetSwapIntervalEXT0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>   */
  public boolean wglEnableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEnableFrameLockI3D"));
    }
        return dispatch_wglEnableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>   */
  private native boolean dispatch_wglEnableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>   */
  public boolean wglDisableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDisableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDisableFrameLockI3D"));
    }
        return dispatch_wglDisableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>   */
  private native boolean dispatch_wglDisableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  pFlag) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglIsEnabledFrameLockI3D(ByteBuffer pFlag)  {

    if (!Buffers.isDirect(pFlag))
      throw new GLException("Argument \"pFlag\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglIsEnabledFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglIsEnabledFrameLockI3D"));
    }
        return dispatch_wglIsEnabledFrameLockI3D0(pFlag, Buffers.getDirectBufferByteOffset(pFlag), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  pFlag) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglIsEnabledFrameLockI3D0(Object pFlag, int pFlag_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  pFlag) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglQueryFrameLockMasterI3D(ByteBuffer pFlag)  {

    if (!Buffers.isDirect(pFlag))
      throw new GLException("Argument \"pFlag\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameLockMasterI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameLockMasterI3D"));
    }
        return dispatch_wglQueryFrameLockMasterI3D0(pFlag, Buffers.getDirectBufferByteOffset(pFlag), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  pFlag) </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code><br>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglQueryFrameLockMasterI3D0(Object pFlag, int pFlag_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>
      @param pUsage a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetFrameUsageI3D(FloatBuffer pUsage)  {

    if (!Buffers.isDirect(pUsage))
      throw new GLException("Argument \"pUsage\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetFrameUsageI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetFrameUsageI3D"));
    }
        return dispatch_wglGetFrameUsageI3D0(pUsage, Buffers.getDirectBufferByteOffset(pUsage), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>
      @param pUsage a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetFrameUsageI3D0(Object pUsage, int pUsage_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>   */
  public boolean wglBeginFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBeginFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBeginFrameTrackingI3D"));
    }
        return dispatch_wglBeginFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>   */
  private native boolean dispatch_wglBeginFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>   */
  public boolean wglEndFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEndFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEndFrameTrackingI3D"));
    }
        return dispatch_wglEndFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>   */
  private native boolean dispatch_wglEndFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>
      @param pFrameCount a direct only {@link java.nio.IntBuffer}
      @param pMissedFrames a direct only {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglQueryFrameTrackingI3D(IntBuffer pFrameCount, IntBuffer pMissedFrames, FloatBuffer pLastMissedUsage)  {

    if (!Buffers.isDirect(pFrameCount))
      throw new GLException("Argument \"pFrameCount\" is not a direct buffer");
    if (!Buffers.isDirect(pMissedFrames))
      throw new GLException("Argument \"pMissedFrames\" is not a direct buffer");
    if (!Buffers.isDirect(pLastMissedUsage))
      throw new GLException("Argument \"pLastMissedUsage\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameTrackingI3D"));
    }
        return dispatch_wglQueryFrameTrackingI3D0(pFrameCount, Buffers.getDirectBufferByteOffset(pFrameCount), pMissedFrames, Buffers.getDirectBufferByteOffset(pMissedFrames), pLastMissedUsage, Buffers.getDirectBufferByteOffset(pLastMissedUsage), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage) </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code><br>
      @param pFrameCount a direct only {@link java.nio.IntBuffer}
      @param pMissedFrames a direct only {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglQueryFrameTrackingI3D0(Object pFrameCount, int pFrameCount_byte_offset, Object pMissedFrames, int pMissedFrames_byte_offset, Object pLastMissedUsage, int pLastMissedUsage_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXSetResourceShareHandleNV(void *  dxObject, HANDLE shareHandle) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  public boolean wglDXSetResourceShareHandleNV(Buffer dxObject, long shareHandle)  {

    if (!Buffers.isDirect(dxObject))
      throw new GLException("Argument \"dxObject\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXSetResourceShareHandleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXSetResourceShareHandleNV"));
    }
        return dispatch_wglDXSetResourceShareHandleNV0(dxObject, Buffers.getDirectBufferByteOffset(dxObject), shareHandle, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXSetResourceShareHandleNV(void *  dxObject, HANDLE shareHandle) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_wglDXSetResourceShareHandleNV0(Object dxObject, int dxObject_byte_offset, long shareHandle, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglDXOpenDeviceNV(void *  dxDevice) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxDevice a direct only {@link java.nio.Buffer}   */
  public long wglDXOpenDeviceNV(Buffer dxDevice)  {

    if (!Buffers.isDirect(dxDevice))
      throw new GLException("Argument \"dxDevice\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXOpenDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXOpenDeviceNV"));
    }
        return dispatch_wglDXOpenDeviceNV0(dxDevice, Buffers.getDirectBufferByteOffset(dxDevice), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglDXOpenDeviceNV(void *  dxDevice) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxDevice a direct only {@link java.nio.Buffer}   */
  private native long dispatch_wglDXOpenDeviceNV0(Object dxDevice, int dxDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXCloseDeviceNV(HANDLE hDevice) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  public boolean wglDXCloseDeviceNV(long hDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXCloseDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXCloseDeviceNV"));
    }
        return dispatch_wglDXCloseDeviceNV0(hDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXCloseDeviceNV(HANDLE hDevice) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  private native boolean dispatch_wglDXCloseDeviceNV0(long hDevice, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglDXRegisterObjectNV(HANDLE hDevice, void *  dxObject, GLuint name, GLenum type, GLenum access) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  public long wglDXRegisterObjectNV(long hDevice, Buffer dxObject, int name, int type, int access)  {

    if (!Buffers.isDirect(dxObject))
      throw new GLException("Argument \"dxObject\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXRegisterObjectNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXRegisterObjectNV"));
    }
        return dispatch_wglDXRegisterObjectNV0(hDevice, dxObject, Buffers.getDirectBufferByteOffset(dxObject), name, type, access, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglDXRegisterObjectNV(HANDLE hDevice, void *  dxObject, GLuint name, GLenum type, GLenum access) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  private native long dispatch_wglDXRegisterObjectNV0(long hDevice, Object dxObject, int dxObject_byte_offset, int name, int type, int access, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  public boolean wglDXUnregisterObjectNV(long hDevice, long hObject)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXUnregisterObjectNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXUnregisterObjectNV"));
    }
        return dispatch_wglDXUnregisterObjectNV0(hDevice, hObject, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  private native boolean dispatch_wglDXUnregisterObjectNV0(long hDevice, long hObject, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXObjectAccessNV(HANDLE hObject, GLenum access) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  public boolean wglDXObjectAccessNV(long hObject, int access)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXObjectAccessNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXObjectAccessNV"));
    }
        return dispatch_wglDXObjectAccessNV0(hObject, access, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXObjectAccessNV(HANDLE hObject, GLenum access) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>   */
  private native boolean dispatch_wglDXObjectAccessNV0(long hObject, int access, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean wglDXLockObjectsNV(long hDevice, int count, PointerBuffer hObjects)  {

    if (!Buffers.isDirect(hObjects))
      throw new GLException("Argument \"hObjects\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXLockObjectsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXLockObjectsNV"));
    }
        return dispatch_wglDXLockObjectsNV0(hDevice, count, hObjects != null ? hObjects.getBuffer() : null, Buffers.getDirectBufferByteOffset(hObjects), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_wglDXLockObjectsNV0(long hDevice, int count, Object hObjects, int hObjects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean wglDXUnlockObjectsNV(long hDevice, int count, PointerBuffer hObjects)  {

    if (!Buffers.isDirect(hObjects))
      throw new GLException("Argument \"hObjects\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXUnlockObjectsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXUnlockObjectsNV"));
    }
        return dispatch_wglDXUnlockObjectsNV0(hDevice, count, hObjects != null ? hObjects.getBuffer() : null, Buffers.getDirectBufferByteOffset(hObjects), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects) </code> <br>Part of <code>WGL_NV_DX_interop</code><br>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_wglDXUnlockObjectsNV0(long hDevice, int count, Object hObjects, int hObjects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>WGL_NV_copy_image</code><br>   */
  public boolean wglCopyImageSubDataNV(long hSrcRC, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long hDstRC, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCopyImageSubDataNV"));
    }
        return dispatch_wglCopyImageSubDataNV0(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>WGL_NV_copy_image</code><br>   */
  private native boolean dispatch_wglCopyImageSubDataNV0(long hSrcRC, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long hDstRC, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDelayBeforeSwapNV(HDC hDC, GLfloat seconds) </code> <br>Part of <code>WGL_NV_delay_before_swap</code><br>   */
  public boolean wglDelayBeforeSwapNV(long hDC, float seconds)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDelayBeforeSwapNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDelayBeforeSwapNV"));
    }
        return dispatch_wglDelayBeforeSwapNV0(hDC, seconds, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDelayBeforeSwapNV(HDC hDC, GLfloat seconds) </code> <br>Part of <code>WGL_NV_delay_before_swap</code><br>   */
  private native boolean dispatch_wglDelayBeforeSwapNV0(long hDC, float seconds, long procAddress);

  /** Entry point to C language function: <code> int wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *  phDeviceList) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param phDeviceList a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public int wglEnumerateVideoDevicesNV(long hDC, PointerBuffer phDeviceList)  {

    if (!Buffers.isDirect(phDeviceList))
      throw new GLException("Argument \"phDeviceList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEnumerateVideoDevicesNV"));
    }
        return dispatch_wglEnumerateVideoDevicesNV0(hDC, phDeviceList != null ? phDeviceList.getBuffer() : null, Buffers.getDirectBufferByteOffset(phDeviceList), __addr_);
  }

  /** Entry point to C language function: <code> int wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *  phDeviceList) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param phDeviceList a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native int dispatch_wglEnumerateVideoDevicesNV0(long hDC, Object phDeviceList, int phDeviceList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *  piAttribList) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public boolean wglBindVideoDeviceNV(long hDC, int uVideoSlot, long hVideoDevice, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindVideoDeviceNV"));
    }
        return dispatch_wglBindVideoDeviceNV0(hDC, uVideoSlot, hVideoDevice, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *  piAttribList) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglBindVideoDeviceNV0(long hDC, int uVideoSlot, long hVideoDevice, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryCurrentContextNV(int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryCurrentContextNV(int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryCurrentContextNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryCurrentContextNV"));
    }
        return dispatch_wglQueryCurrentContextNV0(iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryCurrentContextNV(int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_NV_present_video</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryCurrentContextNV0(int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HDC hDC, GLuint group) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  public boolean wglJoinSwapGroupNV(long hDC, int group)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglJoinSwapGroupNV"));
    }
        return dispatch_wglJoinSwapGroupNV0(hDC, group, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HDC hDC, GLuint group) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  private native boolean dispatch_wglJoinSwapGroupNV0(long hDC, int group, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  public boolean wglBindSwapBarrierNV(int group, int barrier)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindSwapBarrierNV"));
    }
        return dispatch_wglBindSwapBarrierNV0(group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  private native boolean dispatch_wglBindSwapBarrierNV0(int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HDC hDC, GLuint *  group, GLuint *  barrier) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQuerySwapGroupNV(long hDC, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQuerySwapGroupNV"));
    }
        return dispatch_wglQuerySwapGroupNV0(hDC, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HDC hDC, GLuint *  group, GLuint *  barrier) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQuerySwapGroupNV0(long hDC, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *  maxGroups, GLuint *  maxBarriers) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryMaxSwapGroupsNV(long hDC, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryMaxSwapGroupsNV"));
    }
        return dispatch_wglQueryMaxSwapGroupsNV0(hDC, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *  maxGroups, GLuint *  maxBarriers) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryMaxSwapGroupsNV0(long hDC, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HDC hDC, GLuint *  count) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryFrameCountNV(long hDC, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameCountNV"));
    }
        return dispatch_wglQueryFrameCountNV0(hDC, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HDC hDC, GLuint *  count) </code> <br>Part of <code>WGL_NV_swap_group</code><br>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryFrameCountNV0(long hDC, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HDC hDC) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  public boolean wglResetFrameCountNV(long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglResetFrameCountNV"));
    }
        return dispatch_wglResetFrameCountNV0(hDC, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HDC hDC) </code> <br>Part of <code>WGL_NV_swap_group</code><br>   */
  private native boolean dispatch_wglResetFrameCountNV0(long hDC, long procAddress);

  /** Entry point to C language function: <code> void *  wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) </code> <br>Part of <code>WGL_NV_vertex_array_range</code><br>   */
  public ByteBuffer wglAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglAllocateMemoryNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_wglAllocateMemoryNV0(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> void *  wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) </code> <br>Part of <code>WGL_NV_vertex_array_range</code><br>   */
  private native ByteBuffer dispatch_wglAllocateMemoryNV0(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> void wglFreeMemoryNV(void *  pointer) </code> <br>Part of <code>WGL_NV_vertex_array_range</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void wglFreeMemoryNV(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglFreeMemoryNV"));
    }
        dispatch_wglFreeMemoryNV0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void wglFreeMemoryNV(void *  pointer) </code> <br>Part of <code>WGL_NV_vertex_array_range</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_wglFreeMemoryNV0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  public boolean wglBindVideoCaptureDeviceNV(int uVideoSlot, long hDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindVideoCaptureDeviceNV"));
    }
        return dispatch_wglBindVideoCaptureDeviceNV0(uVideoSlot, hDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  private native boolean dispatch_wglBindVideoCaptureDeviceNV0(int uVideoSlot, long hDevice, long procAddress);

  /** Entry point to C language function: <code> UINT wglEnumerateVideoCaptureDevicesNV(HDC hDc, HVIDEOINPUTDEVICENV *  phDeviceList) </code> <br>Part of <code>WGL_NV_video_capture</code><br>
      @param phDeviceList a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public int wglEnumerateVideoCaptureDevicesNV(long hDc, PointerBuffer phDeviceList)  {

    if (!Buffers.isDirect(phDeviceList))
      throw new GLException("Argument \"phDeviceList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnumerateVideoCaptureDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEnumerateVideoCaptureDevicesNV"));
    }
        return dispatch_wglEnumerateVideoCaptureDevicesNV0(hDc, phDeviceList != null ? phDeviceList.getBuffer() : null, Buffers.getDirectBufferByteOffset(phDeviceList), __addr_);
  }

  /** Entry point to C language function: <code> UINT wglEnumerateVideoCaptureDevicesNV(HDC hDc, HVIDEOINPUTDEVICENV *  phDeviceList) </code> <br>Part of <code>WGL_NV_video_capture</code><br>
      @param phDeviceList a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native int dispatch_wglEnumerateVideoCaptureDevicesNV0(long hDc, Object phDeviceList, int phDeviceList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglLockVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  public boolean wglLockVideoCaptureDeviceNV(long hDc, long hDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLockVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglLockVideoCaptureDeviceNV"));
    }
        return dispatch_wglLockVideoCaptureDeviceNV0(hDc, hDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglLockVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  private native boolean dispatch_wglLockVideoCaptureDeviceNV0(long hDc, long hDevice, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_NV_video_capture</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryVideoCaptureDeviceNV(long hDc, long hDevice, int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryVideoCaptureDeviceNV"));
    }
        return dispatch_wglQueryVideoCaptureDeviceNV0(hDc, hDevice, iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *  piValue) </code> <br>Part of <code>WGL_NV_video_capture</code><br>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryVideoCaptureDeviceNV0(long hDc, long hDevice, int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  public boolean wglReleaseVideoCaptureDeviceNV(long hDc, long hDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleaseVideoCaptureDeviceNV"));
    }
        return dispatch_wglReleaseVideoCaptureDeviceNV0(hDc, hDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) </code> <br>Part of <code>WGL_NV_video_capture</code><br>   */
  private native boolean dispatch_wglReleaseVideoCaptureDeviceNV0(long hDc, long hDevice, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *  hVideoDevice) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param hVideoDevice a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean wglGetVideoDeviceNV(long hDC, int numDevices, PointerBuffer hVideoDevice)  {

    if (!Buffers.isDirect(hVideoDevice))
      throw new GLException("Argument \"hVideoDevice\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetVideoDeviceNV"));
    }
        return dispatch_wglGetVideoDeviceNV0(hDC, numDevices, hVideoDevice != null ? hVideoDevice.getBuffer() : null, Buffers.getDirectBufferByteOffset(hVideoDevice), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *  hVideoDevice) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param hVideoDevice a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_wglGetVideoDeviceNV0(long hDC, int numDevices, Object hVideoDevice, int hVideoDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  public boolean wglReleaseVideoDeviceNV(long hVideoDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleaseVideoDeviceNV"));
    }
        return dispatch_wglReleaseVideoDeviceNV0(hVideoDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  private native boolean dispatch_wglReleaseVideoDeviceNV0(long hVideoDevice, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  public boolean wglBindVideoImageNV(long hVideoDevice, long hPbuffer, int iVideoBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindVideoImageNV"));
    }
        return dispatch_wglBindVideoImageNV0(hVideoDevice, hPbuffer, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  private native boolean dispatch_wglBindVideoImageNV0(long hVideoDevice, long hPbuffer, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  public boolean wglReleaseVideoImageNV(long hPbuffer, int iVideoBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleaseVideoImageNV"));
    }
        return dispatch_wglReleaseVideoImageNV0(hPbuffer, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer) </code> <br>Part of <code>WGL_NV_video_output</code><br>   */
  private native boolean dispatch_wglReleaseVideoImageNV0(long hPbuffer, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *  pulCounterPbuffer, BOOL bBlock) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  public boolean wglSendPbufferToVideoNV(long hPbuffer, int iBufferType, LongBuffer pulCounterPbuffer, boolean bBlock)  {

    if (!Buffers.isDirect(pulCounterPbuffer))
      throw new GLException("Argument \"pulCounterPbuffer\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSendPbufferToVideoNV"));
    }
        return dispatch_wglSendPbufferToVideoNV0(hPbuffer, iBufferType, pulCounterPbuffer, Buffers.getDirectBufferByteOffset(pulCounterPbuffer), bBlock, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *  pulCounterPbuffer, BOOL bBlock) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_wglSendPbufferToVideoNV0(long hPbuffer, int iBufferType, Object pulCounterPbuffer, int pulCounterPbuffer_byte_offset, boolean bBlock, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  public boolean wglGetVideoInfoNV(long hpVideoDevice, LongBuffer pulCounterOutputPbuffer, LongBuffer pulCounterOutputVideo)  {

    if (!Buffers.isDirect(pulCounterOutputPbuffer))
      throw new GLException("Argument \"pulCounterOutputPbuffer\" is not a direct buffer");
    if (!Buffers.isDirect(pulCounterOutputVideo))
      throw new GLException("Argument \"pulCounterOutputVideo\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetVideoInfoNV"));
    }
        return dispatch_wglGetVideoInfoNV0(hpVideoDevice, pulCounterOutputPbuffer, Buffers.getDirectBufferByteOffset(pulCounterOutputPbuffer), pulCounterOutputVideo, Buffers.getDirectBufferByteOffset(pulCounterOutputVideo), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo) </code> <br>Part of <code>WGL_NV_video_output</code><br>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_wglGetVideoInfoNV0(long hpVideoDevice, Object pulCounterOutputPbuffer, int pulCounterOutputPbuffer_byte_offset, Object pulCounterOutputVideo, int pulCounterOutputVideo_byte_offset, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public WGLExtImpl(WindowsWGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private WindowsWGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class WGLExtImpl
