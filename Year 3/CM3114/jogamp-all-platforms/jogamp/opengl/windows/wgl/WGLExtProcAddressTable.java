/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:20:16 CEST 2015 ----! */

package jogamp.opengl.windows.wgl;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.ProcAddressTable;
import com.jogamp.common.util.SecurityUtil;

/**
 * This table is a cache of pointers to the dynamically-linkable C library.
 * @see ProcAddressTable
 */
public final class WGLExtProcAddressTable extends ProcAddressTable {


  public WGLExtProcAddressTable(){ super(); }

  public WGLExtProcAddressTable(com.jogamp.gluegen.runtime.FunctionAddressResolver resolver){ super(resolver); }

  /* pp */ long _addressof_wglCreateBufferRegionARB;
  /* pp */ long _addressof_wglDeleteBufferRegionARB;
  /* pp */ long _addressof_wglSaveBufferRegionARB;
  /* pp */ long _addressof_wglRestoreBufferRegionARB;
  /* pp */ long _addressof_wglCreateContextAttribsARB;
  /* pp */ long _addressof_wglGetExtensionsStringARB;
  /* pp */ long _addressof_wglMakeContextCurrent;
  /* pp */ long _addressof_wglGetCurrentReadDC;
  /* pp */ long _addressof_wglCreatePbufferARB;
  /* pp */ long _addressof_wglGetPbufferDCARB;
  /* pp */ long _addressof_wglReleasePbufferDCARB;
  /* pp */ long _addressof_wglDestroyPbufferARB;
  /* pp */ long _addressof_wglQueryPbufferARB;
  /* pp */ long _addressof_wglGetPixelFormatAttribivARB;
  /* pp */ long _addressof_wglGetPixelFormatAttribfvARB;
  /* pp */ long _addressof_wglChoosePixelFormatARB;
  /* pp */ long _addressof_wglBindTexImageARB;
  /* pp */ long _addressof_wglReleaseTexImageARB;
  /* pp */ long _addressof_wglSetPbufferAttribARB;
  /* pp */ long _addressof_wglSetStereoEmitterState3DL;
  /* pp */ long _addressof_wglGetGPUIDsAMD;
  /* pp */ long _addressof_wglGetGPUInfoAMD;
  /* pp */ long _addressof_wglGetContextGPUIDAMD;
  /* pp */ long _addressof_wglCreateAssociatedContextAMD;
  /* pp */ long _addressof_wglCreateAssociatedContextAttribsAMD;
  /* pp */ long _addressof_wglDeleteAssociatedContextAMD;
  /* pp */ long _addressof_wglMakeAssociatedContextCurrentAMD;
  /* pp */ long _addressof_wglGetCurrentAssociatedContextAMD;
  /* pp */ long _addressof_wglBlitContextFramebufferAMD;
  /* pp */ long _addressof_wglCreateDisplayColorTableEXT;
  /* pp */ long _addressof_wglLoadDisplayColorTableEXT;
  /* pp */ long _addressof_wglBindDisplayColorTableEXT;
  /* pp */ long _addressof_wglDestroyDisplayColorTableEXT;
  /* pp */ long _addressof_wglGetExtensionsStringEXT;
  /* pp */ long _addressof_wglCreatePbufferEXT;
  /* pp */ long _addressof_wglGetPbufferDCEXT;
  /* pp */ long _addressof_wglReleasePbufferDCEXT;
  /* pp */ long _addressof_wglDestroyPbufferEXT;
  /* pp */ long _addressof_wglQueryPbufferEXT;
  /* pp */ long _addressof_wglGetPixelFormatAttribivEXT;
  /* pp */ long _addressof_wglGetPixelFormatAttribfvEXT;
  /* pp */ long _addressof_wglChoosePixelFormatEXT;
  /* pp */ long _addressof_wglSwapIntervalEXT;
  /* pp */ long _addressof_wglGetSwapIntervalEXT;
  /* pp */ long _addressof_wglEnableFrameLockI3D;
  /* pp */ long _addressof_wglDisableFrameLockI3D;
  /* pp */ long _addressof_wglIsEnabledFrameLockI3D;
  /* pp */ long _addressof_wglQueryFrameLockMasterI3D;
  /* pp */ long _addressof_wglGetFrameUsageI3D;
  /* pp */ long _addressof_wglBeginFrameTrackingI3D;
  /* pp */ long _addressof_wglEndFrameTrackingI3D;
  /* pp */ long _addressof_wglQueryFrameTrackingI3D;
  /* pp */ long _addressof_wglDXSetResourceShareHandleNV;
  /* pp */ long _addressof_wglDXOpenDeviceNV;
  /* pp */ long _addressof_wglDXCloseDeviceNV;
  /* pp */ long _addressof_wglDXRegisterObjectNV;
  /* pp */ long _addressof_wglDXUnregisterObjectNV;
  /* pp */ long _addressof_wglDXObjectAccessNV;
  /* pp */ long _addressof_wglDXLockObjectsNV;
  /* pp */ long _addressof_wglDXUnlockObjectsNV;
  /* pp */ long _addressof_wglCopyImageSubDataNV;
  /* pp */ long _addressof_wglDelayBeforeSwapNV;
  /* pp */ long _addressof_wglEnumerateVideoDevicesNV;
  /* pp */ long _addressof_wglBindVideoDeviceNV;
  /* pp */ long _addressof_wglQueryCurrentContextNV;
  /* pp */ long _addressof_wglJoinSwapGroupNV;
  /* pp */ long _addressof_wglBindSwapBarrierNV;
  /* pp */ long _addressof_wglQuerySwapGroupNV;
  /* pp */ long _addressof_wglQueryMaxSwapGroupsNV;
  /* pp */ long _addressof_wglQueryFrameCountNV;
  /* pp */ long _addressof_wglResetFrameCountNV;
  /* pp */ long _addressof_wglAllocateMemoryNV;
  /* pp */ long _addressof_wglFreeMemoryNV;
  /* pp */ long _addressof_wglBindVideoCaptureDeviceNV;
  /* pp */ long _addressof_wglEnumerateVideoCaptureDevicesNV;
  /* pp */ long _addressof_wglLockVideoCaptureDeviceNV;
  /* pp */ long _addressof_wglQueryVideoCaptureDeviceNV;
  /* pp */ long _addressof_wglReleaseVideoCaptureDeviceNV;
  /* pp */ long _addressof_wglGetVideoDeviceNV;
  /* pp */ long _addressof_wglReleaseVideoDeviceNV;
  /* pp */ long _addressof_wglBindVideoImageNV;
  /* pp */ long _addressof_wglReleaseVideoImageNV;
  /* pp */ long _addressof_wglSendPbufferToVideoNV;
  /* pp */ long _addressof_wglGetVideoInfoNV;
  @Override
  protected boolean isFunctionAvailableImpl(String functionNameUsr) throws IllegalArgumentException  {
    final String functionNameBase = com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeVEN(com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeARB(functionNameUsr, true), true);
    final String addressFieldNameBase = "_addressof_" + functionNameBase;
    final int funcNamePermNum = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutationNumber(functionNameBase);
    final java.lang.reflect.Field addressField = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<java.lang.reflect.Field>() {
        public final java.lang.reflect.Field run() {
            java.lang.reflect.Field addressField = null;
            for(int i = 0; i < funcNamePermNum; i++) {
                final String addressFieldName = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutation(addressFieldNameBase, i);
                try {
                    addressField = WGLExtProcAddressTable.class.getDeclaredField( addressFieldName );
                    addressField.setAccessible(true); // we need to read the protected value!
                    return addressField;
                } catch (NoSuchFieldException ex) { }
            }
            return null;
        } } );

    if(null==addressField) {
      // The user is calling a bogus function or one which is not
      // runtime linked
      throw new RuntimeException(
          "WARNING: Address field query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or address field is not a known " +
          "function");
    } 
    try {
      return 0 != addressField.getLong(this);
    } catch (Exception e) {
      throw new RuntimeException(
          "WARNING: Address query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or is not a known " +
          "function", e);
    }
  }
  @Override
  public long getAddressFor(String functionNameUsr) throws SecurityException, IllegalArgumentException {
    SecurityUtil.checkAllLinkPermission();
    final String functionNameBase = com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeVEN(com.jogamp.gluegen.runtime.opengl.GLNameResolver.normalizeARB(functionNameUsr, true), true);
    final String addressFieldNameBase = "_addressof_" + functionNameBase;
    final int  funcNamePermNum = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutationNumber(functionNameBase);
    final java.lang.reflect.Field addressField = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<java.lang.reflect.Field>() {
        public final java.lang.reflect.Field run() {
            java.lang.reflect.Field addressField = null;
            for(int i = 0; i < funcNamePermNum; i++) {
                final String addressFieldName = com.jogamp.gluegen.runtime.opengl.GLNameResolver.getFuncNamePermutation(addressFieldNameBase, i);
                try {
                    addressField = WGLExtProcAddressTable.class.getDeclaredField( addressFieldName );
                    addressField.setAccessible(true); // we need to read the protected value!
                    return addressField;
                } catch (NoSuchFieldException ex) { }
            }
            return null;
        } } );

    if(null==addressField) {
      // The user is calling a bogus function or one which is not
      // runtime linked
      throw new RuntimeException(
          "WARNING: Address field query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or address field is not a known " +
          "function");
    } 
    try {
      return addressField.getLong(this);
    } catch (Exception e) {
      throw new RuntimeException(
          "WARNING: Address query failed for \"" + functionNameBase + "\"/\"" + functionNameUsr +
          "\"; it's either statically linked or is not a known " +
          "function", e);
    }
  }
} // end of class WGLExtProcAddressTable
