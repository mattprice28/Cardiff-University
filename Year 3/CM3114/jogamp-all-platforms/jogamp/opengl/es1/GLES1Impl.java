/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Sat Oct 10 03:12:57 CEST 2015 ----! */

package jogamp.opengl.es1;

import java.util.*;
import com.jogamp.opengl.*;
import com.jogamp.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.opengl.GLES1;
import com.jogamp.opengl.GLES2;
import com.jogamp.opengl.GL2;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLES1Impl implements GLBase, GL, GL2ES1, GLES1{
  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_QCOM_alpha_test</code><br>Alias for: <code>glAlphaFuncQCOM</code>   */
  public void glAlphaFunc(int func, float ref)  {

    final long __addr_ = _pat._addressof_glAlphaFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAlphaFunc"));
    }
        dispatch_glAlphaFunc1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFunc}(GLenum func, GLclampf ref) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_QCOM_alpha_test</code><br>Alias for: <code>glAlphaFuncQCOM</code>   */
  private native void dispatch_glAlphaFunc1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColor"));
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat depth) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  public void glClearDepthf(float depth)  {

    final long __addr_ = _pat._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepthf"));
    }
        dispatch_glClearDepthf1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat depth) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClearDepthfOES</code>   */
  private native void dispatch_glClearDepthf1(float depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClipPlanef(int plane, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
    }
        dispatch_glClipPlanef1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClipPlanef1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanef}(GLenum plane, const GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_IMG_user_clip_plane</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glClipPlanefIMG</code>, <code>glClipPlanefOES</code>   */
  public void glClipPlanef(int plane, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanef"));
    }
        dispatch_glClipPlanef1(plane, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColor4f(float red, float green, float blue, float alpha)  {

    final long __addr_ = _pat._addressof_glColor4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4f"));
    }
        dispatch_glColor4f1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4f}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4f1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  public void glDepthRangef(float zNear, float zFar)  {

    final long __addr_ = _pat._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangef"));
    }
        dispatch_glDepthRangef1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLclampf zNear, GLclampf zFar) </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glDepthRangefOES</code>   */
  private native void dispatch_glDepthRangef1(float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFogf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glFogf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogf"));
    }
        dispatch_glFogf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFogf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glFogfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
    }
        dispatch_glFogfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glFogfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFogfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glFogfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogfv"));
    }
        dispatch_glFogfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glFrustumfOES</code>   */
  public void glFrustumf(float left, float right, float bottom, float top, float zNear, float zFar)  {

    final long __addr_ = _pat._addressof_glFrustumf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrustumf"));
    }
        dispatch_glFrustumf1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumf}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glFrustumfOES</code>   */
  private native void dispatch_glFrustumf1(float left, float right, float bottom, float top, float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetClipPlanef(int pname, FloatBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
    }
        dispatch_glGetClipPlanef1(pname, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>
      @param equation a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetClipPlanef1(int pname, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanef}(GLenum pname, GLfloat *  equation) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glGetClipPlanefOES</code>   */
  public void glGetClipPlanef(int pname, float[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glGetClipPlanef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanef"));
    }
        dispatch_glGetClipPlanef1(pname, equation, Buffers.SIZEOF_FLOAT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
    }
        dispatch_glGetLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightfv}(GLenum light, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightfv"));
    }
        dispatch_glGetLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
    }
        dispatch_glGetMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialfv}(GLenum face, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialfv"));
    }
        dispatch_glGetMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexEnvfv(int tenv, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
    }
        dispatch_glGetTexEnvfv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexEnvfv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvfv}(GLenum tenv, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexEnvfv(int tenv, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvfv"));
    }
        dispatch_glGetTexEnvfv1(tenv, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightModelf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glLightModelf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelf"));
    }
        dispatch_glLightModelf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLightModelf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightModelfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
    }
        dispatch_glLightModelfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightModelfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightModelfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightModelfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelfv"));
    }
        dispatch_glLightModelfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightf(int light, int pname, float param)  {

    final long __addr_ = _pat._addressof_glLightf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightf"));
    }
        dispatch_glLightf1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightf}(GLenum light, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLightf1(int light, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLightfv(int light, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
    }
        dispatch_glLightfv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLightfv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightfv}(GLenum light, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLightfv(int light, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightfv"));
    }
        dispatch_glLightfv1(light, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLineWidth(float width)  {

    final long __addr_ = _pat._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineWidth"));
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glLoadMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
    }
        dispatch_glLoadMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glLoadMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLoadMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixf"));
    }
        dispatch_glLoadMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMaterialf(int face, int pname, float param)  {

    final long __addr_ = _pat._addressof_glMaterialf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialf"));
    }
        dispatch_glMaterialf1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialf}(GLenum face, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMaterialf1(int face, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMaterialfv(int face, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
    }
        dispatch_glMaterialfv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMaterialfv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialfv}(GLenum face, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMaterialfv(int face, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMaterialfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialfv"));
    }
        dispatch_glMaterialfv1(face, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glMultMatrixf(FloatBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
    }
        dispatch_glMultMatrixf1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param m a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glMultMatrixf1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixf}(const GLfloat *  m) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMultMatrixf(float[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultMatrixf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixf"));
    }
        dispatch_glMultMatrixf1(m, Buffers.SIZEOF_FLOAT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fARB</code>   */
  public void glMultiTexCoord4f(int target, float s, float t, float r, float q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4f"));
    }
        dispatch_glMultiTexCoord4f1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4f}(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glMultiTexCoord4fARB</code>   */
  private native void dispatch_glMultiTexCoord4f1(int target, float s, float t, float r, float q, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glNormal3f(float nx, float ny, float nz)  {

    final long __addr_ = _pat._addressof_glNormal3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3f"));
    }
        dispatch_glNormal3f1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3f}(GLfloat nx, GLfloat ny, GLfloat nz) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glNormal3f1(float nx, float ny, float nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glOrthofOES</code>   */
  public void glOrthof(float left, float right, float bottom, float top, float zNear, float zFar)  {

    final long __addr_ = _pat._addressof_glOrthof;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glOrthof"));
    }
        dispatch_glOrthof1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthof}(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_OES_single_precision</code><br>Alias for: <code>glOrthofOES</code>   */
  private native void dispatch_glOrthof1(float left, float right, float bottom, float top, float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code>, <code>GL_SGIS_point_parameters</code><br>Alias for: <code>glPointParameterfEXT</code>, <code>glPointParameterfARB</code>, <code>glPointParameterfSGIS</code>   */
  public void glPointParameterf(int pname, float param)  {

    final long __addr_ = _pat._addressof_glPointParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterf"));
    }
        dispatch_glPointParameterf1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterf}(GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code>, <code>GL_SGIS_point_parameters</code><br>Alias for: <code>glPointParameterfEXT</code>, <code>glPointParameterfARB</code>, <code>glPointParameterfSGIS</code>   */
  private native void dispatch_glPointParameterf1(int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glPointParameterfv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
    }
        dispatch_glPointParameterfv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glPointParameterfv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterfv}(GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_4</code>, <code>GL_SGIS_point_parameters</code>, <code>GL_EXT_point_parameters</code>, <code>GL_ARB_point_parameters</code><br>Alias for: <code>glPointParameterfvSGIS</code>, <code>glPointParameterfvEXT</code>, <code>glPointParameterfvARB</code>   */
  public void glPointParameterfv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPointParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterfv"));
    }
        dispatch_glPointParameterfv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPointSize(float size)  {

    final long __addr_ = _pat._addressof_glPointSize;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointSize"));
    }
        dispatch_glPointSize1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSize}(GLfloat size) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPointSize1(float size, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = _pat._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffset"));
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_EXT_polygon_offset</code><br>Alias for: <code>glPolygonOffsetEXT</code>   */
  private native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glRotatef(float angle, float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glRotatef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRotatef"));
    }
        dispatch_glRotatef1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatef}(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glRotatef1(float angle, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glScalef(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glScalef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScalef"));
    }
        dispatch_glScalef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScalef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvf(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexEnvf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvf"));
    }
        dispatch_glTexEnvf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexEnvf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexEnvfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
    }
        dispatch_glTexEnvfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexEnvfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexEnvfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvfv"));
    }
        dispatch_glTexEnvfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterf"));
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTranslatef(float x, float y, float z)  {

    final long __addr_ = _pat._addressof_glTranslatef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTranslatef"));
    }
        dispatch_glTranslatef1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatef}(GLfloat x, GLfloat y, GLfloat z) </code> <br>Part of <code>GL_VERSION_ES_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTranslatef1(float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = _pat._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveTexture"));
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glActiveTextureARB</code>   */
  private native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFuncx}(GLenum func, GLclampx ref) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glAlphaFuncxOES</code>   */
  public void glAlphaFuncx(int func, int ref)  {

    final long __addr_ = _pat._addressof_glAlphaFuncx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAlphaFuncx"));
    }
        dispatch_glAlphaFuncx1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFuncx}(GLenum func, GLclampx ref) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glAlphaFuncxOES</code>   */
  private native void dispatch_glAlphaFuncx1(int func, int ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = _pat._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffer"));
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBindBufferARB</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = _pat._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTexture"));
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glBindTextureEXT</code>   */
  private native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = _pat._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunc"));
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private void glBufferDataDelegate(int target, long size, Buffer data, int usage)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferData"));
    }
        dispatch_glBufferDataDelegate1(target, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, usage, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferData}(GLenum target, GLsizeiptr size, const GLvoid *  data, GLenum usage) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met or the native GL-function fails.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if size is less-than zero
   * @throws GLException if a native GL-Error occurs
   * </p>
   */
  private native void dispatch_glBufferDataDelegate1(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferSubData"));
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glBufferSubDataARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClear(int mask)  {

    final long __addr_ = _pat._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClear"));
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearColorx}(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glClearColorxOES</code>   */
  public void glClearColorx(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glClearColorx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColorx"));
    }
        dispatch_glClearColorx1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColorx}(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glClearColorxOES</code>   */
  private native void dispatch_glClearColorx1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthx}(GLclampx depth) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glClearDepthxOES</code>   */
  public void glClearDepthx(int depth)  {

    final long __addr_ = _pat._addressof_glClearDepthx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepthx"));
    }
        dispatch_glClearDepthx1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthx}(GLclampx depth) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glClearDepthxOES</code>   */
  private native void dispatch_glClearDepthx1(int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glClearStencil(int s)  {

    final long __addr_ = _pat._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearStencil"));
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glClientActiveTextureARB</code>   */
  public void glClientActiveTexture(int texture)  {

    final long __addr_ = _pat._addressof_glClientActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientActiveTexture"));
    }
        dispatch_glClientActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClientActiveTexture}(GLenum texture) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multitexture</code><br>Alias for: <code>glClientActiveTextureARB</code>   */
  private native void dispatch_glClientActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code>, <code>GL_IMG_user_clip_plane</code><br>Alias for: <code>glClipPlanexOES</code>, <code>glClipPlanexIMG</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClipPlanex(int plane, IntBuffer equation)  {

    final boolean equation_is_direct = Buffers.isDirect(equation);
    final long __addr_ = _pat._addressof_glClipPlanex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanex"));
    }
        dispatch_glClipPlanex1(plane, equation_is_direct ? equation : Buffers.getArray(equation), equation_is_direct ? Buffers.getDirectBufferByteOffset(equation) : Buffers.getIndirectBufferByteOffset(equation), equation_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code>, <code>GL_IMG_user_clip_plane</code><br>Alias for: <code>glClipPlanexOES</code>, <code>glClipPlanexIMG</code>
      @param equation a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClipPlanex1(int plane, Object equation, int equation_byte_offset, boolean equation_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanex}(GLenum plane, const GLfixed *  equation) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code>, <code>GL_IMG_user_clip_plane</code><br>Alias for: <code>glClipPlanexOES</code>, <code>glClipPlanexIMG</code>   */
  public void glClipPlanex(int plane, int[] equation, int equation_offset)  {

    if(equation != null && equation.length <= equation_offset)
      throw new GLException("array offset argument \"equation_offset\" (" + equation_offset + ") equals or exceeds array length (" + equation.length + ")");
    final long __addr_ = _pat._addressof_glClipPlanex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanex"));
    }
        dispatch_glClipPlanex1(plane, equation, Buffers.SIZEOF_INT * equation_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColor4ub(byte red, byte green, byte blue, byte alpha)  {

    final long __addr_ = _pat._addressof_glColor4ub;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4ub"));
    }
        dispatch_glColor4ub1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4ub}(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColor4ub1(byte red, byte green, byte blue, byte alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColor4x}(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glColor4xOES</code>   */
  public void glColor4x(int red, int green, int blue, int alpha)  {

    final long __addr_ = _pat._addressof_glColor4x;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColor4x"));
    }
        dispatch_glColor4x1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColor4x}(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glColor4xOES</code>   */
  private native void dispatch_glColor4x1(int red, int green, int blue, int alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = _pat._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMask"));
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glColorPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
    }
        dispatch_glColorPointer0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glColorPointer0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>   */
  public void glColorPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glColorPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorPointer"));
    }
        dispatch_glColorPointer0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glColorPointerEXT</code>   */
  private native void dispatch_glColorPointer0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexImage2DARB</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_texture_compression</code><br>Alias for: <code>glCompressedTexSubImage2DARB</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = _pat._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage2D"));
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexImage2DEXT</code>   */
  private native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage2D"));
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_copy_texture</code><br>Alias for: <code>glCopyTexSubImage2DEXT</code>   */
  private native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glCullFace(int mode)  {

    final long __addr_ = _pat._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullFace"));
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers);
    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glDeleteBuffersARB</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers, buffers_offset);
    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glDeleteTexturesEXT</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = _pat._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthFunc"));
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = _pat._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthMask"));
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangex}(GLclampx zNear, GLclampx zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glDepthRangexOES</code>   */
  public void glDepthRangex(int zNear, int zFar)  {

    final long __addr_ = _pat._addressof_glDepthRangex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangex"));
    }
        dispatch_glDepthRangex1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangex}(GLclampx zNear, GLclampx zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glDepthRangexOES</code>   */
  private native void dispatch_glDepthRangex1(int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glDisable(int cap)  {

    final long __addr_ = _pat._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisable"));
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum array) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glDisableClientState(int array)  {

    final long __addr_ = _pat._addressof_glDisableClientState;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableClientState"));
    }
        dispatch_glDisableClientState1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableClientState}(GLenum array) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glDisableClientState1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = _pat._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArrays"));
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glDrawArraysEXT</code>   */
  private native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = _pat._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glEnable(int cap)  {

    final long __addr_ = _pat._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnable"));
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum array) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  public void glEnableClientState(int array)  {

    final long __addr_ = _pat._addressof_glEnableClientState;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableClientState"));
    }
        dispatch_glEnableClientState1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableClientState}(GLenum array) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code><br>   */
  private native void dispatch_glEnableClientState1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFinish()  {

    final long __addr_ = _pat._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinish"));
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFlush()  {

    final long __addr_ = _pat._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlush"));
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFogx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFogxOES</code>   */
  public void glFogx(int pname, int param)  {

    final long __addr_ = _pat._addressof_glFogx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogx"));
    }
        dispatch_glFogx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFogxOES</code>   */
  private native void dispatch_glFogx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFogxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glFogxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glFogxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogxv"));
    }
        dispatch_glFogxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFogxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glFogxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glFogxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFogxvOES</code>   */
  public void glFogxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glFogxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFogxv"));
    }
        dispatch_glFogxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = _pat._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrontFace"));
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrustumx}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFrustumxOES</code>   */
  public void glFrustumx(int left, int right, int bottom, int top, int zNear, int zFar)  {

    final long __addr_ = _pat._addressof_glFrustumx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrustumx"));
    }
        dispatch_glFrustumx1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrustumx}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glFrustumxOES</code>   */
  private native void dispatch_glFrustumx1(int left, int right, int bottom, int top, int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGetBufferParameterivARB</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetClipPlanexOES</code>
      @param eqn a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetClipPlanex(int pname, IntBuffer eqn)  {

    final boolean eqn_is_direct = Buffers.isDirect(eqn);
    final long __addr_ = _pat._addressof_glGetClipPlanex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanex"));
    }
        dispatch_glGetClipPlanex1(pname, eqn_is_direct ? eqn : Buffers.getArray(eqn), eqn_is_direct ? Buffers.getDirectBufferByteOffset(eqn) : Buffers.getIndirectBufferByteOffset(eqn), eqn_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetClipPlanexOES</code>
      @param eqn a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetClipPlanex1(int pname, Object eqn, int eqn_byte_offset, boolean eqn_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetClipPlanex}(GLenum pname, GLfixed *  eqn) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetClipPlanexOES</code>   */
  public void glGetClipPlanex(int pname, int[] eqn, int eqn_offset)  {

    if(eqn != null && eqn.length <= eqn_offset)
      throw new GLException("array offset argument \"eqn_offset\" (" + eqn_offset + ") equals or exceeds array length (" + eqn.length + ")");
    final long __addr_ = _pat._addressof_glGetClipPlanex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetClipPlanex"));
    }
        dispatch_glGetClipPlanex1(pname, eqn, Buffers.SIZEOF_INT * eqn_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glGenBuffersARB</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = _pat._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glGenTexturesEXT</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = _pat._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public int glGetError()  {

    final long __addr_ = _pat._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetError"));
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetFixedvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFixedv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFixedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFixedv"));
    }
        dispatch_glGetFixedv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetFixedvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFixedv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFixedv}(GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetFixedvOES</code>   */
  public void glGetFixedv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFixedv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFixedv"));
    }
        dispatch_glGetFixedv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetLightxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetLightxv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetLightxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightxv"));
    }
        dispatch_glGetLightxv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetLightxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetLightxv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetLightxv}(GLenum light, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetLightxvOES</code>   */
  public void glGetLightxv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetLightxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetLightxv"));
    }
        dispatch_glGetLightxv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetMaterialxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetMaterialxv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetMaterialxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialxv"));
    }
        dispatch_glGetMaterialxv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetMaterialxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetMaterialxv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetMaterialxv}(GLenum face, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetMaterialxvOES</code>   */
  public void glGetMaterialxv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetMaterialxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetMaterialxv"));
    }
        dispatch_glGetMaterialxv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = _pat._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetString"));
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnviv(int tenv, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
    }
        dispatch_glGetTexEnviv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnviv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnviv}(GLenum tenv, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexEnviv(int tenv, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnviv"));
    }
        dispatch_glGetTexEnviv1(tenv, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexEnvxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexEnvxv(int tenv, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvxv"));
    }
        dispatch_glGetTexEnvxv1(tenv, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexEnvxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexEnvxv1(int tenv, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexEnvxv}(GLenum tenv, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexEnvxvOES</code>   */
  public void glGetTexEnvxv(int tenv, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexEnvxv"));
    }
        dispatch_glGetTexEnvxv1(tenv, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameterxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterxv"));
    }
        dispatch_glGetTexParameterxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameterxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterxv}(GLenum target, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glGetTexParameterxvOES</code>   */
  public void glGetTexParameterxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterxv"));
    }
        dispatch_glGetTexParameterxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = _pat._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHint"));
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_PGI_misc_hints</code><br>Alias for: <code>glHintPGI</code>   */
  private native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = _pat._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsBuffer"));
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glIsBufferARB</code>   */
  private native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = _pat._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabled"));
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap) </code> <br>Part of <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = _pat._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTexture"));
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_texture_object</code><br>Alias for: <code>glIsTextureEXT</code>   */
  private native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightModelxOES</code>   */
  public void glLightModelx(int pname, int param)  {

    final long __addr_ = _pat._addressof_glLightModelx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelx"));
    }
        dispatch_glLightModelx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightModelxOES</code>   */
  private native void dispatch_glLightModelx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightModelxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightModelxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightModelxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelxv"));
    }
        dispatch_glLightModelxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightModelxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightModelxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightModelxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightModelxvOES</code>   */
  public void glLightModelxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightModelxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightModelxv"));
    }
        dispatch_glLightModelxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightx}(GLenum light, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightxOES</code>   */
  public void glLightx(int light, int pname, int param)  {

    final long __addr_ = _pat._addressof_glLightx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightx"));
    }
        dispatch_glLightx1(light, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightx}(GLenum light, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightxOES</code>   */
  private native void dispatch_glLightx1(int light, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLightxv(int light, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glLightxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightxv"));
    }
        dispatch_glLightxv1(light, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLightxv1(int light, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLightxv}(GLenum light, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLightxvOES</code>   */
  public void glLightxv(int light, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glLightxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLightxv"));
    }
        dispatch_glLightxv1(light, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidthx}(GLfixed width) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLineWidthxOES</code>   */
  public void glLineWidthx(int width)  {

    final long __addr_ = _pat._addressof_glLineWidthx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineWidthx"));
    }
        dispatch_glLineWidthx1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidthx}(GLfixed width) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLineWidthxOES</code>   */
  private native void dispatch_glLineWidthx1(int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLoadIdentity()  {

    final long __addr_ = _pat._addressof_glLoadIdentity;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadIdentity"));
    }
        dispatch_glLoadIdentity1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadIdentity}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLoadIdentity1(long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLoadMatrixxOES</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glLoadMatrixx(IntBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glLoadMatrixx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixx"));
    }
        dispatch_glLoadMatrixx1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLoadMatrixxOES</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glLoadMatrixx1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glLoadMatrixxOES</code>   */
  public void glLoadMatrixx(int[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glLoadMatrixx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadMatrixx"));
    }
        dispatch_glLoadMatrixx1(m, Buffers.SIZEOF_INT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glLogicOp(int opcode)  {

    final long __addr_ = _pat._addressof_glLogicOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLogicOp"));
    }
        dispatch_glLogicOp1(opcode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLogicOp}(GLenum opcode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glLogicOp1(int opcode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialx}(GLenum face, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMaterialxOES</code>   */
  public void glMaterialx(int face, int pname, int param)  {

    final long __addr_ = _pat._addressof_glMaterialx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialx"));
    }
        dispatch_glMaterialx1(face, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialx}(GLenum face, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMaterialxOES</code>   */
  private native void dispatch_glMaterialx1(int face, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMaterialxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMaterialxv(int face, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glMaterialxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialxv"));
    }
        dispatch_glMaterialxv1(face, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMaterialxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMaterialxv1(int face, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMaterialxv}(GLenum face, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMaterialxvOES</code>   */
  public void glMaterialxv(int face, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glMaterialxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMaterialxv"));
    }
        dispatch_glMaterialxv1(face, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glMatrixMode(int mode)  {

    final long __addr_ = _pat._addressof_glMatrixMode;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixMode"));
    }
        dispatch_glMatrixMode1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixMode}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glMatrixMode1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMultMatrixxOES</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glMultMatrixx(IntBuffer m)  {

    final boolean m_is_direct = Buffers.isDirect(m);
    final long __addr_ = _pat._addressof_glMultMatrixx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixx"));
    }
        dispatch_glMultMatrixx1(m_is_direct ? m : Buffers.getArray(m), m_is_direct ? Buffers.getDirectBufferByteOffset(m) : Buffers.getIndirectBufferByteOffset(m), m_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMultMatrixxOES</code>
      @param m a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glMultMatrixx1(Object m, int m_byte_offset, boolean m_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glMultMatrixx}(const GLfixed *  m) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMultMatrixxOES</code>   */
  public void glMultMatrixx(int[] m, int m_offset)  {

    if(m != null && m.length <= m_offset)
      throw new GLException("array offset argument \"m_offset\" (" + m_offset + ") equals or exceeds array length (" + m.length + ")");
    final long __addr_ = _pat._addressof_glMultMatrixx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultMatrixx"));
    }
        dispatch_glMultMatrixx1(m, Buffers.SIZEOF_INT * m_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4x}(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMultiTexCoord4xOES</code>   */
  public void glMultiTexCoord4x(int target, int s, int t, int r, int q)  {

    final long __addr_ = _pat._addressof_glMultiTexCoord4x;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMultiTexCoord4x"));
    }
        dispatch_glMultiTexCoord4x1(target, s, t, r, q, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMultiTexCoord4x}(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glMultiTexCoord4xOES</code>   */
  private native void dispatch_glMultiTexCoord4x1(int target, int s, int t, int r, int q, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormal3x}(GLfixed nx, GLfixed ny, GLfixed nz) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glNormal3xOES</code>   */
  public void glNormal3x(int nx, int ny, int nz)  {

    final long __addr_ = _pat._addressof_glNormal3x;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormal3x"));
    }
        dispatch_glNormal3x1(nx, ny, nz, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormal3x}(GLfixed nx, GLfixed ny, GLfixed nz) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glNormal3xOES</code>   */
  private native void dispatch_glNormal3x1(int nx, int ny, int nz, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glNormalPointer(int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
    }
        dispatch_glNormalPointer0(type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glNormalPointer0(int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>   */
  public void glNormalPointer(int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glNormalPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glNormalPointer"));
    }
        dispatch_glNormalPointer0(type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glNormalPointer}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glNormalPointerEXT</code>   */
  private native void dispatch_glNormalPointer0(int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glOrthox}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glOrthoxOES</code>   */
  public void glOrthox(int left, int right, int bottom, int top, int zNear, int zFar)  {

    final long __addr_ = _pat._addressof_glOrthox;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glOrthox"));
    }
        dispatch_glOrthox1(left, right, bottom, top, zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glOrthox}(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glOrthoxOES</code>   */
  private native void dispatch_glOrthox1(int left, int right, int bottom, int top, int zNear, int zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPixelStorei(int pname, int param)  {

    if (pname != GL_PACK_ALIGNMENT && pname != GL_UNPACK_ALIGNMENT) {
    throw new GLException("Unsupported pixel store parameter name 0x" + Integer.toHexString(pname));
    }
    glStateTracker.setInt(pname, param);
    final long __addr_ = _pat._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelStorei"));
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointParameterxOES</code>   */
  public void glPointParameterx(int pname, int param)  {

    final long __addr_ = _pat._addressof_glPointParameterx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterx"));
    }
        dispatch_glPointParameterx1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterx}(GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointParameterxOES</code>   */
  private native void dispatch_glPointParameterx1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glPointParameterxv(int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glPointParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterxv"));
    }
        dispatch_glPointParameterxv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glPointParameterxv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointParameterxv}(GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointParameterxvOES</code>   */
  public void glPointParameterxv(int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glPointParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointParameterxv"));
    }
        dispatch_glPointParameterxv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSizex}(GLfixed size) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointSizexOES</code>   */
  public void glPointSizex(int size)  {

    final long __addr_ = _pat._addressof_glPointSizex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointSizex"));
    }
        dispatch_glPointSizex1(size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSizex}(GLfixed size) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPointSizexOES</code>   */
  private native void dispatch_glPointSizex1(int size, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffsetx}(GLfixed factor, GLfixed units) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPolygonOffsetxOES</code>   */
  public void glPolygonOffsetx(int factor, int units)  {

    final long __addr_ = _pat._addressof_glPolygonOffsetx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffsetx"));
    }
        dispatch_glPolygonOffsetx1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffsetx}(GLfixed factor, GLfixed units) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glPolygonOffsetxOES</code>   */
  private native void dispatch_glPolygonOffsetx1(int factor, int units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPopMatrix()  {

    final long __addr_ = _pat._addressof_glPopMatrix;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopMatrix"));
    }
        dispatch_glPopMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPopMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glPushMatrix()  {

    final long __addr_ = _pat._addressof_glPushMatrix;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushMatrix"));
    }
        dispatch_glPushMatrix1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushMatrix}(void) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glPushMatrix1(long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = _pat._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glRotatex}(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glRotatexOES</code>   */
  public void glRotatex(int angle, int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glRotatex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRotatex"));
    }
        dispatch_glRotatex1(angle, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRotatex}(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glRotatexOES</code>   */
  private native void dispatch_glRotatex1(int angle, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = _pat._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleCoverage"));
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLclampf value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_ARB_multisample</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoverageARB</code>, <code>glSampleCoverageOES</code>   */
  private native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoveragex}(GLclampx value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoveragexOES</code>   */
  public void glSampleCoveragex(int value, boolean invert)  {

    final long __addr_ = _pat._addressof_glSampleCoveragex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleCoveragex"));
    }
        dispatch_glSampleCoveragex1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoveragex}(GLclampx value, GLboolean invert) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glSampleCoveragexOES</code>   */
  private native void dispatch_glSampleCoveragex1(int value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glScalex}(GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glScalexOES</code>   */
  public void glScalex(int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glScalex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScalex"));
    }
        dispatch_glScalex1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScalex}(GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glScalexOES</code>   */
  private native void dispatch_glScalex1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissor"));
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glShadeModel(int mode)  {

    final long __addr_ = _pat._addressof_glShadeModel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShadeModel"));
    }
        dispatch_glShadeModel1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShadeModel}(GLenum mode) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glShadeModel1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = _pat._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFunc"));
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = _pat._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMask"));
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = _pat._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOp"));
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glTexCoordPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
    }
        dispatch_glTexCoordPointer0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glTexCoordPointer0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>   */
  public void glTexCoordPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glTexCoordPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexCoordPointer"));
    }
        dispatch_glTexCoordPointer0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexCoordPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glTexCoordPointerEXT</code>   */
  private native void dispatch_glTexCoordPointer0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnvi(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexEnvi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvi"));
    }
        dispatch_glTexEnvi1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvi}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexEnvi1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvx}(GLenum target, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexEnvxOES</code>   */
  public void glTexEnvx(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexEnvx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvx"));
    }
        dispatch_glTexEnvx1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvx}(GLenum target, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexEnvxOES</code>   */
  private native void dispatch_glTexEnvx1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnviv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
    }
        dispatch_glTexEnviv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnviv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnviv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexEnviv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexEnviv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnviv"));
    }
        dispatch_glTexEnviv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexEnvxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexEnvxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvxv"));
    }
        dispatch_glTexEnvxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexEnvxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexEnvxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexEnvxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexEnvxvOES</code>   */
  public void glTexEnvxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexEnvxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexEnvxv"));
    }
        dispatch_glTexEnvxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteri"));
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterx}(GLenum target, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexParameterxOES</code>   */
  public void glTexParameterx(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexParameterx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterx"));
    }
        dispatch_glTexParameterx1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterx}(GLenum target, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexParameterxOES</code>   */
  private native void dispatch_glTexParameterx1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameterxv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterxv"));
    }
        dispatch_glTexParameterxv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexParameterxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameterxv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterxv}(GLenum target, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTexParameterxvOES</code>   */
  public void glTexParameterxv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexParameterxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterxv"));
    }
        dispatch_glTexParameterxv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format,  type, width, height, 1  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = _pat._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_subtexture</code><br>Alias for: <code>glTexSubImage2DEXT</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTranslatex}(GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTranslatexOES</code>   */
  public void glTranslatex(int x, int y, int z)  {

    final long __addr_ = _pat._addressof_glTranslatex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTranslatex"));
    }
        dispatch_glTranslatex1(x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTranslatex}(GLfixed x, GLfixed y, GLfixed z) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_OES_fixed_point</code><br>Alias for: <code>glTranslatexOES</code>   */
  private native void dispatch_glTranslatex1(int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexPointer(int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
    }
        dispatch_glVertexPointer0(size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexPointer0(int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>   */
  public void glVertexPointer(int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = _pat._addressof_glVertexPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexPointer"));
    }
        dispatch_glVertexPointer0(size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexPointer}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_EXT_vertex_array</code><br>Alias for: <code>glVertexPointerEXT</code>   */
  private native void dispatch_glVertexPointer0(int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = _pat._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewport"));
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code><br>   */
  private native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glPointSizePointerOES}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_point_size_array</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glPointSizePointerOES(int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glPointSizePointerOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPointSizePointerOES"));
    }
        dispatch_glPointSizePointerOES1(type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPointSizePointerOES}(GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_point_size_array</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glPointSizePointerOES1(int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage1D"));
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage1DEXT</code>   */
  private native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2D"));
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage2DEXT</code>   */
  private native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3D"));
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_ARB_texture_storage</code>, <code>GL_VERSION_4_2</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_EXT_texture_storage</code><br>Alias for: <code>glTexStorage3DEXT</code>   */
  private native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage1DEXT(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = _pat._addressof_glTextureStorage1DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1DEXT"));
    }
        dispatch_glTextureStorage1DEXT1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage1DEXT1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage2DEXT(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glTextureStorage2DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2DEXT"));
    }
        dispatch_glTextureStorage2DEXT1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage2DEXT1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  public void glTextureStorage3DEXT(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = _pat._addressof_glTextureStorage3DEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3DEXT"));
    }
        dispatch_glTextureStorage3DEXT1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3DEXT}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>, <code>GL_EXT_direct_state_access</code><br>   */
  private native void dispatch_glTextureStorage3DEXT1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = _pat._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparate"));
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>, <code>GL_OES_blend_equation_separate</code>, <code>GL_EXT_blend_equation_separate</code><br>Alias for: <code>glBlendEquationSeparateOES</code>, <code>glBlendEquationSeparateEXT</code>   */
  private native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  public void glBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = _pat._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparate"));
    }
        dispatch_glBlendFuncSeparate1(srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_INGR_blend_func_separate</code>, <code>GL_OES_blend_func_separate</code>, <code>GL_EXT_blend_func_separate</code><br>Alias for: <code>glBlendFuncSeparateINGR</code>, <code>glBlendFuncSeparateOES</code>, <code>glBlendFuncSeparateEXT</code>   */
  private native void dispatch_glBlendFuncSeparate1(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = _pat._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquation"));
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_1_4</code>, <code>GL_VERSION_1_2</code>, <code>GL_OES_blend_subtract</code>, <code>GL_EXT_blend_minmax</code><br>Alias for: <code>glBlendEquationOES</code>, <code>glBlendEquationEXT</code>   */
  private native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexsOES}(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexsOES(short x, short y, short z, short width, short height)  {

    final long __addr_ = _pat._addressof_glDrawTexsOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexsOES"));
    }
        dispatch_glDrawTexsOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexsOES}(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  private native void dispatch_glDrawTexsOES1(short x, short y, short z, short width, short height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexiOES}(GLint x, GLint y, GLint z, GLint width, GLint height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexiOES(int x, int y, int z, int width, int height)  {

    final long __addr_ = _pat._addressof_glDrawTexiOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexiOES"));
    }
        dispatch_glDrawTexiOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexiOES}(GLint x, GLint y, GLint z, GLint width, GLint height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  private native void dispatch_glDrawTexiOES1(int x, int y, int z, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexxOES}(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexxOES(int x, int y, int z, int width, int height)  {

    final long __addr_ = _pat._addressof_glDrawTexxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexxOES"));
    }
        dispatch_glDrawTexxOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxOES}(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  private native void dispatch_glDrawTexxOES1(int x, int y, int z, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.ShortBuffer}   */
  public void glDrawTexsvOES(ShortBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glDrawTexsvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexsvOES"));
    }
        dispatch_glDrawTexsvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.ShortBuffer}   */
  private native void dispatch_glDrawTexsvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexsvOES}(const GLshort *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexsvOES(short[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glDrawTexsvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexsvOES"));
    }
        dispatch_glDrawTexsvOES1(coords, Buffers.SIZEOF_SHORT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawTexivOES(IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glDrawTexivOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexivOES"));
    }
        dispatch_glDrawTexivOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawTexivOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexivOES}(const GLint *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexivOES(int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glDrawTexivOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexivOES"));
    }
        dispatch_glDrawTexivOES1(coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawTexxvOES(IntBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glDrawTexxvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexxvOES"));
    }
        dispatch_glDrawTexxvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawTexxvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexxvOES}(const GLfixed *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexxvOES(int[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glDrawTexxvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexxvOES"));
    }
        dispatch_glDrawTexxvOES1(coords, Buffers.SIZEOF_INT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexfOES}(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexfOES(float x, float y, float z, float width, float height)  {

    final long __addr_ = _pat._addressof_glDrawTexfOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexfOES"));
    }
        dispatch_glDrawTexfOES1(x, y, z, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexfOES}(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  private native void dispatch_glDrawTexfOES1(float x, float y, float z, float width, float height, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glDrawTexfvOES(FloatBuffer coords)  {

    final boolean coords_is_direct = Buffers.isDirect(coords);
    final long __addr_ = _pat._addressof_glDrawTexfvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexfvOES"));
    }
        dispatch_glDrawTexfvOES1(coords_is_direct ? coords : Buffers.getArray(coords), coords_is_direct ? Buffers.getDirectBufferByteOffset(coords) : Buffers.getIndirectBufferByteOffset(coords), coords_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>
      @param coords a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glDrawTexfvOES1(Object coords, int coords_byte_offset, boolean coords_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawTexfvOES}(const GLfloat *  coords) </code> <br>Part of <code>GL_OES_draw_texture</code><br>   */
  public void glDrawTexfvOES(float[] coords, int coords_offset)  {

    if(coords != null && coords.length <= coords_offset)
      throw new GLException("array offset argument \"coords_offset\" (" + coords_offset + ") equals or exceeds array length (" + coords.length + ")");
    final long __addr_ = _pat._addressof_glDrawTexfvOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawTexfvOES"));
    }
        dispatch_glDrawTexfvOES1(coords, Buffers.SIZEOF_FLOAT * coords_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  public void glEGLImageTargetTexture2DOES(int target, long image)  {

    final long __addr_ = _pat._addressof_glEGLImageTargetTexture2DOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetTexture2DOES"));
    }
        dispatch_glEGLImageTargetTexture2DOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  private native void dispatch_glEGLImageTargetTexture2DOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  public void glEGLImageTargetRenderbufferStorageOES(int target, long image)  {

    final long __addr_ = _pat._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetRenderbufferStorageOES"));
    }
        dispatch_glEGLImageTargetRenderbufferStorageOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image) </code> <br>Part of <code>GL_OES_EGL_image</code><br>   */
  private native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = _pat._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsRenderbuffer"));
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glIsRenderbufferOES</code>, <code>glIsRenderbufferEXT</code>   */
  private native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindRenderbuffer"));
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glBindRenderbufferEXT</code>, <code>glBindRenderbufferOES</code>   */
  private native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteRenderbuffersOES</code>, <code>glDeleteRenderbuffersEXT</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGenRenderbuffersEXT</code>, <code>glGenRenderbuffersOES</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorage"));
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glRenderbufferStorageEXT</code>, <code>glRenderbufferStorageOES</code>   */
  private native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetRenderbufferParameterivEXT</code>, <code>glGetRenderbufferParameterivOES</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = _pat._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsFramebuffer"));
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glIsFramebufferEXT</code>, <code>glIsFramebufferOES</code>   */
  private native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = _pat._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFramebuffer"));
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glBindFramebufferOES</code>, <code>glBindFramebufferEXT</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glDeleteFramebuffersOES</code>, <code>glDeleteFramebuffersEXT</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenFramebuffersOES</code>, <code>glGenFramebuffersEXT</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = _pat._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = _pat._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckFramebufferStatus"));
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glCheckFramebufferStatusEXT</code>, <code>glCheckFramebufferStatusOES</code>   */
  private native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = _pat._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferRenderbuffer"));
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glFramebufferRenderbufferOES</code>, <code>glFramebufferRenderbufferEXT</code>   */
  private native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2D"));
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glFramebufferTexture2DEXT</code>, <code>glFramebufferTexture2DOES</code>   */
  private native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_framebuffer_object</code>, <code>GL_OES_framebuffer_object</code><br>Alias for: <code>glGetFramebufferAttachmentParameterivEXT</code>, <code>glGetFramebufferAttachmentParameterivOES</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = _pat._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateMipmap"));
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target) </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_OES_framebuffer_object</code>, <code>GL_EXT_framebuffer_object</code><br>Alias for: <code>glGenerateMipmapOES</code>, <code>glGenerateMipmapEXT</code>   */
  private native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private long glMapBufferDelegate(int target, int access)  {

    final long __addr_ = _pat._addressof_glMapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBuffer"));
    }
        return dispatch_glMapBufferDelegate1(target, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBuffer}(GLenum target, GLenum access) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glMapBufferOES</code>, <code>glMapBufferARB</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBuffer(int, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * </p>
   */
  private native long dispatch_glMapBufferDelegate1(int target, int access, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private boolean glUnmapBufferDelegate(int target)  {

    final long __addr_ = _pat._addressof_glUnmapBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUnmapBuffer"));
    }
        return dispatch_glUnmapBufferDelegate1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glUnmapBuffer}(GLenum target) </code> <br>Part of <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_OES_mapbuffer</code>, <code>GL_ARB_vertex_buffer_object</code><br>Alias for: <code>glUnmapBufferOES</code>, <code>glUnmapBufferARB</code>   */
  private native boolean dispatch_glUnmapBufferDelegate1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixOES}(GLuint matrixpaletteindex) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>   */
  public void glCurrentPaletteMatrixOES(int matrixpaletteindex)  {

    final long __addr_ = _pat._addressof_glCurrentPaletteMatrixOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCurrentPaletteMatrixOES"));
    }
        dispatch_glCurrentPaletteMatrixOES1(matrixpaletteindex, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCurrentPaletteMatrixOES}(GLuint matrixpaletteindex) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>   */
  private native void dispatch_glCurrentPaletteMatrixOES1(int matrixpaletteindex, long procAddress);

  /** Entry point to C language function: <code> void {@native glLoadPaletteFromModelViewMatrixOES}(void) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>   */
  public void glLoadPaletteFromModelViewMatrixOES()  {

    final long __addr_ = _pat._addressof_glLoadPaletteFromModelViewMatrixOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLoadPaletteFromModelViewMatrixOES"));
    }
        dispatch_glLoadPaletteFromModelViewMatrixOES1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glLoadPaletteFromModelViewMatrixOES}(void) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>   */
  private native void dispatch_glLoadPaletteFromModelViewMatrixOES1(long procAddress);

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glMatrixIndexPointerOES(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glMatrixIndexPointerOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMatrixIndexPointerOES"));
    }
        dispatch_glMatrixIndexPointerOES1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glMatrixIndexPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glMatrixIndexPointerOES1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glWeightPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  public void glWeightPointerOES(int size, int type, int stride, Buffer pointer)  {

    final boolean pointer_is_direct = Buffers.isDirect(pointer);
    final long __addr_ = _pat._addressof_glWeightPointerOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWeightPointerOES"));
    }
        dispatch_glWeightPointerOES1(size, type, stride, pointer_is_direct ? pointer : Buffers.getArray(pointer), pointer_is_direct ? Buffers.getDirectBufferByteOffset(pointer) : Buffers.getIndirectBufferByteOffset(pointer), pointer_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWeightPointerOES}(GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer) </code> <br>Part of <code>GL_OES_matrix_palette</code><br>
      @param pointer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glWeightPointerOES1(int size, int type, int stride, Object pointer, int pointer_byte_offset, boolean pointer_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  public int glQueryMatrixxOES(IntBuffer mantissa, IntBuffer exponent)  {

    final boolean mantissa_is_direct = Buffers.isDirect(mantissa);
    final boolean exponent_is_direct = Buffers.isDirect(exponent);
    final long __addr_ = _pat._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
    }
        return dispatch_glQueryMatrixxOES1(mantissa_is_direct ? mantissa : Buffers.getArray(mantissa), mantissa_is_direct ? Buffers.getDirectBufferByteOffset(mantissa) : Buffers.getIndirectBufferByteOffset(mantissa), mantissa_is_direct, exponent_is_direct ? exponent : Buffers.getArray(exponent), exponent_is_direct ? Buffers.getDirectBufferByteOffset(exponent) : Buffers.getIndirectBufferByteOffset(exponent), exponent_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>
      @param mantissa a direct or array-backed {@link java.nio.IntBuffer}
      @param exponent a direct or array-backed {@link java.nio.IntBuffer}   */
  private native int dispatch_glQueryMatrixxOES1(Object mantissa, int mantissa_byte_offset, boolean mantissa_is_direct, Object exponent, int exponent_byte_offset, boolean exponent_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLbitfield {@native glQueryMatrixxOES}(GLfixed *  mantissa, GLint *  exponent) </code> <br>Part of <code>GL_OES_query_matrix</code><br>   */
  public int glQueryMatrixxOES(int[] mantissa, int mantissa_offset, int[] exponent, int exponent_offset)  {

    if(mantissa != null && mantissa.length <= mantissa_offset)
      throw new GLException("array offset argument \"mantissa_offset\" (" + mantissa_offset + ") equals or exceeds array length (" + mantissa.length + ")");
    if(exponent != null && exponent.length <= exponent_offset)
      throw new GLException("array offset argument \"exponent_offset\" (" + exponent_offset + ") equals or exceeds array length (" + exponent.length + ")");
    final long __addr_ = _pat._addressof_glQueryMatrixxOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryMatrixxOES"));
    }
        return dispatch_glQueryMatrixxOES1(mantissa, Buffers.SIZEOF_INT * mantissa_offset, false, exponent, Buffers.SIZEOF_INT * exponent_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfOES</code>   */
  public void glTexGenf(int coord, int pname, float param)  {

    final long __addr_ = _pat._addressof_glTexGenf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenf"));
    }
        dispatch_glTexGenf1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenf}(GLenum coord, GLenum pname, GLfloat param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfOES</code>   */
  private native void dispatch_glTexGenf1(int coord, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
    }
        dispatch_glTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenfv}(GLenum coord, GLenum pname, const GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenfvOES</code>   */
  public void glTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenfv"));
    }
        dispatch_glTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGeniOES</code>   */
  public void glTexGeni(int coord, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexGeni;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeni"));
    }
        dispatch_glTexGeni1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeni}(GLenum coord, GLenum pname, GLint param) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGeniOES</code>   */
  private native void dispatch_glTexGeni1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
    }
        dispatch_glTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGeniv}(GLenum coord, GLenum pname, const GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenivOES</code>   */
  public void glTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGeniv"));
    }
        dispatch_glTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenx}(GLenum coord, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenxOES</code>   */
  public void glTexGenx(int coord, int pname, int param)  {

    final long __addr_ = _pat._addressof_glTexGenx;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenx"));
    }
        dispatch_glTexGenx1(coord, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenx}(GLenum coord, GLenum pname, GLfixed param) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenxOES</code>   */
  private native void dispatch_glTexGenx1(int coord, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenxv}(GLenum coord, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexGenxv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glTexGenxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenxv"));
    }
        dispatch_glTexGenxv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexGenxv}(GLenum coord, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexGenxv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexGenxv}(GLenum coord, GLenum pname, const GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glTexGenxvOES</code>   */
  public void glTexGenxv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glTexGenxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexGenxv"));
    }
        dispatch_glTexGenxv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexGenfv(int coord, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
    }
        dispatch_glGetTexGenfv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexGenfv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenfv}(GLenum coord, GLenum pname, GLfloat *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenfvOES</code>   */
  public void glGetTexGenfv(int coord, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGenfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenfv"));
    }
        dispatch_glGetTexGenfv1(coord, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGeniv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
    }
        dispatch_glGetTexGeniv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGeniv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGeniv}(GLenum coord, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenivOES</code>   */
  public void glGetTexGeniv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGeniv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGeniv"));
    }
        dispatch_glGetTexGeniv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenxv}(GLenum coord, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexGenxv(int coord, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetTexGenxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenxv"));
    }
        dispatch_glGetTexGenxv1(coord, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexGenxv}(GLenum coord, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenxvOES</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexGenxv1(int coord, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexGenxv}(GLenum coord, GLenum pname, GLfixed *  params) </code> <br>Part of <code>GL_OES_fixed_point</code>, <code>GL_OES_texture_cube_map</code><br>Alias for: <code>glGetTexGenxvOES</code>   */
  public void glGetTexGenxv(int coord, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetTexGenxv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexGenxv"));
    }
        dispatch_glGetTexGenxv1(coord, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glBindVertexArrayOES(int array)  {

    final long __addr_ = _pat._addressof_glBindVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArrayOES"));
    }
        dispatch_glBindVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  private native void dispatch_glBindVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glDeleteVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = _pat._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public void glGenVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = _pat._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  public boolean glIsVertexArrayOES(int array)  {

    final long __addr_ = _pat._addressof_glIsVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArrayOES"));
    }
        return dispatch_glIsVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array) </code> <br>Part of <code>GL_OES_vertex_array_object</code><br>   */
  private native boolean dispatch_glIsVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code><br>   */
  public void glCopyTextureLevelsAPPLE(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount)  {

    final long __addr_ = _pat._addressof_glCopyTextureLevelsAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureLevelsAPPLE"));
    }
        dispatch_glCopyTextureLevelsAPPLE1(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code><br>   */
  private native void dispatch_glCopyTextureLevelsAPPLE1(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  public void glRenderbufferStorageMultisample(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisample"));
    }
        dispatch_glRenderbufferStorageMultisample1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_APPLE_framebuffer_multisample</code>, <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code>, <code>GL_ANGLE_framebuffer_multisample</code>, <code>GL_IMG_multisampled_render_to_texture</code>, <code>GL_NV_framebuffer_multisample</code><br>Alias for: <code>glRenderbufferStorageMultisampleAPPLE</code>, <code>glRenderbufferStorageMultisampleEXT</code>, <code>glRenderbufferStorageMultisampleANGLE</code>, <code>glRenderbufferStorageMultisampleIMG</code>, <code>glRenderbufferStorageMultisampleNV</code>   */
  private native void dispatch_glRenderbufferStorageMultisample1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebuffer}(void) </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code><br>Alias for: <code>glResolveMultisampleFramebufferAPPLE</code>   */
  public void glResolveMultisampleFramebuffer()  {

    final long __addr_ = _pat._addressof_glResolveMultisampleFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResolveMultisampleFramebuffer"));
    }
        dispatch_glResolveMultisampleFramebuffer1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebuffer}(void) </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code><br>Alias for: <code>glResolveMultisampleFramebufferAPPLE</code>   */
  private native void dispatch_glResolveMultisampleFramebuffer1(long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = _pat._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDiscardFramebufferEXT1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments) </code> <br>Part of <code>GL_EXT_discard_framebuffer</code><br>   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = _pat._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private long glMapBufferRangeDelegate(int target, long offset, long length, int access)  {

    final long __addr_ = _pat._addressof_glMapBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glMapBufferRange"));
    }
        return dispatch_glMapBufferRangeDelegate1(target, offset, length, access, __addr_);
  }

  /** Entry point to C language function: <code> void *  {@native glMapBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code><br>Alias for: <code>glMapBufferRangeEXT</code>  
   * <p>
   * Throws a {@link GLException} if GL-function constraints are not met.
   * </p>
   * <p>
   * Returns {@link GL#mapBufferRange(int, long, long, int)}'s {@link GLBufferStorage#getMappedBuffer()}.
   * </p>
   * <p>
   * @throws GLException if buffer is not bound to target
   * @throws GLException if buffer is not tracked
   * @throws GLException if buffer is already mapped
   * @throws GLException if buffer has invalid store size, i.e. less-than zero
   * @throws GLException if buffer mapping range does not fit, incl. offset
   * </p>
   */
  private native long dispatch_glMapBufferRangeDelegate1(int target, long offset, long length, int access, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  public void glFlushMappedBufferRange(int target, long offset, long length)  {

    final long __addr_ = _pat._addressof_glFlushMappedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedBufferRange"));
    }
        dispatch_glFlushMappedBufferRange1(target, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length) </code> <br>Part of <code>GL_ARB_map_buffer_range</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>, <code>GL_EXT_map_buffer_range</code>, <code>GL_APPLE_flush_buffer_range</code><br>Alias for: <code>glFlushMappedBufferRangeEXT</code>, <code>glFlushMappedBufferRangeAPPLE</code>   */
  private native void dispatch_glFlushMappedBufferRange1(int target, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleEXT}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code><br>   */
  public void glRenderbufferStorageMultisampleEXT(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleEXT"));
    }
        dispatch_glRenderbufferStorageMultisampleEXT1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleEXT}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>, <code>GL_EXT_framebuffer_multisample</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleEXT1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code><br>   */
  public void glFramebufferTexture2DMultisampleEXT(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleEXT"));
    }
        dispatch_glFramebufferTexture2DMultisampleEXT1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei) </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glFramebufferTexture2DMultisampleEXT1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = _pat._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetGraphicsResetStatus"));
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetGraphicsResetStatusEXT</code>, <code>glGetGraphicsResetStatusARB</code>, <code>glGetGraphicsResetStatusKHR</code>   */
  private native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsEXT</code>, <code>glReadnPixelsARB</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = _pat._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadnPixels"));
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glReadnPixelsEXT</code>, <code>glReadnPixelsARB</code>, <code>glReadnPixelsKHR</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_KHR_robustness</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code><br>Alias for: <code>glGetnUniformfvKHR</code>, <code>glGetnUniformfvEXT</code>, <code>glGetnUniformfvARB</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params) </code> <br>Part of <code>GL_VERSION_4_5</code>, <code>GL_ES_VERSION_3_2</code>, <code>GL_EXT_robustness</code>, <code>GL_ARB_robustness</code>, <code>GL_KHR_robustness</code><br>Alias for: <code>glGetnUniformivEXT</code>, <code>glGetnUniformivARB</code>, <code>glGetnUniformivKHR</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum, const GLfloat * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClipPlanefIMG(int arg0, FloatBuffer arg1)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = _pat._addressof_glClipPlanefIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanefIMG"));
    }
        dispatch_glClipPlanefIMG1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum, const GLfloat * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClipPlanefIMG1(int arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanefIMG}(GLenum, const GLfloat * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>   */
  public void glClipPlanefIMG(int arg0, float[] arg1, int arg1_offset)  {

    if(arg1 != null && arg1.length <= arg1_offset)
      throw new GLException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = _pat._addressof_glClipPlanefIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanefIMG"));
    }
        dispatch_glClipPlanefIMG1(arg0, arg1, Buffers.SIZEOF_FLOAT * arg1_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum, const GLfixed * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClipPlanexIMG(int arg0, IntBuffer arg1)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = _pat._addressof_glClipPlanexIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanexIMG"));
    }
        dispatch_glClipPlanexIMG1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum, const GLfixed * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClipPlanexIMG1(int arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClipPlanexIMG}(GLenum, const GLfixed * ) </code> <br>Part of <code>GL_IMG_user_clip_plane</code><br>   */
  public void glClipPlanexIMG(int arg0, int[] arg1, int arg1_offset)  {

    if(arg1 != null && arg1.length <= arg1_offset)
      throw new GLException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = _pat._addressof_glClipPlanexIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClipPlanexIMG"));
    }
        dispatch_glClipPlanexIMG1(arg0, arg1, Buffers.SIZEOF_INT * arg1_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  public void glRenderbufferStorageMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = _pat._addressof_glRenderbufferStorageMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleIMG"));
    }
        dispatch_glRenderbufferStorageMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glRenderbufferStorageMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  public void glFramebufferTexture2DMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = _pat._addressof_glFramebufferTexture2DMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleIMG"));
    }
        dispatch_glFramebufferTexture2DMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei) </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code><br>   */
  private native void dispatch_glFramebufferTexture2DMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetDriverControlsQCOM(IntBuffer num, int size, IntBuffer driverControls)  {

    final boolean num_is_direct = Buffers.isDirect(num);
    final boolean driverControls_is_direct = Buffers.isDirect(driverControls);
    final long __addr_ = _pat._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num_is_direct ? num : Buffers.getArray(num), num_is_direct ? Buffers.getDirectBufferByteOffset(num) : Buffers.getIndirectBufferByteOffset(num), num_is_direct, size, driverControls_is_direct ? driverControls : Buffers.getArray(driverControls), driverControls_is_direct ? Buffers.getDirectBufferByteOffset(driverControls) : Buffers.getIndirectBufferByteOffset(driverControls), driverControls_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetDriverControlsQCOM1(Object num, int num_byte_offset, boolean num_is_direct, int size, Object driverControls, int driverControls_byte_offset, boolean driverControls_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glGetDriverControlsQCOM(int[] num, int num_offset, int size, int[] driverControls, int driverControls_offset)  {

    if(num != null && num.length <= num_offset)
      throw new GLException("array offset argument \"num_offset\" (" + num_offset + ") equals or exceeds array length (" + num.length + ")");
    if(driverControls != null && driverControls.length <= driverControls_offset)
      throw new GLException("array offset argument \"driverControls_offset\" (" + driverControls_offset + ") equals or exceeds array length (" + driverControls.length + ")");
    final long __addr_ = _pat._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num, Buffers.SIZEOF_INT * num_offset, false, size, driverControls, Buffers.SIZEOF_INT * driverControls_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, IntBuffer length, ByteBuffer driverControlString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean driverControlString_is_direct = Buffers.isDirect(driverControlString);
    final long __addr_ = _pat._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, driverControlString_is_direct ? driverControlString : Buffers.getArray(driverControlString), driverControlString_is_direct ? Buffers.getDirectBufferByteOffset(driverControlString) : Buffers.getIndirectBufferByteOffset(driverControlString), driverControlString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetDriverControlStringQCOM1(int driverControl, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object driverControlString, int driverControlString_byte_offset, boolean driverControlString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, int[] length, int length_offset, byte[] driverControlString, int driverControlString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(driverControlString != null && driverControlString.length <= driverControlString_offset)
      throw new GLException("array offset argument \"driverControlString_offset\" (" + driverControlString_offset + ") equals or exceeds array length (" + driverControlString.length + ")");
    final long __addr_ = _pat._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, driverControlString, driverControlString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glEnableDriverControlQCOM(int driverControl)  {

    final long __addr_ = _pat._addressof_glEnableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableDriverControlQCOM"));
    }
        dispatch_glEnableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  private native void dispatch_glEnableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  public void glDisableDriverControlQCOM(int driverControl)  {

    final long __addr_ = _pat._addressof_glDisableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableDriverControlQCOM"));
    }
        dispatch_glDisableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl) </code> <br>Part of <code>GL_QCOM_driver_control</code><br>   */
  private native void dispatch_glDisableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexturesQCOM(IntBuffer textures, int maxTextures, IntBuffer numTextures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean numTextures_is_direct = Buffers.isDirect(numTextures);
    final long __addr_ = _pat._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, maxTextures, numTextures_is_direct ? numTextures : Buffers.getArray(numTextures), numTextures_is_direct ? Buffers.getDirectBufferByteOffset(numTextures) : Buffers.getIndirectBufferByteOffset(numTextures), numTextures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexturesQCOM1(Object textures, int textures_byte_offset, boolean textures_is_direct, int maxTextures, Object numTextures, int numTextures_byte_offset, boolean numTextures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetTexturesQCOM(int[] textures, int textures_offset, int maxTextures, int[] numTextures, int numTextures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(numTextures != null && numTextures.length <= numTextures_offset)
      throw new GLException("array offset argument \"numTextures_offset\" (" + numTextures_offset + ") equals or exceeds array length (" + numTextures.length + ")");
    final long __addr_ = _pat._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures, Buffers.SIZEOF_INT * textures_offset, false, maxTextures, numTextures, Buffers.SIZEOF_INT * numTextures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetBuffersQCOM(IntBuffer buffers, int maxBuffers, IntBuffer numBuffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean numBuffers_is_direct = Buffers.isDirect(numBuffers);
    final long __addr_ = _pat._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, maxBuffers, numBuffers_is_direct ? numBuffers : Buffers.getArray(numBuffers), numBuffers_is_direct ? Buffers.getDirectBufferByteOffset(numBuffers) : Buffers.getIndirectBufferByteOffset(numBuffers), numBuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetBuffersQCOM1(Object buffers, int buffers_byte_offset, boolean buffers_is_direct, int maxBuffers, Object numBuffers, int numBuffers_byte_offset, boolean numBuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetBuffersQCOM(int[] buffers, int buffers_offset, int maxBuffers, int[] numBuffers, int numBuffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    if(numBuffers != null && numBuffers.length <= numBuffers_offset)
      throw new GLException("array offset argument \"numBuffers_offset\" (" + numBuffers_offset + ") equals or exceeds array length (" + numBuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers, Buffers.SIZEOF_INT * buffers_offset, false, maxBuffers, numBuffers, Buffers.SIZEOF_INT * numBuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetRenderbuffersQCOM(IntBuffer renderbuffers, int maxRenderbuffers, IntBuffer numRenderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final boolean numRenderbuffers_is_direct = Buffers.isDirect(numRenderbuffers);
    final long __addr_ = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, maxRenderbuffers, numRenderbuffers_is_direct ? numRenderbuffers : Buffers.getArray(numRenderbuffers), numRenderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(numRenderbuffers) : Buffers.getIndirectBufferByteOffset(numRenderbuffers), numRenderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetRenderbuffersQCOM1(Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, int maxRenderbuffers, Object numRenderbuffers, int numRenderbuffers_byte_offset, boolean numRenderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetRenderbuffersQCOM(int[] renderbuffers, int renderbuffers_offset, int maxRenderbuffers, int[] numRenderbuffers, int numRenderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    if(numRenderbuffers != null && numRenderbuffers.length <= numRenderbuffers_offset)
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + numRenderbuffers_offset + ") equals or exceeds array length (" + numRenderbuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, maxRenderbuffers, numRenderbuffers, Buffers.SIZEOF_INT * numRenderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetFramebuffersQCOM(IntBuffer framebuffers, int maxFramebuffers, IntBuffer numFramebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final boolean numFramebuffers_is_direct = Buffers.isDirect(numFramebuffers);
    final long __addr_ = _pat._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, maxFramebuffers, numFramebuffers_is_direct ? numFramebuffers : Buffers.getArray(numFramebuffers), numFramebuffers_is_direct ? Buffers.getDirectBufferByteOffset(numFramebuffers) : Buffers.getIndirectBufferByteOffset(numFramebuffers), numFramebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetFramebuffersQCOM1(Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, int maxFramebuffers, Object numFramebuffers, int numFramebuffers_byte_offset, boolean numFramebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetFramebuffersQCOM(int[] framebuffers, int framebuffers_offset, int maxFramebuffers, int[] numFramebuffers, int numFramebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    if(numFramebuffers != null && numFramebuffers.length <= numFramebuffers_offset)
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + numFramebuffers_offset + ") equals or exceeds array length (" + numFramebuffers.length + ")");
    final long __addr_ = _pat._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, maxFramebuffers, numFramebuffers, Buffers.SIZEOF_INT * numFramebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int texture, int face, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = _pat._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  public void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param)  {

    final long __addr_ = _pat._addressof_glExtTexObjectStateOverrideiQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtTexObjectStateOverrideiQCOM"));
    }
        dispatch_glExtTexObjectStateOverrideiQCOM1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>   */
  private native void dispatch_glExtTexObjectStateOverrideiQCOM1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  public void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer texels)  {

    final boolean texels_is_direct = Buffers.isDirect(texels);
    final long __addr_ = _pat._addressof_glExtGetTexSubImageQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexSubImageQCOM"));
    }
        dispatch_glExtGetTexSubImageQCOM1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels_is_direct ? texels : Buffers.getArray(texels), texels_is_direct ? Buffers.getDirectBufferByteOffset(texels) : Buffers.getIndirectBufferByteOffset(texels), texels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glExtGetTexSubImageQCOM1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object texels, int texels_byte_offset, boolean texels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glExtGetBufferPointervQCOM(int target, PointerBuffer params)  {

    if (!Buffers.isDirect(params))
      throw new GLException("Argument \"params\" is not a direct buffer");
    final long __addr_ = _pat._addressof_glExtGetBufferPointervQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBufferPointervQCOM"));
    }
        dispatch_glExtGetBufferPointervQCOM0(target, params != null ? params.getBuffer() : null, Buffers.getDirectBufferByteOffset(params), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params) </code> <br>Part of <code>GL_QCOM_extended_get</code><br>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glExtGetBufferPointervQCOM0(int target, Object params, int params_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetShadersQCOM(IntBuffer shaders, int maxShaders, IntBuffer numShaders)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean numShaders_is_direct = Buffers.isDirect(numShaders);
    final long __addr_ = _pat._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, maxShaders, numShaders_is_direct ? numShaders : Buffers.getArray(numShaders), numShaders_is_direct ? Buffers.getDirectBufferByteOffset(numShaders) : Buffers.getIndirectBufferByteOffset(numShaders), numShaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetShadersQCOM1(Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int maxShaders, Object numShaders, int numShaders_byte_offset, boolean numShaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetShadersQCOM(int[] shaders, int shaders_offset, int maxShaders, int[] numShaders, int numShaders_offset)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    if(numShaders != null && numShaders.length <= numShaders_offset)
      throw new GLException("array offset argument \"numShaders_offset\" (" + numShaders_offset + ") equals or exceeds array length (" + numShaders.length + ")");
    final long __addr_ = _pat._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders, Buffers.SIZEOF_INT * shaders_offset, false, maxShaders, numShaders, Buffers.SIZEOF_INT * numShaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramsQCOM(IntBuffer programs, int maxPrograms, IntBuffer numPrograms)  {

    final boolean programs_is_direct = Buffers.isDirect(programs);
    final boolean numPrograms_is_direct = Buffers.isDirect(numPrograms);
    final long __addr_ = _pat._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, maxPrograms, numPrograms_is_direct ? numPrograms : Buffers.getArray(numPrograms), numPrograms_is_direct ? Buffers.getDirectBufferByteOffset(numPrograms) : Buffers.getIndirectBufferByteOffset(numPrograms), numPrograms_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramsQCOM1(Object programs, int programs_byte_offset, boolean programs_is_direct, int maxPrograms, Object numPrograms, int numPrograms_byte_offset, boolean numPrograms_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetProgramsQCOM(int[] programs, int programs_offset, int maxPrograms, int[] numPrograms, int numPrograms_offset)  {

    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    if(numPrograms != null && numPrograms.length <= numPrograms_offset)
      throw new GLException("array offset argument \"numPrograms_offset\" (" + numPrograms_offset + ") equals or exceeds array length (" + numPrograms.length + ")");
    final long __addr_ = _pat._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs, Buffers.SIZEOF_INT * programs_offset, false, maxPrograms, numPrograms, Buffers.SIZEOF_INT * numPrograms_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public boolean glExtIsProgramBinaryQCOM(int program)  {

    final long __addr_ = _pat._addressof_glExtIsProgramBinaryQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtIsProgramBinaryQCOM"));
    }
        return dispatch_glExtIsProgramBinaryQCOM1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  private native boolean dispatch_glExtIsProgramBinaryQCOM1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, ByteBuffer source, IntBuffer length)  {

    final boolean source_is_direct = Buffers.isDirect(source);
    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int program, int shadertype, Object source, int source_byte_offset, boolean source_is_direct, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length) </code> <br>Part of <code>GL_QCOM_extended_get2</code><br>   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, byte[] source, int source_offset, int[] length, int length_offset)  {

    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = _pat._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source, source_offset, false, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  public void glStartTilingQCOM(int x, int y, int width, int height, int preserveMask)  {

    final long __addr_ = _pat._addressof_glStartTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStartTilingQCOM"));
    }
        dispatch_glStartTilingQCOM1(x, y, width, height, preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  private native void dispatch_glStartTilingQCOM1(int x, int y, int width, int height, int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  public void glEndTilingQCOM(int preserveMask)  {

    final long __addr_ = _pat._addressof_glEndTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTilingQCOM"));
    }
        dispatch_glEndTilingQCOM1(preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask) </code> <br>Part of <code>GL_QCOM_tiled_rendering</code><br>   */
  private native void dispatch_glEndTilingQCOM1(int preserveMask, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
  public void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val) {
    glOrthof((float) left, (float) right, (float) bottom, (float) top, (float) near_val, (float) far_val); }
  public void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
    glFrustumf((float) left, (float) right, (float) bottom, (float) top, (float) zNear, (float) zFar); }
  public void glClearDepth(double depth) {
   glClearDepthf((float)depth); }
  public void glDepthRange(double zNear, double zFar) {
   glDepthRangef((float)zNear, (float)zFar); }
      private final GLProfile glProfile;
      private final GLContextImpl _context;
  
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
  
      @Override
      public final int getBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final GLBufferStorage getBufferStorage(int bufferName) {
          return bufferObjectTracker.getBufferStorage(bufferName);
      }
  
      @Override
      public final boolean isVBOArrayBound() {
          return checkArrayVBOBound(false);
      }
  
      @Override
      public final boolean isVBOElementArrayBound() {
          return checkElementVBOBound(false);
      }
  
      @Override
      public final GL getDownstreamGL() throws GLException {
          return null;
      }
  
      @Override
      public final GL getRootGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final boolean hasBasicFBOSupport() {
        return _context.hasBasicFBOSupport();
      }
  
      @Override
      public final boolean hasFullFBOSupport() {
        return _context.hasFullFBOSupport();
      }
  
      @Override
      public final int getMaxRenderbufferSamples() {
        return _context.getMaxRenderbufferSamples();
      }
  
      @Override
      public final boolean isTextureFormatBGRA8888Available() {
        return _context.isTextureFormatBGRA8888Available();
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see com.jogamp.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
      @Override
      public final int getDefaultReadBuffer() {
        return _context.getDefaultReadBuffer();
      }
  
      private final GLStateTracker       glStateTracker;
  
      //
      // GLBufferObjectTracker Redirects
      //
      private final GLBufferObjectTracker bufferObjectTracker;
      private final GLBufferStateTracker bufferStateTracker;
  
      @Override
      public final void glBufferData(int target, long size, Buffer data, int usage)  {
          bufferObjectTracker.createBufferStorage(bufferStateTracker, this, 
                                                  target, size, data, usage, 0 /* immutableFlags */, 
                                                  glBufferDataDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch glBufferDataDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
              public final void create(final int target, final long size, final Buffer data, final int mutableUsage) {
                  glBufferDataDelegate(target, size, data, mutableUsage);
              }
          };
  
      @Override
      public boolean glUnmapBuffer(int target)  {
          return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, target, glUnmapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch glUnmapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch() {
              public final boolean unmap(final int target) {
                  return glUnmapBufferDelegate(target);
              }
          };
  
      @Override
      public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
        return mapBuffer(target, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBuffer(final int target, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, access, glMapBufferDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch glMapBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final int access) {
                  return glMapBufferDelegate(target, access);
              }
          };
  
      @Override
      public final ByteBuffer glMapBufferRange(int target, long offset, long length, int access)  {
        return mapBufferRange(target, offset, length, access).getMappedBuffer();
      }
      @Override
      public final GLBufferStorage mapBufferRange(final int target, final long offset, final long length, final int access) {
        return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, offset, length, access, glMapBufferRangeDispatch);
      }
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch glMapBufferRangeDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final long offset, final long length, final int access) {
                  return glMapBufferRangeDelegate(target, offset, length, access);
              }
          };
  
      private native ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  private final GLES1ProcAddressTable _pat;
  
  public GLES1Impl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    this._pat = (GLES1ProcAddressTable)_context.getGLProcAddressTable();
    this.bufferObjectTracker = context.getBufferObjectTracker();
    this.bufferStateTracker = context.getBufferStateTracker();
    this.glStateTracker     = context.getGLStateTracker();
    this.glProfile = glp;
  }
  
  public final void finalizeInit() {
  }
  
  private int[] imageSizeTemp = new int[1];
  
  private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
      return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
  }
  
  @Override
  public final boolean isGL4bc() {
      return false;
  }
  
  @Override
  public final boolean isGL4() {
      return false;
  }
  
  @Override
  public final boolean isGL3bc() {
      return false;
  }
  
  @Override
  public final boolean isGL3() {
      return false;
  }
  
  @Override
  public final boolean isGL2() {
      return false;
  }
  
  @Override
  public final boolean isGLES1() {
      return true;
  }
  
  @Override
  public final boolean isGLES2() {
      return false;
  }
  
  @Override
  public final boolean isGLES3() {
      return false;
  }
  
  @Override
  public final boolean isGLES() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES1() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES2() {
      return false;
  }
  
  @Override
  public final boolean isGL2ES3() {
      return false;
  }
  
  @Override
  public final boolean isGL3ES3() {
      return false;
  }
  
  @Override
  public final boolean isGL4ES3() {
      return false;
  }
  
  @Override
  public final boolean isGL4core() {
      return false;
  }
  
  @Override
  public final boolean isGL3core() {
      return false;
  }
  
  @Override
  public final boolean isGLcore() {
      return false;
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return false;
  }
  
  @Override
  public final boolean isGLES3Compatible() {
      return false;
  }
  
  @Override
  public final boolean isGLES31Compatible() {
      return false;
  }
  
  @Override
  public final boolean isGLES32Compatible() {
      return false;
  }
  
  @Override
  public final boolean isGL2GL3() {
      return false;
  }
  
  @Override
  public final boolean hasGLSL() {
      return false;
  }
  
  @Override
  public boolean isNPOTTextureAvailable() {
    return false;
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      throw new GLException("Not a GL4bc implementation");
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      throw new GLException("Not a GL4 implementation");
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      throw new GLException("Not a GL3bc implementation");
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      throw new GLException("Not a GL3 implementation");
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      throw new GLException("Not a GL2 implementation");
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      return this;
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      throw new GLException("Not a GLES2 implementation");
  }
  
  @Override
  public final GLES3 getGLES3() throws GLException {
      throw new GLException("Not a GLES3 implementation");
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES3 getGL2ES3() throws GLException {
      throw new GLException("Not a GL2ES3 implementation");
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      throw new GLException("Not a GL2ES2 implementation");
  }
  
  @Override
  public final GL3ES3 getGL3ES3() throws GLException {
      throw new GLException("Not a GL3ES3 implementation");
  }
  
  @Override
  public final GL4ES3 getGL4ES3() throws GLException {
      throw new GLException("Not a GL4ES3 implementation");
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      throw new GLException("Not a GL2GL3 implementation");
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final boolean checkBufferObject(boolean bound,
                                          int state,
                                          String kind, boolean throwException) {
    final int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if (bound) {
      if (0 == buffer) {
        if(throwException) {
            throw new GLException(kind + " must be bound to call this method");
        }
        return false;
      }
    } else {
      if (0 != buffer) {
        if(throwException) {
            throw new GLException(kind + " must be unbound to call this method");
        }
        return false;
      }
    }
    return true;
  }  
  
  private final boolean checkArrayVBOUnbound(boolean throwException) { 
    return checkBufferObject(false, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOBound(boolean throwException) { 
    return checkBufferObject(true, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOUnbound(boolean throwException) { 
    return checkBufferObject(false, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOBound(boolean throwException) { 
    return checkBufferObject(true, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOUnbound(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkUnpackPBOBound(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  private final boolean checkPackPBOUnbound(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return true;
  }
  
  private final boolean checkPackPBOBound(boolean throwException) { 
      // PBO n/a for ES 1.1 or ES 2.0
      return false;
  }
  
  @Override
  public final void glVertexPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glVertexPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glColorPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glColorPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  
  }
  @Override
  public final void glNormalPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.getComponentCount()!=3) {
      throw new GLException("Only 3 components per normal allowed");
    }
    if(array.isVBO()) {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glNormalPointer(array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  @Override
  public final void glTexCoordPointer(GLArrayData array) {
    if(array.getComponentCount()==0) return;
    if(array.isVBO()) {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getVBOOffset());
    } else {
        glTexCoordPointer(array.getComponentCount(), array.getComponentType(), array.getStride(), array.getBuffer());
    }
  }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLES1Impl
