/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Fri Oct 09 06:31:43 CEST 2015 ----! */

package jogamp.openal;

import java.io.UnsupportedEncodingException;
import java.util.*;
import com.jogamp.openal.*;
import jogamp.openal.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public abstract class ALCAbstractImpl implements ALC{
  /** Entry point (through function pointer) to C language function: <br> <code>ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist)</code><br>
      @param attrlist a direct or array-backed {@link java.nio.IntBuffer}   */
  public ALCcontext alcCreateContext(ALCdevice device, IntBuffer attrlist)  {

    final boolean attrlist_is_direct = Buffers.isDirect(attrlist);
    final long __addr_ = alcProcAddressTable._addressof_alcCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCreateContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcCreateContext1(((device == null) ? null : device.getBuffer()), attrlist_is_direct ? attrlist : Buffers.getArray(attrlist), attrlist_is_direct ? Buffers.getDirectBufferByteOffset(attrlist) : Buffers.getIndirectBufferByteOffset(attrlist), attrlist_is_direct, __addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist)</code><br>
      @param attrlist a direct or array-backed {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_alcCreateContext1(ByteBuffer device, Object attrlist, int attrlist_byte_offset, boolean attrlist_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCcontext *  alcCreateContext(ALCdevice *  device, const ALCint *  attrlist)</code><br>   */
  public ALCcontext alcCreateContext(ALCdevice device, int[] attrlist, int attrlist_offset)  {

    if(attrlist != null && attrlist.length <= attrlist_offset)
      throw new ALException("array offset argument \"attrlist_offset\" (" + attrlist_offset + ") equals or exceeds array length (" + attrlist.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCreateContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcCreateContext1(((device == null) ? null : device.getBuffer()), attrlist, Buffers.SIZEOF_INT * attrlist_offset, false, __addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcMakeContextCurrent(ALCcontext *  context)</code><br>   */
  public boolean alcMakeContextCurrent(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcMakeContextCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcMakeContextCurrent"));
    }
        return dispatch_alcMakeContextCurrent1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcMakeContextCurrent(ALCcontext *  context)</code><br>   */
  private native boolean dispatch_alcMakeContextCurrent1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcProcessContext(ALCcontext *  context)</code><br>   */
  public void alcProcessContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcProcessContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcProcessContext"));
    }
        dispatch_alcProcessContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcProcessContext(ALCcontext *  context)</code><br>   */
  private native void dispatch_alcProcessContext1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcSuspendContext(ALCcontext *  context)</code><br>   */
  public void alcSuspendContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcSuspendContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcSuspendContext"));
    }
        dispatch_alcSuspendContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcSuspendContext(ALCcontext *  context)</code><br>   */
  private native void dispatch_alcSuspendContext1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcDestroyContext(ALCcontext *  context)</code><br>   */
  public void alcDestroyContext(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcDestroyContext"));
    }
        dispatch_alcDestroyContext1(((context == null) ? null : context.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcDestroyContext(ALCcontext *  context)</code><br>   */
  private native void dispatch_alcDestroyContext1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCcontext *  alcGetCurrentContext(void)</code><br>   */
  public ALCcontext alcGetCurrentContext()  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetCurrentContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcGetCurrentContext1(__addr_);
    if (_res == null) return null;
    return ALCcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCcontext *  alcGetCurrentContext(void)</code><br>   */
  private native ByteBuffer dispatch_alcGetCurrentContext1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcGetContextsDevice(ALCcontext *  context)</code><br>   */
  public ALCdevice alcGetContextsDevice(ALCcontext context)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetContextsDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetContextsDevice"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcGetContextsDevice1(((context == null) ? null : context.getBuffer()), __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcGetContextsDevice(ALCcontext *  context)</code><br>   */
  private native ByteBuffer dispatch_alcGetContextsDevice1(ByteBuffer context, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcOpenDevice(const ALCchar *  devicename)</code><br>   */
  public ALCdevice alcOpenDevice(String devicename)  {

    final long __addr_ = alcProcAddressTable._addressof_alcOpenDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcOpenDevice"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcOpenDevice1(devicename, __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcOpenDevice(const ALCchar *  devicename)</code><br>   */
  private native ByteBuffer dispatch_alcOpenDevice1(String devicename, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcCloseDevice(ALCdevice *  device)</code><br>   */
  public boolean alcCloseDevice(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCloseDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCloseDevice"));
    }
        return dispatch_alcCloseDevice1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcCloseDevice(ALCdevice *  device)</code><br>   */
  private native boolean dispatch_alcCloseDevice1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCenum alcGetError(ALCdevice *  device)</code><br>   */
  public int alcGetError(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetError"));
    }
        return dispatch_alcGetError1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCenum alcGetError(ALCdevice *  device)</code><br>   */
  private native int dispatch_alcGetError1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcIsExtensionPresent(ALCdevice *  device, const ALCchar *  extname)</code><br>   */
  public boolean alcIsExtensionPresent(ALCdevice device, String extname)  {

    final long __addr_ = alcProcAddressTable._addressof_alcIsExtensionPresent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcIsExtensionPresent"));
    }
        return dispatch_alcIsExtensionPresent1(((device == null) ? null : device.getBuffer()), extname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcIsExtensionPresent(ALCdevice *  device, const ALCchar *  extname)</code><br>   */
  private native boolean dispatch_alcIsExtensionPresent1(ByteBuffer device, String extname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCproc alcGetProcAddress(ALCdevice *  device, const ALCchar *  funcname)</code><br>   */
  long alcGetProcAddress(ALCdevice device, String funcname)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetProcAddress;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetProcAddress"));
    }
        return dispatch_alcGetProcAddress1(((device == null) ? null : device.getBuffer()), funcname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCproc alcGetProcAddress(ALCdevice *  device, const ALCchar *  funcname)</code><br>   */
  private native long dispatch_alcGetProcAddress1(ByteBuffer device, String funcname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCenum alcGetEnumValue(ALCdevice *  device, const ALCchar *  enumname)</code><br>   */
  public int alcGetEnumValue(ALCdevice device, String enumname)  {

    final long __addr_ = alcProcAddressTable._addressof_alcGetEnumValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetEnumValue"));
    }
        return dispatch_alcGetEnumValue1(((device == null) ? null : device.getBuffer()), enumname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCenum alcGetEnumValue(ALCdevice *  device, const ALCchar *  enumname)</code><br>   */
  private native int dispatch_alcGetEnumValue1(ByteBuffer device, String enumname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  values)</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void alcGetIntegerv(ALCdevice device, int param, int size, IntBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = alcProcAddressTable._addressof_alcGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetIntegerv"));
    }
        dispatch_alcGetIntegerv1(((device == null) ? null : device.getBuffer()), param, size, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  values)</code><br>
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_alcGetIntegerv1(ByteBuffer device, int param, int size, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcGetIntegerv(ALCdevice *  device, ALCenum param, ALCsizei size, ALCint *  values)</code><br>   */
  public void alcGetIntegerv(ALCdevice device, int param, int size, int[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new ALException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = alcProcAddressTable._addressof_alcGetIntegerv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcGetIntegerv"));
    }
        dispatch_alcGetIntegerv1(((device == null) ? null : device.getBuffer()), param, size, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcCaptureOpenDevice(const ALCchar *  devicename, ALCuint frequency, ALCenum format, ALCsizei buffersize)</code><br>   */
  public ALCdevice alcCaptureOpenDevice(String devicename, int frequency, int format, int buffersize)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureOpenDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCaptureOpenDevice"));
    }
    final ByteBuffer _res;
    _res = dispatch_alcCaptureOpenDevice1(devicename, frequency, format, buffersize, __addr_);
    if (_res == null) return null;
    return ALCdevice.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCdevice *  alcCaptureOpenDevice(const ALCchar *  devicename, ALCuint frequency, ALCenum format, ALCsizei buffersize)</code><br>   */
  private native ByteBuffer dispatch_alcCaptureOpenDevice1(String devicename, int frequency, int format, int buffersize, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcCaptureCloseDevice(ALCdevice *  device)</code><br>   */
  public boolean alcCaptureCloseDevice(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureCloseDevice;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCaptureCloseDevice"));
    }
        return dispatch_alcCaptureCloseDevice1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>ALCboolean alcCaptureCloseDevice(ALCdevice *  device)</code><br>   */
  private native boolean dispatch_alcCaptureCloseDevice1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureStart(ALCdevice *  device)</code><br>   */
  public void alcCaptureStart(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureStart;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCaptureStart"));
    }
        dispatch_alcCaptureStart1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureStart(ALCdevice *  device)</code><br>   */
  private native void dispatch_alcCaptureStart1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureStop(ALCdevice *  device)</code><br>   */
  public void alcCaptureStop(ALCdevice device)  {

    final long __addr_ = alcProcAddressTable._addressof_alcCaptureStop;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCaptureStop"));
    }
        dispatch_alcCaptureStop1(((device == null) ? null : device.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureStop(ALCdevice *  device)</code><br>   */
  private native void dispatch_alcCaptureStop1(ByteBuffer device, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureSamples(ALCdevice *  device, ALCvoid *  buffer, ALCsizei samples)</code><br>
      @param buffer a direct or array-backed {@link java.nio.Buffer}   */
  public void alcCaptureSamples(ALCdevice device, Buffer buffer, int samples)  {

    final boolean buffer_is_direct = Buffers.isDirect(buffer);
    final long __addr_ = alcProcAddressTable._addressof_alcCaptureSamples;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "alcCaptureSamples"));
    }
        dispatch_alcCaptureSamples1(((device == null) ? null : device.getBuffer()), buffer_is_direct ? buffer : Buffers.getArray(buffer), buffer_is_direct ? Buffers.getDirectBufferByteOffset(buffer) : Buffers.getIndirectBufferByteOffset(buffer), buffer_is_direct, samples, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void alcCaptureSamples(ALCdevice *  device, ALCvoid *  buffer, ALCsizei samples)</code><br>
      @param buffer a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_alcCaptureSamples1(ByteBuffer device, Object buffer, int buffer_byte_offset, boolean buffer_is_direct, int samples, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static final ALCProcAddressTable alcProcAddressTable;
  
  static {
      alcProcAddressTable = AccessController.doPrivileged(new PrivilegedAction<ALCProcAddressTable>() {
                                  public ALCProcAddressTable run() {
                                      final ALCProcAddressTable alcProcAddressTable = new ALCProcAddressTable();
                                      if(null==alcProcAddressTable) {
                                        throw new RuntimeException("Couldn't instantiate ALCProcAddressTable");
                                      }
                                      alcProcAddressTable.reset(ALImpl.alDynamicLookupHelper);
                                      /** Not required nor forced
                                      if( !initializeImpl() ) {
                                          throw new RuntimeException("Initialization failure");
                                      } */
                                      return alcProcAddressTable;
                                  } } );
  }
  
  public static ALCProcAddressTable getALCProcAddressTable() { return alcProcAddressTable; }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class ALCAbstractImpl
