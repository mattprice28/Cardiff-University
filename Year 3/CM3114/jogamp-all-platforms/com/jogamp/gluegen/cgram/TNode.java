package com.jogamp.gluegen.cgram;

import antlr.collections.AST;
import antlr.CommonAST;
import antlr.Token;

import java.lang.reflect.*;
import java.util.Hashtable;
import java.util.Enumeration;

import com.jogamp.gluegen.ASTLocusTag;
import com.jogamp.gluegen.ASTLocusTag.ASTLocusTagProvider;
import com.jogamp.gluegen.GlueGen;

/**
  Class TNode is an implementation of the AST interface
  and adds many useful features:

  It is double-linked for reverse searching.
  (this is currently incomplete, in that method doubleLink() must
  be called after any changes to the tree to maintain the
  reverse links).

  It can store a definition node (defNode), so that nodes such
  as scoped names can refer to the node that defines the name.

  It stores line numbers for nodes.

  Searches for parents and children of a tree can be done
  based on their type.

  The tree can be printed to System.out using a lisp-style syntax.



 */
@SuppressWarnings("serial")
public class TNode extends CommonAST implements ASTLocusTagProvider {
  protected int ttype;
  protected String text;
  protected int lineNum = 0;
  protected TNode defNode;
  protected TNode up;
  protected TNode left;
  protected boolean marker = false;
  protected Hashtable<String, Object> attributes = null;
  static String tokenVocabulary;

  /**
   * {@inheritDoc}
   * <p>
   * If <i>source</i> is not available,
   * implementation returns {@code null}.
   * </p>
   */
  @Override
  public ASTLocusTag getASTLocusTag() {
      final Object s = getAttribute("source");
      if( null != s ) {
          return new ASTLocusTag(s, getLineNum(), -1, getText());
      } else {
          return null;
      }
  }


  /** Set the token vocabulary to a tokentypes class
      generated by antlr.
  */
  public static void setTokenVocabulary(final String s) {
    tokenVocabulary = s;
  }


@Override
public void initialize(final Token token) {
        final CToken tok = (CToken) token;
        setText(tok.getText());
        setType(tok.getType());
        setLineNum(tok.getLine());
        setAttribute("source", tok.getSource());
        setAttribute("tokenNumber", new Integer(tok.getTokenNumber()));
}
@Override
public void initialize(final AST tr) {
        final TNode t = (TNode) tr;
        setText(t.getText());
        setType(t.getType());
        setLineNum(t.getLineNum());
        setDefNode(t.getDefNode());
        this.attributes = t.getAttributesTable();
}


  /** Get the token type for this node */
  @Override
  public int getType() { return ttype; }

  /** Set the token type for this node */
  @Override
  public void setType(final int ttype_) {
    ttype = ttype_;
  }

  /** Get the marker value for this node.
   This member is a general-use marker.
   */
  public boolean getMarker() { return marker; }

  /** Set the marker value for this node.
   This property is a general-use boolean marker.
   */
  public void setMarker(final boolean marker_) {
    marker = marker_;
  }

  /** get the hashtable that holds attribute values.
   */
  public Hashtable<String, Object> getAttributesTable() {
    if(attributes == null)
      attributes = new Hashtable<String, Object>(7);
    return attributes;
  }

  /** set an attribute in the attribute table.
   */
  public void setAttribute(final String attrName, final Object value) {
    if(attributes == null)
      attributes = new Hashtable<String, Object>(7);
    attributes.put(attrName,value);
  }

  /** lookup the attribute name in the attribute table.
    If the value does not exist, it returns null.
    */
  public Object getAttribute(final String attrName) {
    if(attributes == null)
      return null;
    else
      return attributes.get(attrName);
  }

  /** Get the line number for this node.
   If the line number is 0, search for a non-zero line num among children */
  public int getLineNum() {
    if(lineNum != 0)
      return lineNum;
    else
      if(down == null)
        return lineNum;
      else
        return ((TNode)down).getLocalLineNum();
  }

  public int getLocalLineNum() {
    if(lineNum != 0)
      return lineNum;
    else
      if(down == null)
        if(right == null)
          return lineNum;
        else
          return ((TNode)right).getLocalLineNum();
      else
        return ((TNode)down).getLocalLineNum();
  }

  /** Set the line number for this node */
  public void setLineNum(final int lineNum_) {
    lineNum = lineNum_;
  }

  /** Get the token text for this node */
  @Override
  public String getText() { return text; }

  /** Set the token text for this node */
  @Override
  public void setText(final String text_) {
    text = text_;
  }

  static class DebugASTVisitor {
      protected int level;
      private String tabs(final StringBuilder sb) {
          sb.setLength(0);
          for (int i = 0; i < level; i++) {
              sb.append("   ");
          }
          return sb.toString();
      }
      DebugASTVisitor(final int level) {
          this.level = level;
      }
      void visit(final AST node) {
          final StringBuilder sb = new StringBuilder();
          AST node2;
          for (node2 = node; node2 != null; node2 = node2.getNextSibling()) {
              if (node2.getText() == null) {
                  System.err.printf("%03d: %snil [%d]%n", level, tabs(sb), node2.getType());
              } else {
                  System.err.printf("%03d: %s%s [%d]%n", level, tabs(sb), node2.getText(), node2.getType());
              }
              if (node2.getFirstChild() != null) {
                  level++;
                  visit(node2.getFirstChild());
                  level--;
              }
          }
      }
  }

  /**
   * Returns the text for this node, its children and siblings.
   * <p>
   * Implementation converts the AST LISP notation to serialized form.
   * </p>
   */
  public String getAllChildrenText(final String name) {
    if( GlueGen.debug() ) {
        System.err.println("TNode.XXX: "+name);
        new DebugASTVisitor(1).visit(getFirstChild());
    }
    final StringBuilder buf = new StringBuilder();
    final TNode down = (TNode) this.getFirstChild();
    if( null == down ) {
        buf.append(this.getText());
    } else {
        getAllChildrenText(buf, this, down);
    }
    return buf.toString();
  }
  private static void getAllChildrenText(final StringBuilder buf,
                                         final TNode upNode, TNode thisNode) {
    boolean first = true;
    while( null != thisNode ) {
      final boolean isClosing = HeaderParserTokenTypes.RPAREN == thisNode.getType();
      final boolean isGroupStart = HeaderParserTokenTypes.NExpressionGroup == thisNode.getType();

      final TNode nextNode = (TNode) thisNode.getNextSibling();
      final TNode downNode = (TNode) thisNode.getFirstChild();
      if( !isClosing &&
          ( null == downNode && null == nextNode || // unary
            !first                                  // binary
          )
        ) {
          buf.append(" ").append(upNode.getText());
      }
      if( null != downNode ) {
          if( !isGroupStart ) {
              buf.append(" (");
          }
          getAllChildrenText(buf, thisNode, downNode);
          if( !isGroupStart ) {
              buf.append(" )");
          }
      } else if( !isClosing ) {
          buf.append(" ").append(thisNode.getText());
      }
      thisNode = nextNode;
      first = false;
    }
  }

  /** return the last child of this node, or null if there is none */
  public TNode getLastChild() {
    final TNode down = (TNode)getFirstChild();
    if(down != null)
      return down.getLastSibling();
    else
      return null;
  }

  /** return the last sibling of this node, which is
      this if the next sibling is null */
  public TNode getLastSibling() {
    final TNode next = (TNode)getNextSibling();
    if(next != null)
      return next.getLastSibling();
    else
      return this;
  }

  /** return the first sibling of this node, which is
      this if the prev sibling is null */
  public TNode getFirstSibling() {
    final TNode prev = left;
    if(prev != null)
      return prev.getFirstSibling();
    else
      return this;
  }


  /** return the parent node of this node */
  public TNode getParent() {
    return getFirstSibling().up;
  }


  /** add the new node as a new sibling, inserting it ahead of any
    existing next sibling.  This method maintains double-linking.
    if node is null, nothing happens.  If the node has siblings,
    then they are added in as well.
    */
  public void addSibling(final AST node) {
    if(node == null) return;
    final TNode next = (TNode)right;
    right = (TNode)node;
    ((TNode)node).left = this;
    final TNode nodeLastSib = ((TNode)node).getLastSibling();
    nodeLastSib.right = next;
    if(next != null)
      next.left = nodeLastSib;
  }


  /** return the number of children of this node */
  public int numberOfChildren() {
    int count = 0;
    AST child = getFirstChild();
    while(child != null) {
      count++;
      child = child.getNextSibling();
    }
    return count;
  }


  /** remove this node from the tree, resetting sibling and parent
    pointers as necessary.  This method maintains double-linking */
  public void removeSelf() {
    final TNode parent = up;
    final TNode prev = left;
    final TNode next = (TNode)right;

    if(parent != null) {
      parent.down = next;
      if(next != null) {
        next.up = parent;
        next.left = prev;    // which should be null
      }
    }
    else {
     if(prev != null)
      prev.right = next;
     if(next != null)
       next.left = prev;
    }
  }


  /** return the def node for this node */
  public TNode getDefNode() {
      return defNode;
  }

  /** set the def node for this node */
  public void setDefNode(final TNode n) {
    defNode = n;
  }


  /** return a deep copy of this node, and all sub nodes.
    New tree is doubleLinked, with no parent or siblings.
    Marker value is not copied!
    */
  public TNode deepCopy() {
    final TNode copy = new TNode();
    copy.ttype = ttype;
    copy.text = text;
    copy.lineNum = lineNum;
    copy.defNode = defNode;
    if(attributes != null)
      copy.attributes = new Hashtable<String, Object>(attributes);
    if(down != null)
      copy.down = ((TNode)down).deepCopyWithRightSiblings();
    copy.doubleLink();
    return copy;
  }


  /** return a deep copy of this node, all sub nodes,
    and right siblings.
    New tree is doubleLinked, with no parent or left siblings.
    defNode is not copied  */
  public TNode deepCopyWithRightSiblings() {
    final TNode copy = new TNode();
    copy.ttype = ttype;
    copy.text = text;
    copy.lineNum = lineNum;
    copy.defNode = defNode;
    if(attributes != null)
      copy.attributes = new Hashtable<String, Object>(attributes);
    if(down != null)
      copy.down = ((TNode)down).deepCopyWithRightSiblings();
    if(right != null)
      copy.right = ((TNode)right).deepCopyWithRightSiblings();
    copy.doubleLink();
    return copy;
  }


  /** return a short string representation of the node */
  @Override
  public String toString() {
    final StringBuilder str = new StringBuilder( getNameForType(getType()) +
           "[" + getText() + ", " + "]");

     if(this.getLineNum() != 0)
       str.append(" line:" + (this.getLineNum() ) );

     final Enumeration<String> keys = (this.getAttributesTable().keys());
     while (keys.hasMoreElements()) {
       final String key = keys.nextElement();
       str.append(" " + key + ":" + (this.getAttribute(key)));
     }

    return str.toString();
  }


  /** print given tree to System.out */
  public static void printTree(final AST t) {
       if (t == null) return;
       printASTNode(t,0);
       System.out.print("\n");
  }


  /** protected method that does the work of printing */
  protected static void printASTNode(final AST t, final int indent) {
     AST child1, next;
     child1 = t.getFirstChild();

    System.out.print("\n");
     for(int i = 0; i < indent; i++)
       System.out.print("   ");

     if(child1 != null)
        System.out.print("(");

     final String s = t.getText();
     if(s != null && s.length() > 0) {
       System.out.print(getNameForType(t.getType()));
       System.out.print(": \"" + s + "\"");
     }
     else
       System.out.print(getNameForType(t.getType()));
     if(((TNode)t).getLineNum() != 0)
       System.out.print(" line:" + ((TNode)t).getLineNum() );

     final Enumeration<String> keys = ((TNode)t).getAttributesTable().keys();
     while (keys.hasMoreElements()) {
       final String key = keys.nextElement();
       System.out.print(" " + key + ":" + ((TNode)t).getAttribute(key));
     }
     final TNode def = ((TNode)t).getDefNode();
     if(def != null)
       System.out.print("[" + getNameForType(def.getType()) + "]");


     if(child1 != null) {
        printASTNode(child1,indent + 1);

        System.out.print("\n");
        for(int i = 0; i < indent; i++)
           System.out.print("   ");
        System.out.print(")");
     }

     next = t.getNextSibling();
     if(next != null) {
        printASTNode(next,indent);
     }
  }

  /** converts an int tree token type to a name.
      Does this by reflecting on nsdidl.IDLTreeTokenTypes,
      and is dependent on how ANTLR 2.00 outputs that class. */
  public static String getNameForType(final int t) {
    try{
      final Class<?> c = Class.forName(tokenVocabulary);
      final Field[] fields = c.getDeclaredFields();
      if(t-2 < fields.length)
        return fields[t-2].getName();
    } catch (final Exception e) { System.out.println(e); }
    return "unfoundtype: " + t;
  }


  /** set up reverse links between this node and its first
     child and its first sibling, and link those as well */
  public void doubleLink() {
    final TNode right = (TNode)getNextSibling();
    if(right != null) {
      right.left = this;
      right.doubleLink();
    }
    final TNode down = (TNode)getFirstChild();
    if(down != null) {
      down.up = this;
      down.doubleLink();
    }
  }

  /** find first parent of the given type,
    return null on failure */
  public TNode parentOfType(final int type) {
    if(up == null) {
      if(left == null)
        return null;
      else
        return left.parentOfType(type);
    }
    if(up.getType() == type)
      return up;
    return up.parentOfType(type);
  }

  /** find the first child of the node
    of the given type, return null on failure */
  public TNode firstChildOfType(final int type) {
    final TNode down = (TNode)getFirstChild();
    if(down == null)
      return null;
    if(down.getType() == type)
      return down;
    return down.firstSiblingOfType(type);
  }

  /** find the first sibling of the node
    of the given type, return null on failure */
  public TNode firstSiblingOfType(final int type) {
    final TNode right = (TNode)getNextSibling();
    if(right == null)
      return null;
    if(right.getType() == type)
      return right;
    return right.firstSiblingOfType(type);
  }

}
