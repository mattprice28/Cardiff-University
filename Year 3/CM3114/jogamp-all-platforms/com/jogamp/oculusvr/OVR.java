/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Sat Oct 10 03:31:12 CEST 2015 ----! */

package com.jogamp.oculusvr;

import com.jogamp.oculusvr.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class OVR {

  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_None = 0x0;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_DK1 = 0x3;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_DKHD = 0x4;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_DK2 = 0x6;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_BlackStar = 0x7;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_CB = 0x8;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_Other = 0x9;
  /** Defined as part of enum type "ovrHmdType" - CType: int */
  public static final int ovrHmd_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_TimeWarp = 0x2;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_Vignette = 0x8;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_NoRestore = 0x10;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_FlipInput = 0x20;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_SRGB = 0x40;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_Overdrive = 0x80;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_HqDistortion = 0x100;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_LinuxDevFullscreen = 0x200;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_ComputeShader = 0x400;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_TimewarpJitDelay = 0x1000;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_ProfileNoSpinWaits = 0x10000;
  /** Defined as part of enum type "ovrDistortionCaps" - CType: int */
  public static final int ovrDistortionCap_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_Present = 0x1;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_Available = 0x2;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_Captured = 0x4;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_ExtendDesktop = 0x8;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_DebugDevice = 0x10;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_NoMirrorToWindow = 0x2000;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_DisplayOff = 0x40;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_LowPersistence = 0x80;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_DynamicPrediction = 0x200;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_NoVSync = 0x1000;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_Writable_Mask = ( ( ( ovrHmdCap_NoMirrorToWindow | ovrHmdCap_DisplayOff ) | ovrHmdCap_LowPersistence ) | ovrHmdCap_DynamicPrediction ) | ovrHmdCap_NoVSync;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_Service_Mask = ( ( ovrHmdCap_NoMirrorToWindow | ovrHmdCap_DisplayOff ) | ovrHmdCap_LowPersistence ) | ovrHmdCap_DynamicPrediction;
  /** Defined as part of enum type "ovrHmdCaps" - CType: int */
  public static final int ovrHmdCap_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrInitFlags" - CType: int */
  public static final int ovrInit_Debug = 0x1;
  /** Defined as part of enum type "ovrInitFlags" - CType: int */
  public static final int ovrInit_ServerOptional = 0x2;
  /** Defined as part of enum type "ovrInitFlags" - CType: int */
  public static final int ovrInit_RequestVersion = 0x4;
  /** Defined as part of enum type "ovrInitFlags" - CType: int */
  public static final int ovrInit_ForceNoDebug = 0x8;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_OrientationTracked = 0x1;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_PositionTracked = 0x2;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_CameraPoseTracked = 0x4;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_PositionConnected = 0x20;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_HmdConnected = 0x80;
  /** Defined as part of enum type "ovrStatusBits" - CType: int */
  public static final int ovrStatus_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrTrackingCaps" - CType: int */
  public static final int ovrTrackingCap_Orientation = 0x10;
  /** Defined as part of enum type "ovrTrackingCaps" - CType: int */
  public static final int ovrTrackingCap_MagYawCorrection = 0x20;
  /** Defined as part of enum type "ovrTrackingCaps" - CType: int */
  public static final int ovrTrackingCap_Position = 0x40;
  /** Defined as part of enum type "ovrTrackingCaps" - CType: int */
  public static final int ovrTrackingCap_Idle = 0x100;
  /** Defined as part of enum type "ovrTrackingCaps" - CType: int */
  public static final int ovrTrackingCap_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrEyeType" - CType: int */
  public static final int ovrEye_Left = 0x0;
  /** Defined as part of enum type "ovrEyeType" - CType: int */
  public static final int ovrEye_Right = 0x1;
  /** Defined as part of enum type "ovrEyeType" - CType: int */
  public static final int ovrEye_Count = 0x2;
  /** Defined as part of enum type "ovrEyeType" - CType: int */
  public static final int ovrEye_EnumSize = 0x7fffffff;
  /** Defined as part of enum type "ovrProjectionModifier" - CType: int */
  public static final int ovrProjection_None = 0x0;
  /** Defined as part of enum type "ovrProjectionModifier" - CType: int */
  public static final int ovrProjection_RightHanded = 0x1;
  /** Defined as part of enum type "ovrProjectionModifier" - CType: int */
  public static final int ovrProjection_FarLessThanNear = 0x2;
  /** Defined as part of enum type "ovrProjectionModifier" - CType: int */
  public static final int ovrProjection_FarClipAtInfinity = 0x4;
  /** Defined as part of enum type "ovrProjectionModifier" - CType: int */
  public static final int ovrProjection_ClipRangeOpenGL = 0x8;
  /** Defined as part of enum type "ovrLogLevel" - CType: int */
  public static final int ovrLogLevel_Debug = 0x0;
  /** Defined as part of enum type "ovrLogLevel" - CType: int */
  public static final int ovrLogLevel_Info = 0x1;
  /** Defined as part of enum type "ovrLogLevel" - CType: int */
  public static final int ovrLogLevel_Error = 0x2;
  /** Defined as part of enum type "ovrRenderAPIType" - CType: long */
  public static final long ovrRenderAPI_None = 0x0L;
  /** Defined as part of enum type "ovrRenderAPIType" - CType: long */
  public static final long ovrRenderAPI_Count = 0x1L;
  /** Defined as part of enum type "ovrRenderAPIType" - CType: int */
  public static final int ovrRenderAPI_EnumSize = 0x7fffffff;
  /** CType: int */
  public static final int ovrTrue = 0x1;
  /** CType: int */
  public static final int HEADLESS_APP = 0x1;
  /** CType: int */
  public static final int OVR_PRODUCT_VERSION = 0x0;
  /** CType: int */
  public static final int OVR_DK2_LATEST_FIRMWARE_MINOR_VERSION = 0xc;
  /** CType: int */
  public static final int OVR_MAJOR_VERSION = 0x5;
  /** CType: float */
  public static final float OVR_DEFAULT_IPD = 0.064f;
  /** CType: float */
  public static final float OVR_DEFAULT_NECK_TO_EYE_HORIZONTAL = 0.0805f;
  /** CType: int */
  public static final int ovrFalse = 0x0;
  /** CType: int */
  public static final int OVR_MINOR_VERSION = 0x0;
  /** CType: int */
  public static final int ovrDistortionCap_Chromatic = 0x1;
  /** CType: int */
  public static final int OVR_BUILD_NUMBER = 0x0;
  /** CType: float */
  public static final float OVR_DEFAULT_NECK_TO_EYE_VERTICAL = 0.075f;
  /** CType: int */
  public static final int OVR_PATCH_VERSION = 0x1;
  /** CType: float */
  public static final float OVR_DEFAULT_PLAYER_HEIGHT = 1.778f;
  /** CType: float */
  public static final float OVR_DEFAULT_EYE_HEIGHT = 1.675f;
  /** CType: int */
  public static final int OVR_DK2_LATEST_FIRMWARE_MAJOR_VERSION = 0x2;
  /** CType: int */
  public static final int OVR_DEFAULT_EYE_RELIEF_DIAL = 0x3;

  /** Interface to C language function: <br> <code>ovrBool ovr_Initialize(ovrInitParams *  params)</code><br>   */
  public static boolean ovr_Initialize(ovrInitParams params)  {

    if( !isAvailable() ) { return false; }
        return ovr_Initialize1(((params == null) ? null : params.getBuffer()));
  }

  /** Entry point to C language function: <code>ovrBool ovr_Initialize(ovrInitParams *  params)</code><br>   */
  private static native boolean ovr_Initialize1(ByteBuffer params);

  /** Interface to C language function: <br> <code>void ovr_Shutdown()</code><br>   */
  public static native void ovr_Shutdown();

  /** Interface to C language function: <br> <code>const char *  ovr_GetVersionString()</code><br>   */
  public static ByteBuffer ovr_GetVersionString()  {

    final ByteBuffer _res;
    _res = ovr_GetVersionString1();
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code>const char *  ovr_GetVersionString()</code><br>   */
  private static native ByteBuffer ovr_GetVersionString1();

  /** Interface to C language function: <br> <code>int ovrHmd_Detect()</code><br>   */
  public static native int ovrHmd_Detect();

  /** Interface to C language function: <br> <code>ovrHmd ovrHmd_Create(int index)</code><br>   */
  public static ovrHmdDesc ovrHmd_Create(int index)  {

    if( !isAvailable() ) { return null; }
    final ByteBuffer _res;
    _res = ovrHmd_Create1(index);
    if (_res == null) return null;
    return ovrHmdDesc.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrHmd ovrHmd_Create(int index)</code><br>   */
  private static native ByteBuffer ovrHmd_Create1(int index);

  /** Interface to C language function: <br> <code>void ovrHmd_Destroy(ovrHmd hmd)</code><br>   */
  public static void ovrHmd_Destroy(ovrHmdDesc hmd)  {

        ovrHmd_Destroy1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>void ovrHmd_Destroy(ovrHmd hmd)</code><br>   */
  private static native void ovrHmd_Destroy1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>ovrHmd ovrHmd_CreateDebug(ovrHmdType type)</code><br>
      @param type valid values are: <code>ovrHmd_None, ovrHmd_DK1, ovrHmd_DKHD, ovrHmd_DK2, ovrHmd_BlackStar, ovrHmd_CB, ovrHmd_Other, ovrHmd_EnumSize</code>
   */
  public static ovrHmdDesc ovrHmd_CreateDebug(int type)  {

    if( !isAvailable() ) { return null; }
    final ByteBuffer _res;
    _res = ovrHmd_CreateDebug1(type);
    if (_res == null) return null;
    return ovrHmdDesc.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrHmd ovrHmd_CreateDebug(ovrHmdType type)</code><br>
      @param type valid values are: <code>ovrHmd_None, ovrHmd_DK1, ovrHmd_DKHD, ovrHmd_DK2, ovrHmd_BlackStar, ovrHmd_CB, ovrHmd_Other, ovrHmd_EnumSize</code>
   */
  private static native ByteBuffer ovrHmd_CreateDebug1(int type);

  /** Interface to C language function: <br> <code>const char *  ovrHmd_GetLastError(ovrHmd hmd)</code><br>   */
  public static String ovrHmd_GetLastError(ovrHmdDesc hmd)  {

        return ovrHmd_GetLastError1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>const char *  ovrHmd_GetLastError(ovrHmd hmd)</code><br>   */
  private static native String ovrHmd_GetLastError1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>unsigned int ovrHmd_GetEnabledCaps(ovrHmd hmd)</code><br>   */
  public static int ovrHmd_GetEnabledCaps(ovrHmdDesc hmd)  {

        return ovrHmd_GetEnabledCaps1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>unsigned int ovrHmd_GetEnabledCaps(ovrHmd hmd)</code><br>   */
  private static native int ovrHmd_GetEnabledCaps1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>void ovrHmd_SetEnabledCaps(ovrHmd hmd, unsigned int hmdCaps)</code><br>   */
  public static void ovrHmd_SetEnabledCaps(ovrHmdDesc hmd, int hmdCaps)  {

        ovrHmd_SetEnabledCaps1(((hmd == null) ? null : hmd.getBuffer()), hmdCaps);
  }

  /** Entry point to C language function: <code>void ovrHmd_SetEnabledCaps(ovrHmd hmd, unsigned int hmdCaps)</code><br>   */
  private static native void ovrHmd_SetEnabledCaps1(ByteBuffer hmd, int hmdCaps);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_ConfigureTracking(ovrHmd hmd, unsigned int supportedTrackingCaps, unsigned int requiredTrackingCaps)</code><br>   */
  public static boolean ovrHmd_ConfigureTracking(ovrHmdDesc hmd, int supportedTrackingCaps, int requiredTrackingCaps)  {

        return ovrHmd_ConfigureTracking1(((hmd == null) ? null : hmd.getBuffer()), supportedTrackingCaps, requiredTrackingCaps);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_ConfigureTracking(ovrHmd hmd, unsigned int supportedTrackingCaps, unsigned int requiredTrackingCaps)</code><br>   */
  private static native boolean ovrHmd_ConfigureTracking1(ByteBuffer hmd, int supportedTrackingCaps, int requiredTrackingCaps);

  /** Interface to C language function: <br> <code>void ovrHmd_RecenterPose(ovrHmd hmd)</code><br>   */
  public static void ovrHmd_RecenterPose(ovrHmdDesc hmd)  {

        ovrHmd_RecenterPose1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>void ovrHmd_RecenterPose(ovrHmd hmd)</code><br>   */
  private static native void ovrHmd_RecenterPose1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>ovrTrackingState ovrHmd_GetTrackingState(ovrHmd hmd, double absTime)</code><br>   */
  public static ovrTrackingState ovrHmd_GetTrackingState(ovrHmdDesc hmd, double absTime)  {

    final ByteBuffer _res;
    _res = ovrHmd_GetTrackingState1(((hmd == null) ? null : hmd.getBuffer()), absTime);
    if (_res == null) return null;
    return ovrTrackingState.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrTrackingState ovrHmd_GetTrackingState(ovrHmd hmd, double absTime)</code><br>   */
  private static native ByteBuffer ovrHmd_GetTrackingState1(ByteBuffer hmd, double absTime);

  /** Interface to C language function: <br> <code>ovrSizei ovrHmd_GetFovTextureSize(ovrHmd hmd, ovrEyeType eye, ovrFovPort fov, float pixelsPerDisplayPixel)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static ovrSizei ovrHmd_GetFovTextureSize(ovrHmdDesc hmd, int eye, ovrFovPort fov, float pixelsPerDisplayPixel)  {

    final ByteBuffer _res;
    _res = ovrHmd_GetFovTextureSize1(((hmd == null) ? null : hmd.getBuffer()), eye, ((fov == null) ? null : fov.getBuffer()), pixelsPerDisplayPixel);
    if (_res == null) return null;
    return ovrSizei.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrSizei ovrHmd_GetFovTextureSize(ovrHmd hmd, ovrEyeType eye, ovrFovPort fov, float pixelsPerDisplayPixel)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native ByteBuffer ovrHmd_GetFovTextureSize1(ByteBuffer hmd, int eye, ByteBuffer fov, float pixelsPerDisplayPixel);

  /** Interface to C language function: <br> <code>void ovrHmd_GetEyePoses(ovrHmd hmd, unsigned int frameIndex, const ovrVector3f hmdToEyeViewOffset[2], ovrPosef outEyePoses[2], ovrTrackingState *  outHmdTrackingState)</code><br>   */
  public static void ovrHmd_GetEyePoses(ovrHmdDesc hmd, int frameIndex, ovrVector3f[] hmdToEyeViewOffset, ovrPosef[] outEyePoses, ovrTrackingState outHmdTrackingState)  {

    if ( hmdToEyeViewOffset.length < 2)
      throw new OVRException("Array \"hmdToEyeViewOffset\" length (" + hmdToEyeViewOffset.length+ ") was less than the required (2)");
    if ( outEyePoses.length < 2)
      throw new OVRException("Array \"outEyePoses\" length (" + outEyePoses.length+ ") was less than the required (2)");
    final ByteBuffer[] hmdToEyeViewOffset_buf_array_copy = new ByteBuffer[hmdToEyeViewOffset.length];
    for (int _ctr = 0; _ctr < + hmdToEyeViewOffset.length; _ctr++) {
      ovrVector3f _tmp = hmdToEyeViewOffset[_ctr];
      hmdToEyeViewOffset_buf_array_copy[_ctr] = ((_tmp == null) ? null : _tmp.getBuffer());
    }
    final ByteBuffer[] outEyePoses_buf_array_copy = new ByteBuffer[outEyePoses.length];
    for (int _ctr = 0; _ctr < + outEyePoses.length; _ctr++) {
      ovrPosef _tmp = outEyePoses[_ctr];
      outEyePoses_buf_array_copy[_ctr] = ((_tmp == null) ? null : _tmp.getBuffer());
    }
        ovrHmd_GetEyePoses1(((hmd == null) ? null : hmd.getBuffer()), frameIndex, hmdToEyeViewOffset_buf_array_copy, outEyePoses_buf_array_copy, ((outHmdTrackingState == null) ? null : outHmdTrackingState.getBuffer()));
    for (int _ctr = 0; _ctr < outEyePoses.length; _ctr++) {
      if ((outEyePoses[_ctr] == null && outEyePoses_buf_array_copy[_ctr] == null) ||
          (outEyePoses[_ctr] != null && outEyePoses[_ctr].getBuffer() == outEyePoses_buf_array_copy[_ctr])) {
        // No copy back needed
      } else {
        if (outEyePoses_buf_array_copy[_ctr] == null) {
          outEyePoses[_ctr] = null;
        } else {
          outEyePoses[_ctr] = ovrPosef.create(outEyePoses_buf_array_copy[_ctr]);
        }
      }
    }
  }

  /** Entry point to C language function: <code>void ovrHmd_GetEyePoses(ovrHmd hmd, unsigned int frameIndex, const ovrVector3f hmdToEyeViewOffset[2], ovrPosef outEyePoses[2], ovrTrackingState *  outHmdTrackingState)</code><br>   */
  private static native void ovrHmd_GetEyePoses1(ByteBuffer hmd, int frameIndex, ByteBuffer[] hmdToEyeViewOffset, ByteBuffer[] outEyePoses, ByteBuffer outHmdTrackingState);

  /** Interface to C language function: <br> <code>ovrPosef ovrHmd_GetHmdPosePerEye(ovrHmd hmd, ovrEyeType eye)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static ovrPosef ovrHmd_GetHmdPosePerEye(ovrHmdDesc hmd, int eye)  {

    final ByteBuffer _res;
    _res = ovrHmd_GetHmdPosePerEye1(((hmd == null) ? null : hmd.getBuffer()), eye);
    if (_res == null) return null;
    return ovrPosef.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrPosef ovrHmd_GetHmdPosePerEye(ovrHmd hmd, ovrEyeType eye)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native ByteBuffer ovrHmd_GetHmdPosePerEye1(ByteBuffer hmd, int eye);

  /** Interface to C language function: <br> <code>ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmd hmd, ovrEyeType eyeType, ovrFovPort fov)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmdDesc hmd, int eyeType, ovrFovPort fov)  {

    final ByteBuffer _res;
    _res = ovrHmd_GetRenderDesc1(((hmd == null) ? null : hmd.getBuffer()), eyeType, ((fov == null) ? null : fov.getBuffer()));
    if (_res == null) return null;
    return ovrEyeRenderDesc.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrEyeRenderDesc ovrHmd_GetRenderDesc(ovrHmd hmd, ovrEyeType eyeType, ovrFovPort fov)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native ByteBuffer ovrHmd_GetRenderDesc1(ByteBuffer hmd, int eyeType, ByteBuffer fov);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_CreateDistortionMesh(ovrHmd hmd, ovrEyeType eyeType, ovrFovPort fov, unsigned int distortionCaps, ovrDistortionMesh *  meshData)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static boolean ovrHmd_CreateDistortionMesh(ovrHmdDesc hmd, int eyeType, ovrFovPort fov, int distortionCaps, ovrDistortionMesh meshData)  {

        return ovrHmd_CreateDistortionMesh1(((hmd == null) ? null : hmd.getBuffer()), eyeType, ((fov == null) ? null : fov.getBuffer()), distortionCaps, ((meshData == null) ? null : meshData.getBuffer()));
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_CreateDistortionMesh(ovrHmd hmd, ovrEyeType eyeType, ovrFovPort fov, unsigned int distortionCaps, ovrDistortionMesh *  meshData)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native boolean ovrHmd_CreateDistortionMesh1(ByteBuffer hmd, int eyeType, ByteBuffer fov, int distortionCaps, ByteBuffer meshData);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_CreateDistortionMeshDebug(ovrHmd hmddesc, ovrEyeType eyeType, ovrFovPort fov, unsigned int distortionCaps, ovrDistortionMesh *  meshData, float debugEyeReliefOverrideInMetres)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static boolean ovrHmd_CreateDistortionMeshDebug(ovrHmdDesc hmddesc, int eyeType, ovrFovPort fov, int distortionCaps, ovrDistortionMesh meshData, float debugEyeReliefOverrideInMetres)  {

        return ovrHmd_CreateDistortionMeshDebug1(((hmddesc == null) ? null : hmddesc.getBuffer()), eyeType, ((fov == null) ? null : fov.getBuffer()), distortionCaps, ((meshData == null) ? null : meshData.getBuffer()), debugEyeReliefOverrideInMetres);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_CreateDistortionMeshDebug(ovrHmd hmddesc, ovrEyeType eyeType, ovrFovPort fov, unsigned int distortionCaps, ovrDistortionMesh *  meshData, float debugEyeReliefOverrideInMetres)</code><br>
      @param eyeType valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native boolean ovrHmd_CreateDistortionMeshDebug1(ByteBuffer hmddesc, int eyeType, ByteBuffer fov, int distortionCaps, ByteBuffer meshData, float debugEyeReliefOverrideInMetres);

  /** Interface to C language function: <br> <code>void ovrHmd_DestroyDistortionMesh(ovrDistortionMesh *  meshData)</code><br>   */
  public static void ovrHmd_DestroyDistortionMesh(ovrDistortionMesh meshData)  {

        ovrHmd_DestroyDistortionMesh1(((meshData == null) ? null : meshData.getBuffer()));
  }

  /** Entry point to C language function: <code>void ovrHmd_DestroyDistortionMesh(ovrDistortionMesh *  meshData)</code><br>   */
  private static native void ovrHmd_DestroyDistortionMesh1(ByteBuffer meshData);

  /** Interface to C language function: <br> <code>void ovrHmd_GetRenderScaleAndOffset(ovrFovPort fov, ovrSizei textureSize, ovrRecti renderViewport, ovrVector2f uvScaleOffsetOut[2])</code><br>   */
  public static void ovrHmd_GetRenderScaleAndOffset(ovrFovPort fov, ovrSizei textureSize, ovrRecti renderViewport, ovrVector2f[] uvScaleOffsetOut)  {

    if ( uvScaleOffsetOut.length < 2)
      throw new OVRException("Array \"uvScaleOffsetOut\" length (" + uvScaleOffsetOut.length+ ") was less than the required (2)");
    final ByteBuffer[] uvScaleOffsetOut_buf_array_copy = new ByteBuffer[uvScaleOffsetOut.length];
    for (int _ctr = 0; _ctr < + uvScaleOffsetOut.length; _ctr++) {
      ovrVector2f _tmp = uvScaleOffsetOut[_ctr];
      uvScaleOffsetOut_buf_array_copy[_ctr] = ((_tmp == null) ? null : _tmp.getBuffer());
    }
        ovrHmd_GetRenderScaleAndOffset1(((fov == null) ? null : fov.getBuffer()), ((textureSize == null) ? null : textureSize.getBuffer()), ((renderViewport == null) ? null : renderViewport.getBuffer()), uvScaleOffsetOut_buf_array_copy);
    for (int _ctr = 0; _ctr < uvScaleOffsetOut.length; _ctr++) {
      if ((uvScaleOffsetOut[_ctr] == null && uvScaleOffsetOut_buf_array_copy[_ctr] == null) ||
          (uvScaleOffsetOut[_ctr] != null && uvScaleOffsetOut[_ctr].getBuffer() == uvScaleOffsetOut_buf_array_copy[_ctr])) {
        // No copy back needed
      } else {
        if (uvScaleOffsetOut_buf_array_copy[_ctr] == null) {
          uvScaleOffsetOut[_ctr] = null;
        } else {
          uvScaleOffsetOut[_ctr] = ovrVector2f.create(uvScaleOffsetOut_buf_array_copy[_ctr]);
        }
      }
    }
  }

  /** Entry point to C language function: <code>void ovrHmd_GetRenderScaleAndOffset(ovrFovPort fov, ovrSizei textureSize, ovrRecti renderViewport, ovrVector2f uvScaleOffsetOut[2])</code><br>   */
  private static native void ovrHmd_GetRenderScaleAndOffset1(ByteBuffer fov, ByteBuffer textureSize, ByteBuffer renderViewport, ByteBuffer[] uvScaleOffsetOut);

  /** Interface to C language function: <br> <code>ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  public static ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmdDesc hmd, int frameIndex)  {

    final ByteBuffer _res;
    _res = ovrHmd_GetFrameTiming1(((hmd == null) ? null : hmd.getBuffer()), frameIndex);
    if (_res == null) return null;
    return ovrFrameTiming.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrFrameTiming ovrHmd_GetFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  private static native ByteBuffer ovrHmd_GetFrameTiming1(ByteBuffer hmd, int frameIndex);

  /** Interface to C language function: <br> <code>ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  public static ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmdDesc hmd, int frameIndex)  {

    final ByteBuffer _res;
    _res = ovrHmd_BeginFrameTiming1(((hmd == null) ? null : hmd.getBuffer()), frameIndex);
    if (_res == null) return null;
    return ovrFrameTiming.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrFrameTiming ovrHmd_BeginFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  private static native ByteBuffer ovrHmd_BeginFrameTiming1(ByteBuffer hmd, int frameIndex);

  /** Interface to C language function: <br> <code>void ovrHmd_EndFrameTiming(ovrHmd hmd)</code><br>   */
  public static void ovrHmd_EndFrameTiming(ovrHmdDesc hmd)  {

        ovrHmd_EndFrameTiming1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>void ovrHmd_EndFrameTiming(ovrHmd hmd)</code><br>   */
  private static native void ovrHmd_EndFrameTiming1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>void ovrHmd_ResetFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  public static void ovrHmd_ResetFrameTiming(ovrHmdDesc hmd, int frameIndex)  {

        ovrHmd_ResetFrameTiming1(((hmd == null) ? null : hmd.getBuffer()), frameIndex);
  }

  /** Entry point to C language function: <code>void ovrHmd_ResetFrameTiming(ovrHmd hmd, unsigned int frameIndex)</code><br>   */
  private static native void ovrHmd_ResetFrameTiming1(ByteBuffer hmd, int frameIndex);

  /** Interface to C language function: <br> <code>void ovrHmd_GetEyeTimewarpMatrices(ovrHmd hmd, ovrEyeType eye, ovrPosef renderPose, ovrMatrix4f twmOut[2])</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static void ovrHmd_GetEyeTimewarpMatrices(ovrHmdDesc hmd, int eye, ovrPosef renderPose, ovrMatrix4f[] twmOut)  {

    if ( twmOut.length < 2)
      throw new OVRException("Array \"twmOut\" length (" + twmOut.length+ ") was less than the required (2)");
    final ByteBuffer[] twmOut_buf_array_copy = new ByteBuffer[twmOut.length];
    for (int _ctr = 0; _ctr < + twmOut.length; _ctr++) {
      ovrMatrix4f _tmp = twmOut[_ctr];
      twmOut_buf_array_copy[_ctr] = ((_tmp == null) ? null : _tmp.getBuffer());
    }
        ovrHmd_GetEyeTimewarpMatrices1(((hmd == null) ? null : hmd.getBuffer()), eye, ((renderPose == null) ? null : renderPose.getBuffer()), twmOut_buf_array_copy);
    for (int _ctr = 0; _ctr < twmOut.length; _ctr++) {
      if ((twmOut[_ctr] == null && twmOut_buf_array_copy[_ctr] == null) ||
          (twmOut[_ctr] != null && twmOut[_ctr].getBuffer() == twmOut_buf_array_copy[_ctr])) {
        // No copy back needed
      } else {
        if (twmOut_buf_array_copy[_ctr] == null) {
          twmOut[_ctr] = null;
        } else {
          twmOut[_ctr] = ovrMatrix4f.create(twmOut_buf_array_copy[_ctr]);
        }
      }
    }
  }

  /** Entry point to C language function: <code>void ovrHmd_GetEyeTimewarpMatrices(ovrHmd hmd, ovrEyeType eye, ovrPosef renderPose, ovrMatrix4f twmOut[2])</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native void ovrHmd_GetEyeTimewarpMatrices1(ByteBuffer hmd, int eye, ByteBuffer renderPose, ByteBuffer[] twmOut);

  /** Interface to C language function: <br> <code>void ovrHmd_GetEyeTimewarpMatricesDebug(ovrHmd hmddesc, ovrEyeType eye, ovrPosef renderPose, ovrQuatf playerTorsoMotion, ovrMatrix4f twmOut[2], double debugTimingOffsetInSeconds)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  public static void ovrHmd_GetEyeTimewarpMatricesDebug(ovrHmdDesc hmddesc, int eye, ovrPosef renderPose, ovrQuatf playerTorsoMotion, ovrMatrix4f[] twmOut, double debugTimingOffsetInSeconds)  {

    if ( twmOut.length < 2)
      throw new OVRException("Array \"twmOut\" length (" + twmOut.length+ ") was less than the required (2)");
    final ByteBuffer[] twmOut_buf_array_copy = new ByteBuffer[twmOut.length];
    for (int _ctr = 0; _ctr < + twmOut.length; _ctr++) {
      ovrMatrix4f _tmp = twmOut[_ctr];
      twmOut_buf_array_copy[_ctr] = ((_tmp == null) ? null : _tmp.getBuffer());
    }
        ovrHmd_GetEyeTimewarpMatricesDebug1(((hmddesc == null) ? null : hmddesc.getBuffer()), eye, ((renderPose == null) ? null : renderPose.getBuffer()), ((playerTorsoMotion == null) ? null : playerTorsoMotion.getBuffer()), twmOut_buf_array_copy, debugTimingOffsetInSeconds);
    for (int _ctr = 0; _ctr < twmOut.length; _ctr++) {
      if ((twmOut[_ctr] == null && twmOut_buf_array_copy[_ctr] == null) ||
          (twmOut[_ctr] != null && twmOut[_ctr].getBuffer() == twmOut_buf_array_copy[_ctr])) {
        // No copy back needed
      } else {
        if (twmOut_buf_array_copy[_ctr] == null) {
          twmOut[_ctr] = null;
        } else {
          twmOut[_ctr] = ovrMatrix4f.create(twmOut_buf_array_copy[_ctr]);
        }
      }
    }
  }

  /** Entry point to C language function: <code>void ovrHmd_GetEyeTimewarpMatricesDebug(ovrHmd hmddesc, ovrEyeType eye, ovrPosef renderPose, ovrQuatf playerTorsoMotion, ovrMatrix4f twmOut[2], double debugTimingOffsetInSeconds)</code><br>
      @param eye valid values are: <code>ovrEye_Left, ovrEye_Right, ovrEye_Count, ovrEye_EnumSize</code>
   */
  private static native void ovrHmd_GetEyeTimewarpMatricesDebug1(ByteBuffer hmddesc, int eye, ByteBuffer renderPose, ByteBuffer playerTorsoMotion, ByteBuffer[] twmOut, double debugTimingOffsetInSeconds);

  /** Interface to C language function: <br> <code>double ovr_GetTimeInSeconds()</code><br>   */
  public static native double ovr_GetTimeInSeconds();

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_ProcessLatencyTest(ovrHmd hmd, unsigned char rgbColorOut[3])</code><br>
      @param rgbColorOut a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_ProcessLatencyTest(ovrHmdDesc hmd, ByteBuffer rgbColorOut)  {

    if ( Buffers.remainingElem(rgbColorOut) < 3)
      throw new OVRException("Array \"rgbColorOut\" length (" + Buffers.remainingElem(rgbColorOut)+ ") was less than the required (3)");
    final boolean rgbColorOut_is_direct = Buffers.isDirect(rgbColorOut);
        return ovrHmd_ProcessLatencyTest1(((hmd == null) ? null : hmd.getBuffer()), rgbColorOut_is_direct ? rgbColorOut : Buffers.getArray(rgbColorOut), rgbColorOut_is_direct ? Buffers.getDirectBufferByteOffset(rgbColorOut) : Buffers.getIndirectBufferByteOffset(rgbColorOut), rgbColorOut_is_direct);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_ProcessLatencyTest(ovrHmd hmd, unsigned char rgbColorOut[3])</code><br>
      @param rgbColorOut a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_ProcessLatencyTest1(ByteBuffer hmd, Object rgbColorOut, int rgbColorOut_byte_offset, boolean rgbColorOut_is_direct);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_ProcessLatencyTest(ovrHmd hmd, unsigned char rgbColorOut[3])</code><br>   */
  public static boolean ovrHmd_ProcessLatencyTest(ovrHmdDesc hmd, byte[] rgbColorOut, int rgbColorOut_offset)  {

    if ( rgbColorOut.length < 3)
      throw new OVRException("Array \"rgbColorOut\" length (" + rgbColorOut.length+ ") was less than the required (3)");
    if(rgbColorOut != null && rgbColorOut.length <= rgbColorOut_offset)
      throw new OVRException("array offset argument \"rgbColorOut_offset\" (" + rgbColorOut_offset + ") equals or exceeds array length (" + rgbColorOut.length + ")");
        return ovrHmd_ProcessLatencyTest1(((hmd == null) ? null : hmd.getBuffer()), rgbColorOut, rgbColorOut_offset, false);
  }

  /** Interface to C language function: <br> <code>const char *  ovrHmd_GetLatencyTestResult(ovrHmd hmd)</code><br>   */
  public static String ovrHmd_GetLatencyTestResult(ovrHmdDesc hmd)  {

        return ovrHmd_GetLatencyTestResult1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>const char *  ovrHmd_GetLatencyTestResult(ovrHmd hmd)</code><br>   */
  private static native String ovrHmd_GetLatencyTestResult1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_GetLatencyTest2DrawColor(ovrHmd hmddesc, unsigned char rgbColorOut[3])</code><br>
      @param rgbColorOut a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_GetLatencyTest2DrawColor(ovrHmdDesc hmddesc, ByteBuffer rgbColorOut)  {

    if ( Buffers.remainingElem(rgbColorOut) < 3)
      throw new OVRException("Array \"rgbColorOut\" length (" + Buffers.remainingElem(rgbColorOut)+ ") was less than the required (3)");
    final boolean rgbColorOut_is_direct = Buffers.isDirect(rgbColorOut);
        return ovrHmd_GetLatencyTest2DrawColor1(((hmddesc == null) ? null : hmddesc.getBuffer()), rgbColorOut_is_direct ? rgbColorOut : Buffers.getArray(rgbColorOut), rgbColorOut_is_direct ? Buffers.getDirectBufferByteOffset(rgbColorOut) : Buffers.getIndirectBufferByteOffset(rgbColorOut), rgbColorOut_is_direct);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_GetLatencyTest2DrawColor(ovrHmd hmddesc, unsigned char rgbColorOut[3])</code><br>
      @param rgbColorOut a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_GetLatencyTest2DrawColor1(ByteBuffer hmddesc, Object rgbColorOut, int rgbColorOut_byte_offset, boolean rgbColorOut_is_direct);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_GetLatencyTest2DrawColor(ovrHmd hmddesc, unsigned char rgbColorOut[3])</code><br>   */
  public static boolean ovrHmd_GetLatencyTest2DrawColor(ovrHmdDesc hmddesc, byte[] rgbColorOut, int rgbColorOut_offset)  {

    if ( rgbColorOut.length < 3)
      throw new OVRException("Array \"rgbColorOut\" length (" + rgbColorOut.length+ ") was less than the required (3)");
    if(rgbColorOut != null && rgbColorOut.length <= rgbColorOut_offset)
      throw new OVRException("array offset argument \"rgbColorOut_offset\" (" + rgbColorOut_offset + ") equals or exceeds array length (" + rgbColorOut.length + ")");
        return ovrHmd_GetLatencyTest2DrawColor1(((hmddesc == null) ? null : hmddesc.getBuffer()), rgbColorOut, rgbColorOut_offset, false);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_GetBool(ovrHmd hmd, const char *  propertyName, ovrBool defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_GetBool(ovrHmdDesc hmd, ByteBuffer propertyName, boolean defaultVal)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
        return ovrHmd_GetBool1(((hmd == null) ? null : hmd.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, defaultVal);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_GetBool(ovrHmd hmd, const char *  propertyName, ovrBool defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_GetBool1(ByteBuffer hmd, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, boolean defaultVal);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_GetBool(ovrHmd hmd, const char *  propertyName, ovrBool defaultVal)</code><br>   */
  public static boolean ovrHmd_GetBool(ovrHmdDesc hmd, byte[] propertyName, int propertyName_offset, boolean defaultVal)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
        return ovrHmd_GetBool1(((hmd == null) ? null : hmd.getBuffer()), propertyName, propertyName_offset, false, defaultVal);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetBool(ovrHmd hmd, const char *  propertyName, ovrBool value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_SetBool(ovrHmdDesc hmd, ByteBuffer propertyName, boolean value)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
        return ovrHmd_SetBool1(((hmd == null) ? null : hmd.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, value);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_SetBool(ovrHmd hmd, const char *  propertyName, ovrBool value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_SetBool1(ByteBuffer hmd, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, boolean value);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetBool(ovrHmd hmd, const char *  propertyName, ovrBool value)</code><br>   */
  public static boolean ovrHmd_SetBool(ovrHmdDesc hmd, byte[] propertyName, int propertyName_offset, boolean value)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
        return ovrHmd_SetBool1(((hmd == null) ? null : hmd.getBuffer()), propertyName, propertyName_offset, false, value);
  }

  /** Interface to C language function: <br> <code>int ovrHmd_GetInt(ovrHmd hmd, const char *  propertyName, int defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int ovrHmd_GetInt(ovrHmdDesc hmd, ByteBuffer propertyName, int defaultVal)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
        return ovrHmd_GetInt1(((hmd == null) ? null : hmd.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, defaultVal);
  }

  /** Entry point to C language function: <code>int ovrHmd_GetInt(ovrHmd hmd, const char *  propertyName, int defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int ovrHmd_GetInt1(ByteBuffer hmd, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, int defaultVal);

  /** Interface to C language function: <br> <code>int ovrHmd_GetInt(ovrHmd hmd, const char *  propertyName, int defaultVal)</code><br>   */
  public static int ovrHmd_GetInt(ovrHmdDesc hmd, byte[] propertyName, int propertyName_offset, int defaultVal)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
        return ovrHmd_GetInt1(((hmd == null) ? null : hmd.getBuffer()), propertyName, propertyName_offset, false, defaultVal);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetInt(ovrHmd hmd, const char *  propertyName, int value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_SetInt(ovrHmdDesc hmd, ByteBuffer propertyName, int value)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
        return ovrHmd_SetInt1(((hmd == null) ? null : hmd.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, value);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_SetInt(ovrHmd hmd, const char *  propertyName, int value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_SetInt1(ByteBuffer hmd, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, int value);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetInt(ovrHmd hmd, const char *  propertyName, int value)</code><br>   */
  public static boolean ovrHmd_SetInt(ovrHmdDesc hmd, byte[] propertyName, int propertyName_offset, int value)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
        return ovrHmd_SetInt1(((hmd == null) ? null : hmd.getBuffer()), propertyName, propertyName_offset, false, value);
  }

  /** Interface to C language function: <br> <code>float ovrHmd_GetFloat(ovrHmd hmd, const char *  propertyName, float defaultVal)</code><br>   */
  public static float ovrHmd_GetFloat(ovrHmdDesc hmd, String propertyName, float defaultVal)  {

        return ovrHmd_GetFloat1(((hmd == null) ? null : hmd.getBuffer()), propertyName, defaultVal);
  }

  /** Entry point to C language function: <code>float ovrHmd_GetFloat(ovrHmd hmd, const char *  propertyName, float defaultVal)</code><br>   */
  private static native float ovrHmd_GetFloat1(ByteBuffer hmd, String propertyName, float defaultVal);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetFloat(ovrHmd hmd, const char *  propertyName, float value)</code><br>   */
  public static boolean ovrHmd_SetFloat(ovrHmdDesc hmd, String propertyName, float value)  {

        return ovrHmd_SetFloat1(((hmd == null) ? null : hmd.getBuffer()), propertyName, value);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_SetFloat(ovrHmd hmd, const char *  propertyName, float value)</code><br>   */
  private static native boolean ovrHmd_SetFloat1(ByteBuffer hmd, String propertyName, float value);

  /** Interface to C language function: <br> <code>unsigned int ovrHmd_GetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static int ovrHmd_GetFloatArray(ovrHmdDesc hmd, String propertyName, FloatBuffer values, int arraySize)  {

    final boolean values_is_direct = Buffers.isDirect(values);
        return ovrHmd_GetFloatArray1(((hmd == null) ? null : hmd.getBuffer()), propertyName, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, arraySize);
  }

  /** Entry point to C language function: <code>unsigned int ovrHmd_GetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native int ovrHmd_GetFloatArray1(ByteBuffer hmd, String propertyName, Object values, int values_byte_offset, boolean values_is_direct, int arraySize);

  /** Interface to C language function: <br> <code>unsigned int ovrHmd_GetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>   */
  public static int ovrHmd_GetFloatArray(ovrHmdDesc hmd, String propertyName, float[] values, int values_offset, int arraySize)  {

    if(values != null && values.length <= values_offset)
      throw new OVRException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
        return ovrHmd_GetFloatArray1(((hmd == null) ? null : hmd.getBuffer()), propertyName, values, Buffers.SIZEOF_FLOAT * values_offset, false, arraySize);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static boolean ovrHmd_SetFloatArray(ovrHmdDesc hmd, String propertyName, FloatBuffer values, int arraySize)  {

    final boolean values_is_direct = Buffers.isDirect(values);
        return ovrHmd_SetFloatArray1(((hmd == null) ? null : hmd.getBuffer()), propertyName, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, arraySize);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_SetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native boolean ovrHmd_SetFloatArray1(ByteBuffer hmd, String propertyName, Object values, int values_byte_offset, boolean values_is_direct, int arraySize);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetFloatArray(ovrHmd hmd, const char *  propertyName, float *  values, unsigned int arraySize)</code><br>   */
  public static boolean ovrHmd_SetFloatArray(ovrHmdDesc hmd, String propertyName, float[] values, int values_offset, int arraySize)  {

    if(values != null && values.length <= values_offset)
      throw new OVRException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
        return ovrHmd_SetFloatArray1(((hmd == null) ? null : hmd.getBuffer()), propertyName, values, Buffers.SIZEOF_FLOAT * values_offset, false, arraySize);
  }

  /** Interface to C language function: <br> <code>const char *  ovrHmd_GetString(ovrHmd hmd, const char *  propertyName, const char *  defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}
      @param defaultVal a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static String ovrHmd_GetString(ovrHmdDesc hmd, ByteBuffer propertyName, ByteBuffer defaultVal)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
    final boolean defaultVal_is_direct = Buffers.isDirect(defaultVal);
        return ovrHmd_GetString1(((hmd == null) ? null : hmd.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, defaultVal_is_direct ? defaultVal : Buffers.getArray(defaultVal), defaultVal_is_direct ? Buffers.getDirectBufferByteOffset(defaultVal) : Buffers.getIndirectBufferByteOffset(defaultVal), defaultVal_is_direct);
  }

  /** Entry point to C language function: <code>const char *  ovrHmd_GetString(ovrHmd hmd, const char *  propertyName, const char *  defaultVal)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}
      @param defaultVal a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native String ovrHmd_GetString1(ByteBuffer hmd, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, Object defaultVal, int defaultVal_byte_offset, boolean defaultVal_is_direct);

  /** Interface to C language function: <br> <code>const char *  ovrHmd_GetString(ovrHmd hmd, const char *  propertyName, const char *  defaultVal)</code><br>   */
  public static String ovrHmd_GetString(ovrHmdDesc hmd, byte[] propertyName, int propertyName_offset, byte[] defaultVal, int defaultVal_offset)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
    if(defaultVal != null && defaultVal.length <= defaultVal_offset)
      throw new OVRException("array offset argument \"defaultVal_offset\" (" + defaultVal_offset + ") equals or exceeds array length (" + defaultVal.length + ")");
        return ovrHmd_GetString1(((hmd == null) ? null : hmd.getBuffer()), propertyName, propertyName_offset, false, defaultVal, defaultVal_offset, false);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char *  propertyName, const char *  value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}
      @param value a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_SetString(ovrHmdDesc hmddesc, ByteBuffer propertyName, ByteBuffer value)  {

    final boolean propertyName_is_direct = Buffers.isDirect(propertyName);
    final boolean value_is_direct = Buffers.isDirect(value);
        return ovrHmd_SetString1(((hmddesc == null) ? null : hmddesc.getBuffer()), propertyName_is_direct ? propertyName : Buffers.getArray(propertyName), propertyName_is_direct ? Buffers.getDirectBufferByteOffset(propertyName) : Buffers.getIndirectBufferByteOffset(propertyName), propertyName_is_direct, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char *  propertyName, const char *  value)</code><br>
      @param propertyName a direct or array-backed {@link java.nio.ByteBuffer}
      @param value a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_SetString1(ByteBuffer hmddesc, Object propertyName, int propertyName_byte_offset, boolean propertyName_is_direct, Object value, int value_byte_offset, boolean value_is_direct);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_SetString(ovrHmd hmddesc, const char *  propertyName, const char *  value)</code><br>   */
  public static boolean ovrHmd_SetString(ovrHmdDesc hmddesc, byte[] propertyName, int propertyName_offset, byte[] value, int value_offset)  {

    if(propertyName != null && propertyName.length <= propertyName_offset)
      throw new OVRException("array offset argument \"propertyName_offset\" (" + propertyName_offset + ") equals or exceeds array length (" + propertyName.length + ")");
    if(value != null && value.length <= value_offset)
      throw new OVRException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
        return ovrHmd_SetString1(((hmddesc == null) ? null : hmddesc.getBuffer()), propertyName, propertyName_offset, false, value, value_offset, false);
  }

  /** Interface to C language function: <br> <code>int ovr_TraceMessage(int level, const char *  message)</code><br>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int ovr_TraceMessage(int level, ByteBuffer message)  {

    final boolean message_is_direct = Buffers.isDirect(message);
        return ovr_TraceMessage1(level, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct);
  }

  /** Entry point to C language function: <code>int ovr_TraceMessage(int level, const char *  message)</code><br>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int ovr_TraceMessage1(int level, Object message, int message_byte_offset, boolean message_is_direct);

  /** Interface to C language function: <br> <code>int ovr_TraceMessage(int level, const char *  message)</code><br>   */
  public static int ovr_TraceMessage(int level, byte[] message, int message_offset)  {

    if(message != null && message.length <= message_offset)
      throw new OVRException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
        return ovr_TraceMessage1(level, message, message_offset, false);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_StartPerfLog(ovrHmd hmd, const char *  fileName, const char *  userData1)</code><br>
      @param fileName a direct or array-backed {@link java.nio.ByteBuffer}
      @param userData1 a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static boolean ovrHmd_StartPerfLog(ovrHmdDesc hmd, ByteBuffer fileName, ByteBuffer userData1)  {

    final boolean fileName_is_direct = Buffers.isDirect(fileName);
    final boolean userData1_is_direct = Buffers.isDirect(userData1);
        return ovrHmd_StartPerfLog1(((hmd == null) ? null : hmd.getBuffer()), fileName_is_direct ? fileName : Buffers.getArray(fileName), fileName_is_direct ? Buffers.getDirectBufferByteOffset(fileName) : Buffers.getIndirectBufferByteOffset(fileName), fileName_is_direct, userData1_is_direct ? userData1 : Buffers.getArray(userData1), userData1_is_direct ? Buffers.getDirectBufferByteOffset(userData1) : Buffers.getIndirectBufferByteOffset(userData1), userData1_is_direct);
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_StartPerfLog(ovrHmd hmd, const char *  fileName, const char *  userData1)</code><br>
      @param fileName a direct or array-backed {@link java.nio.ByteBuffer}
      @param userData1 a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native boolean ovrHmd_StartPerfLog1(ByteBuffer hmd, Object fileName, int fileName_byte_offset, boolean fileName_is_direct, Object userData1, int userData1_byte_offset, boolean userData1_is_direct);

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_StartPerfLog(ovrHmd hmd, const char *  fileName, const char *  userData1)</code><br>   */
  public static boolean ovrHmd_StartPerfLog(ovrHmdDesc hmd, byte[] fileName, int fileName_offset, byte[] userData1, int userData1_offset)  {

    if(fileName != null && fileName.length <= fileName_offset)
      throw new OVRException("array offset argument \"fileName_offset\" (" + fileName_offset + ") equals or exceeds array length (" + fileName.length + ")");
    if(userData1 != null && userData1.length <= userData1_offset)
      throw new OVRException("array offset argument \"userData1_offset\" (" + userData1_offset + ") equals or exceeds array length (" + userData1.length + ")");
        return ovrHmd_StartPerfLog1(((hmd == null) ? null : hmd.getBuffer()), fileName, fileName_offset, false, userData1, userData1_offset, false);
  }

  /** Interface to C language function: <br> <code>ovrBool ovrHmd_StopPerfLog(ovrHmd hmd)</code><br>   */
  public static boolean ovrHmd_StopPerfLog(ovrHmdDesc hmd)  {

        return ovrHmd_StopPerfLog1(((hmd == null) ? null : hmd.getBuffer()));
  }

  /** Entry point to C language function: <code>ovrBool ovrHmd_StopPerfLog(ovrHmd hmd)</code><br>   */
  private static native boolean ovrHmd_StopPerfLog1(ByteBuffer hmd);

  /** Interface to C language function: <br> <code>ovrMatrix4f ovrMatrix4f_Projection(ovrFovPort fov, float znear, float zfar, unsigned int projectionModFlags)</code><br>   */
  public static ovrMatrix4f ovrMatrix4f_Projection(ovrFovPort fov, float znear, float zfar, int projectionModFlags)  {

    final ByteBuffer _res;
    _res = ovrMatrix4f_Projection1(((fov == null) ? null : fov.getBuffer()), znear, zfar, projectionModFlags);
    if (_res == null) return null;
    return ovrMatrix4f.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrMatrix4f ovrMatrix4f_Projection(ovrFovPort fov, float znear, float zfar, unsigned int projectionModFlags)</code><br>   */
  private static native ByteBuffer ovrMatrix4f_Projection1(ByteBuffer fov, float znear, float zfar, int projectionModFlags);

  /** Interface to C language function: <br> <code>ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale, float orthoDistance, float hmdToEyeViewOffsetX)</code><br>   */
  public static ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale, float orthoDistance, float hmdToEyeViewOffsetX)  {

    final ByteBuffer _res;
    _res = ovrMatrix4f_OrthoSubProjection1(((projection == null) ? null : projection.getBuffer()), ((orthoScale == null) ? null : orthoScale.getBuffer()), orthoDistance, hmdToEyeViewOffsetX);
    if (_res == null) return null;
    return ovrMatrix4f.create(Buffers.nativeOrder(_res));
  }

  /** Entry point to C language function: <code>ovrMatrix4f ovrMatrix4f_OrthoSubProjection(ovrMatrix4f projection, ovrVector2f orthoScale, float orthoDistance, float hmdToEyeViewOffsetX)</code><br>   */
  private static native ByteBuffer ovrMatrix4f_OrthoSubProjection1(ByteBuffer projection, ByteBuffer orthoScale, float orthoDistance, float hmdToEyeViewOffsetX);

  /** Interface to C language function: <br> <code>double ovr_WaitTillTime(double absTime)</code><br>   */
  public static native double ovr_WaitTillTime(double absTime);


  // --- Begin CustomJavaCode .cfg declarations
  
      static final DynamicLibraryBundle dynamicLookupHelper;
  
      static {
          dynamicLookupHelper = AccessController.doPrivileged(new PrivilegedAction<DynamicLibraryBundle>() {
                      public DynamicLibraryBundle run() {
                          final DynamicLibraryBundle bundle =  new DynamicLibraryBundle(new OVRDynamicLibraryBundleInfo());
                          if(null==bundle) {
                            throw new RuntimeException("Null DynamicLibraryBundle");
                          }
                          /** No native tool library to load
                          if(!bundle.isToolLibLoaded()) {
                            System.err.println("Couldn't load native OVR/JNI glue library");
                            return null;
                          } */
                          if(!bundle.isLibComplete()) {
                            System.err.println("Couldn't load native OVR/JNI glue library");
                            return null;
                          }
                          if( !initializeImpl() ) {
                            System.err.println("Native initialization failure of OVR/JNI glue library");
                            return null;
                          }
                          return bundle;
                      } } );
      }
  
      /**
       * Accessor.
       * @returns true if OVR library is available on this machine.
       */
      public static boolean isAvailable() { return dynamicLookupHelper != null; }
  
  // ---- End CustomJavaCode .cfg declarations

  private static native boolean initializeImpl();


  private static native int getCStringLengthImpl(final long pString);


} // end of class OVR
