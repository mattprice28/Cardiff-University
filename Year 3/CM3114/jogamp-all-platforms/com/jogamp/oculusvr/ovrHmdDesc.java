/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/JavaEmitter.java on Sat Oct 10 03:31:13 CEST 2015 ----! */


package com.jogamp.oculusvr;

import java.nio.*;

import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import jogamp.common.os.MachineDataInfoRuntime;

import com.jogamp.oculusvr.*;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class ovrHmdDesc {

  StructAccessor accessor;

  private static final int mdIdx = MachineDataInfoRuntime.getStatic().ordinal();
  private final MachineDataInfo md;

  private static final int[] ovrHmdDesc_size = new int[] { 172 /* ARM_MIPS_32 */, 172 /* X86_32_UNIX */, 172 /* X86_32_MACOS */, 172 /* PPC_32_UNIX */, 172 /* SPARC_32_SUNOS */, 172 /* X86_32_WINDOWS */, 200 /* LP64_UNIX */, 200 /* X86_64_WINDOWS */  };
  private static final int[] Handle_offset = new int[] { 0 /* ARM_MIPS_32 */, 0 /* X86_32_UNIX */, 0 /* X86_32_MACOS */, 0 /* PPC_32_UNIX */, 0 /* SPARC_32_SUNOS */, 0 /* X86_32_WINDOWS */, 0 /* LP64_UNIX */, 0 /* X86_64_WINDOWS */ };
//private static final int[] Handle_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };// JType[OvrHmdContext / 'OvrHmdContext', is[compound, ], descriptor 'LOvrHmdContext;']
  private static final int[] Type_offset = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */ };
//private static final int[] Type_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] ProductName_offset = new int[] { 8 /* ARM_MIPS_32 */, 8 /* X86_32_UNIX */, 8 /* X86_32_MACOS */, 8 /* PPC_32_UNIX */, 8 /* SPARC_32_SUNOS */, 8 /* X86_32_WINDOWS */, 16 /* LP64_UNIX */, 16 /* X86_64_WINDOWS */ };
//private static final int[] ProductName_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };// JType[ANON / NIL, primitivePointerType = CHAR, is[C-Primitive-Pointer, ], descriptor 'ANON_NIO']
  private static final int[] Manufacturer_offset = new int[] { 12 /* ARM_MIPS_32 */, 12 /* X86_32_UNIX */, 12 /* X86_32_MACOS */, 12 /* PPC_32_UNIX */, 12 /* SPARC_32_SUNOS */, 12 /* X86_32_WINDOWS */, 24 /* LP64_UNIX */, 24 /* X86_64_WINDOWS */ };
//private static final int[] Manufacturer_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };// JType[ANON / NIL, primitivePointerType = CHAR, is[C-Primitive-Pointer, ], descriptor 'ANON_NIO']
  private static final int[] VendorId_offset = new int[] { 16 /* ARM_MIPS_32 */, 16 /* X86_32_UNIX */, 16 /* X86_32_MACOS */, 16 /* PPC_32_UNIX */, 16 /* SPARC_32_SUNOS */, 16 /* X86_32_WINDOWS */, 32 /* LP64_UNIX */, 32 /* X86_64_WINDOWS */ };
//private static final int[] VendorId_size = new int[] { 2 /* ARM_MIPS_32 */, 2 /* X86_32_UNIX */, 2 /* X86_32_MACOS */, 2 /* PPC_32_UNIX */, 2 /* SPARC_32_SUNOS */, 2 /* X86_32_WINDOWS */, 2 /* LP64_UNIX */, 2 /* X86_64_WINDOWS */  };
  private static final int[] ProductId_offset = new int[] { 18 /* ARM_MIPS_32 */, 18 /* X86_32_UNIX */, 18 /* X86_32_MACOS */, 18 /* PPC_32_UNIX */, 18 /* SPARC_32_SUNOS */, 18 /* X86_32_WINDOWS */, 34 /* LP64_UNIX */, 34 /* X86_64_WINDOWS */ };
//private static final int[] ProductId_size = new int[] { 2 /* ARM_MIPS_32 */, 2 /* X86_32_UNIX */, 2 /* X86_32_MACOS */, 2 /* PPC_32_UNIX */, 2 /* SPARC_32_SUNOS */, 2 /* X86_32_WINDOWS */, 2 /* LP64_UNIX */, 2 /* X86_64_WINDOWS */  };
  private static final int[] SerialNumber_offset = new int[] { 20 /* ARM_MIPS_32 */, 20 /* X86_32_UNIX */, 20 /* X86_32_MACOS */, 20 /* PPC_32_UNIX */, 20 /* SPARC_32_SUNOS */, 20 /* X86_32_WINDOWS */, 36 /* LP64_UNIX */, 36 /* X86_64_WINDOWS */ };
  private static final int[] SerialNumber_size = new int[] { 24 /* ARM_MIPS_32 */, 24 /* X86_32_UNIX */, 24 /* X86_32_MACOS */, 24 /* PPC_32_UNIX */, 24 /* SPARC_32_SUNOS */, 24 /* X86_32_WINDOWS */, 24 /* LP64_UNIX */, 24 /* X86_64_WINDOWS */  };
  private static final int[] FirmwareMajor_offset = new int[] { 44 /* ARM_MIPS_32 */, 44 /* X86_32_UNIX */, 44 /* X86_32_MACOS */, 44 /* PPC_32_UNIX */, 44 /* SPARC_32_SUNOS */, 44 /* X86_32_WINDOWS */, 60 /* LP64_UNIX */, 60 /* X86_64_WINDOWS */ };
//private static final int[] FirmwareMajor_size = new int[] { 2 /* ARM_MIPS_32 */, 2 /* X86_32_UNIX */, 2 /* X86_32_MACOS */, 2 /* PPC_32_UNIX */, 2 /* SPARC_32_SUNOS */, 2 /* X86_32_WINDOWS */, 2 /* LP64_UNIX */, 2 /* X86_64_WINDOWS */  };
  private static final int[] FirmwareMinor_offset = new int[] { 46 /* ARM_MIPS_32 */, 46 /* X86_32_UNIX */, 46 /* X86_32_MACOS */, 46 /* PPC_32_UNIX */, 46 /* SPARC_32_SUNOS */, 46 /* X86_32_WINDOWS */, 62 /* LP64_UNIX */, 62 /* X86_64_WINDOWS */ };
//private static final int[] FirmwareMinor_size = new int[] { 2 /* ARM_MIPS_32 */, 2 /* X86_32_UNIX */, 2 /* X86_32_MACOS */, 2 /* PPC_32_UNIX */, 2 /* SPARC_32_SUNOS */, 2 /* X86_32_WINDOWS */, 2 /* LP64_UNIX */, 2 /* X86_64_WINDOWS */  };
  private static final int[] CameraFrustumHFovInRadians_offset = new int[] { 48 /* ARM_MIPS_32 */, 48 /* X86_32_UNIX */, 48 /* X86_32_MACOS */, 48 /* PPC_32_UNIX */, 48 /* SPARC_32_SUNOS */, 48 /* X86_32_WINDOWS */, 64 /* LP64_UNIX */, 64 /* X86_64_WINDOWS */ };
//private static final int[] CameraFrustumHFovInRadians_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] CameraFrustumVFovInRadians_offset = new int[] { 52 /* ARM_MIPS_32 */, 52 /* X86_32_UNIX */, 52 /* X86_32_MACOS */, 52 /* PPC_32_UNIX */, 52 /* SPARC_32_SUNOS */, 52 /* X86_32_WINDOWS */, 68 /* LP64_UNIX */, 68 /* X86_64_WINDOWS */ };
//private static final int[] CameraFrustumVFovInRadians_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] CameraFrustumNearZInMeters_offset = new int[] { 56 /* ARM_MIPS_32 */, 56 /* X86_32_UNIX */, 56 /* X86_32_MACOS */, 56 /* PPC_32_UNIX */, 56 /* SPARC_32_SUNOS */, 56 /* X86_32_WINDOWS */, 72 /* LP64_UNIX */, 72 /* X86_64_WINDOWS */ };
//private static final int[] CameraFrustumNearZInMeters_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] CameraFrustumFarZInMeters_offset = new int[] { 60 /* ARM_MIPS_32 */, 60 /* X86_32_UNIX */, 60 /* X86_32_MACOS */, 60 /* PPC_32_UNIX */, 60 /* SPARC_32_SUNOS */, 60 /* X86_32_WINDOWS */, 76 /* LP64_UNIX */, 76 /* X86_64_WINDOWS */ };
//private static final int[] CameraFrustumFarZInMeters_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] HmdCaps_offset = new int[] { 64 /* ARM_MIPS_32 */, 64 /* X86_32_UNIX */, 64 /* X86_32_MACOS */, 64 /* PPC_32_UNIX */, 64 /* SPARC_32_SUNOS */, 64 /* X86_32_WINDOWS */, 80 /* LP64_UNIX */, 80 /* X86_64_WINDOWS */ };
//private static final int[] HmdCaps_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] TrackingCaps_offset = new int[] { 68 /* ARM_MIPS_32 */, 68 /* X86_32_UNIX */, 68 /* X86_32_MACOS */, 68 /* PPC_32_UNIX */, 68 /* SPARC_32_SUNOS */, 68 /* X86_32_WINDOWS */, 84 /* LP64_UNIX */, 84 /* X86_64_WINDOWS */ };
//private static final int[] TrackingCaps_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] DistortionCaps_offset = new int[] { 72 /* ARM_MIPS_32 */, 72 /* X86_32_UNIX */, 72 /* X86_32_MACOS */, 72 /* PPC_32_UNIX */, 72 /* SPARC_32_SUNOS */, 72 /* X86_32_WINDOWS */, 88 /* LP64_UNIX */, 88 /* X86_64_WINDOWS */ };
//private static final int[] DistortionCaps_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };
  private static final int[] DefaultEyeFov_offset = new int[] { 76 /* ARM_MIPS_32 */, 76 /* X86_32_UNIX */, 76 /* X86_32_MACOS */, 76 /* PPC_32_UNIX */, 76 /* SPARC_32_SUNOS */, 76 /* X86_32_WINDOWS */, 92 /* LP64_UNIX */, 92 /* X86_64_WINDOWS */ };
  private static final int[] DefaultEyeFov_size = new int[] { 32 /* ARM_MIPS_32 */, 32 /* X86_32_UNIX */, 32 /* X86_32_MACOS */, 32 /* PPC_32_UNIX */, 32 /* SPARC_32_SUNOS */, 32 /* X86_32_WINDOWS */, 32 /* LP64_UNIX */, 32 /* X86_64_WINDOWS */  };
  private static final int[] MaxEyeFov_offset = new int[] { 108 /* ARM_MIPS_32 */, 108 /* X86_32_UNIX */, 108 /* X86_32_MACOS */, 108 /* PPC_32_UNIX */, 108 /* SPARC_32_SUNOS */, 108 /* X86_32_WINDOWS */, 124 /* LP64_UNIX */, 124 /* X86_64_WINDOWS */ };
  private static final int[] MaxEyeFov_size = new int[] { 32 /* ARM_MIPS_32 */, 32 /* X86_32_UNIX */, 32 /* X86_32_MACOS */, 32 /* PPC_32_UNIX */, 32 /* SPARC_32_SUNOS */, 32 /* X86_32_WINDOWS */, 32 /* LP64_UNIX */, 32 /* X86_64_WINDOWS */  };
  private static final int[] EyeRenderOrder_offset = new int[] { 140 /* ARM_MIPS_32 */, 140 /* X86_32_UNIX */, 140 /* X86_32_MACOS */, 140 /* PPC_32_UNIX */, 140 /* SPARC_32_SUNOS */, 140 /* X86_32_WINDOWS */, 156 /* LP64_UNIX */, 156 /* X86_64_WINDOWS */ };
  private static final int[] EyeRenderOrder_size = new int[] { 8 /* ARM_MIPS_32 */, 8 /* X86_32_UNIX */, 8 /* X86_32_MACOS */, 8 /* PPC_32_UNIX */, 8 /* SPARC_32_SUNOS */, 8 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };
  private static final int[] Resolution_offset = new int[] { 148 /* ARM_MIPS_32 */, 148 /* X86_32_UNIX */, 148 /* X86_32_MACOS */, 148 /* PPC_32_UNIX */, 148 /* SPARC_32_SUNOS */, 148 /* X86_32_WINDOWS */, 164 /* LP64_UNIX */, 164 /* X86_64_WINDOWS */ };
  private static final int[] Resolution_size = new int[] { 8 /* ARM_MIPS_32 */, 8 /* X86_32_UNIX */, 8 /* X86_32_MACOS */, 8 /* PPC_32_UNIX */, 8 /* SPARC_32_SUNOS */, 8 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };
  private static final int[] WindowsPos_offset = new int[] { 156 /* ARM_MIPS_32 */, 156 /* X86_32_UNIX */, 156 /* X86_32_MACOS */, 156 /* PPC_32_UNIX */, 156 /* SPARC_32_SUNOS */, 156 /* X86_32_WINDOWS */, 172 /* LP64_UNIX */, 172 /* X86_64_WINDOWS */ };
  private static final int[] WindowsPos_size = new int[] { 8 /* ARM_MIPS_32 */, 8 /* X86_32_UNIX */, 8 /* X86_32_MACOS */, 8 /* PPC_32_UNIX */, 8 /* SPARC_32_SUNOS */, 8 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };
  private static final int[] DisplayDeviceName_offset = new int[] { 164 /* ARM_MIPS_32 */, 164 /* X86_32_UNIX */, 164 /* X86_32_MACOS */, 164 /* PPC_32_UNIX */, 164 /* SPARC_32_SUNOS */, 164 /* X86_32_WINDOWS */, 184 /* LP64_UNIX */, 184 /* X86_64_WINDOWS */ };
//private static final int[] DisplayDeviceName_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 8 /* LP64_UNIX */, 8 /* X86_64_WINDOWS */  };// JType[ANON / NIL, primitivePointerType = CHAR, is[C-Primitive-Pointer, ], descriptor 'ANON_NIO']
  private static final int[] DisplayId_offset = new int[] { 168 /* ARM_MIPS_32 */, 168 /* X86_32_UNIX */, 168 /* X86_32_MACOS */, 168 /* PPC_32_UNIX */, 168 /* SPARC_32_SUNOS */, 168 /* X86_32_WINDOWS */, 192 /* LP64_UNIX */, 192 /* X86_64_WINDOWS */ };
//private static final int[] DisplayId_size = new int[] { 4 /* ARM_MIPS_32 */, 4 /* X86_32_UNIX */, 4 /* X86_32_MACOS */, 4 /* PPC_32_UNIX */, 4 /* SPARC_32_SUNOS */, 4 /* X86_32_WINDOWS */, 4 /* LP64_UNIX */, 4 /* X86_64_WINDOWS */  };

  public static int size() {
    return ovrHmdDesc_size[mdIdx];
  }

  public static ovrHmdDesc create() {
    return create(Buffers.newDirectByteBuffer(size()));
  }

  public static ovrHmdDesc create(java.nio.ByteBuffer buf) {
      return new ovrHmdDesc(buf);
  }

  ovrHmdDesc(java.nio.ByteBuffer buf) {
    md = MachineDataInfo.StaticConfig.values()[mdIdx].md;
    accessor = new StructAccessor(buf);
  }

  public java.nio.ByteBuffer getBuffer() {
    return accessor.getBuffer();
  }

  // SKIP setter for complex-pointer type in struct: ovrHmdDesc.Handle: CType[(PointerType) 'OvrHmdContext *' -> (OvrHmdContext) * , size [fixed false, lnx64 8], [const[false], pointer*1]]

  /** Entry point to C language function: <code>OvrHmdContext *  getHandle(const ovrHmd this0, const int32_t elem_offset)</code><br>, covering an array of length <code>1</code>   */
  private native ByteBuffer getHandle0(ByteBuffer jthis0, int elem_offset);

  /** Getter for native field <code>Handle</code>: CType[(PointerType) 'OvrHmdContext *' -> (OvrHmdContext) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>1</code> */
  public OvrHmdContext getHandle() {
    final ByteBuffer source = getBuffer();
    final ByteBuffer _res = getHandle0(source, 0);
    if (_res == null) return null;
    return OvrHmdContext.create(_res);
  }

  /** Setter for native field <code>Type</code>: CType[(EnumType) typedef 'ovrHmdType', size [fixed true, lnx64 4], [const[type , false], enum  [const ovrHmdType_] {8: [ovrHmd_None = [0, [int: 0]], [ovrHmd_DK1 = [3, [int: 3]], [ovrHmd_DKHD = [4, [int: 4]], [ovrHmd_DK2 = [6, [int: 6]], [ovrHmd_BlackStar = [7, [int: 7]], [ovrHmd_CB = [8, [int: 8]], [ovrHmd_Other = [9, [int: 9]], [ovrHmd_EnumSize = [0x7fffffff, [int: 2147483647]], }, int]] */
  public ovrHmdDesc setType(int val) {
    accessor.setIntAt(Type_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>Type</code>: CType[(EnumType) typedef 'ovrHmdType', size [fixed true, lnx64 4], [const[type , false], enum  [const ovrHmdType_] {8: [ovrHmd_None = [0, [int: 0]], [ovrHmd_DK1 = [3, [int: 3]], [ovrHmd_DKHD = [4, [int: 4]], [ovrHmd_DK2 = [6, [int: 6]], [ovrHmd_BlackStar = [7, [int: 7]], [ovrHmd_CB = [8, [int: 8]], [ovrHmd_Other = [9, [int: 9]], [ovrHmd_EnumSize = [0x7fffffff, [int: 2147483647]], }, int]] */
  public int getType() {
    return accessor.getIntAt(Type_offset[mdIdx]);
  }

  /** Entry point to C language function: <code>const char *  getProductName(const ovrHmd this0, const int32_t arrayLength)</code><br>, covering an array of length <code>getCStringLengthImpl(pString)+1</code>   */
  private native ByteBuffer getProductName0(ByteBuffer jthis0, int arrayLength);

  /** Getter for native field <code>ProductName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public ByteBuffer getProductName() {
    final int arrayLength = getProductNameArrayLength();
    final ByteBuffer _res = getProductName0(getBuffer(), arrayLength);
    if (_res == null) return null;
    return Buffers.nativeOrder(_res);
  }

  /** Getter for native field <code>ProductName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public String getProductNameAsString() {
    final int arrayLength = getProductNameArrayLength();
    final ByteBuffer bb = getProductName0(getBuffer(), arrayLength);
    if (bb == null) return null;
    final byte[] ba = new byte[arrayLength];
    int i = -1;
    while( ++i < arrayLength ) {
      ba[i] = bb.get(i);
      if( (byte)0 == ba[i] ) break;
    }
    return new String(ba, 0, i);
  }

  /** Getter for native field <code>ProductName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public final int getProductNameArrayLength() {
    final long pString = PointerBuffer.wrap( accessor.slice(ProductName_offset[mdIdx],  PointerBuffer.ELEMENT_SIZE) ).get(0);
    return getCStringLengthImpl(pString)+1;
  }

  /** Entry point to C language function: <code>const char *  getManufacturer(const ovrHmd this0, const int32_t arrayLength)</code><br>, covering an array of length <code>getCStringLengthImpl(pString)+1</code>   */
  private native ByteBuffer getManufacturer0(ByteBuffer jthis0, int arrayLength);

  /** Getter for native field <code>Manufacturer</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public ByteBuffer getManufacturer() {
    final int arrayLength = getManufacturerArrayLength();
    final ByteBuffer _res = getManufacturer0(getBuffer(), arrayLength);
    if (_res == null) return null;
    return Buffers.nativeOrder(_res);
  }

  /** Getter for native field <code>Manufacturer</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public String getManufacturerAsString() {
    final int arrayLength = getManufacturerArrayLength();
    final ByteBuffer bb = getManufacturer0(getBuffer(), arrayLength);
    if (bb == null) return null;
    final byte[] ba = new byte[arrayLength];
    int i = -1;
    while( ++i < arrayLength ) {
      ba[i] = bb.get(i);
      if( (byte)0 == ba[i] ) break;
    }
    return new String(ba, 0, i);
  }

  /** Getter for native field <code>Manufacturer</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public final int getManufacturerArrayLength() {
    final long pString = PointerBuffer.wrap( accessor.slice(Manufacturer_offset[mdIdx],  PointerBuffer.ELEMENT_SIZE) ).get(0);
    return getCStringLengthImpl(pString)+1;
  }

  /** Setter for native field <code>VendorId</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public ovrHmdDesc setVendorId(short val) {
    accessor.setShortAt(VendorId_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>VendorId</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public short getVendorId() {
    return accessor.getShortAt(VendorId_offset[mdIdx]);
  }

  /** Setter for native field <code>ProductId</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public ovrHmdDesc setProductId(short val) {
    accessor.setShortAt(ProductId_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>ProductId</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public short getProductId() {
    return accessor.getShortAt(ProductId_offset[mdIdx]);
  }

  /** Getter for native field <code>SerialNumber</code>: CType[(ArrayType) 'char *', size [fixed false, lnx64 24], [const[false], array*1]], with array length of <code>24</code> */
  public static final int getSerialNumberArrayLength() {
    return 24;
  }

  /** Setter for native field <code>SerialNumber</code>: CType[(ArrayType) 'char *', size [fixed false, lnx64 24], [const[false], array*1]], with array length of <code>24</code> */
  public ovrHmdDesc setSerialNumber(final int offset, byte[] val) {
    final int arrayLength = 24;
    if( offset + val.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + val.length "+val.length+" > array-length "+arrayLength); };
    final int elemSize = Buffers.SIZEOF_BYTE;
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > SerialNumber_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+SerialNumber_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = SerialNumber_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * offset;
    accessor.setBytesAt(bOffset, val);
    return this;
  }

  /** Getter for native field <code>SerialNumber</code>: CType[(ArrayType) 'char *', size [fixed false, lnx64 24], [const[false], array*1]], with array length of <code>24</code> */
  public ByteBuffer getSerialNumber() {
    return accessor.slice(SerialNumber_offset[mdIdx],  Buffers.SIZEOF_BYTE * 24);
  }

  /** Getter for native field <code>SerialNumber</code>: CType[(ArrayType) 'char *', size [fixed false, lnx64 24], [const[false], array*1]], with array length of <code>24</code> */
  public String getSerialNumberAsString() {
    final int offset = SerialNumber_offset[mdIdx];
    final int arrayLength = 24;
    final ByteBuffer bb = getBuffer();
    final byte[] ba = new byte[arrayLength];
    int i = -1;
    while( ++i < arrayLength ) {
      ba[i] = bb.get(offset+i);
      if( (byte)0 == ba[i] ) break;
    }
    return new String(ba, 0, i);
  }

  /** Setter for native field <code>FirmwareMajor</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public ovrHmdDesc setFirmwareMajor(short val) {
    accessor.setShortAt(FirmwareMajor_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>FirmwareMajor</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public short getFirmwareMajor() {
    return accessor.getShortAt(FirmwareMajor_offset[mdIdx]);
  }

  /** Setter for native field <code>FirmwareMinor</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public ovrHmdDesc setFirmwareMinor(short val) {
    accessor.setShortAt(FirmwareMinor_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>FirmwareMinor</code>: CType[(IntType) 'short', size [fixed true, lnx64 2], [const[false], int]] */
  public short getFirmwareMinor() {
    return accessor.getShortAt(FirmwareMinor_offset[mdIdx]);
  }

  /** Setter for native field <code>CameraFrustumHFovInRadians</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public ovrHmdDesc setCameraFrustumHFovInRadians(float val) {
    accessor.setFloatAt(CameraFrustumHFovInRadians_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>CameraFrustumHFovInRadians</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public float getCameraFrustumHFovInRadians() {
    return accessor.getFloatAt(CameraFrustumHFovInRadians_offset[mdIdx]);
  }

  /** Setter for native field <code>CameraFrustumVFovInRadians</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public ovrHmdDesc setCameraFrustumVFovInRadians(float val) {
    accessor.setFloatAt(CameraFrustumVFovInRadians_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>CameraFrustumVFovInRadians</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public float getCameraFrustumVFovInRadians() {
    return accessor.getFloatAt(CameraFrustumVFovInRadians_offset[mdIdx]);
  }

  /** Setter for native field <code>CameraFrustumNearZInMeters</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public ovrHmdDesc setCameraFrustumNearZInMeters(float val) {
    accessor.setFloatAt(CameraFrustumNearZInMeters_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>CameraFrustumNearZInMeters</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public float getCameraFrustumNearZInMeters() {
    return accessor.getFloatAt(CameraFrustumNearZInMeters_offset[mdIdx]);
  }

  /** Setter for native field <code>CameraFrustumFarZInMeters</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public ovrHmdDesc setCameraFrustumFarZInMeters(float val) {
    accessor.setFloatAt(CameraFrustumFarZInMeters_offset[mdIdx], val);
    return this;
  }

  /** Getter for native field <code>CameraFrustumFarZInMeters</code>: CType[(FloatType) 'float', size [fixed true, lnx64 4], [const[false], float]] */
  public float getCameraFrustumFarZInMeters() {
    return accessor.getFloatAt(CameraFrustumFarZInMeters_offset[mdIdx]);
  }

  /** Setter for native field <code>HmdCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public ovrHmdDesc setHmdCaps(int val) {
    accessor.setIntAt(HmdCaps_offset[mdIdx], val, md.intSizeInBytes());
    return this;
  }

  /** Getter for native field <code>HmdCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public int getHmdCaps() {
    return accessor.getIntAt(HmdCaps_offset[mdIdx], md.intSizeInBytes());
  }

  /** Setter for native field <code>TrackingCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public ovrHmdDesc setTrackingCaps(int val) {
    accessor.setIntAt(TrackingCaps_offset[mdIdx], val, md.intSizeInBytes());
    return this;
  }

  /** Getter for native field <code>TrackingCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public int getTrackingCaps() {
    return accessor.getIntAt(TrackingCaps_offset[mdIdx], md.intSizeInBytes());
  }

  /** Setter for native field <code>DistortionCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public ovrHmdDesc setDistortionCaps(int val) {
    accessor.setIntAt(DistortionCaps_offset[mdIdx], val, md.intSizeInBytes());
    return this;
  }

  /** Getter for native field <code>DistortionCaps</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public int getDistortionCaps() {
    return accessor.getIntAt(DistortionCaps_offset[mdIdx], md.intSizeInBytes());
  }

  /** Getter for native field <code>DefaultEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public static final int getDefaultEyeFovArrayLength() {
    return 2;
  }

  /** Setter for native field <code>DefaultEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrHmdDesc setDefaultEyeFov(final int offset, ovrFovPort[] val) {
    final int arrayLength = 2;
    if( offset + val.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + val.length "+val.length+" > array-length "+arrayLength); };
    final int elemSize = ovrFovPort.size();
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > DefaultEyeFov_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+DefaultEyeFov_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = DefaultEyeFov_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * offset;
    for(int index=0; index<val.length; index++) {
      final ByteBuffer sourceB = val[index].getBuffer();
      for(int f=0; f<elemSize; f++) {
        if( bOffset >= bLimes ) { throw new IndexOutOfBoundsException("elem-byte["+(offset+index)+"]["+f+"]: bOffset "+bOffset+" >= bLimes "+bLimes+", elemSize "+elemSize+" * "+arrayLength); };
        destB.put(bOffset++, sourceB.get(f));
      }
    }
    return this;
  }

  /** Setter for native field <code>DefaultEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrHmdDesc setDefaultEyeFov(final int index, ovrFovPort val) {
    final int arrayLength = 2;
    final int elemSize = ovrFovPort.size();
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > DefaultEyeFov_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+DefaultEyeFov_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = DefaultEyeFov_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * index;
    final ByteBuffer sourceB = val.getBuffer();
    for(int f=0; f<elemSize; f++) {
      if( bOffset >= bLimes ) { throw new IndexOutOfBoundsException("elem-byte["+index+"]["+f+"]: bOffset "+bOffset+" >= bLimes "+bLimes+", elemSize "+elemSize+" * "+arrayLength); };
      destB.put(bOffset++, sourceB.get(f));
    }
    return this;
  }

  /** Getter for native field <code>DefaultEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrFovPort[] getDefaultEyeFov(final int offset, ovrFovPort result[]) {
    final int arrayLength = 2;
    if( offset + result.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + result.length "+result.length+" > array-length "+arrayLength); };
    final int elemSize = ovrFovPort.size();
    int bOffset = DefaultEyeFov_offset[mdIdx] + ( elemSize * offset );
    for(int index=0; index<result.length; index++) {
      result[index] = ovrFovPort.create(accessor.slice(bOffset, elemSize));
      bOffset += elemSize;
    }
    return result;
  }

  /** Getter for native field <code>MaxEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public static final int getMaxEyeFovArrayLength() {
    return 2;
  }

  /** Setter for native field <code>MaxEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrHmdDesc setMaxEyeFov(final int offset, ovrFovPort[] val) {
    final int arrayLength = 2;
    if( offset + val.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + val.length "+val.length+" > array-length "+arrayLength); };
    final int elemSize = ovrFovPort.size();
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > MaxEyeFov_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+MaxEyeFov_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = MaxEyeFov_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * offset;
    for(int index=0; index<val.length; index++) {
      final ByteBuffer sourceB = val[index].getBuffer();
      for(int f=0; f<elemSize; f++) {
        if( bOffset >= bLimes ) { throw new IndexOutOfBoundsException("elem-byte["+(offset+index)+"]["+f+"]: bOffset "+bOffset+" >= bLimes "+bLimes+", elemSize "+elemSize+" * "+arrayLength); };
        destB.put(bOffset++, sourceB.get(f));
      }
    }
    return this;
  }

  /** Setter for native field <code>MaxEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrHmdDesc setMaxEyeFov(final int index, ovrFovPort val) {
    final int arrayLength = 2;
    final int elemSize = ovrFovPort.size();
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > MaxEyeFov_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+MaxEyeFov_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = MaxEyeFov_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * index;
    final ByteBuffer sourceB = val.getBuffer();
    for(int f=0; f<elemSize; f++) {
      if( bOffset >= bLimes ) { throw new IndexOutOfBoundsException("elem-byte["+index+"]["+f+"]: bOffset "+bOffset+" >= bLimes "+bLimes+", elemSize "+elemSize+" * "+arrayLength); };
      destB.put(bOffset++, sourceB.get(f));
    }
    return this;
  }

  /** Getter for native field <code>MaxEyeFov</code>: CType[(ArrayType) 'ovrFovPort *', size [fixed false, lnx64 32], [const[false], array*1]], with array length of <code>2</code> */
  public ovrFovPort[] getMaxEyeFov(final int offset, ovrFovPort result[]) {
    final int arrayLength = 2;
    if( offset + result.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + result.length "+result.length+" > array-length "+arrayLength); };
    final int elemSize = ovrFovPort.size();
    int bOffset = MaxEyeFov_offset[mdIdx] + ( elemSize * offset );
    for(int index=0; index<result.length; index++) {
      result[index] = ovrFovPort.create(accessor.slice(bOffset, elemSize));
      bOffset += elemSize;
    }
    return result;
  }

  /** Getter for native field <code>EyeRenderOrder</code>: CType[(ArrayType) 'ovrEyeType *', size [fixed false, lnx64 8], [const[false], array*1]], with array length of <code>2</code> */
  public static final int getEyeRenderOrderArrayLength() {
    return 2;
  }

  /** Setter for native field <code>EyeRenderOrder</code>: CType[(ArrayType) 'ovrEyeType *', size [fixed false, lnx64 8], [const[false], array*1]], with array length of <code>2</code> */
  public ovrHmdDesc setEyeRenderOrder(final int offset, int[] val) {
    final int arrayLength = 2;
    if( offset + val.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + val.length "+val.length+" > array-length "+arrayLength); };
    final int elemSize = Buffers.SIZEOF_INT;
    final ByteBuffer destB = getBuffer();
    final int bTotal = arrayLength * elemSize;
    if( bTotal > EyeRenderOrder_size[mdIdx] ) { throw new IndexOutOfBoundsException("bTotal "+bTotal+" > size "+EyeRenderOrder_size[mdIdx]+", elemSize "+elemSize+" * "+arrayLength); };
    int bOffset = EyeRenderOrder_offset[mdIdx];
    final int bLimes = bOffset + bTotal;
    if( bLimes > destB.limit() ) { throw new IndexOutOfBoundsException("bLimes "+bLimes+" > buffer.limit "+destB.limit()+", elemOff "+bOffset+", elemSize "+elemSize+" * "+arrayLength); };
    bOffset += elemSize * offset;
    accessor.setIntsAt(bOffset, val);
    return this;
  }

  /** Getter for native field <code>EyeRenderOrder</code>: CType[(ArrayType) 'ovrEyeType *', size [fixed false, lnx64 8], [const[false], array*1]], with array length of <code>2</code> */
  public IntBuffer getEyeRenderOrder() {
    return accessor.slice(EyeRenderOrder_offset[mdIdx],  Buffers.SIZEOF_INT * 2).asIntBuffer();
  }

  /** Getter for native field <code>EyeRenderOrder</code>: CType[(ArrayType) 'ovrEyeType *', size [fixed false, lnx64 8], [const[false], array*1]], with array length of <code>2</code> */
  public int[] getEyeRenderOrder(final int offset, int result[]) {
    final int arrayLength = 2;
    if( offset + result.length > arrayLength ) { throw new IndexOutOfBoundsException("offset "+offset+" + result.length "+result.length+" > array-length "+arrayLength); };
    return accessor.getIntsAt(EyeRenderOrder_offset[mdIdx] + (Buffers.SIZEOF_INT * offset), result);
  }


  /** Getter for native field <code>Resolution</code>: CType[(StructType) typedef 'ovrSizei', size [fixed false, lnx64 8], [const[false], struct{ovrSizei_: 2, }]] */
  public ovrSizei getResolution() {
    return ovrSizei.create( accessor.slice( Resolution_offset[mdIdx], Resolution_size[mdIdx] ) );
 }

  /** Getter for native field <code>WindowsPos</code>: CType[(StructType) typedef 'ovrVector2i', size [fixed false, lnx64 8], [const[false], struct{ovrVector2i_: 2, }]] */
  public ovrVector2i getWindowsPos() {
    return ovrVector2i.create( accessor.slice( WindowsPos_offset[mdIdx], WindowsPos_size[mdIdx] ) );
 }

  /** Entry point to C language function: <code>const char *  getDisplayDeviceName(const ovrHmd this0, const int32_t arrayLength)</code><br>, covering an array of length <code>getCStringLengthImpl(pString)+1</code>   */
  private native ByteBuffer getDisplayDeviceName0(ByteBuffer jthis0, int arrayLength);

  /** Getter for native field <code>DisplayDeviceName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public ByteBuffer getDisplayDeviceName() {
    final int arrayLength = getDisplayDeviceNameArrayLength();
    final ByteBuffer _res = getDisplayDeviceName0(getBuffer(), arrayLength);
    if (_res == null) return null;
    return Buffers.nativeOrder(_res);
  }

  /** Getter for native field <code>DisplayDeviceName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public String getDisplayDeviceNameAsString() {
    final int arrayLength = getDisplayDeviceNameArrayLength();
    final ByteBuffer bb = getDisplayDeviceName0(getBuffer(), arrayLength);
    if (bb == null) return null;
    final byte[] ba = new byte[arrayLength];
    int i = -1;
    while( ++i < arrayLength ) {
      ba[i] = bb.get(i);
      if( (byte)0 == ba[i] ) break;
    }
    return new String(ba, 0, i);
  }

  /** Getter for native field <code>DisplayDeviceName</code>: CType[(PointerType) 'char *' -> (const char) * , size [fixed false, lnx64 8], [const[false], pointer*1]], with array length of <code>getCStringLengthImpl(pString)+1</code> */
  public final int getDisplayDeviceNameArrayLength() {
    final long pString = PointerBuffer.wrap( accessor.slice(DisplayDeviceName_offset[mdIdx],  PointerBuffer.ELEMENT_SIZE) ).get(0);
    return getCStringLengthImpl(pString)+1;
  }

  /** Setter for native field <code>DisplayId</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public ovrHmdDesc setDisplayId(int val) {
    accessor.setIntAt(DisplayId_offset[mdIdx], val, md.intSizeInBytes());
    return this;
  }

  /** Getter for native field <code>DisplayId</code>: CType[(IntType) 'int', size [fixed false, lnx64 4], [const[false], int]] */
  public int getDisplayId() {
    return accessor.getIntAt(DisplayId_offset[mdIdx], md.intSizeInBytes());
  }


  private static native boolean initializeImpl();


  private static native int getCStringLengthImpl(final long pString);


  static {
    if( !initializeImpl() ) {
      throw new RuntimeException("Initialization failure");
    }
  }



}
