/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Sat Oct 10 03:21:06 CEST 2015 ----! */

package com.jogamp.opengl.cg;

import jogamp.opengl.*;
import com.jogamp.common.os.DynamicLookupHelper;
import com.jogamp.common.os.DynamicLibraryBundle;
import com.jogamp.opengl.cg.CgDynamicLibraryBundleInfo;
import java.security.PrivilegedAction;
import java.security.AccessController;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class CgGL {

  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NO_ERROR = 0x0;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_COMPILER_ERROR = 0x1;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PARAMETER_ERROR = 0x2;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PROFILE_ERROR = 0x3;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PROGRAM_LOAD_ERROR = 0x4;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PROGRAM_BIND_ERROR = 0x5;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PROGRAM_NOT_LOADED_ERROR = 0x6;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_UNSUPPORTED_GL_EXTENSION_ERROR = 0x7;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_VALUE_TYPE_ERROR = 0x8;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NOT_MATRIX_PARAM_ERROR = 0x9;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_ENUMERANT_ERROR = 0xa;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NOT_4x4_MATRIX_ERROR = 0xb;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_FILE_READ_ERROR = 0xc;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_FILE_WRITE_ERROR = 0xd;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NVPARSE_ERROR = 0xe;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_MEMORY_ALLOC_ERROR = 0xf;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_CONTEXT_HANDLE_ERROR = 0x10;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PROGRAM_HANDLE_ERROR = 0x11;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PARAM_HANDLE_ERROR = 0x12;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_UNKNOWN_PROFILE_ERROR = 0x13;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_VAR_ARG_ERROR = 0x14;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_DIMENSION_ERROR = 0x15;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_ARRAY_PARAM_ERROR = 0x16;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_OUT_OF_ARRAY_BOUNDS_ERROR = 0x17;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_CONFLICTING_TYPES_ERROR = 0x18;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_CONFLICTING_PARAMETER_TYPES_ERROR = 0x19;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PARAMETER_IS_NOT_SHARED_ERROR = 0x1a;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PARAMETER_VARIABILITY_ERROR = 0x1b;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_CANNOT_DESTROY_PARAMETER_ERROR = 0x1c;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NOT_ROOT_PARAMETER_ERROR = 0x1d;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PARAMETERS_DO_NOT_MATCH_ERROR = 0x1e;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_IS_NOT_PROGRAM_PARAMETER_ERROR = 0x1f;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PARAMETER_TYPE_ERROR = 0x20;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR = 0x21;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_SIZE_ERROR = 0x22;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_BIND_CREATES_CYCLE_ERROR = 0x23;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR = 0x24;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR = 0x25;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_ARRAY_HAS_WRONG_DIMENSION_ERROR = 0x26;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR = 0x27;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_EFFECT_HANDLE_ERROR = 0x28;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_STATE_HANDLE_ERROR = 0x29;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR = 0x2a;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PASS_HANDLE_ERROR = 0x2b;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_ANNOTATION_HANDLE_ERROR = 0x2c;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_TECHNIQUE_HANDLE_ERROR = 0x2d;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_PARAMETER_HANDLE_ERROR = 0x2e;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR = 0x2f;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_FUNCTION_HANDLE_ERROR = 0x30;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_TECHNIQUE_ERROR = 0x31;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_INVALID_POINTER_ERROR = 0x32;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NOT_ENOUGH_DATA_ERROR = 0x33;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_NON_NUMERIC_PARAMETER_ERROR = 0x34;
  /** Defined as part of enum type "CGerror" - CType: int */
  public static final int CG_ARRAY_SIZE_MISMATCH_ERROR = 0x35;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MATRIX_IDENTITY = 0x0;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MATRIX_TRANSPOSE = 0x1;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MATRIX_INVERSE = 0x2;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MATRIX_INVERSE_TRANSPOSE = 0x3;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MODELVIEW_MATRIX = 0x4;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_PROJECTION_MATRIX = 0x5;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_TEXTURE_MATRIX = 0x6;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_MODELVIEW_PROJECTION_MATRIX = 0x7;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_VERTEX = 0x8;
  /** Defined as part of enum type "CGGLenum" - CType: int */
  public static final int CG_GL_FRAGMENT = 0x9;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT0 = 0x800;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT1 = 0x801;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT2 = 0x802;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT3 = 0x803;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT4 = 0x804;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT5 = 0x805;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT6 = 0x806;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT7 = 0x807;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT8 = 0x808;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT9 = 0x809;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT10 = 0x80a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT11 = 0x80b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT12 = 0x80c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT13 = 0x80d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT14 = 0x80e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXUNIT15 = 0x80f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR0 = 0x841;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR1 = 0x842;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR2 = 0x843;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR3 = 0x844;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR4 = 0x845;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR5 = 0x846;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR6 = 0x847;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR7 = 0x848;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR8 = 0x849;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR9 = 0x84a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR10 = 0x84b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR11 = 0x84c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR12 = 0x84d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR13 = 0x84e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR14 = 0x84f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_ATTR15 = 0x850;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_C = 0x882;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX0 = 0x883;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX1 = 0x884;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX2 = 0x885;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX3 = 0x890;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX4 = 0x891;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX5 = 0x892;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX6 = 0x893;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEX7 = 0x894;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_HPOS = 0x8c3;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COL0 = 0x8c5;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COL1 = 0x8c6;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COL2 = 0x8c7;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COL3 = 0x8c8;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZ = 0x905;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_WPOS = 0x945;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION0 = 0x985;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION1 = 0x986;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION2 = 0x987;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION3 = 0x988;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION4 = 0x989;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION5 = 0x98a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION6 = 0x98b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION7 = 0x98c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION8 = 0x98d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION9 = 0x98e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION10 = 0x98f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION11 = 0x990;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION12 = 0x991;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION13 = 0x992;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION14 = 0x993;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_POSITION15 = 0x994;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DIFFUSE0 = 0x9c5;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT0 = 0xa05;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT1 = 0xa06;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT2 = 0xa07;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT3 = 0xa08;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT4 = 0xa09;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT5 = 0xa0a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT6 = 0xa0b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT7 = 0xa0c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT8 = 0xa0d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT9 = 0xa0e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT10 = 0xa0f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT11 = 0xa10;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT12 = 0xa11;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT13 = 0xa12;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT14 = 0xa13;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TANGENT15 = 0xa14;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SPECULAR0 = 0xa45;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES0 = 0xa85;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES1 = 0xa86;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES2 = 0xa87;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES3 = 0xa88;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES4 = 0xa89;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES5 = 0xa8a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES6 = 0xa8b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES7 = 0xa8c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES8 = 0xa8d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES9 = 0xa8e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES10 = 0xa8f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES11 = 0xa90;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES12 = 0xa91;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES13 = 0xa92;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES14 = 0xa93;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDINDICES15 = 0xa94;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR0 = 0xac5;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR1 = 0xac6;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR2 = 0xac7;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR3 = 0xac8;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR4 = 0xac9;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR5 = 0xaca;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR6 = 0xacb;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR7 = 0xacc;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR8 = 0xacd;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR9 = 0xace;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR10 = 0xacf;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR11 = 0xad0;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR12 = 0xad1;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR13 = 0xad2;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR14 = 0xad3;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COLOR15 = 0xad4;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE0 = 0xb05;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE1 = 0xb06;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE2 = 0xb07;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE3 = 0xb08;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE4 = 0xb09;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE5 = 0xb0a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE6 = 0xb0b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE7 = 0xb0c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE8 = 0xb0d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE9 = 0xb0e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE10 = 0xb0f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE11 = 0xb10;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE12 = 0xb11;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE13 = 0xb12;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE14 = 0xb13;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_PSIZE15 = 0xb14;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL0 = 0xb45;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL1 = 0xb46;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL2 = 0xb47;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL3 = 0xb48;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL4 = 0xb49;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL5 = 0xb4a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL6 = 0xb4b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL7 = 0xb4c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL8 = 0xb4d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL9 = 0xb4e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL10 = 0xb4f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL11 = 0xb50;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL12 = 0xb51;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL13 = 0xb52;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL14 = 0xb53;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BINORMAL15 = 0xb54;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG0 = 0xb65;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG1 = 0xb66;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG2 = 0xb67;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG3 = 0xb68;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG4 = 0xb69;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG5 = 0xb6a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG6 = 0xb6b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG7 = 0xb6c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG8 = 0xb6d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG9 = 0xb6e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG10 = 0xb6f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG11 = 0xb70;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG12 = 0xb71;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG13 = 0xb72;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG14 = 0xb73;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOG15 = 0xb74;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH0 = 0xb75;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH1 = 0xb76;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH2 = 0xb77;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH3 = 0xb78;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH4 = 0xb79;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH5 = 0xb7a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH6 = 0xb7b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH7 = 0xb7c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH8 = 0xb7d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH9 = 0x7366;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH10 = 0xb7f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH11 = 0xb80;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH12 = 0xb81;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH13 = 0xb82;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH14 = 0xb83;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_DEPTH15 = 0xb84;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE0 = 0xb85;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE1 = 0xb86;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE2 = 0xb87;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE3 = 0xb88;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE4 = 0xb89;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE5 = 0xb8a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE6 = 0xb8b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE7 = 0xb8c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE8 = 0xb8d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE9 = 0xb8e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE10 = 0xb8f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE11 = 0xb90;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE12 = 0xb91;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE13 = 0xb92;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE14 = 0xb93;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_SAMPLE15 = 0xb94;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT0 = 0xbd4;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT1 = 0xbd5;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT2 = 0xbd6;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT3 = 0xbd7;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT4 = 0xbd8;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT5 = 0xbd9;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT6 = 0xbda;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT7 = 0xbdb;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT8 = 0xbdc;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT9 = 0xbdd;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT10 = 0xbde;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT11 = 0xbdf;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT12 = 0xbe0;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT13 = 0xbe1;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT14 = 0xbe2;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_BLENDWEIGHT15 = 0xbe3;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL0 = 0xc14;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL1 = 0xc15;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL2 = 0xc16;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL3 = 0xc17;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL4 = 0xc18;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL5 = 0xc19;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL6 = 0xc1a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL7 = 0xc1b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL8 = 0xc1c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL9 = 0xc1d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL10 = 0xc1e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL11 = 0xc1f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL12 = 0xc20;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL13 = 0xc21;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL14 = 0xc22;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_NORMAL15 = 0xc23;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_FOGCOORD = 0xc54;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD0 = 0xc94;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD1 = 0xc95;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD2 = 0xc96;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD3 = 0xc97;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD4 = 0xc98;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD5 = 0xc99;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD6 = 0xc9a;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD7 = 0xc9b;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD8 = 0xc9c;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD9 = 0xc9d;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD10 = 0xc9e;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD11 = 0xc9f;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD12 = 0xca0;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD13 = 0xca1;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD14 = 0xca2;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TEXCOORD15 = 0xca3;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COMBINER_CONST0 = 0xcd4;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COMBINER_CONST1 = 0xcd5;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COMBINER_STAGE_CONST0 = 0xcd6;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_COMBINER_STAGE_CONST1 = 0xcd7;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_OFFSET_TEXTURE_MATRIX = 0xcd8;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_OFFSET_TEXTURE_SCALE = 0xcd9;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_OFFSET_TEXTURE_BIAS = 0xcda;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_CONST_EYE = 0xcdb;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_TESSFACTOR = 0xcb7;
  /** Defined as part of enum type "CGresource" - CType: int */
  public static final int CG_UNDEFINED = 0xcb8;
  /** Defined as part of enum type "CGtype" - CType: long */
  public static final long CG_UNKNOWN_TYPE = 0x0L;
  /** Defined as part of enum type "CGtype" - CType: long */
  public static final long CG_STRUCT = 0x1L;
  /** Defined as part of enum type "CGtype" - CType: long */
  public static final long CG_ARRAY = 0x2L;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_TYPE_START_ENUM = 0x400;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF = 0x401;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF2 = 0x402;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF3 = 0x403;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF4 = 0x404;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF1x1 = 0x405;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF1x2 = 0x406;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF1x3 = 0x407;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF1x4 = 0x408;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF2x1 = 0x409;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF2x2 = 0x40a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF2x3 = 0x40b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF2x4 = 0x40c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF3x1 = 0x40d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF3x2 = 0x40e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF3x3 = 0x40f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF3x4 = 0x410;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF4x1 = 0x411;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF4x2 = 0x412;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF4x3 = 0x413;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF4x4 = 0x414;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT = 0x415;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT2 = 0x416;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT3 = 0x417;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT4 = 0x418;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT1x1 = 0x419;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT1x2 = 0x41a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT1x3 = 0x41b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT1x4 = 0x41c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT2x1 = 0x41d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT2x2 = 0x41e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT2x3 = 0x41f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT2x4 = 0x420;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT3x1 = 0x421;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT3x2 = 0x422;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT3x3 = 0x423;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT3x4 = 0x424;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT4x1 = 0x425;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT4x2 = 0x426;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT4x3 = 0x427;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT4x4 = 0x428;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_SAMPLER1D = 0x429;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_SAMPLER2D = 0x42a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_SAMPLER3D = 0x42b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_SAMPLERRECT = 0x42c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_SAMPLERCUBE = 0x42d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED = 0x42e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED2 = 0x42f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED3 = 0x430;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED4 = 0x431;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED1x1 = 0x432;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED1x2 = 0x433;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED1x3 = 0x434;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED1x4 = 0x435;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED2x1 = 0x436;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED2x2 = 0x437;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED2x3 = 0x438;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED2x4 = 0x439;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED3x1 = 0x43a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED3x2 = 0x43b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED3x3 = 0x43c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED3x4 = 0x43d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED4x1 = 0x43e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED4x2 = 0x43f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED4x3 = 0x440;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED4x4 = 0x441;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_HALF1 = 0x442;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FLOAT1 = 0x443;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_FIXED1 = 0x444;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT = 0x445;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT1 = 0x446;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT2 = 0x447;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT3 = 0x448;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT4 = 0x449;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT1x1 = 0x44a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT1x2 = 0x44b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT1x3 = 0x44c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT1x4 = 0x44d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT2x1 = 0x44e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT2x2 = 0x44f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT2x3 = 0x450;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT2x4 = 0x451;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT3x1 = 0x452;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT3x2 = 0x453;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT3x3 = 0x454;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT3x4 = 0x455;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT4x1 = 0x456;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT4x2 = 0x457;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT4x3 = 0x458;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_INT4x4 = 0x459;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL = 0x45a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL1 = 0x45b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL2 = 0x45c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL3 = 0x45d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL4 = 0x45e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL1x1 = 0x45f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL1x2 = 0x460;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL1x3 = 0x461;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL1x4 = 0x462;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL2x1 = 0x463;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL2x2 = 0x464;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL2x3 = 0x465;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL2x4 = 0x466;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL3x1 = 0x467;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL3x2 = 0x468;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL3x3 = 0x469;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL3x4 = 0x46a;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL4x1 = 0x46b;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL4x2 = 0x46c;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL4x3 = 0x46d;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_BOOL4x4 = 0x46e;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_STRING = 0x46f;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_PROGRAM_TYPE = 0x470;
  /** Defined as part of enum type "CGtype" - CType: int */
  public static final int CG_TEXTURE = 0x471;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_START = 0x1800;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_UNKNOWN = 0x1801;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VP20 = 0x1802;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_FP20 = 0x1803;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VP30 = 0x1804;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_FP30 = 0x1805;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_ARBVP1 = 0x1806;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_FP40 = 0x1807;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_ARBFP1 = 0x1b58;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VP40 = 0x1b59;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VS_1_1 = 0x1809;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VS_2_0 = 0x180a;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_VS_2_X = 0x180b;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_PS_1_1 = 0x180f;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_PS_1_2 = 0x1810;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_PS_1_3 = 0x1811;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_PS_2_0 = 0x1812;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_PS_2_X = 0x1813;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int GENERIC = 0x1b5a;
  /** Defined as part of enum type "CGprofile" - CType: int */
  public static final int CG_PROFILE_MAX = 0x1bbc;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_UNKNOWN = 0x0;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_SCALAR = 0x1;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_VECTOR = 0x2;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_MATRIX = 0x3;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_STRUCT = 0x4;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_ARRAY = 0x5;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_SAMPLER = 0x6;
  /** Defined as part of enum type "CGparameterclass" - CType: int */
  public static final int CG_PARAMETERCLASS_OBJECT = 0x7;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_UNKNOWN = 0x1000;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_IN = 0x1001;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_OUT = 0x1002;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_INOUT = 0x1003;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_MIXED = 0x1004;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_VARYING = 0x1005;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_UNIFORM = 0x1006;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_CONSTANT = 0x1007;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_PROGRAM_SOURCE = 0x1008;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_PROGRAM_ENTRY = 0x1009;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_COMPILED_PROGRAM = 0x100a;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_PROGRAM_PROFILE = 0x100b;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_GLOBAL = 0x100c;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_PROGRAM = 0x100d;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_DEFAULT = 0x100e;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_ERROR = 0x100f;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_SOURCE = 0x1010;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_OBJECT = 0x1011;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_COMPILE_MANUAL = 0x1012;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_COMPILE_IMMEDIATE = 0x1013;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_COMPILE_LAZY = 0x1014;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_CURRENT = 0x1015;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_LITERAL = 0x1016;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_VERSION = 0x1017;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_ROW_MAJOR = 0x1018;
  /** Defined as part of enum type "CGenum" - CType: int */
  public static final int CG_COLUMN_MAJOR = 0x1019;
  /** CType: int */
  public static final int CG_VERSION_NUM = 0x578;

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgCreateContext(void)</code><br>   */
  public static CGcontext cgCreateContext()  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateContext1(__addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgCreateContext(void)</code><br>   */
  private static native ByteBuffer dispatch_cgCreateContext1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyContext(CGcontext ctx)</code><br>   */
  public static void cgDestroyContext(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgDestroyContext"));
    }
        dispatch_cgDestroyContext1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyContext(CGcontext ctx)</code><br>   */
  private static native void dispatch_cgDestroyContext1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsContext(CGcontext ctx)</code><br>   */
  public static boolean cgIsContext(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsContext"));
    }
        return dispatch_cgIsContext1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsContext(CGcontext ctx)</code><br>   */
  private static native boolean dispatch_cgIsContext1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetLastListing(CGcontext ctx)</code><br>   */
  public static String cgGetLastListing(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetLastListing;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetLastListing"));
    }
        return dispatch_cgGetLastListing1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetLastListing(CGcontext ctx)</code><br>   */
  private static native String dispatch_cgGetLastListing1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetLastListing(CGhandle handle, const char *  listing)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static void cgSetLastListing(Buffer handle, String listing)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgSetLastListing;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetLastListing"));
    }
        dispatch_cgSetLastListing1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, listing, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetLastListing(CGhandle handle, const char *  listing)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native void dispatch_cgSetLastListing1(Object handle, int handle_byte_offset, boolean handle_is_direct, String listing, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetAutoCompile(CGcontext ctx, CGenum flag)</code><br>
      @param flag valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static void cgSetAutoCompile(CGcontext ctx, int flag)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetAutoCompile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetAutoCompile"));
    }
        dispatch_cgSetAutoCompile1(((ctx == null) ? null : ctx.getBuffer()), flag, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetAutoCompile(CGcontext ctx, CGenum flag)</code><br>
      @param flag valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native void dispatch_cgSetAutoCompile1(ByteBuffer ctx, int flag, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetAutoCompile(CGcontext ctx)</code><br>   */
  public static int cgGetAutoCompile(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAutoCompile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetAutoCompile"));
    }
        return dispatch_cgGetAutoCompile1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetAutoCompile(CGcontext ctx)</code><br>   */
  private static native int dispatch_cgGetAutoCompile1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgram(CGcontext ctx, CGenum program_type, const char *  program, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgram(CGcontext ctx, int program_type, String program, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateProgram"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgram1(((ctx == null) ? null : ctx.getBuffer()), program_type, program, profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgram(CGcontext ctx, CGenum program_type, const char *  program, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgram1(ByteBuffer ctx, int program_type, String program, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgramFromFile(CGcontext ctx, CGenum program_type, const char *  program_file, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgramFromFile(CGcontext ctx, int program_type, String program_file, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgramFromFile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateProgramFromFile"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgramFromFile1(((ctx == null) ? null : ctx.getBuffer()), program_type, program_file, profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgramFromFile(CGcontext ctx, CGenum program_type, const char *  program_file, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param program_type valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>

      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgramFromFile1(ByteBuffer ctx, int program_type, String program_file, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCopyProgram(CGprogram program)</code><br>   */
  public static CGprogram cgCopyProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCopyProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCopyProgram"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCopyProgram1(((program == null) ? null : program.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCopyProgram(CGprogram program)</code><br>   */
  private static native ByteBuffer dispatch_cgCopyProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyProgram(CGprogram program)</code><br>   */
  public static void cgDestroyProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgDestroyProgram"));
    }
        dispatch_cgDestroyProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyProgram(CGprogram program)</code><br>   */
  private static native void dispatch_cgDestroyProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetFirstProgram(CGcontext ctx)</code><br>   */
  public static CGprogram cgGetFirstProgram(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstProgram"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstProgram1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetFirstProgram(CGcontext ctx)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstProgram1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetNextProgram(CGprogram current)</code><br>   */
  public static CGprogram cgGetNextProgram(CGprogram current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextProgram"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextProgram1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetNextProgram(CGprogram current)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextProgram1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetProgramContext(CGprogram prog)</code><br>   */
  public static CGcontext cgGetProgramContext(CGprogram prog)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProgramContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetProgramContext1(((prog == null) ? null : prog.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetProgramContext(CGprogram prog)</code><br>   */
  private static native ByteBuffer dispatch_cgGetProgramContext1(ByteBuffer prog, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsProgram(CGprogram program)</code><br>   */
  public static boolean cgIsProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsProgram"));
    }
        return dispatch_cgIsProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsProgram(CGprogram program)</code><br>   */
  private static native boolean dispatch_cgIsProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgCompileProgram(CGprogram program)</code><br>   */
  public static void cgCompileProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCompileProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCompileProgram"));
    }
        dispatch_cgCompileProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgCompileProgram(CGprogram program)</code><br>   */
  private static native void dispatch_cgCompileProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsProgramCompiled(CGprogram program)</code><br>   */
  public static boolean cgIsProgramCompiled(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsProgramCompiled;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsProgramCompiled"));
    }
        return dispatch_cgIsProgramCompiled1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsProgramCompiled(CGprogram program)</code><br>   */
  private static native boolean dispatch_cgIsProgramCompiled1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetProgramString(CGprogram prog, CGenum pname)</code><br>
      @param pname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetProgramString(CGprogram prog, int pname)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProgramString"));
    }
        return dispatch_cgGetProgramString1(((prog == null) ? null : prog.getBuffer()), pname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetProgramString(CGprogram prog, CGenum pname)</code><br>
      @param pname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native String dispatch_cgGetProgramString1(ByteBuffer prog, int pname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGetProgramProfile(CGprogram prog)</code><br>   */
  public static int cgGetProgramProfile(CGprogram prog)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProgramProfile"));
    }
        return dispatch_cgGetProgramProfile1(((prog == null) ? null : prog.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGetProgramProfile(CGprogram prog)</code><br>   */
  private static native int dispatch_cgGetProgramProfile1(ByteBuffer prog, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetProgramProfile(CGprogram prog, CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgSetProgramProfile(CGprogram prog, int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetProgramProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetProgramProfile"));
    }
        dispatch_cgSetProgramProfile1(((prog == null) ? null : prog.getBuffer()), profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetProgramProfile(CGprogram prog, CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native void dispatch_cgSetProgramProfile1(ByteBuffer prog, int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetPassProgramParameters(CGprogram)</code><br>   */
  public static void cgSetPassProgramParameters(CGprogram arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetPassProgramParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetPassProgramParameters"));
    }
        dispatch_cgSetPassProgramParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetPassProgramParameters(CGprogram)</code><br>   */
  private static native void dispatch_cgSetPassProgramParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameter(CGcontext ctx, CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameter(CGcontext ctx, int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameter1(((ctx == null) ? null : ctx.getBuffer()), type, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameter(CGcontext ctx, CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateParameter1(ByteBuffer ctx, int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameterArray(CGcontext ctx, CGtype type, int length)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameterArray(CGcontext ctx, int type, int length)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateParameterArray"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterArray1(((ctx == null) ? null : ctx.getBuffer()), type, length, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameterArray(CGcontext ctx, CGtype type, int length)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateParameterArray1(ByteBuffer ctx, int type, int length, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param lengths a direct or array-backed {@link java.nio.IntBuffer}   */
  public static CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, int type, int dim, IntBuffer lengths)  {

    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterMultiDimArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateParameterMultiDimArray"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterMultiDimArray1(((ctx == null) ? null : ctx.getBuffer()), type, dim, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param lengths a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native ByteBuffer dispatch_cgCreateParameterMultiDimArray1(ByteBuffer ctx, int type, int dim, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, CGtype type, int dim, const int *  lengths)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGparameter cgCreateParameterMultiDimArray(CGcontext ctx, int type, int dim, int[] lengths, int lengths_offset)  {

    if(lengths != null && lengths.length <= lengths_offset)
      throw new CgException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgCreateParameterMultiDimArray;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateParameterMultiDimArray"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateParameterMultiDimArray1(((ctx == null) ? null : ctx.getBuffer()), type, dim, lengths, Buffers.SIZEOF_INT * lengths_offset, false, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyParameter(CGparameter param)</code><br>   */
  public static void cgDestroyParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgDestroyParameter"));
    }
        dispatch_cgDestroyParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyParameter(CGparameter param)</code><br>   */
  private static native void dispatch_cgDestroyParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgConnectParameter(CGparameter from, CGparameter to)</code><br>   */
  public static void cgConnectParameter(CGparameter from, CGparameter to)  {

    final long __addr_ = cgProcAddressTable._addressof_cgConnectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgConnectParameter"));
    }
        dispatch_cgConnectParameter1(((from == null) ? null : from.getBuffer()), ((to == null) ? null : to.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgConnectParameter(CGparameter from, CGparameter to)</code><br>   */
  private static native void dispatch_cgConnectParameter1(ByteBuffer from, ByteBuffer to, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDisconnectParameter(CGparameter param)</code><br>   */
  public static void cgDisconnectParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDisconnectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgDisconnectParameter"));
    }
        dispatch_cgDisconnectParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDisconnectParameter(CGparameter param)</code><br>   */
  private static native void dispatch_cgDisconnectParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetConnectedParameter(CGparameter param)</code><br>   */
  public static CGparameter cgGetConnectedParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetConnectedParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetConnectedParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetConnectedParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetConnectedParameter(CGparameter param)</code><br>   */
  private static native ByteBuffer dispatch_cgGetConnectedParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumConnectedToParameters(CGparameter param)</code><br>   */
  public static int cgGetNumConnectedToParameters(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumConnectedToParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNumConnectedToParameters"));
    }
        return dispatch_cgGetNumConnectedToParameters1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumConnectedToParameters(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetNumConnectedToParameters1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetConnectedToParameter(CGparameter param, int index)</code><br>   */
  public static CGparameter cgGetConnectedToParameter(CGparameter param, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetConnectedToParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetConnectedToParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetConnectedToParameter1(((param == null) ? null : param.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetConnectedToParameter(CGparameter param, int index)</code><br>   */
  private static native ByteBuffer dispatch_cgGetConnectedToParameter1(ByteBuffer param, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedParameter(CGprogram prog, const char *  name)</code><br>   */
  public static CGparameter cgGetNamedParameter(CGprogram prog, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedParameter1(((prog == null) ? null : prog.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedParameter(CGprogram prog, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedParameter1(ByteBuffer prog, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedProgramParameter(CGprogram prog, CGenum name_space, const char *  name)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetNamedProgramParameter(CGprogram prog, int name_space, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedProgramParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedProgramParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedProgramParameter1(((prog == null) ? null : prog.getBuffer()), name_space, name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedProgramParameter(CGprogram prog, CGenum name_space, const char *  name)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetNamedProgramParameter1(ByteBuffer prog, int name_space, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstParameter(CGprogram prog, CGenum name_space)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetFirstParameter(CGprogram prog, int name_space)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstParameter1(((prog == null) ? null : prog.getBuffer()), name_space, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstParameter(CGprogram prog, CGenum name_space)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetFirstParameter1(ByteBuffer prog, int name_space, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNextParameter(CGparameter current)</code><br>   */
  public static CGparameter cgGetNextParameter(CGparameter current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextParameter1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNextParameter(CGparameter current)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextParameter1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstLeafParameter(CGprogram prog, CGenum name_space)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static CGparameter cgGetFirstLeafParameter(CGprogram prog, int name_space)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstLeafParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstLeafParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstLeafParameter1(((prog == null) ? null : prog.getBuffer()), name_space, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstLeafParameter(CGprogram prog, CGenum name_space)</code><br>
      @param name_space valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native ByteBuffer dispatch_cgGetFirstLeafParameter1(ByteBuffer prog, int name_space, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNextLeafParameter(CGparameter current)</code><br>   */
  public static CGparameter cgGetNextLeafParameter(CGparameter current)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextLeafParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextLeafParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextLeafParameter1(((current == null) ? null : current.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNextLeafParameter(CGparameter current)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextLeafParameter1(ByteBuffer current, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstStructParameter(CGparameter param)</code><br>   */
  public static CGparameter cgGetFirstStructParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstStructParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstStructParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstStructParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstStructParameter(CGparameter param)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstStructParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedStructParameter(CGparameter param, const char *  name)</code><br>   */
  public static CGparameter cgGetNamedStructParameter(CGparameter param, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedStructParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedStructParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedStructParameter1(((param == null) ? null : param.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedStructParameter(CGparameter param, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedStructParameter1(ByteBuffer param, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstDependentParameter(CGparameter param)</code><br>   */
  public static CGparameter cgGetFirstDependentParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstDependentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstDependentParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstDependentParameter1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstDependentParameter(CGparameter param)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstDependentParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetArrayParameter(CGparameter aparam, int index)</code><br>   */
  public static CGparameter cgGetArrayParameter(CGparameter aparam, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetArrayParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetArrayParameter1(((aparam == null) ? null : aparam.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetArrayParameter(CGparameter aparam, int index)</code><br>   */
  private static native ByteBuffer dispatch_cgGetArrayParameter1(ByteBuffer aparam, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArrayDimension(CGparameter param)</code><br>   */
  public static int cgGetArrayDimension(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayDimension;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetArrayDimension"));
    }
        return dispatch_cgGetArrayDimension1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArrayDimension(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetArrayDimension1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetArrayType(CGparameter param)</code><br>   */
  public static int cgGetArrayType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetArrayType"));
    }
        return dispatch_cgGetArrayType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetArrayType(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetArrayType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArraySize(CGparameter param, int dimension)</code><br>   */
  public static int cgGetArraySize(CGparameter param, int dimension)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetArraySize"));
    }
        return dispatch_cgGetArraySize1(((param == null) ? null : param.getBuffer()), dimension, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArraySize(CGparameter param, int dimension)</code><br>   */
  private static native int dispatch_cgGetArraySize1(ByteBuffer param, int dimension, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArrayTotalSize(CGparameter param)</code><br>   */
  public static int cgGetArrayTotalSize(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetArrayTotalSize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetArrayTotalSize"));
    }
        return dispatch_cgGetArrayTotalSize1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetArrayTotalSize(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetArrayTotalSize1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetArraySize(CGparameter param, int size)</code><br>   */
  public static void cgSetArraySize(CGparameter param, int size)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetArraySize"));
    }
        dispatch_cgSetArraySize1(((param == null) ? null : param.getBuffer()), size, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetArraySize(CGparameter param, int size)</code><br>   */
  private static native void dispatch_cgSetArraySize1(ByteBuffer param, int size, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMultiDimArraySize(CGparameter param, const int *  sizes)</code><br>
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMultiDimArraySize(CGparameter param, IntBuffer sizes)  {

    final boolean sizes_is_direct = Buffers.isDirect(sizes);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMultiDimArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMultiDimArraySize"));
    }
        dispatch_cgSetMultiDimArraySize1(((param == null) ? null : param.getBuffer()), sizes_is_direct ? sizes : Buffers.getArray(sizes), sizes_is_direct ? Buffers.getDirectBufferByteOffset(sizes) : Buffers.getIndirectBufferByteOffset(sizes), sizes_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMultiDimArraySize(CGparameter param, const int *  sizes)</code><br>
      @param sizes a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMultiDimArraySize1(ByteBuffer param, Object sizes, int sizes_byte_offset, boolean sizes_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMultiDimArraySize(CGparameter param, const int *  sizes)</code><br>   */
  public static void cgSetMultiDimArraySize(CGparameter param, int[] sizes, int sizes_offset)  {

    if(sizes != null && sizes.length <= sizes_offset)
      throw new CgException("array offset argument \"sizes_offset\" (" + sizes_offset + ") equals or exceeds array length (" + sizes.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMultiDimArraySize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMultiDimArraySize"));
    }
        dispatch_cgSetMultiDimArraySize1(((param == null) ? null : param.getBuffer()), sizes, Buffers.SIZEOF_INT * sizes_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetParameterProgram(CGparameter param)</code><br>   */
  public static CGprogram cgGetParameterProgram(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterProgram"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetParameterProgram1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetParameterProgram(CGparameter param)</code><br>   */
  private static native ByteBuffer dispatch_cgGetParameterProgram1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetParameterContext(CGparameter param)</code><br>   */
  public static CGcontext cgGetParameterContext(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetParameterContext1(((param == null) ? null : param.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetParameterContext(CGparameter param)</code><br>   */
  private static native ByteBuffer dispatch_cgGetParameterContext1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameter(CGparameter param)</code><br>   */
  public static boolean cgIsParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsParameter"));
    }
        return dispatch_cgIsParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameter(CGparameter param)</code><br>   */
  private static native boolean dispatch_cgIsParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetParameterName(CGparameter param)</code><br>   */
  public static String cgGetParameterName(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterName"));
    }
        return dispatch_cgGetParameterName1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetParameterName(CGparameter param)</code><br>   */
  private static native String dispatch_cgGetParameterName1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterType(CGparameter param)</code><br>   */
  public static int cgGetParameterType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterType"));
    }
        return dispatch_cgGetParameterType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterType(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterBaseType(CGparameter param)</code><br>   */
  public static int cgGetParameterBaseType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterBaseType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterBaseType"));
    }
        return dispatch_cgGetParameterBaseType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterBaseType(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterBaseType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameterclass cgGetParameterClass(CGparameter param)</code><br>   */
  public static int cgGetParameterClass(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterClass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterClass"));
    }
        return dispatch_cgGetParameterClass1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameterclass cgGetParameterClass(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterClass1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterRows(CGparameter param)</code><br>   */
  public static int cgGetParameterRows(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterRows;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterRows"));
    }
        return dispatch_cgGetParameterRows1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterRows(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterRows1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterColumns(CGparameter param)</code><br>   */
  public static int cgGetParameterColumns(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterColumns;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterColumns"));
    }
        return dispatch_cgGetParameterColumns1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterColumns(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterColumns1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterNamedType(CGparameter param)</code><br>   */
  public static int cgGetParameterNamedType(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterNamedType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterNamedType"));
    }
        return dispatch_cgGetParameterNamedType1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParameterNamedType(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterNamedType1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetParameterSemantic(CGparameter param)</code><br>   */
  public static String cgGetParameterSemantic(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterSemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterSemantic"));
    }
        return dispatch_cgGetParameterSemantic1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetParameterSemantic(CGparameter param)</code><br>   */
  private static native String dispatch_cgGetParameterSemantic1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetParameterResource(CGparameter param)</code><br>   */
  public static int cgGetParameterResource(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterResource"));
    }
        return dispatch_cgGetParameterResource1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetParameterResource(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterResource1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetParameterBaseResource(CGparameter param)</code><br>   */
  public static int cgGetParameterBaseResource(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterBaseResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterBaseResource"));
    }
        return dispatch_cgGetParameterBaseResource1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetParameterBaseResource(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterBaseResource1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>unsigned long cgGetParameterResourceIndex(CGparameter param)</code><br>   */
  public static long cgGetParameterResourceIndex(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterResourceIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterResourceIndex"));
    }
        return dispatch_cgGetParameterResourceIndex1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>unsigned long cgGetParameterResourceIndex(CGparameter param)</code><br>   */
  private static native long dispatch_cgGetParameterResourceIndex1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetParameterVariability(CGparameter param)</code><br>   */
  public static int cgGetParameterVariability(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterVariability;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterVariability"));
    }
        return dispatch_cgGetParameterVariability1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetParameterVariability(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterVariability1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetParameterDirection(CGparameter param)</code><br>   */
  public static int cgGetParameterDirection(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterDirection;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterDirection"));
    }
        return dispatch_cgGetParameterDirection1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetParameterDirection(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterDirection1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterReferenced(CGparameter param)</code><br>   */
  public static boolean cgIsParameterReferenced(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterReferenced;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsParameterReferenced"));
    }
        return dispatch_cgIsParameterReferenced1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterReferenced(CGparameter param)</code><br>   */
  private static native boolean dispatch_cgIsParameterReferenced1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterUsed(CGparameter param, CGhandle handle)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static boolean cgIsParameterUsed(CGparameter param, Buffer handle)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterUsed;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsParameterUsed"));
    }
        return dispatch_cgIsParameterUsed1(((param == null) ? null : param.getBuffer()), handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterUsed(CGparameter param, CGhandle handle)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native boolean dispatch_cgIsParameterUsed1(ByteBuffer param, Object handle, int handle_byte_offset, boolean handle_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedr(CGparameter param, int n, const double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameterValuedr(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuedr"));
    }
        dispatch_cgSetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedr(CGparameter param, int n, const double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameterValuedr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedr(CGparameter param, int n, const double *  vals)</code><br>   */
  public static void cgSetParameterValuedr(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuedr"));
    }
        dispatch_cgSetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedc(CGparameter param, int n, const double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameterValuedc(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuedc"));
    }
        dispatch_cgSetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedc(CGparameter param, int n, const double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameterValuedc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuedc(CGparameter param, int n, const double *  vals)</code><br>   */
  public static void cgSetParameterValuedc(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuedc"));
    }
        dispatch_cgSetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefr(CGparameter param, int n, const float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameterValuefr(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuefr"));
    }
        dispatch_cgSetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefr(CGparameter param, int n, const float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameterValuefr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefr(CGparameter param, int n, const float *  vals)</code><br>   */
  public static void cgSetParameterValuefr(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuefr"));
    }
        dispatch_cgSetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefc(CGparameter param, int n, const float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameterValuefc(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuefc"));
    }
        dispatch_cgSetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefc(CGparameter param, int n, const float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameterValuefc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValuefc(CGparameter param, int n, const float *  vals)</code><br>   */
  public static void cgSetParameterValuefc(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValuefc"));
    }
        dispatch_cgSetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueir(CGparameter param, int n, const int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameterValueir(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValueir"));
    }
        dispatch_cgSetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueir(CGparameter param, int n, const int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameterValueir1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueir(CGparameter param, int n, const int *  vals)</code><br>   */
  public static void cgSetParameterValueir(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValueir"));
    }
        dispatch_cgSetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueic(CGparameter param, int n, const int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameterValueic(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValueic"));
    }
        dispatch_cgSetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueic(CGparameter param, int n, const int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameterValueic1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterValueic(CGparameter param, int n, const int *  vals)</code><br>   */
  public static void cgSetParameterValueic(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterValueic"));
    }
        dispatch_cgSetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedr(CGparameter param, int n, double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static int cgGetParameterValuedr(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuedr"));
    }
        return dispatch_cgGetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedr(CGparameter param, int n, double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native int dispatch_cgGetParameterValuedr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedr(CGparameter param, int n, double *  vals)</code><br>   */
  public static int cgGetParameterValuedr(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuedr"));
    }
        return dispatch_cgGetParameterValuedr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedc(CGparameter param, int n, double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static int cgGetParameterValuedc(CGparameter param, int n, DoubleBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuedc"));
    }
        return dispatch_cgGetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedc(CGparameter param, int n, double *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native int dispatch_cgGetParameterValuedc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuedc(CGparameter param, int n, double *  vals)</code><br>   */
  public static int cgGetParameterValuedc(CGparameter param, int n, double[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuedc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuedc"));
    }
        return dispatch_cgGetParameterValuedc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_DOUBLE * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefr(CGparameter param, int n, float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static int cgGetParameterValuefr(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuefr"));
    }
        return dispatch_cgGetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefr(CGparameter param, int n, float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native int dispatch_cgGetParameterValuefr1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefr(CGparameter param, int n, float *  vals)</code><br>   */
  public static int cgGetParameterValuefr(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuefr"));
    }
        return dispatch_cgGetParameterValuefr1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefc(CGparameter param, int n, float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static int cgGetParameterValuefc(CGparameter param, int n, FloatBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuefc"));
    }
        return dispatch_cgGetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefc(CGparameter param, int n, float *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native int dispatch_cgGetParameterValuefc1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValuefc(CGparameter param, int n, float *  vals)</code><br>   */
  public static int cgGetParameterValuefc(CGparameter param, int n, float[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValuefc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValuefc"));
    }
        return dispatch_cgGetParameterValuefc1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_FLOAT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueir(CGparameter param, int n, int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int cgGetParameterValueir(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValueir"));
    }
        return dispatch_cgGetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueir(CGparameter param, int n, int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_cgGetParameterValueir1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueir(CGparameter param, int n, int *  vals)</code><br>   */
  public static int cgGetParameterValueir(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValueir"));
    }
        return dispatch_cgGetParameterValueir1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueic(CGparameter param, int n, int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  public static int cgGetParameterValueic(CGparameter param, int n, IntBuffer vals)  {

    final boolean vals_is_direct = Buffers.isDirect(vals);
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValueic"));
    }
        return dispatch_cgGetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals_is_direct ? vals : Buffers.getArray(vals), vals_is_direct ? Buffers.getDirectBufferByteOffset(vals) : Buffers.getIndirectBufferByteOffset(vals), vals_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueic(CGparameter param, int n, int *  vals)</code><br>
      @param vals a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native int dispatch_cgGetParameterValueic1(ByteBuffer param, int n, Object vals, int vals_byte_offset, boolean vals_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterValueic(CGparameter param, int n, int *  vals)</code><br>   */
  public static int cgGetParameterValueic(CGparameter param, int n, int[] vals, int vals_offset)  {

    if(vals != null && vals.length <= vals_offset)
      throw new CgException("array offset argument \"vals_offset\" (" + vals_offset + ") equals or exceeds array length (" + vals.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterValueic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterValueic"));
    }
        return dispatch_cgGetParameterValueic1(((param == null) ? null : param.getBuffer()), n, vals, Buffers.SIZEOF_INT * vals_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringParameterValue(CGparameter param)</code><br>   */
  public static String cgGetStringParameterValue(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringParameterValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStringParameterValue"));
    }
        return dispatch_cgGetStringParameterValue1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringParameterValue(CGparameter param)</code><br>   */
  private static native String dispatch_cgGetStringParameterValue1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetStringParameterValue(CGparameter param, const char *  str)</code><br>   */
  public static void cgSetStringParameterValue(CGparameter param, String str)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetStringParameterValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetStringParameterValue"));
    }
        dispatch_cgSetStringParameterValue1(((param == null) ? null : param.getBuffer()), str, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetStringParameterValue(CGparameter param, const char *  str)</code><br>   */
  private static native void dispatch_cgSetStringParameterValue1(ByteBuffer param, String str, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterOrdinalNumber(CGparameter param)</code><br>   */
  public static int cgGetParameterOrdinalNumber(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterOrdinalNumber;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterOrdinalNumber"));
    }
        return dispatch_cgGetParameterOrdinalNumber1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterOrdinalNumber(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterOrdinalNumber1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterGlobal(CGparameter param)</code><br>   */
  public static boolean cgIsParameterGlobal(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParameterGlobal;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsParameterGlobal"));
    }
        return dispatch_cgIsParameterGlobal1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParameterGlobal(CGparameter param)</code><br>   */
  private static native boolean dispatch_cgIsParameterGlobal1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterIndex(CGparameter param)</code><br>   */
  public static int cgGetParameterIndex(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParameterIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParameterIndex"));
    }
        return dispatch_cgGetParameterIndex1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetParameterIndex(CGparameter param)</code><br>   */
  private static native int dispatch_cgGetParameterIndex1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterVariability(CGparameter param, CGenum vary)</code><br>
      @param vary valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static void cgSetParameterVariability(CGparameter param, int vary)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterVariability;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterVariability"));
    }
        dispatch_cgSetParameterVariability1(((param == null) ? null : param.getBuffer()), vary, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterVariability(CGparameter param, CGenum vary)</code><br>
      @param vary valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  private static native void dispatch_cgSetParameterVariability1(ByteBuffer param, int vary, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterSemantic(CGparameter param, const char *  semantic)</code><br>   */
  public static void cgSetParameterSemantic(CGparameter param, String semantic)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameterSemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameterSemantic"));
    }
        dispatch_cgSetParameterSemantic1(((param == null) ? null : param.getBuffer()), semantic, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameterSemantic(CGparameter param, const char *  semantic)</code><br>   */
  private static native void dispatch_cgSetParameterSemantic1(ByteBuffer param, String semantic, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1f(CGparameter param, float x)</code><br>   */
  public static void cgSetParameter1f(CGparameter param, float x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1f"));
    }
        dispatch_cgSetParameter1f1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1f(CGparameter param, float x)</code><br>   */
  private static native void dispatch_cgSetParameter1f1(ByteBuffer param, float x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2f(CGparameter param, float x, float y)</code><br>   */
  public static void cgSetParameter2f(CGparameter param, float x, float y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2f"));
    }
        dispatch_cgSetParameter2f1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2f(CGparameter param, float x, float y)</code><br>   */
  private static native void dispatch_cgSetParameter2f1(ByteBuffer param, float x, float y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3f(CGparameter param, float x, float y, float z)</code><br>   */
  public static void cgSetParameter3f(CGparameter param, float x, float y, float z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3f"));
    }
        dispatch_cgSetParameter3f1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3f(CGparameter param, float x, float y, float z)</code><br>   */
  private static native void dispatch_cgSetParameter3f1(ByteBuffer param, float x, float y, float z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4f(CGparameter param, float x, float y, float z, float w)</code><br>   */
  public static void cgSetParameter4f(CGparameter param, float x, float y, float z, float w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4f"));
    }
        dispatch_cgSetParameter4f1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4f(CGparameter param, float x, float y, float z, float w)</code><br>   */
  private static native void dispatch_cgSetParameter4f1(ByteBuffer param, float x, float y, float z, float w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1d(CGparameter param, double x)</code><br>   */
  public static void cgSetParameter1d(CGparameter param, double x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1d"));
    }
        dispatch_cgSetParameter1d1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1d(CGparameter param, double x)</code><br>   */
  private static native void dispatch_cgSetParameter1d1(ByteBuffer param, double x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2d(CGparameter param, double x, double y)</code><br>   */
  public static void cgSetParameter2d(CGparameter param, double x, double y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2d"));
    }
        dispatch_cgSetParameter2d1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2d(CGparameter param, double x, double y)</code><br>   */
  private static native void dispatch_cgSetParameter2d1(ByteBuffer param, double x, double y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3d(CGparameter param, double x, double y, double z)</code><br>   */
  public static void cgSetParameter3d(CGparameter param, double x, double y, double z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3d"));
    }
        dispatch_cgSetParameter3d1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3d(CGparameter param, double x, double y, double z)</code><br>   */
  private static native void dispatch_cgSetParameter3d1(ByteBuffer param, double x, double y, double z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4d(CGparameter param, double x, double y, double z, double w)</code><br>   */
  public static void cgSetParameter4d(CGparameter param, double x, double y, double z, double w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4d"));
    }
        dispatch_cgSetParameter4d1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4d(CGparameter param, double x, double y, double z, double w)</code><br>   */
  private static native void dispatch_cgSetParameter4d1(ByteBuffer param, double x, double y, double z, double w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1i(CGparameter param, int x)</code><br>   */
  public static void cgSetParameter1i(CGparameter param, int x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1i"));
    }
        dispatch_cgSetParameter1i1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1i(CGparameter param, int x)</code><br>   */
  private static native void dispatch_cgSetParameter1i1(ByteBuffer param, int x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2i(CGparameter param, int x, int y)</code><br>   */
  public static void cgSetParameter2i(CGparameter param, int x, int y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2i"));
    }
        dispatch_cgSetParameter2i1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2i(CGparameter param, int x, int y)</code><br>   */
  private static native void dispatch_cgSetParameter2i1(ByteBuffer param, int x, int y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3i(CGparameter param, int x, int y, int z)</code><br>   */
  public static void cgSetParameter3i(CGparameter param, int x, int y, int z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3i"));
    }
        dispatch_cgSetParameter3i1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3i(CGparameter param, int x, int y, int z)</code><br>   */
  private static native void dispatch_cgSetParameter3i1(ByteBuffer param, int x, int y, int z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4i(CGparameter param, int x, int y, int z, int w)</code><br>   */
  public static void cgSetParameter4i(CGparameter param, int x, int y, int z, int w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4i;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4i"));
    }
        dispatch_cgSetParameter4i1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4i(CGparameter param, int x, int y, int z, int w)</code><br>   */
  private static native void dispatch_cgSetParameter4i1(ByteBuffer param, int x, int y, int z, int w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter1iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1iv"));
    }
        dispatch_cgSetParameter1iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter1iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1iv(CGparameter param, const int *  v)</code><br>   */
  public static void cgSetParameter1iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1iv"));
    }
        dispatch_cgSetParameter1iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter2iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2iv"));
    }
        dispatch_cgSetParameter2iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter2iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2iv(CGparameter param, const int *  v)</code><br>   */
  public static void cgSetParameter2iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2iv"));
    }
        dispatch_cgSetParameter2iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter3iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3iv"));
    }
        dispatch_cgSetParameter3iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter3iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3iv(CGparameter param, const int *  v)</code><br>   */
  public static void cgSetParameter3iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3iv"));
    }
        dispatch_cgSetParameter3iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetParameter4iv(CGparameter param, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4iv"));
    }
        dispatch_cgSetParameter4iv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4iv(CGparameter param, const int *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetParameter4iv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4iv(CGparameter param, const int *  v)</code><br>   */
  public static void cgSetParameter4iv(CGparameter param, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4iv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4iv"));
    }
        dispatch_cgSetParameter4iv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter1fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1fv"));
    }
        dispatch_cgSetParameter1fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter1fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgSetParameter1fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1fv"));
    }
        dispatch_cgSetParameter1fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter2fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2fv"));
    }
        dispatch_cgSetParameter2fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter2fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgSetParameter2fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2fv"));
    }
        dispatch_cgSetParameter2fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter3fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3fv"));
    }
        dispatch_cgSetParameter3fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter3fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgSetParameter3fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3fv"));
    }
        dispatch_cgSetParameter3fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetParameter4fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4fv"));
    }
        dispatch_cgSetParameter4fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetParameter4fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgSetParameter4fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4fv"));
    }
        dispatch_cgSetParameter4fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter1dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1dv"));
    }
        dispatch_cgSetParameter1dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter1dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter1dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgSetParameter1dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter1dv"));
    }
        dispatch_cgSetParameter1dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter2dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2dv"));
    }
        dispatch_cgSetParameter2dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter2dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter2dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgSetParameter2dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter2dv"));
    }
        dispatch_cgSetParameter2dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter3dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3dv"));
    }
        dispatch_cgSetParameter3dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter3dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter3dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgSetParameter3dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter3dv"));
    }
        dispatch_cgSetParameter3dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetParameter4dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4dv"));
    }
        dispatch_cgSetParameter4dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetParameter4dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetParameter4dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgSetParameter4dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetParameter4dv"));
    }
        dispatch_cgSetParameter4dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterir(CGparameter param, const int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMatrixParameterir(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterir"));
    }
        dispatch_cgSetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterir(CGparameter param, const int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMatrixParameterir1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterir(CGparameter param, const int *  matrix)</code><br>   */
  public static void cgSetMatrixParameterir(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterir"));
    }
        dispatch_cgSetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterdr"));
    }
        dispatch_cgSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>   */
  public static void cgSetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterdr"));
    }
        dispatch_cgSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterfr"));
    }
        dispatch_cgSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>   */
  public static void cgSetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterfr"));
    }
        dispatch_cgSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameteric(CGparameter param, const int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgSetMatrixParameteric(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameteric"));
    }
        dispatch_cgSetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameteric(CGparameter param, const int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgSetMatrixParameteric1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameteric(CGparameter param, const int *  matrix)</code><br>   */
  public static void cgSetMatrixParameteric(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameteric"));
    }
        dispatch_cgSetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgSetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterdc"));
    }
        dispatch_cgSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgSetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>   */
  public static void cgSetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterdc"));
    }
        dispatch_cgSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgSetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterfc"));
    }
        dispatch_cgSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgSetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>   */
  public static void cgSetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetMatrixParameterfc"));
    }
        dispatch_cgSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterir(CGparameter param, int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgGetMatrixParameterir(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterir"));
    }
        dispatch_cgGetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterir(CGparameter param, int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgGetMatrixParameterir1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterir(CGparameter param, int *  matrix)</code><br>   */
  public static void cgGetMatrixParameterir(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterir;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterir"));
    }
        dispatch_cgGetMatrixParameterir1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterdr"));
    }
        dispatch_cgGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>   */
  public static void cgGetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterdr"));
    }
        dispatch_cgGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterfr"));
    }
        dispatch_cgGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>   */
  public static void cgGetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterfr"));
    }
        dispatch_cgGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameteric(CGparameter param, int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  public static void cgGetMatrixParameteric(CGparameter param, IntBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameteric"));
    }
        dispatch_cgGetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameteric(CGparameter param, int *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native void dispatch_cgGetMatrixParameteric1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameteric(CGparameter param, int *  matrix)</code><br>   */
  public static void cgGetMatrixParameteric(CGparameter param, int[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameteric;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameteric"));
    }
        dispatch_cgGetMatrixParameteric1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_INT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterdc"));
    }
        dispatch_cgGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>   */
  public static void cgGetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterdc"));
    }
        dispatch_cgGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterfc"));
    }
        dispatch_cgGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>   */
  public static void cgGetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetMatrixParameterfc"));
    }
        dispatch_cgGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetTypeString(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static String cgGetTypeString(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTypeString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetTypeString"));
    }
        return dispatch_cgGetTypeString1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetTypeString(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  static private native String dispatch_cgGetTypeString1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetType(const char *  type_string)</code><br>   */
  public static int cgGetType(String type_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetType"));
    }
        return dispatch_cgGetType1(type_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetType(const char *  type_string)</code><br>   */
  static private native int dispatch_cgGetType1(String type_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetNamedUserType(CGhandle handle, const char *  name)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetNamedUserType(Buffer handle, String name)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedUserType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedUserType"));
    }
        return dispatch_cgGetNamedUserType1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, name, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetNamedUserType(CGhandle handle, const char *  name)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetNamedUserType1(Object handle, int handle_byte_offset, boolean handle_is_direct, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumUserTypes(CGhandle handle)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetNumUserTypes(Buffer handle)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetNumUserTypes;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNumUserTypes"));
    }
        return dispatch_cgGetNumUserTypes1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumUserTypes(CGhandle handle)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetNumUserTypes1(Object handle, int handle_byte_offset, boolean handle_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetUserType(CGhandle handle, int index)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  public static int cgGetUserType(Buffer handle, int index)  {

    final boolean handle_is_direct = Buffers.isDirect(handle);
    final long __addr_ = cgProcAddressTable._addressof_cgGetUserType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetUserType"));
    }
        return dispatch_cgGetUserType1(handle_is_direct ? handle : Buffers.getArray(handle), handle_is_direct ? Buffers.getDirectBufferByteOffset(handle) : Buffers.getIndirectBufferByteOffset(handle), handle_is_direct, index, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetUserType(CGhandle handle, int index)</code><br>
      @param handle a direct or array-backed {@link java.nio.Buffer}   */
  private static native int dispatch_cgGetUserType1(Object handle, int handle_byte_offset, boolean handle_is_direct, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumParentTypes(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static int cgGetNumParentTypes(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumParentTypes;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNumParentTypes"));
    }
        return dispatch_cgGetNumParentTypes1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumParentTypes(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  static private native int dispatch_cgGetNumParentTypes1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParentType(CGtype type, int index)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static int cgGetParentType(int type, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetParentType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetParentType"));
    }
        return dispatch_cgGetParentType1(type, index, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetParentType(CGtype type, int index)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  static private native int dispatch_cgGetParentType1(int type, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParentType(CGtype parent, CGtype child)</code><br>
      @param parent valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param child valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static boolean cgIsParentType(int parent, int child)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsParentType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsParentType"));
    }
        return dispatch_cgIsParentType1(parent, child, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsParentType(CGtype parent, CGtype child)</code><br>
      @param parent valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>

      @param child valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  static private native boolean dispatch_cgIsParentType1(int parent, int child, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsInterfaceType(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static boolean cgIsInterfaceType(int type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsInterfaceType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsInterfaceType"));
    }
        return dispatch_cgIsInterfaceType1(type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsInterfaceType(CGtype type)</code><br>
      @param type valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  static private native boolean dispatch_cgIsInterfaceType1(int type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetResourceString(CGresource resource)</code><br>
      @param resource valid values are: <code>CG_TEXUNIT0, CG_TEXUNIT1, CG_TEXUNIT2, CG_TEXUNIT3, CG_TEXUNIT4, CG_TEXUNIT5, CG_TEXUNIT6, CG_TEXUNIT7, CG_TEXUNIT8, CG_TEXUNIT9, CG_TEXUNIT10, CG_TEXUNIT11, CG_TEXUNIT12, CG_TEXUNIT13, CG_TEXUNIT14, CG_TEXUNIT15, CG_ATTR0, CG_ATTR1, CG_ATTR2, CG_ATTR3, CG_ATTR4, CG_ATTR5, CG_ATTR6, CG_ATTR7, CG_ATTR8, CG_ATTR9, CG_ATTR10, CG_ATTR11, CG_ATTR12, CG_ATTR13, CG_ATTR14, CG_ATTR15, CG_C, CG_TEX0, CG_TEX1, CG_TEX2, CG_TEX3, CG_TEX4, CG_TEX5, CG_TEX6, CG_TEX7, CG_HPOS, CG_COL0, CG_COL1, CG_COL2, CG_COL3, CG_PSIZ, CG_WPOS, CG_POSITION0, CG_POSITION1, CG_POSITION2, CG_POSITION3, CG_POSITION4, CG_POSITION5, CG_POSITION6, CG_POSITION7, CG_POSITION8, CG_POSITION9, CG_POSITION10, CG_POSITION11, CG_POSITION12, CG_POSITION13, CG_POSITION14, CG_POSITION15, CG_DIFFUSE0, CG_TANGENT0, CG_TANGENT1, CG_TANGENT2, CG_TANGENT3, CG_TANGENT4, CG_TANGENT5, CG_TANGENT6, CG_TANGENT7, CG_TANGENT8, CG_TANGENT9, CG_TANGENT10, CG_TANGENT11, CG_TANGENT12, CG_TANGENT13, CG_TANGENT14, CG_TANGENT15, CG_SPECULAR0, CG_BLENDINDICES0, CG_BLENDINDICES1, CG_BLENDINDICES2, CG_BLENDINDICES3, CG_BLENDINDICES4, CG_BLENDINDICES5, CG_BLENDINDICES6, CG_BLENDINDICES7, CG_BLENDINDICES8, CG_BLENDINDICES9, CG_BLENDINDICES10, CG_BLENDINDICES11, CG_BLENDINDICES12, CG_BLENDINDICES13, CG_BLENDINDICES14, CG_BLENDINDICES15, CG_COLOR0, CG_COLOR1, CG_COLOR2, CG_COLOR3, CG_COLOR4, CG_COLOR5, CG_COLOR6, CG_COLOR7, CG_COLOR8, CG_COLOR9, CG_COLOR10, CG_COLOR11, CG_COLOR12, CG_COLOR13, CG_COLOR14, CG_COLOR15, CG_PSIZE0, CG_PSIZE1, CG_PSIZE2, CG_PSIZE3, CG_PSIZE4, CG_PSIZE5, CG_PSIZE6, CG_PSIZE7, CG_PSIZE8, CG_PSIZE9, CG_PSIZE10, CG_PSIZE11, CG_PSIZE12, CG_PSIZE13, CG_PSIZE14, CG_PSIZE15, CG_BINORMAL0, CG_BINORMAL1, CG_BINORMAL2, CG_BINORMAL3, CG_BINORMAL4, CG_BINORMAL5, CG_BINORMAL6, CG_BINORMAL7, CG_BINORMAL8, CG_BINORMAL9, CG_BINORMAL10, CG_BINORMAL11, CG_BINORMAL12, CG_BINORMAL13, CG_BINORMAL14, CG_BINORMAL15, CG_FOG0, CG_FOG1, CG_FOG2, CG_FOG3, CG_FOG4, CG_FOG5, CG_FOG6, CG_FOG7, CG_FOG8, CG_FOG9, CG_FOG10, CG_FOG11, CG_FOG12, CG_FOG13, CG_FOG14, CG_FOG15, CG_DEPTH0, CG_DEPTH1, CG_DEPTH2, CG_DEPTH3, CG_DEPTH4, CG_DEPTH5, CG_DEPTH6, CG_DEPTH7, CG_DEPTH8, CG_DEPTH9, CG_DEPTH10, CG_DEPTH11, CG_DEPTH12, CG_DEPTH13, CG_DEPTH14, CG_DEPTH15, CG_SAMPLE0, CG_SAMPLE1, CG_SAMPLE2, CG_SAMPLE3, CG_SAMPLE4, CG_SAMPLE5, CG_SAMPLE6, CG_SAMPLE7, CG_SAMPLE8, CG_SAMPLE9, CG_SAMPLE10, CG_SAMPLE11, CG_SAMPLE12, CG_SAMPLE13, CG_SAMPLE14, CG_SAMPLE15, CG_BLENDWEIGHT0, CG_BLENDWEIGHT1, CG_BLENDWEIGHT2, CG_BLENDWEIGHT3, CG_BLENDWEIGHT4, CG_BLENDWEIGHT5, CG_BLENDWEIGHT6, CG_BLENDWEIGHT7, CG_BLENDWEIGHT8, CG_BLENDWEIGHT9, CG_BLENDWEIGHT10, CG_BLENDWEIGHT11, CG_BLENDWEIGHT12, CG_BLENDWEIGHT13, CG_BLENDWEIGHT14, CG_BLENDWEIGHT15, CG_NORMAL0, CG_NORMAL1, CG_NORMAL2, CG_NORMAL3, CG_NORMAL4, CG_NORMAL5, CG_NORMAL6, CG_NORMAL7, CG_NORMAL8, CG_NORMAL9, CG_NORMAL10, CG_NORMAL11, CG_NORMAL12, CG_NORMAL13, CG_NORMAL14, CG_NORMAL15, CG_FOGCOORD, CG_TEXCOORD0, CG_TEXCOORD1, CG_TEXCOORD2, CG_TEXCOORD3, CG_TEXCOORD4, CG_TEXCOORD5, CG_TEXCOORD6, CG_TEXCOORD7, CG_TEXCOORD8, CG_TEXCOORD9, CG_TEXCOORD10, CG_TEXCOORD11, CG_TEXCOORD12, CG_TEXCOORD13, CG_TEXCOORD14, CG_TEXCOORD15, CG_COMBINER_CONST0, CG_COMBINER_CONST1, CG_COMBINER_STAGE_CONST0, CG_COMBINER_STAGE_CONST1, CG_OFFSET_TEXTURE_MATRIX, CG_OFFSET_TEXTURE_SCALE, CG_OFFSET_TEXTURE_BIAS, CG_CONST_EYE, CG_TESSFACTOR, CG_UNDEFINED</code>
   */
  public static String cgGetResourceString(int resource)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetResourceString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetResourceString"));
    }
        return dispatch_cgGetResourceString1(resource, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetResourceString(CGresource resource)</code><br>
      @param resource valid values are: <code>CG_TEXUNIT0, CG_TEXUNIT1, CG_TEXUNIT2, CG_TEXUNIT3, CG_TEXUNIT4, CG_TEXUNIT5, CG_TEXUNIT6, CG_TEXUNIT7, CG_TEXUNIT8, CG_TEXUNIT9, CG_TEXUNIT10, CG_TEXUNIT11, CG_TEXUNIT12, CG_TEXUNIT13, CG_TEXUNIT14, CG_TEXUNIT15, CG_ATTR0, CG_ATTR1, CG_ATTR2, CG_ATTR3, CG_ATTR4, CG_ATTR5, CG_ATTR6, CG_ATTR7, CG_ATTR8, CG_ATTR9, CG_ATTR10, CG_ATTR11, CG_ATTR12, CG_ATTR13, CG_ATTR14, CG_ATTR15, CG_C, CG_TEX0, CG_TEX1, CG_TEX2, CG_TEX3, CG_TEX4, CG_TEX5, CG_TEX6, CG_TEX7, CG_HPOS, CG_COL0, CG_COL1, CG_COL2, CG_COL3, CG_PSIZ, CG_WPOS, CG_POSITION0, CG_POSITION1, CG_POSITION2, CG_POSITION3, CG_POSITION4, CG_POSITION5, CG_POSITION6, CG_POSITION7, CG_POSITION8, CG_POSITION9, CG_POSITION10, CG_POSITION11, CG_POSITION12, CG_POSITION13, CG_POSITION14, CG_POSITION15, CG_DIFFUSE0, CG_TANGENT0, CG_TANGENT1, CG_TANGENT2, CG_TANGENT3, CG_TANGENT4, CG_TANGENT5, CG_TANGENT6, CG_TANGENT7, CG_TANGENT8, CG_TANGENT9, CG_TANGENT10, CG_TANGENT11, CG_TANGENT12, CG_TANGENT13, CG_TANGENT14, CG_TANGENT15, CG_SPECULAR0, CG_BLENDINDICES0, CG_BLENDINDICES1, CG_BLENDINDICES2, CG_BLENDINDICES3, CG_BLENDINDICES4, CG_BLENDINDICES5, CG_BLENDINDICES6, CG_BLENDINDICES7, CG_BLENDINDICES8, CG_BLENDINDICES9, CG_BLENDINDICES10, CG_BLENDINDICES11, CG_BLENDINDICES12, CG_BLENDINDICES13, CG_BLENDINDICES14, CG_BLENDINDICES15, CG_COLOR0, CG_COLOR1, CG_COLOR2, CG_COLOR3, CG_COLOR4, CG_COLOR5, CG_COLOR6, CG_COLOR7, CG_COLOR8, CG_COLOR9, CG_COLOR10, CG_COLOR11, CG_COLOR12, CG_COLOR13, CG_COLOR14, CG_COLOR15, CG_PSIZE0, CG_PSIZE1, CG_PSIZE2, CG_PSIZE3, CG_PSIZE4, CG_PSIZE5, CG_PSIZE6, CG_PSIZE7, CG_PSIZE8, CG_PSIZE9, CG_PSIZE10, CG_PSIZE11, CG_PSIZE12, CG_PSIZE13, CG_PSIZE14, CG_PSIZE15, CG_BINORMAL0, CG_BINORMAL1, CG_BINORMAL2, CG_BINORMAL3, CG_BINORMAL4, CG_BINORMAL5, CG_BINORMAL6, CG_BINORMAL7, CG_BINORMAL8, CG_BINORMAL9, CG_BINORMAL10, CG_BINORMAL11, CG_BINORMAL12, CG_BINORMAL13, CG_BINORMAL14, CG_BINORMAL15, CG_FOG0, CG_FOG1, CG_FOG2, CG_FOG3, CG_FOG4, CG_FOG5, CG_FOG6, CG_FOG7, CG_FOG8, CG_FOG9, CG_FOG10, CG_FOG11, CG_FOG12, CG_FOG13, CG_FOG14, CG_FOG15, CG_DEPTH0, CG_DEPTH1, CG_DEPTH2, CG_DEPTH3, CG_DEPTH4, CG_DEPTH5, CG_DEPTH6, CG_DEPTH7, CG_DEPTH8, CG_DEPTH9, CG_DEPTH10, CG_DEPTH11, CG_DEPTH12, CG_DEPTH13, CG_DEPTH14, CG_DEPTH15, CG_SAMPLE0, CG_SAMPLE1, CG_SAMPLE2, CG_SAMPLE3, CG_SAMPLE4, CG_SAMPLE5, CG_SAMPLE6, CG_SAMPLE7, CG_SAMPLE8, CG_SAMPLE9, CG_SAMPLE10, CG_SAMPLE11, CG_SAMPLE12, CG_SAMPLE13, CG_SAMPLE14, CG_SAMPLE15, CG_BLENDWEIGHT0, CG_BLENDWEIGHT1, CG_BLENDWEIGHT2, CG_BLENDWEIGHT3, CG_BLENDWEIGHT4, CG_BLENDWEIGHT5, CG_BLENDWEIGHT6, CG_BLENDWEIGHT7, CG_BLENDWEIGHT8, CG_BLENDWEIGHT9, CG_BLENDWEIGHT10, CG_BLENDWEIGHT11, CG_BLENDWEIGHT12, CG_BLENDWEIGHT13, CG_BLENDWEIGHT14, CG_BLENDWEIGHT15, CG_NORMAL0, CG_NORMAL1, CG_NORMAL2, CG_NORMAL3, CG_NORMAL4, CG_NORMAL5, CG_NORMAL6, CG_NORMAL7, CG_NORMAL8, CG_NORMAL9, CG_NORMAL10, CG_NORMAL11, CG_NORMAL12, CG_NORMAL13, CG_NORMAL14, CG_NORMAL15, CG_FOGCOORD, CG_TEXCOORD0, CG_TEXCOORD1, CG_TEXCOORD2, CG_TEXCOORD3, CG_TEXCOORD4, CG_TEXCOORD5, CG_TEXCOORD6, CG_TEXCOORD7, CG_TEXCOORD8, CG_TEXCOORD9, CG_TEXCOORD10, CG_TEXCOORD11, CG_TEXCOORD12, CG_TEXCOORD13, CG_TEXCOORD14, CG_TEXCOORD15, CG_COMBINER_CONST0, CG_COMBINER_CONST1, CG_COMBINER_STAGE_CONST0, CG_COMBINER_STAGE_CONST1, CG_OFFSET_TEXTURE_MATRIX, CG_OFFSET_TEXTURE_SCALE, CG_OFFSET_TEXTURE_BIAS, CG_CONST_EYE, CG_TESSFACTOR, CG_UNDEFINED</code>
   */
  static private native String dispatch_cgGetResourceString1(int resource, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetResource(const char *  resource_string)</code><br>   */
  public static int cgGetResource(String resource_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetResource;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetResource"));
    }
        return dispatch_cgGetResource1(resource_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGresource cgGetResource(const char *  resource_string)</code><br>   */
  static private native int dispatch_cgGetResource1(String resource_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetEnumString(CGenum en)</code><br>
      @param en valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetEnumString(int en)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEnumString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetEnumString"));
    }
        return dispatch_cgGetEnumString1(en, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetEnumString(CGenum en)</code><br>
      @param en valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  static private native String dispatch_cgGetEnumString1(int en, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetEnum(const char *  enum_string)</code><br>   */
  public static int cgGetEnum(String enum_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEnum;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetEnum"));
    }
        return dispatch_cgGetEnum1(enum_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGenum cgGetEnum(const char *  enum_string)</code><br>   */
  static private native int dispatch_cgGetEnum1(String enum_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetProfileString(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static String cgGetProfileString(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProfileString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProfileString"));
    }
        return dispatch_cgGetProfileString1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetProfileString(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native String dispatch_cgGetProfileString1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGetProfile(const char *  profile_string)</code><br>   */
  public static int cgGetProfile(String profile_string)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProfile"));
    }
        return dispatch_cgGetProfile1(profile_string, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGetProfile(const char *  profile_string)</code><br>   */
  static private native int dispatch_cgGetProfile1(String profile_string, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGerror cgGetError(void)</code><br>   */
  public static int cgGetError()  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetError"));
    }
        return dispatch_cgGetError1(__addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGerror cgGetError(void)</code><br>   */
  static private native int dispatch_cgGetError1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGerror cgGetFirstError(void)</code><br>   */
  public static int cgGetFirstError()  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstError"));
    }
        return dispatch_cgGetFirstError1(__addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGerror cgGetFirstError(void)</code><br>   */
  static private native int dispatch_cgGetFirstError1(long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetErrorString(CGerror error)</code><br>
      @param error valid values are: <code>CG_NO_ERROR, CG_COMPILER_ERROR, CG_INVALID_PARAMETER_ERROR, CG_INVALID_PROFILE_ERROR, CG_PROGRAM_LOAD_ERROR, CG_PROGRAM_BIND_ERROR, CG_PROGRAM_NOT_LOADED_ERROR, CG_UNSUPPORTED_GL_EXTENSION_ERROR, CG_INVALID_VALUE_TYPE_ERROR, CG_NOT_MATRIX_PARAM_ERROR, CG_INVALID_ENUMERANT_ERROR, CG_NOT_4x4_MATRIX_ERROR, CG_FILE_READ_ERROR, CG_FILE_WRITE_ERROR, CG_NVPARSE_ERROR, CG_MEMORY_ALLOC_ERROR, CG_INVALID_CONTEXT_HANDLE_ERROR, CG_INVALID_PROGRAM_HANDLE_ERROR, CG_INVALID_PARAM_HANDLE_ERROR, CG_UNKNOWN_PROFILE_ERROR, CG_VAR_ARG_ERROR, CG_INVALID_DIMENSION_ERROR, CG_ARRAY_PARAM_ERROR, CG_OUT_OF_ARRAY_BOUNDS_ERROR, CG_CONFLICTING_TYPES_ERROR, CG_CONFLICTING_PARAMETER_TYPES_ERROR, CG_PARAMETER_IS_NOT_SHARED_ERROR, CG_INVALID_PARAMETER_VARIABILITY_ERROR, CG_CANNOT_DESTROY_PARAMETER_ERROR, CG_NOT_ROOT_PARAMETER_ERROR, CG_PARAMETERS_DO_NOT_MATCH_ERROR, CG_IS_NOT_PROGRAM_PARAMETER_ERROR, CG_INVALID_PARAMETER_TYPE_ERROR, CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR, CG_INVALID_SIZE_ERROR, CG_BIND_CREATES_CYCLE_ERROR, CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR, CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR, CG_ARRAY_HAS_WRONG_DIMENSION_ERROR, CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR, CG_INVALID_EFFECT_HANDLE_ERROR, CG_INVALID_STATE_HANDLE_ERROR, CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR, CG_INVALID_PASS_HANDLE_ERROR, CG_INVALID_ANNOTATION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_HANDLE_ERROR, CG_INVALID_PARAMETER_HANDLE_ERROR, CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR, CG_INVALID_FUNCTION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_ERROR, CG_INVALID_POINTER_ERROR, CG_NOT_ENOUGH_DATA_ERROR, CG_NON_NUMERIC_PARAMETER_ERROR, CG_ARRAY_SIZE_MISMATCH_ERROR</code>
   */
  public static String cgGetErrorString(int error)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetErrorString"));
    }
        return dispatch_cgGetErrorString1(error, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetErrorString(CGerror error)</code><br>
      @param error valid values are: <code>CG_NO_ERROR, CG_COMPILER_ERROR, CG_INVALID_PARAMETER_ERROR, CG_INVALID_PROFILE_ERROR, CG_PROGRAM_LOAD_ERROR, CG_PROGRAM_BIND_ERROR, CG_PROGRAM_NOT_LOADED_ERROR, CG_UNSUPPORTED_GL_EXTENSION_ERROR, CG_INVALID_VALUE_TYPE_ERROR, CG_NOT_MATRIX_PARAM_ERROR, CG_INVALID_ENUMERANT_ERROR, CG_NOT_4x4_MATRIX_ERROR, CG_FILE_READ_ERROR, CG_FILE_WRITE_ERROR, CG_NVPARSE_ERROR, CG_MEMORY_ALLOC_ERROR, CG_INVALID_CONTEXT_HANDLE_ERROR, CG_INVALID_PROGRAM_HANDLE_ERROR, CG_INVALID_PARAM_HANDLE_ERROR, CG_UNKNOWN_PROFILE_ERROR, CG_VAR_ARG_ERROR, CG_INVALID_DIMENSION_ERROR, CG_ARRAY_PARAM_ERROR, CG_OUT_OF_ARRAY_BOUNDS_ERROR, CG_CONFLICTING_TYPES_ERROR, CG_CONFLICTING_PARAMETER_TYPES_ERROR, CG_PARAMETER_IS_NOT_SHARED_ERROR, CG_INVALID_PARAMETER_VARIABILITY_ERROR, CG_CANNOT_DESTROY_PARAMETER_ERROR, CG_NOT_ROOT_PARAMETER_ERROR, CG_PARAMETERS_DO_NOT_MATCH_ERROR, CG_IS_NOT_PROGRAM_PARAMETER_ERROR, CG_INVALID_PARAMETER_TYPE_ERROR, CG_PARAMETER_IS_NOT_RESIZABLE_ARRAY_ERROR, CG_INVALID_SIZE_ERROR, CG_BIND_CREATES_CYCLE_ERROR, CG_ARRAY_TYPES_DO_NOT_MATCH_ERROR, CG_ARRAY_DIMENSIONS_DO_NOT_MATCH_ERROR, CG_ARRAY_HAS_WRONG_DIMENSION_ERROR, CG_TYPE_IS_NOT_DEFINED_IN_PROGRAM_ERROR, CG_INVALID_EFFECT_HANDLE_ERROR, CG_INVALID_STATE_HANDLE_ERROR, CG_INVALID_STATE_ASSIGNMENT_HANDLE_ERROR, CG_INVALID_PASS_HANDLE_ERROR, CG_INVALID_ANNOTATION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_HANDLE_ERROR, CG_INVALID_PARAMETER_HANDLE_ERROR, CG_STATE_ASSIGNMENT_TYPE_MISMATCH_ERROR, CG_INVALID_FUNCTION_HANDLE_ERROR, CG_INVALID_TECHNIQUE_ERROR, CG_INVALID_POINTER_ERROR, CG_NOT_ENOUGH_DATA_ERROR, CG_NON_NUMERIC_PARAMETER_ERROR, CG_ARRAY_SIZE_MISMATCH_ERROR</code>
   */
  static private native String dispatch_cgGetErrorString1(int error, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetLastErrorString(CGerror *  error)</code><br>
      @param error a direct or array-backed {@link java.nio.IntBuffer}   */
  public static String cgGetLastErrorString(IntBuffer error)  {

    final boolean error_is_direct = Buffers.isDirect(error);
    final long __addr_ = cgProcAddressTable._addressof_cgGetLastErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetLastErrorString"));
    }
        return dispatch_cgGetLastErrorString1(error_is_direct ? error : Buffers.getArray(error), error_is_direct ? Buffers.getDirectBufferByteOffset(error) : Buffers.getIndirectBufferByteOffset(error), error_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetLastErrorString(CGerror *  error)</code><br>
      @param error a direct or array-backed {@link java.nio.IntBuffer}   */
  private static native String dispatch_cgGetLastErrorString1(Object error, int error_byte_offset, boolean error_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetLastErrorString(CGerror *  error)</code><br>   */
  public static String cgGetLastErrorString(int[] error, int error_offset)  {

    if(error != null && error.length <= error_offset)
      throw new CgException("array offset argument \"error_offset\" (" + error_offset + ") equals or exceeds array length (" + error.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGetLastErrorString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetLastErrorString"));
    }
        return dispatch_cgGetLastErrorString1(error, Buffers.SIZEOF_INT * error_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetString(CGenum sname)</code><br>
      @param sname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  public static String cgGetString(int sname)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetString"));
    }
        return dispatch_cgGetString1(sname, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetString(CGenum sname)</code><br>
      @param sname valid values are: <code>CG_UNKNOWN, CG_IN, CG_OUT, CG_INOUT, CG_MIXED, CG_VARYING, CG_UNIFORM, CG_CONSTANT, CG_PROGRAM_SOURCE, CG_PROGRAM_ENTRY, CG_COMPILED_PROGRAM, CG_PROGRAM_PROFILE, CG_GLOBAL, CG_PROGRAM, CG_DEFAULT, CG_ERROR, CG_SOURCE, CG_OBJECT, CG_COMPILE_MANUAL, CG_COMPILE_IMMEDIATE, CG_COMPILE_LAZY, CG_CURRENT, CG_LITERAL, CG_VERSION, CG_ROW_MAJOR, CG_COLUMN_MAJOR</code>
   */
  static private native String dispatch_cgGetString1(int sname, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgCreateEffect(CGcontext, const char *  code, const char *  *  args)</code><br>   */
  public static CGeffect cgCreateEffect(CGcontext arg0, String code, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateEffect"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateEffect1(((arg0 == null) ? null : arg0.getBuffer()), code, args, __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgCreateEffect(CGcontext, const char *  code, const char *  *  args)</code><br>   */
  private static native ByteBuffer dispatch_cgCreateEffect1(ByteBuffer arg0, String code, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgCreateEffectFromFile(CGcontext, const char *  filename, const char *  *  args)</code><br>   */
  public static CGeffect cgCreateEffectFromFile(CGcontext arg0, String filename, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateEffectFromFile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateEffectFromFile"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateEffectFromFile1(((arg0 == null) ? null : arg0.getBuffer()), filename, args, __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgCreateEffectFromFile(CGcontext, const char *  filename, const char *  *  args)</code><br>   */
  private static native ByteBuffer dispatch_cgCreateEffectFromFile1(ByteBuffer arg0, String filename, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyEffect(CGeffect)</code><br>   */
  public static void cgDestroyEffect(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgDestroyEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgDestroyEffect"));
    }
        dispatch_cgDestroyEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgDestroyEffect(CGeffect)</code><br>   */
  private static native void dispatch_cgDestroyEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetEffectContext(CGeffect)</code><br>   */
  public static CGcontext cgGetEffectContext(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEffectContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetEffectContext"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetEffectContext1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGcontext.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGcontext cgGetEffectContext(CGeffect)</code><br>   */
  private static native ByteBuffer dispatch_cgGetEffectContext1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsEffect(CGeffect effect)</code><br>   */
  public static boolean cgIsEffect(CGeffect effect)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsEffect"));
    }
        return dispatch_cgIsEffect1(((effect == null) ? null : effect.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsEffect(CGeffect effect)</code><br>   */
  private static native boolean dispatch_cgIsEffect1(ByteBuffer effect, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetFirstEffect(CGcontext)</code><br>   */
  public static CGeffect cgGetFirstEffect(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstEffect"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetFirstEffect(CGcontext)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetNextEffect(CGeffect)</code><br>   */
  public static CGeffect cgGetNextEffect(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextEffect"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetNextEffect(CGeffect)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgramFromEffect(CGeffect effect, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static CGprogram cgCreateProgramFromEffect(CGeffect effect, int profile, String entry, String[] args)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateProgramFromEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateProgramFromEffect"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateProgramFromEffect1(((effect == null) ? null : effect.getBuffer()), profile, entry, args, __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgCreateProgramFromEffect(CGeffect effect, CGprofile profile, const char *  entry, const char *  *  args)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  private static native ByteBuffer dispatch_cgCreateProgramFromEffect1(ByteBuffer effect, int profile, String entry, String[] args, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetFirstTechnique(CGeffect)</code><br>   */
  public static CGtechnique cgGetFirstTechnique(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstTechnique"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetFirstTechnique(CGeffect)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetNextTechnique(CGtechnique)</code><br>   */
  public static CGtechnique cgGetNextTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextTechnique"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetNextTechnique(CGtechnique)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetNamedTechnique(CGeffect, const char *  name)</code><br>   */
  public static CGtechnique cgGetNamedTechnique(CGeffect arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedTechnique"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedTechnique1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetNamedTechnique(CGeffect, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedTechnique1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetTechniqueName(CGtechnique)</code><br>   */
  public static String cgGetTechniqueName(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTechniqueName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetTechniqueName"));
    }
        return dispatch_cgGetTechniqueName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetTechniqueName(CGtechnique)</code><br>   */
  private static native String dispatch_cgGetTechniqueName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsTechnique(CGtechnique)</code><br>   */
  public static boolean cgIsTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsTechnique"));
    }
        return dispatch_cgIsTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsTechnique(CGtechnique)</code><br>   */
  private static native boolean dispatch_cgIsTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgValidateTechnique(CGtechnique)</code><br>   */
  public static boolean cgValidateTechnique(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgValidateTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgValidateTechnique"));
    }
        return dispatch_cgValidateTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgValidateTechnique(CGtechnique)</code><br>   */
  private static native boolean dispatch_cgValidateTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsTechniqueValidated(CGtechnique)</code><br>   */
  public static boolean cgIsTechniqueValidated(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsTechniqueValidated;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsTechniqueValidated"));
    }
        return dispatch_cgIsTechniqueValidated1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsTechniqueValidated(CGtechnique)</code><br>   */
  private static native boolean dispatch_cgIsTechniqueValidated1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetTechniqueEffect(CGtechnique)</code><br>   */
  public static CGeffect cgGetTechniqueEffect(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTechniqueEffect;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetTechniqueEffect"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetTechniqueEffect1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGeffect.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGeffect cgGetTechniqueEffect(CGtechnique)</code><br>   */
  private static native ByteBuffer dispatch_cgGetTechniqueEffect1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetFirstPass(CGtechnique)</code><br>   */
  public static CGpass cgGetFirstPass(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstPass"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetFirstPass(CGtechnique)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetNamedPass(CGtechnique, const char *  name)</code><br>   */
  public static CGpass cgGetNamedPass(CGtechnique arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedPass"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedPass1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetNamedPass(CGtechnique, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedPass1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetNextPass(CGpass)</code><br>   */
  public static CGpass cgGetNextPass(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextPass"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetNextPass(CGpass)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsPass(CGpass)</code><br>   */
  public static boolean cgIsPass(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsPass"));
    }
        return dispatch_cgIsPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsPass(CGpass)</code><br>   */
  private static native boolean dispatch_cgIsPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetPassName(CGpass)</code><br>   */
  public static String cgGetPassName(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetPassName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetPassName"));
    }
        return dispatch_cgGetPassName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetPassName(CGpass)</code><br>   */
  private static native String dispatch_cgGetPassName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetPassTechnique(CGpass)</code><br>   */
  public static CGtechnique cgGetPassTechnique(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetPassTechnique;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetPassTechnique"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetPassTechnique1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGtechnique.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtechnique cgGetPassTechnique(CGpass)</code><br>   */
  private static native ByteBuffer dispatch_cgGetPassTechnique1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetPassState(CGpass)</code><br>   */
  public static void cgSetPassState(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetPassState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetPassState"));
    }
        dispatch_cgSetPassState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetPassState(CGpass)</code><br>   */
  private static native void dispatch_cgSetPassState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgResetPassState(CGpass)</code><br>   */
  public static void cgResetPassState(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgResetPassState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgResetPassState"));
    }
        dispatch_cgResetPassState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgResetPassState(CGpass)</code><br>   */
  private static native void dispatch_cgResetPassState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetFirstStateAssignment(CGpass)</code><br>   */
  public static CGstateassignment cgGetFirstStateAssignment(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstStateAssignment"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetFirstStateAssignment(CGpass)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNamedStateAssignment(CGpass, const char *  name)</code><br>   */
  public static CGstateassignment cgGetNamedStateAssignment(CGpass arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedStateAssignment"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNamedStateAssignment(CGpass, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedStateAssignment1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNextStateAssignment(CGstateassignment)</code><br>   */
  public static CGstateassignment cgGetNextStateAssignment(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextStateAssignment"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNextStateAssignment(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsStateAssignment(CGstateassignment)</code><br>   */
  public static boolean cgIsStateAssignment(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsStateAssignment"));
    }
        return dispatch_cgIsStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsStateAssignment(CGstateassignment)</code><br>   */
  private static native boolean dispatch_cgIsStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateSetCallback(CGstateassignment)</code><br>   */
  public static boolean cgCallStateSetCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateSetCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCallStateSetCallback"));
    }
        return dispatch_cgCallStateSetCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateSetCallback(CGstateassignment)</code><br>   */
  private static native boolean dispatch_cgCallStateSetCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateValidateCallback(CGstateassignment)</code><br>   */
  public static boolean cgCallStateValidateCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateValidateCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCallStateValidateCallback"));
    }
        return dispatch_cgCallStateValidateCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateValidateCallback(CGstateassignment)</code><br>   */
  private static native boolean dispatch_cgCallStateValidateCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateResetCallback(CGstateassignment)</code><br>   */
  public static boolean cgCallStateResetCallback(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCallStateResetCallback;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCallStateResetCallback"));
    }
        return dispatch_cgCallStateResetCallback1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgCallStateResetCallback(CGstateassignment)</code><br>   */
  private static native boolean dispatch_cgCallStateResetCallback1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetStateAssignmentPass(CGstateassignment)</code><br>   */
  public static CGpass cgGetStateAssignmentPass(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentPass;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStateAssignmentPass"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetStateAssignmentPass1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGpass.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGpass cgGetStateAssignmentPass(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetStateAssignmentPass1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment)</code><br>   */
  public static CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetSamplerStateAssignmentParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetSamplerStateAssignmentParameter(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringStateAssignmentValue(CGstateassignment)</code><br>   */
  public static String cgGetStringStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStringStateAssignmentValue"));
    }
        return dispatch_cgGetStringStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringStateAssignmentValue(CGstateassignment)</code><br>   */
  private static native String dispatch_cgGetStringStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetProgramStateAssignmentValue(CGstateassignment)</code><br>   */
  public static CGprogram cgGetProgramStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetProgramStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetProgramStateAssignmentValue"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetProgramStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGprogram.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprogram cgGetProgramStateAssignmentValue(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetProgramStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetTextureStateAssignmentValue(CGstateassignment)</code><br>   */
  public static CGparameter cgGetTextureStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetTextureStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetTextureStateAssignmentValue"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetTextureStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetTextureStateAssignmentValue(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetTextureStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment)</code><br>   */
  public static CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetSamplerStateAssignmentValue"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetSamplerStateAssignmentValue(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetStateAssignmentIndex(CGstateassignment)</code><br>   */
  public static int cgGetStateAssignmentIndex(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentIndex;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStateAssignmentIndex"));
    }
        return dispatch_cgGetStateAssignmentIndex1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetStateAssignmentIndex(CGstateassignment)</code><br>   */
  private static native int dispatch_cgGetStateAssignmentIndex1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumDependentStateAssignmentParameters(CGstateassignment)</code><br>   */
  public static int cgGetNumDependentStateAssignmentParameters(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumDependentStateAssignmentParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNumDependentStateAssignmentParameters"));
    }
        return dispatch_cgGetNumDependentStateAssignmentParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumDependentStateAssignmentParameters(CGstateassignment)</code><br>   */
  private static native int dispatch_cgGetNumDependentStateAssignmentParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment, int index)</code><br>   */
  public static CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment arg0, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetDependentStateAssignmentParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetDependentStateAssignmentParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetDependentStateAssignmentParameter1(((arg0 == null) ? null : arg0.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetDependentStateAssignmentParameter(CGstateassignment, int index)</code><br>   */
  private static native ByteBuffer dispatch_cgGetDependentStateAssignmentParameter1(ByteBuffer arg0, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetStateAssignmentState(CGstateassignment)</code><br>   */
  public static CGstate cgGetStateAssignmentState(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateAssignmentState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStateAssignmentState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetStateAssignmentState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetStateAssignmentState(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetStateAssignmentState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetSamplerStateAssignmentState(CGstateassignment)</code><br>   */
  public static CGstate cgGetSamplerStateAssignmentState(CGstateassignment arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetSamplerStateAssignmentState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetSamplerStateAssignmentState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetSamplerStateAssignmentState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetSamplerStateAssignmentState(CGstateassignment)</code><br>   */
  private static native ByteBuffer dispatch_cgGetSamplerStateAssignmentState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateState(CGcontext, const char *  name, CGtype)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateState(CGcontext arg0, String name, int arg2)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateState(CGcontext, const char *  name, CGtype)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateState1(ByteBuffer arg0, String name, int arg2, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateArrayState(CGcontext, const char *  name, CGtype, int nelems)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateArrayState(CGcontext arg0, String name, int arg2, int nelems)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateArrayState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateArrayState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateArrayState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, nelems, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateArrayState(CGcontext, const char *  name, CGtype, int nelems)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateArrayState1(ByteBuffer arg0, String name, int arg2, int nelems, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetStateType(CGstate)</code><br>   */
  public static int cgGetStateType(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStateType"));
    }
        return dispatch_cgGetStateType1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetStateType(CGstate)</code><br>   */
  private static native int dispatch_cgGetStateType1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStateName(CGstate)</code><br>   */
  public static String cgGetStateName(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStateName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStateName"));
    }
        return dispatch_cgGetStateName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStateName(CGstate)</code><br>   */
  private static native String dispatch_cgGetStateName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNamedState(CGcontext, const char *  name)</code><br>   */
  public static CGstate cgGetNamedState(CGcontext arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedState1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNamedState(CGcontext, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedState1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetFirstState(CGcontext)</code><br>   */
  public static CGstate cgGetFirstState(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetFirstState(CGcontext)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNextState(CGstate)</code><br>   */
  public static CGstate cgGetNextState(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNextState(CGstate)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsState(CGstate)</code><br>   */
  public static boolean cgIsState(CGstate arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsState"));
    }
        return dispatch_cgIsState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsState(CGstate)</code><br>   */
  private static native boolean dispatch_cgIsState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgAddStateEnumerant(CGstate, const char *  name, int value)</code><br>   */
  public static void cgAddStateEnumerant(CGstate arg0, String name, int value)  {

    final long __addr_ = cgProcAddressTable._addressof_cgAddStateEnumerant;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgAddStateEnumerant"));
    }
        dispatch_cgAddStateEnumerant1(((arg0 == null) ? null : arg0.getBuffer()), name, value, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgAddStateEnumerant(CGstate, const char *  name, int value)</code><br>   */
  private static native void dispatch_cgAddStateEnumerant1(ByteBuffer arg0, String name, int value, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateSamplerState(CGcontext, const char *  name, CGtype)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateSamplerState(CGcontext arg0, String name, int arg2)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateSamplerState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateSamplerState(CGcontext, const char *  name, CGtype)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateSamplerState1(ByteBuffer arg0, String name, int arg2, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateArraySamplerState(CGcontext, const char *  name, CGtype, int nelems)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  public static CGstate cgCreateArraySamplerState(CGcontext arg0, String name, int arg2, int nelems)  {

    final long __addr_ = cgProcAddressTable._addressof_cgCreateArraySamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgCreateArraySamplerState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgCreateArraySamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, arg2, nelems, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgCreateArraySamplerState(CGcontext, const char *  name, CGtype, int nelems)</code><br>
      @param arg2 valid values are: <code>CG_UNKNOWN_TYPE, CG_STRUCT, CG_ARRAY, CG_TYPE_START_ENUM, CG_HALF, CG_HALF2, CG_HALF3, CG_HALF4, CG_HALF1x1, CG_HALF1x2, CG_HALF1x3, CG_HALF1x4, CG_HALF2x1, CG_HALF2x2, CG_HALF2x3, CG_HALF2x4, CG_HALF3x1, CG_HALF3x2, CG_HALF3x3, CG_HALF3x4, CG_HALF4x1, CG_HALF4x2, CG_HALF4x3, CG_HALF4x4, CG_FLOAT, CG_FLOAT2, CG_FLOAT3, CG_FLOAT4, CG_FLOAT1x1, CG_FLOAT1x2, CG_FLOAT1x3, CG_FLOAT1x4, CG_FLOAT2x1, CG_FLOAT2x2, CG_FLOAT2x3, CG_FLOAT2x4, CG_FLOAT3x1, CG_FLOAT3x2, CG_FLOAT3x3, CG_FLOAT3x4, CG_FLOAT4x1, CG_FLOAT4x2, CG_FLOAT4x3, CG_FLOAT4x4, CG_SAMPLER1D, CG_SAMPLER2D, CG_SAMPLER3D, CG_SAMPLERRECT, CG_SAMPLERCUBE, CG_FIXED, CG_FIXED2, CG_FIXED3, CG_FIXED4, CG_FIXED1x1, CG_FIXED1x2, CG_FIXED1x3, CG_FIXED1x4, CG_FIXED2x1, CG_FIXED2x2, CG_FIXED2x3, CG_FIXED2x4, CG_FIXED3x1, CG_FIXED3x2, CG_FIXED3x3, CG_FIXED3x4, CG_FIXED4x1, CG_FIXED4x2, CG_FIXED4x3, CG_FIXED4x4, CG_HALF1, CG_FLOAT1, CG_FIXED1, CG_INT, CG_INT1, CG_INT2, CG_INT3, CG_INT4, CG_INT1x1, CG_INT1x2, CG_INT1x3, CG_INT1x4, CG_INT2x1, CG_INT2x2, CG_INT2x3, CG_INT2x4, CG_INT3x1, CG_INT3x2, CG_INT3x3, CG_INT3x4, CG_INT4x1, CG_INT4x2, CG_INT4x3, CG_INT4x4, CG_BOOL, CG_BOOL1, CG_BOOL2, CG_BOOL3, CG_BOOL4, CG_BOOL1x1, CG_BOOL1x2, CG_BOOL1x3, CG_BOOL1x4, CG_BOOL2x1, CG_BOOL2x2, CG_BOOL2x3, CG_BOOL2x4, CG_BOOL3x1, CG_BOOL3x2, CG_BOOL3x3, CG_BOOL3x4, CG_BOOL4x1, CG_BOOL4x2, CG_BOOL4x3, CG_BOOL4x4, CG_STRING, CG_PROGRAM_TYPE, CG_TEXTURE</code>
   */
  private static native ByteBuffer dispatch_cgCreateArraySamplerState1(ByteBuffer arg0, String name, int arg2, int nelems, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNamedSamplerState(CGcontext, const char *  name)</code><br>   */
  public static CGstate cgGetNamedSamplerState(CGcontext arg0, String name)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedSamplerState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), name, __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetNamedSamplerState(CGcontext, const char *  name)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedSamplerState1(ByteBuffer arg0, String name, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetFirstSamplerState(CGcontext)</code><br>   */
  public static CGstate cgGetFirstSamplerState(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstSamplerState"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstate.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstate cgGetFirstSamplerState(CGcontext)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstSamplerState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter)</code><br>   */
  public static CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstSamplerStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstSamplerStateAssignment"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstSamplerStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetFirstSamplerStateAssignment(CGparameter)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstSamplerStateAssignment1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter, const char * )</code><br>   */
  public static CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedSamplerStateAssignment;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedSamplerStateAssignment"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedSamplerStateAssignment1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGstateassignment.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGstateassignment cgGetNamedSamplerStateAssignment(CGparameter, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedSamplerStateAssignment1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetSamplerState(CGparameter)</code><br>   */
  public static void cgSetSamplerState(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgSetSamplerState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgSetSamplerState"));
    }
        dispatch_cgSetSamplerState1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgSetSamplerState(CGparameter)</code><br>   */
  private static native void dispatch_cgSetSamplerState1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedEffectParameter(CGeffect, const char * )</code><br>   */
  public static CGparameter cgGetNamedEffectParameter(CGeffect arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedEffectParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetNamedEffectParameter(CGeffect, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedEffectParameter1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstLeafEffectParameter(CGeffect)</code><br>   */
  public static CGparameter cgGetFirstLeafEffectParameter(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstLeafEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstLeafEffectParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstLeafEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstLeafEffectParameter(CGeffect)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstLeafEffectParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstEffectParameter(CGeffect)</code><br>   */
  public static CGparameter cgGetFirstEffectParameter(CGeffect arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstEffectParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstEffectParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstEffectParameter1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetFirstEffectParameter(CGeffect)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstEffectParameter1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetEffectParameterBySemantic(CGeffect, const char * )</code><br>   */
  public static CGparameter cgGetEffectParameterBySemantic(CGeffect arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetEffectParameterBySemantic;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetEffectParameterBySemantic"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetEffectParameterBySemantic1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetEffectParameterBySemantic(CGeffect, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetEffectParameterBySemantic1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstTechniqueAnnotation(CGtechnique)</code><br>   */
  public static CGannotation cgGetFirstTechniqueAnnotation(CGtechnique arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstTechniqueAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstTechniqueAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstTechniqueAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstTechniqueAnnotation(CGtechnique)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstTechniqueAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstPassAnnotation(CGpass)</code><br>   */
  public static CGannotation cgGetFirstPassAnnotation(CGpass arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstPassAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstPassAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstPassAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstPassAnnotation(CGpass)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstPassAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstParameterAnnotation(CGparameter)</code><br>   */
  public static CGannotation cgGetFirstParameterAnnotation(CGparameter arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstParameterAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstParameterAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstParameterAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstParameterAnnotation(CGparameter)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstParameterAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstProgramAnnotation(CGprogram)</code><br>   */
  public static CGannotation cgGetFirstProgramAnnotation(CGprogram arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetFirstProgramAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetFirstProgramAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetFirstProgramAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetFirstProgramAnnotation(CGprogram)</code><br>   */
  private static native ByteBuffer dispatch_cgGetFirstProgramAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNextAnnotation(CGannotation)</code><br>   */
  public static CGannotation cgGetNextAnnotation(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNextAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNextAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNextAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNextAnnotation(CGannotation)</code><br>   */
  private static native ByteBuffer dispatch_cgGetNextAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedTechniqueAnnotation(CGtechnique, const char * )</code><br>   */
  public static CGannotation cgGetNamedTechniqueAnnotation(CGtechnique arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedTechniqueAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedTechniqueAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedTechniqueAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedTechniqueAnnotation(CGtechnique, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedTechniqueAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedPassAnnotation(CGpass, const char * )</code><br>   */
  public static CGannotation cgGetNamedPassAnnotation(CGpass arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedPassAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedPassAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedPassAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedPassAnnotation(CGpass, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedPassAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedParameterAnnotation(CGparameter, const char * )</code><br>   */
  public static CGannotation cgGetNamedParameterAnnotation(CGparameter arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedParameterAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedParameterAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedParameterAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedParameterAnnotation(CGparameter, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedParameterAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedProgramAnnotation(CGprogram, const char * )</code><br>   */
  public static CGannotation cgGetNamedProgramAnnotation(CGprogram arg0, String arg1)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNamedProgramAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNamedProgramAnnotation"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetNamedProgramAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), arg1, __addr_);
    if (_res == null) return null;
    return CGannotation.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGannotation cgGetNamedProgramAnnotation(CGprogram, const char * )</code><br>   */
  private static native ByteBuffer dispatch_cgGetNamedProgramAnnotation1(ByteBuffer arg0, String arg1, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsAnnotation(CGannotation)</code><br>   */
  public static boolean cgIsAnnotation(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgIsAnnotation;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgIsAnnotation"));
    }
        return dispatch_cgIsAnnotation1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgIsAnnotation(CGannotation)</code><br>   */
  private static native boolean dispatch_cgIsAnnotation1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetAnnotationName(CGannotation)</code><br>   */
  public static String cgGetAnnotationName(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAnnotationName;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetAnnotationName"));
    }
        return dispatch_cgGetAnnotationName1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetAnnotationName(CGannotation)</code><br>   */
  private static native String dispatch_cgGetAnnotationName1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetAnnotationType(CGannotation)</code><br>   */
  public static int cgGetAnnotationType(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetAnnotationType;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetAnnotationType"));
    }
        return dispatch_cgGetAnnotationType1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGtype cgGetAnnotationType(CGannotation)</code><br>   */
  private static native int dispatch_cgGetAnnotationType1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringAnnotationValue(CGannotation)</code><br>   */
  public static String cgGetStringAnnotationValue(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetStringAnnotationValue;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetStringAnnotationValue"));
    }
        return dispatch_cgGetStringAnnotationValue1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>const char *  cgGetStringAnnotationValue(CGannotation)</code><br>   */
  private static native String dispatch_cgGetStringAnnotationValue1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumDependentAnnotationParameters(CGannotation)</code><br>   */
  public static int cgGetNumDependentAnnotationParameters(CGannotation arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetNumDependentAnnotationParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetNumDependentAnnotationParameters"));
    }
        return dispatch_cgGetNumDependentAnnotationParameters1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>int cgGetNumDependentAnnotationParameters(CGannotation)</code><br>   */
  private static native int dispatch_cgGetNumDependentAnnotationParameters1(ByteBuffer arg0, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetDependentAnnotationParameter(CGannotation, int index)</code><br>   */
  public static CGparameter cgGetDependentAnnotationParameter(CGannotation arg0, int index)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGetDependentAnnotationParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGetDependentAnnotationParameter"));
    }
    final ByteBuffer _res;
    _res = dispatch_cgGetDependentAnnotationParameter1(((arg0 == null) ? null : arg0.getBuffer()), index, __addr_);
    if (_res == null) return null;
    return CGparameter.create(Buffers.nativeOrder(_res));
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGparameter cgGetDependentAnnotationParameter(CGannotation, int index)</code><br>   */
  private static native ByteBuffer dispatch_cgGetDependentAnnotationParameter1(ByteBuffer arg0, int index, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgEvaluateProgram(CGprogram arg0, FloatBuffer arg1, int ncomps, int nx, int ny, int nz)  {

    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = cgProcAddressTable._addressof_cgEvaluateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgEvaluateProgram"));
    }
        dispatch_cgEvaluateProgram1(((arg0 == null) ? null : arg0.getBuffer()), arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, ncomps, nx, ny, nz, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz)</code><br>
      @param arg1 a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgEvaluateProgram1(ByteBuffer arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, int ncomps, int nx, int ny, int nz, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgEvaluateProgram(CGprogram, float * , int ncomps, int nx, int ny, int nz)</code><br>   */
  public static void cgEvaluateProgram(CGprogram arg0, float[] arg1, int arg1_offset, int ncomps, int nx, int ny, int nz)  {

    if(arg1 != null && arg1.length <= arg1_offset)
      throw new CgException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgEvaluateProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgEvaluateProgram"));
    }
        dispatch_cgEvaluateProgram1(((arg0 == null) ? null : arg0.getBuffer()), arg1, Buffers.SIZEOF_FLOAT * arg1_offset, false, ncomps, nx, ny, nz, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLIsProfileSupported(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static boolean cgGLIsProfileSupported(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLIsProfileSupported;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLIsProfileSupported"));
    }
        return dispatch_cgGLIsProfileSupported1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLIsProfileSupported(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native boolean dispatch_cgGLIsProfileSupported1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableProfile(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLEnableProfile(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLEnableProfile"));
    }
        dispatch_cgGLEnableProfile1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableProfile(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native void dispatch_cgGLEnableProfile1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableProfile(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLDisableProfile(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLDisableProfile"));
    }
        dispatch_cgGLDisableProfile1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableProfile(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native void dispatch_cgGLDisableProfile1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGLGetLatestProfile(CGGLenum profile_type)</code><br>
      @param profile_type valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  public static int cgGLGetLatestProfile(int profile_type)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetLatestProfile;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetLatestProfile"));
    }
        return dispatch_cgGLGetLatestProfile1(profile_type, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGprofile cgGLGetLatestProfile(CGGLenum profile_type)</code><br>
      @param profile_type valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  static private native int dispatch_cgGLGetLatestProfile1(int profile_type, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetOptimalOptions(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLSetOptimalOptions(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetOptimalOptions;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetOptimalOptions"));
    }
        dispatch_cgGLSetOptimalOptions1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetOptimalOptions(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native void dispatch_cgGLSetOptimalOptions1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLLoadProgram(CGprogram program)</code><br>   */
  public static void cgGLLoadProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLLoadProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLLoadProgram"));
    }
        dispatch_cgGLLoadProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLLoadProgram(CGprogram program)</code><br>   */
  private static native void dispatch_cgGLLoadProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLIsProgramLoaded(CGprogram program)</code><br>   */
  public static boolean cgGLIsProgramLoaded(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLIsProgramLoaded;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLIsProgramLoaded"));
    }
        return dispatch_cgGLIsProgramLoaded1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLIsProgramLoaded(CGprogram program)</code><br>   */
  private static native boolean dispatch_cgGLIsProgramLoaded1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLBindProgram(CGprogram program)</code><br>   */
  public static void cgGLBindProgram(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLBindProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLBindProgram"));
    }
        dispatch_cgGLBindProgram1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLBindProgram(CGprogram program)</code><br>   */
  private static native void dispatch_cgGLBindProgram1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLUnbindProgram(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  public static void cgGLUnbindProgram(int profile)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLUnbindProgram;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLUnbindProgram"));
    }
        dispatch_cgGLUnbindProgram1(profile, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLUnbindProgram(CGprofile profile)</code><br>
      @param profile valid values are: <code>CG_PROFILE_START, CG_PROFILE_UNKNOWN, CG_PROFILE_VP20, CG_PROFILE_FP20, CG_PROFILE_VP30, CG_PROFILE_FP30, CG_PROFILE_ARBVP1, CG_PROFILE_FP40, CG_PROFILE_ARBFP1, CG_PROFILE_VP40, CG_PROFILE_VS_1_1, CG_PROFILE_VS_2_0, CG_PROFILE_VS_2_X, CG_PROFILE_PS_1_1, CG_PROFILE_PS_1_2, CG_PROFILE_PS_1_3, CG_PROFILE_PS_2_0, CG_PROFILE_PS_2_X, GENERIC, CG_PROFILE_MAX</code>
   */
  static private native void dispatch_cgGLUnbindProgram1(int profile, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>GLuint cgGLGetProgramID(CGprogram program)</code><br>   */
  public static int cgGLGetProgramID(CGprogram program)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetProgramID;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetProgramID"));
    }
        return dispatch_cgGLGetProgramID1(((program == null) ? null : program.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>GLuint cgGLGetProgramID(CGprogram program)</code><br>   */
  private static native int dispatch_cgGLGetProgramID1(ByteBuffer program, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1f(CGparameter param, float x)</code><br>   */
  public static void cgGLSetParameter1f(CGparameter param, float x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1f"));
    }
        dispatch_cgGLSetParameter1f1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1f(CGparameter param, float x)</code><br>   */
  private static native void dispatch_cgGLSetParameter1f1(ByteBuffer param, float x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2f(CGparameter param, float x, float y)</code><br>   */
  public static void cgGLSetParameter2f(CGparameter param, float x, float y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2f"));
    }
        dispatch_cgGLSetParameter2f1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2f(CGparameter param, float x, float y)</code><br>   */
  private static native void dispatch_cgGLSetParameter2f1(ByteBuffer param, float x, float y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3f(CGparameter param, float x, float y, float z)</code><br>   */
  public static void cgGLSetParameter3f(CGparameter param, float x, float y, float z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3f"));
    }
        dispatch_cgGLSetParameter3f1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3f(CGparameter param, float x, float y, float z)</code><br>   */
  private static native void dispatch_cgGLSetParameter3f1(ByteBuffer param, float x, float y, float z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w)</code><br>   */
  public static void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4f"));
    }
        dispatch_cgGLSetParameter4f1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4f(CGparameter param, float x, float y, float z, float w)</code><br>   */
  private static native void dispatch_cgGLSetParameter4f1(ByteBuffer param, float x, float y, float z, float w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter1fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1fv"));
    }
        dispatch_cgGLSetParameter1fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter1fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgGLSetParameter1fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1fv"));
    }
        dispatch_cgGLSetParameter1fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter2fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2fv"));
    }
        dispatch_cgGLSetParameter2fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter2fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgGLSetParameter2fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2fv"));
    }
        dispatch_cgGLSetParameter2fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter3fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3fv"));
    }
        dispatch_cgGLSetParameter3fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter3fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgGLSetParameter3fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3fv"));
    }
        dispatch_cgGLSetParameter3fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameter4fv(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4fv"));
    }
        dispatch_cgGLSetParameter4fv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4fv(CGparameter param, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameter4fv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4fv(CGparameter param, const float *  v)</code><br>   */
  public static void cgGLSetParameter4fv(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4fv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4fv"));
    }
        dispatch_cgGLSetParameter4fv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1d(CGparameter param, double x)</code><br>   */
  public static void cgGLSetParameter1d(CGparameter param, double x)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1d"));
    }
        dispatch_cgGLSetParameter1d1(((param == null) ? null : param.getBuffer()), x, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1d(CGparameter param, double x)</code><br>   */
  private static native void dispatch_cgGLSetParameter1d1(ByteBuffer param, double x, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2d(CGparameter param, double x, double y)</code><br>   */
  public static void cgGLSetParameter2d(CGparameter param, double x, double y)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2d"));
    }
        dispatch_cgGLSetParameter2d1(((param == null) ? null : param.getBuffer()), x, y, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2d(CGparameter param, double x, double y)</code><br>   */
  private static native void dispatch_cgGLSetParameter2d1(ByteBuffer param, double x, double y, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3d(CGparameter param, double x, double y, double z)</code><br>   */
  public static void cgGLSetParameter3d(CGparameter param, double x, double y, double z)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3d"));
    }
        dispatch_cgGLSetParameter3d1(((param == null) ? null : param.getBuffer()), x, y, z, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3d(CGparameter param, double x, double y, double z)</code><br>   */
  private static native void dispatch_cgGLSetParameter3d1(ByteBuffer param, double x, double y, double z, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w)</code><br>   */
  public static void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4d"));
    }
        dispatch_cgGLSetParameter4d1(((param == null) ? null : param.getBuffer()), x, y, z, w, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4d(CGparameter param, double x, double y, double z, double w)</code><br>   */
  private static native void dispatch_cgGLSetParameter4d1(ByteBuffer param, double x, double y, double z, double w, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter1dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1dv"));
    }
        dispatch_cgGLSetParameter1dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter1dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter1dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgGLSetParameter1dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter1dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter1dv"));
    }
        dispatch_cgGLSetParameter1dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter2dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2dv"));
    }
        dispatch_cgGLSetParameter2dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter2dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter2dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgGLSetParameter2dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter2dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter2dv"));
    }
        dispatch_cgGLSetParameter2dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter3dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3dv"));
    }
        dispatch_cgGLSetParameter3dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter3dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter3dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgGLSetParameter3dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter3dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter3dv"));
    }
        dispatch_cgGLSetParameter3dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameter4dv(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4dv"));
    }
        dispatch_cgGLSetParameter4dv1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4dv(CGparameter param, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameter4dv1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameter4dv(CGparameter param, const double *  v)</code><br>   */
  public static void cgGLSetParameter4dv(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameter4dv;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameter4dv"));
    }
        dispatch_cgGLSetParameter4dv1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter1f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter1f"));
    }
        dispatch_cgGLGetParameter1f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter1f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1f(CGparameter param, float *  v)</code><br>   */
  public static void cgGLGetParameter1f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter1f"));
    }
        dispatch_cgGLGetParameter1f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter2f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter2f"));
    }
        dispatch_cgGLGetParameter2f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter2f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2f(CGparameter param, float *  v)</code><br>   */
  public static void cgGLGetParameter2f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter2f"));
    }
        dispatch_cgGLGetParameter2f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter3f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter3f"));
    }
        dispatch_cgGLGetParameter3f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter3f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3f(CGparameter param, float *  v)</code><br>   */
  public static void cgGLGetParameter3f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter3f"));
    }
        dispatch_cgGLGetParameter3f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameter4f(CGparameter param, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter4f"));
    }
        dispatch_cgGLGetParameter4f1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4f(CGparameter param, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameter4f1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4f(CGparameter param, float *  v)</code><br>   */
  public static void cgGLGetParameter4f(CGparameter param, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter4f"));
    }
        dispatch_cgGLGetParameter4f1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter1d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter1d"));
    }
        dispatch_cgGLGetParameter1d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter1d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter1d(CGparameter param, double *  v)</code><br>   */
  public static void cgGLGetParameter1d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter1d"));
    }
        dispatch_cgGLGetParameter1d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter2d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter2d"));
    }
        dispatch_cgGLGetParameter2d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter2d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter2d(CGparameter param, double *  v)</code><br>   */
  public static void cgGLGetParameter2d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter2d"));
    }
        dispatch_cgGLGetParameter2d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter3d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter3d"));
    }
        dispatch_cgGLGetParameter3d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter3d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter3d(CGparameter param, double *  v)</code><br>   */
  public static void cgGLGetParameter3d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter3d"));
    }
        dispatch_cgGLGetParameter3d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameter4d(CGparameter param, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter4d"));
    }
        dispatch_cgGLGetParameter4d1(((param == null) ? null : param.getBuffer()), v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4d(CGparameter param, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameter4d1(ByteBuffer param, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameter4d(CGparameter param, double *  v)</code><br>   */
  public static void cgGLGetParameter4d(CGparameter param, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameter4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameter4d"));
    }
        dispatch_cgGLGetParameter4d1(((param == null) ? null : param.getBuffer()), v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray1f"));
    }
        dispatch_cgGLSetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray1f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, const float *  v)</code><br>   */
  public static void cgGLSetParameterArray1f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray1f"));
    }
        dispatch_cgGLSetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray2f"));
    }
        dispatch_cgGLSetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray2f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, const float *  v)</code><br>   */
  public static void cgGLSetParameterArray2f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray2f"));
    }
        dispatch_cgGLSetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray3f"));
    }
        dispatch_cgGLSetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray3f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, const float *  v)</code><br>   */
  public static void cgGLSetParameterArray3f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray3f"));
    }
        dispatch_cgGLSetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray4f"));
    }
        dispatch_cgGLSetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetParameterArray4f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, const float *  v)</code><br>   */
  public static void cgGLSetParameterArray4f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray4f"));
    }
        dispatch_cgGLSetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray1d"));
    }
        dispatch_cgGLSetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray1d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, const double *  v)</code><br>   */
  public static void cgGLSetParameterArray1d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray1d"));
    }
        dispatch_cgGLSetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray2d"));
    }
        dispatch_cgGLSetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray2d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, const double *  v)</code><br>   */
  public static void cgGLSetParameterArray2d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray2d"));
    }
        dispatch_cgGLSetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray3d"));
    }
        dispatch_cgGLSetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray3d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, const double *  v)</code><br>   */
  public static void cgGLSetParameterArray3d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray3d"));
    }
        dispatch_cgGLSetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray4d"));
    }
        dispatch_cgGLSetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetParameterArray4d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, const double *  v)</code><br>   */
  public static void cgGLSetParameterArray4d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterArray4d"));
    }
        dispatch_cgGLSetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray1f"));
    }
        dispatch_cgGLGetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray1f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float *  v)</code><br>   */
  public static void cgGLGetParameterArray1f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray1f"));
    }
        dispatch_cgGLGetParameterArray1f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray2f"));
    }
        dispatch_cgGLGetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray2f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float *  v)</code><br>   */
  public static void cgGLGetParameterArray2f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray2f"));
    }
        dispatch_cgGLGetParameterArray2f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray3f"));
    }
        dispatch_cgGLGetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray3f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float *  v)</code><br>   */
  public static void cgGLGetParameterArray3f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray3f"));
    }
        dispatch_cgGLGetParameterArray3f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray4f"));
    }
        dispatch_cgGLGetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetParameterArray4f1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float *  v)</code><br>   */
  public static void cgGLGetParameterArray4f(CGparameter param, long offset, long nelements, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4f;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray4f"));
    }
        dispatch_cgGLGetParameterArray4f1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray1d"));
    }
        dispatch_cgGLGetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray1d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double *  v)</code><br>   */
  public static void cgGLGetParameterArray1d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray1d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray1d"));
    }
        dispatch_cgGLGetParameterArray1d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray2d"));
    }
        dispatch_cgGLGetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray2d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double *  v)</code><br>   */
  public static void cgGLGetParameterArray2d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray2d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray2d"));
    }
        dispatch_cgGLGetParameterArray2d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray3d"));
    }
        dispatch_cgGLGetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray3d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double *  v)</code><br>   */
  public static void cgGLGetParameterArray3d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray3d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray3d"));
    }
        dispatch_cgGLGetParameterArray3d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, DoubleBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray4d"));
    }
        dispatch_cgGLGetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v)</code><br>
      @param v a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetParameterArray4d1(ByteBuffer param, long offset, long nelements, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double *  v)</code><br>   */
  public static void cgGLGetParameterArray4d(CGparameter param, long offset, long nelements, double[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new CgException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetParameterArray4d;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetParameterArray4d"));
    }
        dispatch_cgGLGetParameterArray4d1(((param == null) ? null : param.getBuffer()), offset, nelements, v, Buffers.SIZEOF_DOUBLE * v_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterPointer(CGparameter param, GLint fsize, GLenum type, GLsizei stride, const GLvoid *  pointer)</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public static void cgGLSetParameterPointer(CGparameter param, int fsize, int type, int stride, Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new CgException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetParameterPointer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetParameterPointer"));
    }
        dispatch_cgGLSetParameterPointer0(((param == null) ? null : param.getBuffer()), fsize, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetParameterPointer(CGparameter param, GLint fsize, GLenum type, GLsizei stride, const GLvoid *  pointer)</code><br>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private static native void dispatch_cgGLSetParameterPointer0(ByteBuffer param, int fsize, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableClientState(CGparameter param)</code><br>   */
  public static void cgGLEnableClientState(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableClientState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLEnableClientState"));
    }
        dispatch_cgGLEnableClientState1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableClientState(CGparameter param)</code><br>   */
  private static native void dispatch_cgGLEnableClientState1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableClientState(CGparameter param)</code><br>   */
  public static void cgGLDisableClientState(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableClientState;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLDisableClientState"));
    }
        dispatch_cgGLDisableClientState1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableClientState(CGparameter param)</code><br>   */
  private static native void dispatch_cgGLDisableClientState1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterdr"));
    }
        dispatch_cgGLSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdr(CGparameter param, const double *  matrix)</code><br>   */
  public static void cgGLSetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterdr"));
    }
        dispatch_cgGLSetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterfr"));
    }
        dispatch_cgGLSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfr(CGparameter param, const float *  matrix)</code><br>   */
  public static void cgGLSetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterfr"));
    }
        dispatch_cgGLSetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterdc"));
    }
        dispatch_cgGLSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterdc(CGparameter param, const double *  matrix)</code><br>   */
  public static void cgGLSetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterdc"));
    }
        dispatch_cgGLSetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterfc"));
    }
        dispatch_cgGLSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterfc(CGparameter param, const float *  matrix)</code><br>   */
  public static void cgGLSetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterfc"));
    }
        dispatch_cgGLSetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterdr(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterdr"));
    }
        dispatch_cgGLGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterdr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdr(CGparameter param, double *  matrix)</code><br>   */
  public static void cgGLGetMatrixParameterdr(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterdr"));
    }
        dispatch_cgGLGetMatrixParameterdr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterfr(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterfr"));
    }
        dispatch_cgGLGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterfr1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfr(CGparameter param, float *  matrix)</code><br>   */
  public static void cgGLGetMatrixParameterfr(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterfr"));
    }
        dispatch_cgGLGetMatrixParameterfr1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterdc(CGparameter param, DoubleBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterdc"));
    }
        dispatch_cgGLGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterdc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterdc(CGparameter param, double *  matrix)</code><br>   */
  public static void cgGLGetMatrixParameterdc(CGparameter param, double[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterdc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterdc"));
    }
        dispatch_cgGLGetMatrixParameterdc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_DOUBLE * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterfc(CGparameter param, FloatBuffer matrix)  {

    final boolean matrix_is_direct = Buffers.isDirect(matrix);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterfc"));
    }
        dispatch_cgGLGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix_is_direct ? matrix : Buffers.getArray(matrix), matrix_is_direct ? Buffers.getDirectBufferByteOffset(matrix) : Buffers.getIndirectBufferByteOffset(matrix), matrix_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>
      @param matrix a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterfc1(ByteBuffer param, Object matrix, int matrix_byte_offset, boolean matrix_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterfc(CGparameter param, float *  matrix)</code><br>   */
  public static void cgGLGetMatrixParameterfc(CGparameter param, float[] matrix, int matrix_offset)  {

    if(matrix != null && matrix.length <= matrix_offset)
      throw new CgException("array offset argument \"matrix_offset\" (" + matrix_offset + ") equals or exceeds array length (" + matrix.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterfc"));
    }
        dispatch_cgGLGetMatrixParameterfc1(((param == null) ? null : param.getBuffer()), matrix, Buffers.SIZEOF_FLOAT * matrix_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetStateMatrixParameter(CGparameter param, CGGLenum matrix, CGGLenum transform)</code><br>
      @param matrix valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>

      @param transform valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  public static void cgGLSetStateMatrixParameter(CGparameter param, int matrix, int transform)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetStateMatrixParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetStateMatrixParameter"));
    }
        dispatch_cgGLSetStateMatrixParameter1(((param == null) ? null : param.getBuffer()), matrix, transform, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetStateMatrixParameter(CGparameter param, CGGLenum matrix, CGGLenum transform)</code><br>
      @param matrix valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>

      @param transform valid values are: <code>CG_GL_MATRIX_IDENTITY, CG_GL_MATRIX_TRANSPOSE, CG_GL_MATRIX_INVERSE, CG_GL_MATRIX_INVERSE_TRANSPOSE, CG_GL_MODELVIEW_MATRIX, CG_GL_PROJECTION_MATRIX, CG_GL_TEXTURE_MATRIX, CG_GL_MODELVIEW_PROJECTION_MATRIX, CG_GL_VERTEX, CG_GL_FRAGMENT</code>
   */
  private static native void dispatch_cgGLSetStateMatrixParameter1(ByteBuffer param, int matrix, int transform, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArrayfc"));
    }
        dispatch_cgGLSetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArrayfc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>   */
  public static void cgGLSetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArrayfc"));
    }
        dispatch_cgGLSetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArrayfr"));
    }
        dispatch_cgGLSetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArrayfr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, const float *  matrices)</code><br>   */
  public static void cgGLSetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArrayfr"));
    }
        dispatch_cgGLSetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArraydc"));
    }
        dispatch_cgGLSetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArraydc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>   */
  public static void cgGLSetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArraydc"));
    }
        dispatch_cgGLSetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArraydr"));
    }
        dispatch_cgGLSetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLSetMatrixParameterArraydr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, const double *  matrices)</code><br>   */
  public static void cgGLSetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLSetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetMatrixParameterArraydr"));
    }
        dispatch_cgGLSetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArrayfc"));
    }
        dispatch_cgGLGetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArrayfc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float *  matrices)</code><br>   */
  public static void cgGLGetMatrixParameterArrayfc(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArrayfc"));
    }
        dispatch_cgGLGetMatrixParameterArrayfc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  public static void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, FloatBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArrayfr"));
    }
        dispatch_cgGLGetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.FloatBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArrayfr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float *  matrices)</code><br>   */
  public static void cgGLGetMatrixParameterArrayfr(CGparameter param, long offset, long nelements, float[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArrayfr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArrayfr"));
    }
        dispatch_cgGLGetMatrixParameterArrayfr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_FLOAT * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArraydc"));
    }
        dispatch_cgGLGetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArraydc1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double *  matrices)</code><br>   */
  public static void cgGLGetMatrixParameterArraydc(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydc;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArraydc"));
    }
        dispatch_cgGLGetMatrixParameterArraydc1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  public static void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, DoubleBuffer matrices)  {

    final boolean matrices_is_direct = Buffers.isDirect(matrices);
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArraydr"));
    }
        dispatch_cgGLGetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices_is_direct ? matrices : Buffers.getArray(matrices), matrices_is_direct ? Buffers.getDirectBufferByteOffset(matrices) : Buffers.getIndirectBufferByteOffset(matrices), matrices_is_direct, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices)</code><br>
      @param matrices a direct or array-backed {@link java.nio.DoubleBuffer}   */
  private static native void dispatch_cgGLGetMatrixParameterArraydr1(ByteBuffer param, long offset, long nelements, Object matrices, int matrices_byte_offset, boolean matrices_is_direct, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double *  matrices)</code><br>   */
  public static void cgGLGetMatrixParameterArraydr(CGparameter param, long offset, long nelements, double[] matrices, int matrices_offset)  {

    if(matrices != null && matrices.length <= matrices_offset)
      throw new CgException("array offset argument \"matrices_offset\" (" + matrices_offset + ") equals or exceeds array length (" + matrices.length + ")");
    final long __addr_ = cgProcAddressTable._addressof_cgGLGetMatrixParameterArraydr;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetMatrixParameterArraydr"));
    }
        dispatch_cgGLGetMatrixParameterArraydr1(((param == null) ? null : param.getBuffer()), offset, nelements, matrices, Buffers.SIZEOF_DOUBLE * matrices_offset, false, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetTextureParameter(CGparameter param, GLuint texobj)</code><br>   */
  public static void cgGLSetTextureParameter(CGparameter param, int texobj)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetTextureParameter"));
    }
        dispatch_cgGLSetTextureParameter1(((param == null) ? null : param.getBuffer()), texobj, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetTextureParameter(CGparameter param, GLuint texobj)</code><br>   */
  private static native void dispatch_cgGLSetTextureParameter1(ByteBuffer param, int texobj, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>GLuint cgGLGetTextureParameter(CGparameter param)</code><br>   */
  public static int cgGLGetTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetTextureParameter"));
    }
        return dispatch_cgGLGetTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>GLuint cgGLGetTextureParameter(CGparameter param)</code><br>   */
  private static native int dispatch_cgGLGetTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableTextureParameter(CGparameter param)</code><br>   */
  public static void cgGLEnableTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLEnableTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLEnableTextureParameter"));
    }
        dispatch_cgGLEnableTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLEnableTextureParameter(CGparameter param)</code><br>   */
  private static native void dispatch_cgGLEnableTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableTextureParameter(CGparameter param)</code><br>   */
  public static void cgGLDisableTextureParameter(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLDisableTextureParameter;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLDisableTextureParameter"));
    }
        dispatch_cgGLDisableTextureParameter1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLDisableTextureParameter(CGparameter param)</code><br>   */
  private static native void dispatch_cgGLDisableTextureParameter1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>GLenum cgGLGetTextureEnum(CGparameter param)</code><br>   */
  public static int cgGLGetTextureEnum(CGparameter param)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetTextureEnum;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetTextureEnum"));
    }
        return dispatch_cgGLGetTextureEnum1(((param == null) ? null : param.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>GLenum cgGLGetTextureEnum(CGparameter param)</code><br>   */
  private static native int dispatch_cgGLGetTextureEnum1(ByteBuffer param, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetManageTextureParameters(CGcontext ctx, CGbool flag)</code><br>   */
  public static void cgGLSetManageTextureParameters(CGcontext ctx, boolean flag)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetManageTextureParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetManageTextureParameters"));
    }
        dispatch_cgGLSetManageTextureParameters1(((ctx == null) ? null : ctx.getBuffer()), flag, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetManageTextureParameters(CGcontext ctx, CGbool flag)</code><br>   */
  private static native void dispatch_cgGLSetManageTextureParameters1(ByteBuffer ctx, boolean flag, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLGetManageTextureParameters(CGcontext ctx)</code><br>   */
  public static boolean cgGLGetManageTextureParameters(CGcontext ctx)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLGetManageTextureParameters;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLGetManageTextureParameters"));
    }
        return dispatch_cgGLGetManageTextureParameters1(((ctx == null) ? null : ctx.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>CGbool cgGLGetManageTextureParameters(CGcontext ctx)</code><br>   */
  private static native boolean dispatch_cgGLGetManageTextureParameters1(ByteBuffer ctx, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetupSampler(CGparameter param, GLuint texobj)</code><br>   */
  public static void cgGLSetupSampler(CGparameter param, int texobj)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLSetupSampler;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLSetupSampler"));
    }
        dispatch_cgGLSetupSampler1(((param == null) ? null : param.getBuffer()), texobj, __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLSetupSampler(CGparameter param, GLuint texobj)</code><br>   */
  private static native void dispatch_cgGLSetupSampler1(ByteBuffer param, int texobj, long procAddress);

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLRegisterStates(CGcontext)</code><br>   */
  public static void cgGLRegisterStates(CGcontext arg0)  {

    final long __addr_ = cgProcAddressTable._addressof_cgGLRegisterStates;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "cgGLRegisterStates"));
    }
        dispatch_cgGLRegisterStates1(((arg0 == null) ? null : arg0.getBuffer()), __addr_);
  }

  /** Entry point (through function pointer) to C language function: <br> <code>void cgGLRegisterStates(CGcontext)</code><br>   */
  private static native void dispatch_cgGLRegisterStates1(ByteBuffer arg0, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static final DynamicLibraryBundle cgDynamicLookupHelper;
  private static final CgProcAddressTable cgProcAddressTable;
  
  static {
      cgProcAddressTable = new CgProcAddressTable();
      if(null==cgProcAddressTable) {
        throw new RuntimeException("Couldn't instantiate CgProcAddressTable");
      }
  
      cgDynamicLookupHelper = AccessController.doPrivileged(new PrivilegedAction<DynamicLibraryBundle>() {
                                  public DynamicLibraryBundle run() {
                                      return new DynamicLibraryBundle(new CgDynamicLibraryBundleInfo());
                                  } } );
      if(null==cgDynamicLookupHelper) {
        throw new RuntimeException("Null CgDynamicLookupHelper");
      }
      if(!cgDynamicLookupHelper.isToolLibLoaded()) {
        throw new RuntimeException("Couln't load native Cg or CgGL library");
      }
      if(!cgDynamicLookupHelper.isGlueLibLoaded(CgDynamicLibraryBundleInfo.getCgGlueLibIndex())) {
        throw new RuntimeException("Couln't load native GLue/JNI library");
      }
      cgProcAddressTable.reset(cgDynamicLookupHelper);
  }
  
  public  static CgProcAddressTable getCgProcAddressTable() { return cgProcAddressTable; }
  
  /** A convenience method which reads all available data from the InputStream and then calls cgCreateProgram. */
  public static CGprogram cgCreateProgramFromStream(CGcontext ctx, int program_type, java.io.InputStream stream, int profile, java.lang.String entry, java.lang.String[] args) throws java.io.IOException {
    if (stream == null) {
      throw new java.io.IOException("null stream");
    }
    stream = new java.io.BufferedInputStream(stream);
    int avail = stream.available();
    byte[] data = new byte[avail];
    int numRead = 0;
    int pos = 0;
    do {
      if (pos + avail > data.length) {
        byte[] newData = new byte[pos + avail];
        System.arraycopy(data, 0, newData, 0, pos);
        data = newData;
      }
      numRead = stream.read(data, pos, avail);
      if (numRead >= 0) {
        pos += numRead;
      }
      avail = stream.available();
    } while (avail > 0 && numRead >= 0);
    String program = new String(data, 0, pos, "US-ASCII");
    return cgCreateProgram(ctx, program_type, program, profile, entry, args);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class CgGL
