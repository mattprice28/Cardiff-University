/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/procaddress/ProcAddressEmitter.java on Sat Oct 10 04:58:01 CEST 2015 ----! */

#include <jni.h>
#include <stdlib.h>
#include <string.h>

#include <assert.h>
#include <stddef.h>

static jobject JVMUtil_NewDirectByteBufferCopy(JNIEnv *env, void * source_address, size_t capacity); /* forward decl. */

 #include <inttypes.h>
 #include <GL/glcorearb.h>
 #include <CL/cl.h>
 #include <CL/cl_ext.h>
 #include <CL/cl_gl.h>
  /*
  void checkStatus(const char* msg, int status) {
      if (status != CL_SUCCESS) {
          printf("%s; error: %d \n", msg, status);
          exit(EXIT_FAILURE);
      }
  }
  */
  
  JavaVM * jvm;
  
  jmethodID buildCB_mid;
  jmethodID contextCB_mid;
  jmethodID eventCB_mid;
  jmethodID memObjCB_mid;
  
  
  JNIEXPORT jint JNICALL
  JNI_OnLoad(JavaVM * _jvm, void *reserved) {
  
      JNIEnv *env;
      jvm = _jvm;
  
      if ((*jvm)->GetEnv(_jvm, (void **)&env, JNI_VERSION_1_2)) {
          return JNI_ERR;
      }
  
      // throws ClassNotFoundException (or other reflection stuff)
      jclass buildCBClassID      = (*env)->FindClass(env, "com/jogamp/opencl/llb/impl/BuildProgramCallback");
      jclass errorHandlerClassID = (*env)->FindClass(env, "com/jogamp/opencl/CLErrorHandler");
      jclass eventCBClassID      = (*env)->FindClass(env, "com/jogamp/opencl/llb/impl/CLEventCallback");
      jclass memObjCBClassID     = (*env)->FindClass(env, "com/jogamp/opencl/llb/impl/CLMemObjectDestructorCallback");
  
      // throws even more reflection Exceptions
      // IDs are unique and do not change
      if (buildCBClassID != NULL) {
          buildCB_mid   = (*env)->GetMethodID(env, buildCBClassID, "buildFinished", "(J)V");
      }
      if (errorHandlerClassID != NULL) {
          contextCB_mid = (*env)->GetMethodID(env, errorHandlerClassID, "onError", "(Ljava/lang/String;Ljava/nio/ByteBuffer;J)V");
      }
      if (eventCBClassID != NULL) {
          eventCB_mid = (*env)->GetMethodID(env, eventCBClassID, "eventStateChanged", "(JI)V");
      }
      if (memObjCBClassID != NULL) {
          memObjCB_mid = (*env)->GetMethodID(env, memObjCBClassID, "memoryDeallocated", "(J)V");
      }
  
      return JNI_VERSION_1_2;
  }
  
  
  // callbacks
  typedef void (CL_CALLBACK * cccallback)(const char *, const void *, size_t, void *);
  typedef void (CL_CALLBACK * bpcallback)(cl_program, void *);
  typedef void (CL_CALLBACK * evcallback)(cl_event, cl_int, void *);
  typedef void (CL_CALLBACK * mocallback)(cl_mem, void *);
  
  CL_CALLBACK void buildProgramCallback(cl_program id, void * object) {
  
      JNIEnv *env;
      jobject obj = (jobject)object;
  
      (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
  
          (*env)->CallVoidMethod(env, obj, buildCB_mid, (jlong)(intptr_t)id);
          (*env)->DeleteGlobalRef(env, obj);
  
      (*jvm)->DetachCurrentThread(jvm);
  
  }
  
  CL_CALLBACK void createContextCallback(const char * errinfo, const void * private_info, size_t cb, void * object) {
  
      JNIEnv *env;
      jobject obj = (jobject)object;
  
      (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
  
          jstring errorString = (*env)->NewStringUTF(env, errinfo);
  
          //TODO private_info
          (*env)->CallVoidMethod(env, obj, contextCB_mid, errorString, NULL, 0);
  
      (*jvm)->DetachCurrentThread(jvm);
  
  }
  
  CL_CALLBACK void eventCallback(cl_event event, cl_int status, void * object) {
  
      JNIEnv *env;
      jobject obj = (jobject)object;
  
      (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
  
          (*env)->CallVoidMethod(env, obj, eventCB_mid, event, status);
          (*env)->DeleteGlobalRef(env, obj); // events can only fire once
  
      (*jvm)->DetachCurrentThread(jvm);
  }
  
  CL_CALLBACK void memObjDestructorCallback(cl_mem mem, void * object) {
  
      JNIEnv *env;
      jobject obj = (jobject)object;
  
      (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);
      
          (*env)->CallVoidMethod(env, obj, memObjCB_mid, mem);
          (*env)->DeleteGlobalRef(env, obj);
  
      (*jvm)->DetachCurrentThread(jvm);
  }
  
  // extern CL_API_ENTRY void * CL_API_CALL clGetExtensionFunctionAddress(const char * /* func_name */) CL_API_SUFFIX__VERSION_1_0;
  
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetExtensionFunctionAddressStatic(JNIEnv *env, jclass _unused, jstring fname, jlong procAddress) {
    typedef void* (CL_API_CALL * _local_LPCLGETPROCADDRESS)(const char *  fname);
    _local_LPCLGETPROCADDRESS ptr_clGetExtensionFunctionAddress;
    const char* _strchars_fname = NULL;
    void* _res;
    if ( NULL != fname ) {
      _strchars_fname = (*env)->GetStringUTFChars(env, fname, (jboolean*)NULL);
    if ( NULL == _strchars_fname ) {
        (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                         "Failed to get UTF-8 chars for argument \"fname\" in native dispatcher for \"dispatch_clGetExtensionFunctionAddress\"");
        return 0;
      }
    }
    ptr_clGetExtensionFunctionAddress = (_local_LPCLGETPROCADDRESS) (intptr_t) procAddress;
    assert(ptr_clGetExtensionFunctionAddress != NULL);
    _res = (* ptr_clGetExtensionFunctionAddress) (_strchars_fname);
    if ( NULL != fname ) {
      (*env)->ReleaseStringUTFChars(env, fname, _strchars_fname);
    }
    return (jlong) (intptr_t) _res;
  }
  
  /*   Java->C glue code:
   *   Java package: com.jogamp.opencl.impl.CLImpl
   *    Java method: long clCreateContextFromType(java.nio.IntBuffer props, long device_type, CreateContextCallback pfn_notify, Object userData, IntBuffer errcode_ret)
   *     C function: cl_context clCreateContextFromType(  const cl_context_properties *  properties ,
   *                                                      cl_device_type                 device_type ,
   *                                                      void (CL_CALLBACK *      pfn_notify )(const char *, const void *, size_t, void *),
   *                                                      void *                         user_data ,
   *                                                      cl_int *                       errcode_ret);
   */
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clCreateContextFromType0(JNIEnv *env, jobject _unused,
          jobject props, jint props_byte_offset, jlong device_type, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress) {
  
      cl_context_properties* _props_ptr  = NULL;
      cl_int * _errcode_ptr = NULL;
      cl_context _ctx = NULL;
      cccallback _pfn_notify = NULL;
      jobject globalCB = NULL;
  
      typedef cl_context (*function)(const cl_context_properties *, cl_device_type, void (*pfn_notify)(const char *, const void *, size_t, void *), void *, cl_int *);
      function clCreateContextFromType = (function)(intptr_t) procAddress;
  
      if (props != NULL) {
          _props_ptr = (cl_context_properties*) (((char*) (*env)->GetDirectBufferAddress(env, props)) + props_byte_offset);
      }
  
      if (errcode != NULL) {
          _errcode_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, errcode)) + errcode_byte_offset);
      }
  
      if (cb != NULL) {
          _pfn_notify = &createContextCallback;
          globalCB = (*env)->NewGlobalRef(env, cb);
      }
  
      _ctx = (*clCreateContextFromType)(_props_ptr, (uint64_t) device_type, _pfn_notify, globalCB, _errcode_ptr);
  
      if(globalCB != NULL) {
          jlong *g = (*env)->GetPrimitiveArrayCritical(env, global, NULL);
          // if something went wrong
          if(_ctx == NULL) {
              g[0] = 0;
              (*env)->DeleteGlobalRef(env, globalCB);
          }else{
              g[0] = (jlong)globalCB;
          }
          (*env)->ReleasePrimitiveArrayCritical(env, global, g, 0);
      }
  
      return (jlong) (intptr_t)_ctx;
  }
  
  /*
   * Entry point to C language function:
   *extern CL_API_ENTRY cl_context CL_API_CALL
   *clCreateContext(cl_context_properties *    properties   ,
   *                cl_uint                    num_devices   ,
   *                const cl_device_id *       devices   ,
   *                void (*pfn_notify)(const char *, const void *, size_t, void *)  pfn_notify ,
   *                void *                     user_data   ,
   *                cl_int *                   errcode_ret   ) CL_API_SUFFIX__VERSION_1_0;
   */
  JNIEXPORT jlong JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clCreateContext0(JNIEnv *env, jobject _unused,
          jobject props, jint props_byte_offset, jint numDevices, jobject deviceList, jint device_type_offset, jobject cb, jobject global, jobject errcode, jint errcode_byte_offset, jlong procAddress) {
  
      cl_context_properties* _props_ptr  = NULL;
      cl_int * _errcode_ptr = NULL;
      cl_device_id * _deviceListPtr = NULL;
      cl_context _ctx = NULL;
      cccallback _pfn_notify = NULL;
      jobject globalCB = NULL;
  
      typedef cl_context (CL_API_CALL * function)(cl_context_properties *, cl_uint, const cl_device_id *, void (*pfn_notify)(const char *, const void *, size_t, void *), void *, cl_int *);
      function clCreateContext = (function)(intptr_t) procAddress;
  
      if (props != NULL) {
          _props_ptr = (cl_context_properties*) (((char*) (*env)->GetDirectBufferAddress(env, props)) + props_byte_offset);
      }
      if (deviceList != NULL) {
          _deviceListPtr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, deviceList)) + device_type_offset);
      }
      if (errcode != NULL) {
          _errcode_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, errcode)) + errcode_byte_offset);
      }
  
      if (cb != NULL) {
          _pfn_notify = &createContextCallback;
          globalCB = (*env)->NewGlobalRef(env, cb);
      }
  
      _ctx = (*clCreateContext)(_props_ptr, numDevices, _deviceListPtr, _pfn_notify, globalCB, _errcode_ptr);
  
      if(globalCB != NULL) {
          jlong *g = (*env)->GetPrimitiveArrayCritical(env, global, NULL);
          // if something went wrong
          if(_ctx == NULL) {
              g[0] = 0;
              (*env)->DeleteGlobalRef(env, globalCB);
          }else{
              g[0] = (jlong)globalCB;
          }
          (*env)->ReleasePrimitiveArrayCritical(env, global, g, 0);
      }
  
      return (jlong) (intptr_t)_ctx;
  }
  
  /*   Java->C glue code:
   *   Java package: com.jogamp.opencl.impl.CLImpl
   *    Java method: int clReleaseContextImpl(long context)
   *     C function: int32_t clReleaseContextImpl(cl_context context);
   */
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clReleaseContextImpl(JNIEnv *env, jobject _unused, jlong context, jlong global, jlong procAddress) {
  
      int32_t _res;
      typedef int32_t (*function)(cl_context);
      function clReleaseContext = (function)(intptr_t) procAddress;
  
      _res = (*clReleaseContext)((cl_context) (intptr_t) context);
      // TODO deal with retains
      if (global != 0) {
          (*env)->DeleteGlobalRef(env, (jobject) global);
      }
      return _res;
  }
  
  
  /**
   * Entry point to C language function:
   * extern CL_API_ENTRY cl_int CL_API_CALL
   *clBuildProgram(cl_program              program   ,
   *               cl_uint                 num_devices   ,
   *               const cl_device_id *    device_list   ,
   *               const char *            options   ,
   *               void (*pfn_notify)(cl_program    program   , void *    user_data   ),
   *               void *                  user_data   ) CL_API_SUFFIX__VERSION_1_0;
   */
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clBuildProgram0(JNIEnv *env, jobject _unused,
          jlong program, jint deviceCount, jobject deviceList, jint device_type_offset, jstring options, jobject cb, jlong procAddress) {
  
      const char* _strchars_options = NULL;
      cl_int _res;
      cl_device_id * _deviceListPtr = NULL;
      bpcallback _pfn_notify = NULL;
      jobject globalCB = NULL;
  
      typedef cl_int (CL_API_CALL * function)(cl_program, cl_uint, const cl_device_id *, const char *, void (CL_CALLBACK *)(cl_program, void *), void *);
      function clBuildProgram = (function)(intptr_t)procAddress;
  
      if (options != NULL) {
          _strchars_options = (*env)->GetStringUTFChars(env, options, (jboolean*)NULL);
          if (_strchars_options == NULL) {
              (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                             "Failed to get UTF-8 chars for argument \"options\" in native dispatcher for \"clBuildProgram\"");
              return CL_FALSE;
          }
      }
  
      if (deviceList != NULL) {
          _deviceListPtr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, deviceList)) + device_type_offset);
      }
  
      if (cb != NULL) {
          _pfn_notify = &buildProgramCallback;
          globalCB = (*env)->NewGlobalRef(env, cb);
      }
  
      _res = (*clBuildProgram)((cl_program)(intptr_t)program, (cl_uint)deviceCount, (cl_device_id *)_deviceListPtr, _strchars_options, _pfn_notify, globalCB);
  
      // if something went wrong
      if(_res != CL_SUCCESS && globalCB != NULL) {
          (*env)->DeleteGlobalRef(env, globalCB);
      }
  
      if (options != NULL) {
          (*env)->ReleaseStringUTFChars(env, options, _strchars_options);
      }
  
      return (jint)_res;
  }
  
  /*   Java->C glue code:
   *   Java package: com.jogamp.opencl.impl.CLImpl
   *    Java method: java.nio.ByteBuffer clEnqueueMapImage(long command_queue, long image, int blocking_map, long map_flags, com.jogamp.gluegen.common.nio.PointerBuffer origin, com.jogamp.gluegen.common.nio.PointerBuffer range, com.jogamp.gluegen.common.nio.PointerBuffer image_row_pitch, com.jogamp.gluegen.common.nio.PointerBuffer image_slice_pitch, int num_events_in_wait_list, com.jogamp.gluegen.common.nio.PointerBuffer event_wait_list, com.jogamp.gluegen.common.nio.PointerBuffer event, java.nio.IntBuffer errcode_ret)
   *     C function: void *  clEnqueueMapImage(cl_command_queue command_queue, cl_mem image, uint32_t blocking_map, uint64_t map_flags, const size_t * , const size_t * , size_t *  image_row_pitch, size_t *  image_slice_pitch, uint32_t num_events_in_wait_list, cl_event *  event_wait_list, cl_event *  event, int32_t *  errcode_ret);
   */
  JNIEXPORT jobject JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clEnqueueMapImage0__JJIJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2I(JNIEnv *env, jobject _unused,
          jlong command_queue, jlong image, jint blocking_map, jlong map_flags,
          jobject origin, jint origin_byte_offset, jobject range, jint range_byte_offset,
          jobject image_row_pitch, jint image_row_pitch_byte_offset, jobject image_slice_pitch,
          jint image_slice_pitch_byte_offset, jint num_events_in_wait_list, jobject event_wait_list,
          jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset,
          jlong imageInfoAddress, jlong mapImageAddress) {
  
      size_t * _origin_ptr = NULL;
      size_t * _range_ptr = NULL;
      size_t * _image_row_pitch_ptr = NULL;
      size_t * _image_slice_pitch_ptr = NULL;
      cl_event * _event_wait_list_ptr = NULL;
      cl_event * _event_ptr = NULL;
      int32_t * _errcode_ret_ptr = NULL;
      size_t * elements = NULL;
      size_t * depth = NULL;
      size_t pixels;
      cl_int status;
  
      typedef int32_t (*imageInfoFunctionType)(cl_mem, uint32_t, size_t, void *, size_t *);
      imageInfoFunctionType clGetImageInfo = (imageInfoFunctionType)(intptr_t)imageInfoAddress;
  
      typedef void* (*mapInfoFunctionType)(cl_command_queue, cl_mem, uint32_t, uint64_t, const size_t *,
                  const size_t *, size_t *, size_t *, uint32_t, cl_event *, cl_event *, int32_t *);
      mapInfoFunctionType clEnqueueMapImage = (mapInfoFunctionType)(intptr_t)mapImageAddress;
  
      void * _res;
  
      if (origin != NULL) {
          _origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, origin)) + origin_byte_offset);
      }
      if (range != NULL) {
          _range_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, range)) + range_byte_offset);
      }
      if (image_row_pitch != NULL) {
          _image_row_pitch_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, image_row_pitch)) + image_row_pitch_byte_offset);
      }
      if (image_slice_pitch != NULL) {
          _image_slice_pitch_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, image_slice_pitch)) + image_slice_pitch_byte_offset);
      }
      if (event_wait_list != NULL) {
          _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
      }
      if (event != NULL) {
          _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
      }
      if (errcode_ret != NULL) {
          _errcode_ret_ptr = (int32_t *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
      }
  
      _res = (*clEnqueueMapImage)((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image,
                 (uint32_t) blocking_map, (uint64_t) map_flags, (size_t *) _origin_ptr, (size_t *) _range_ptr,
                 (size_t *) _image_row_pitch_ptr, (size_t *) _image_slice_pitch_ptr, (uint32_t) num_events_in_wait_list,
                 (cl_event *) _event_wait_list_ptr, (cl_event *) _event_ptr, (int32_t *) _errcode_ret_ptr);
      if (_res == NULL) return NULL;
  
      // calculate buffer size
      status  = (*clGetImageInfo)((cl_mem) (intptr_t) image, CL_IMAGE_ELEMENT_SIZE, sizeof(size_t), (void *) elements, NULL);
      status |= (*clGetImageInfo)((cl_mem) (intptr_t) image, CL_IMAGE_DEPTH, sizeof(size_t), (void *) depth, NULL);
  
      if(status != CL_SUCCESS) {
          return NULL;
      }
  
      if(*depth == 0) { // 2D
          pixels = (*_image_row_pitch_ptr)   * _range_ptr[1] + _range_ptr[0];
      }else{            // 3D
          pixels = (*_image_slice_pitch_ptr) * _range_ptr[2]
                 + (*_image_row_pitch_ptr)   * _range_ptr[1] + _range_ptr[0];
      }
  
    return (*env)->NewDirectByteBuffer(env, _res, pixels * (*elements));
  
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clSetEventCallback0(JNIEnv *env, jobject _unused,
          jlong event, jint trigger, jobject listener, jlong procAddress) {
  
      cl_event _event = (cl_event)event;
      cl_int _trigger = trigger;
      cl_int _res;
      typedef int32_t (*function)(cl_event, cl_int, void (*pfn_event_notify) (cl_event, cl_int, void *), void *);
      function clSetEventCallback = (function)(intptr_t) procAddress;
  
      jobject cb = (*env)->NewGlobalRef(env, listener);
      _res = (*clSetEventCallback)(_event, _trigger, &eventCallback, cb);
  
      return _res;
  }
  
  JNIEXPORT jint JNICALL
  Java_com_jogamp_opencl_llb_impl_CLImpl_clSetMemObjectDestructorCallback0(JNIEnv *env, jobject _unused,
          jlong mem, jobject listener, jlong procAddress) {
  
      cl_mem _mem = (cl_mem)mem;
      cl_int _res;
      typedef int32_t (*function)(cl_mem, void (*pfn_event_notify) (cl_mem, void *), void *);
      function clSetMemObjectDestructorCallback = (function)(intptr_t) procAddress;
  
      jobject cb = (*env)->NewGlobalRef(env, listener);
      _res = (*clSetMemObjectDestructorCallback)(_mem, &memObjDestructorCallback, cb);
  
      return _res;
  }

/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetPlatformIDs(int num_entries, com.jogamp.common.nio.PointerBuffer platforms, java.nio.IntBuffer num_platforms)
 *     C function: cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id *  platforms, cl_uint *  num_platforms)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetPlatformIDs0__ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint num_entries, jobject platforms, jint platforms_byte_offset, jobject num_platforms, jint num_platforms_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint num_entries, cl_platform_id *  platforms, cl_uint *  num_platforms);
  _local_ARG ptr_clGetPlatformIDs;
  cl_platform_id * _platforms_ptr = NULL;
  cl_uint * _num_platforms_ptr = NULL;
  cl_int _res;
    if ( NULL != platforms ) {
        _platforms_ptr = (cl_platform_id *) (((char*) (*env)->GetDirectBufferAddress(env, platforms)) + platforms_byte_offset);
    }

    if ( NULL != num_platforms ) {
        _num_platforms_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_platforms)) + num_platforms_byte_offset);
    }

  ptr_clGetPlatformIDs = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetPlatformIDs != NULL);
  _res = (cl_int) (* ptr_clGetPlatformIDs) ((cl_uint) num_entries, (cl_platform_id * ) _platforms_ptr, (cl_uint * ) _num_platforms_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetPlatformInfo(long platform, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetPlatformInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong platform, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetPlatformInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetPlatformInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetPlatformInfo != NULL);
  _res = (cl_int) (* ptr_clGetPlatformInfo) ((cl_platform_id) (intptr_t) platform, (cl_platform_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetDeviceIDs(long platform, long device_type, int num_entries, com.jogamp.common.nio.PointerBuffer devices, java.nio.IntBuffer num_devices)
 *     C function: cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *  devices, cl_uint *  num_devices)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetDeviceIDs0__JJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong platform, jlong device_type, jint num_entries, jobject devices, jint devices_byte_offset, jobject num_devices, jint num_devices_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *  devices, cl_uint *  num_devices);
  _local_ARG ptr_clGetDeviceIDs;
  cl_device_id * _devices_ptr = NULL;
  cl_uint * _num_devices_ptr = NULL;
  cl_int _res;
    if ( NULL != devices ) {
        _devices_ptr = (cl_device_id *) (((char*) (*env)->GetDirectBufferAddress(env, devices)) + devices_byte_offset);
    }

    if ( NULL != num_devices ) {
        _num_devices_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_devices)) + num_devices_byte_offset);
    }

  ptr_clGetDeviceIDs = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetDeviceIDs != NULL);
  _res = (cl_int) (* ptr_clGetDeviceIDs) ((cl_platform_id) (intptr_t) platform, (cl_device_type) device_type, (cl_uint) num_entries, (cl_device_id * ) _devices_ptr, (cl_uint * ) _num_devices_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetDeviceInfo(long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetDeviceInfo(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetDeviceInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetDeviceInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetDeviceInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetDeviceInfo != NULL);
  _res = (cl_int) (* ptr_clGetDeviceInfo) ((cl_device_id) (intptr_t) device, (cl_device_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainContext(long context)
 *     C function: cl_int clRetainContext(cl_context context)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainContext1__JJ(JNIEnv *env, jobject _unused, jlong context, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context);
  _local_ARG ptr_clRetainContext;
  cl_int _res;
  ptr_clRetainContext = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainContext != NULL);
  _res = (cl_int) (* ptr_clRetainContext) ((cl_context) (intptr_t) context);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetContextInfo(long context, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetContextInfo(cl_context context, cl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetContextInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context, cl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetContextInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetContextInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetContextInfo != NULL);
  _res = (cl_int) (* ptr_clGetContextInfo) ((cl_context) (intptr_t) context, (cl_context_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateCommandQueue(long context, long device, long properties, java.nio.IntBuffer errcode_ret)
 *     C function: cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateCommandQueue1__JJJLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong device, jlong properties, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_command_queue (CL_API_CALL*_local_ARG)(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateCommandQueue;
  cl_int * _errcode_ret_ptr = NULL;
  cl_command_queue _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateCommandQueue != NULL);
  _res = (cl_command_queue) (* ptr_clCreateCommandQueue) ((cl_context) (intptr_t) context, (cl_device_id) (intptr_t) device, (cl_command_queue_properties) properties, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainCommandQueue(long command_queue)
 *     C function: cl_int clRetainCommandQueue(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainCommandQueue1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clRetainCommandQueue;
  cl_int _res;
  ptr_clRetainCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainCommandQueue != NULL);
  _res = (cl_int) (* ptr_clRetainCommandQueue) ((cl_command_queue) (intptr_t) command_queue);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseCommandQueue(long command_queue)
 *     C function: cl_int clReleaseCommandQueue(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseCommandQueue1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clReleaseCommandQueue;
  cl_int _res;
  ptr_clReleaseCommandQueue = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseCommandQueue != NULL);
  _res = (cl_int) (* ptr_clReleaseCommandQueue) ((cl_command_queue) (intptr_t) command_queue);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetCommandQueueInfo(long command_queue, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetCommandQueueInfo(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetCommandQueueInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetCommandQueueInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetCommandQueueInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetCommandQueueInfo != NULL);
  _res = (cl_int) (* ptr_clGetCommandQueueInfo) ((cl_command_queue) (intptr_t) command_queue, (cl_command_queue_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateBuffer(long context, long flags, long size, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateBuffer1__JJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jlong size, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, size_t size, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateBuffer;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateBuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (size_t) size, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateSubBuffer(long buffer, long flags, int buffer_create_type, java.nio.Buffer buffer_create_info, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *  buffer_create_info, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateSubBuffer1__JJILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong buffer, jlong flags, jint buffer_create_type, jobject buffer_create_info, jint buffer_create_info_byte_offset, jboolean buffer_create_info_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *  buffer_create_info, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateSubBuffer;
  void * _buffer_create_info_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != buffer_create_info ) {
    _buffer_create_info_ptr = (void *) ( JNI_TRUE == buffer_create_info_is_nio ?  (*env)->GetDirectBufferAddress(env, buffer_create_info) :  (*env)->GetPrimitiveArrayCritical(env, buffer_create_info, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateSubBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSubBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateSubBuffer) ((cl_mem) (intptr_t) buffer, (cl_mem_flags) flags, (cl_buffer_create_type) buffer_create_type, (const void * ) (((char *) _buffer_create_info_ptr) + buffer_create_info_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == buffer_create_info_is_nio && NULL != buffer_create_info ) {
    (*env)->ReleasePrimitiveArrayCritical(env, buffer_create_info, _buffer_create_info_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateImage2D(long context, long flags, CLImageFormatImpl image_format, long image_width, long image_height, long image_row_pitch, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateImage2D(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateImage2D1__JJLjava_nio_ByteBuffer_2JJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jobject image_format, jlong image_width, jlong image_height, jlong image_row_pitch, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateImage2D;
  cl_image_format * _image_format_ptr = NULL;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
    if ( NULL != image_format ) {
        _image_format_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_format)) + 0);
    }

  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateImage2D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateImage2D != NULL);
  _res = (cl_mem) (* ptr_clCreateImage2D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (const cl_image_format * ) _image_format_ptr, (size_t) image_width, (size_t) image_height, (size_t) image_row_pitch, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateImage3D(long context, long flags, CLImageFormatImpl image_format, long image_width, long image_height, long image_depth, long image_row_pitch, long image_slice_pitch, java.nio.Buffer host_ptr, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateImage3D(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *  host_ptr, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateImage3D1__JJLjava_nio_ByteBuffer_2JJJJJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jobject image_format, jlong image_width, jlong image_height, jlong image_depth, jlong image_row_pitch, jlong image_slice_pitch, jobject host_ptr, jint host_ptr_byte_offset, jboolean host_ptr_is_nio, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, const cl_image_format *  image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *  host_ptr, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateImage3D;
  cl_image_format * _image_format_ptr = NULL;
  void * _host_ptr_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
    if ( NULL != image_format ) {
        _image_format_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_format)) + 0);
    }

  if ( NULL != host_ptr ) {
    _host_ptr_ptr = (void *) ( JNI_TRUE == host_ptr_is_nio ?  (*env)->GetDirectBufferAddress(env, host_ptr) :  (*env)->GetPrimitiveArrayCritical(env, host_ptr, NULL) );  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateImage3D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateImage3D != NULL);
  _res = (cl_mem) (* ptr_clCreateImage3D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (const cl_image_format * ) _image_format_ptr, (size_t) image_width, (size_t) image_height, (size_t) image_depth, (size_t) image_row_pitch, (size_t) image_slice_pitch, (void * ) (((char *) _host_ptr_ptr) + host_ptr_byte_offset), (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == host_ptr_is_nio && NULL != host_ptr ) {
    (*env)->ReleasePrimitiveArrayCritical(env, host_ptr, _host_ptr_ptr, 0);  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainMemObject(long memobj)
 *     C function: cl_int clRetainMemObject(cl_mem memobj)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainMemObject1__JJ(JNIEnv *env, jobject _unused, jlong memobj, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj);
  _local_ARG ptr_clRetainMemObject;
  cl_int _res;
  ptr_clRetainMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainMemObject != NULL);
  _res = (cl_int) (* ptr_clRetainMemObject) ((cl_mem) (intptr_t) memobj);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseMemObject(long memobj)
 *     C function: cl_int clReleaseMemObject(cl_mem memobj)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseMemObject1__JJ(JNIEnv *env, jobject _unused, jlong memobj, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj);
  _local_ARG ptr_clReleaseMemObject;
  cl_int _res;
  ptr_clReleaseMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseMemObject != NULL);
  _res = (cl_int) (* ptr_clReleaseMemObject) ((cl_mem) (intptr_t) memobj);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetSupportedImageFormats(long context, long flags, int image_type, int num_entries, CLImageFormatImpl image_formats, java.nio.IntBuffer num_image_formats)
 *     C function: cl_int clGetSupportedImageFormats(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *  image_formats, cl_uint *  num_image_formats)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetSupportedImageFormats1__JJIILjava_nio_ByteBuffer_2Ljava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint image_type, jint num_entries, jobject image_formats, jobject num_image_formats, jint num_image_formats_byte_offset, jboolean num_image_formats_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *  image_formats, cl_uint *  num_image_formats);
  _local_ARG ptr_clGetSupportedImageFormats;
  cl_image_format * _image_formats_ptr = NULL;
  cl_uint * _num_image_formats_ptr = NULL;
  cl_int _res;
    if ( NULL != image_formats ) {
        _image_formats_ptr = (cl_image_format *) (((char*) (*env)->GetDirectBufferAddress(env, image_formats)) + 0);
    }

  if ( NULL != num_image_formats ) {
    _num_image_formats_ptr = (cl_uint *) ( JNI_TRUE == num_image_formats_is_nio ?  (*env)->GetDirectBufferAddress(env, num_image_formats) :  (*env)->GetPrimitiveArrayCritical(env, num_image_formats, NULL) );  }
  ptr_clGetSupportedImageFormats = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetSupportedImageFormats != NULL);
  _res = (cl_int) (* ptr_clGetSupportedImageFormats) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_mem_object_type) image_type, (cl_uint) num_entries, (cl_image_format * ) _image_formats_ptr, (cl_uint * ) (((char *) _num_image_formats_ptr) + num_image_formats_byte_offset));
  if ( JNI_FALSE == num_image_formats_is_nio && NULL != num_image_formats ) {
    (*env)->ReleasePrimitiveArrayCritical(env, num_image_formats, _num_image_formats_ptr, 0);  }
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetMemObjectInfo(long memobj, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetMemObjectInfo(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetMemObjectInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong memobj, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetMemObjectInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetMemObjectInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetMemObjectInfo != NULL);
  _res = (cl_int) (* ptr_clGetMemObjectInfo) ((cl_mem) (intptr_t) memobj, (cl_mem_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetImageInfo(long image, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetImageInfo(cl_mem image, cl_image_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetImageInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong image, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem image, cl_image_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetImageInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetImageInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetImageInfo != NULL);
  _res = (cl_int) (* ptr_clGetImageInfo) ((cl_mem) (intptr_t) image, (cl_image_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateSampler(long context, int normalized_coords, int addressing_mode, int filter_mode, java.nio.IntBuffer errcode_ret)
 *     C function: cl_sampler clCreateSampler(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateSampler1__JIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jint normalized_coords, jint addressing_mode, jint filter_mode, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_sampler (CL_API_CALL*_local_ARG)(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateSampler;
  cl_int * _errcode_ret_ptr = NULL;
  cl_sampler _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSampler != NULL);
  _res = (cl_sampler) (* ptr_clCreateSampler) ((cl_context) (intptr_t) context, (cl_bool) normalized_coords, (cl_addressing_mode) addressing_mode, (cl_filter_mode) filter_mode, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainSampler(long sampler)
 *     C function: cl_int clRetainSampler(cl_sampler sampler)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainSampler1__JJ(JNIEnv *env, jobject _unused, jlong sampler, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler);
  _local_ARG ptr_clRetainSampler;
  cl_int _res;
  ptr_clRetainSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainSampler != NULL);
  _res = (cl_int) (* ptr_clRetainSampler) ((cl_sampler) (intptr_t) sampler);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseSampler(long sampler)
 *     C function: cl_int clReleaseSampler(cl_sampler sampler)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseSampler1__JJ(JNIEnv *env, jobject _unused, jlong sampler, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler);
  _local_ARG ptr_clReleaseSampler;
  cl_int _res;
  ptr_clReleaseSampler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseSampler != NULL);
  _res = (cl_int) (* ptr_clReleaseSampler) ((cl_sampler) (intptr_t) sampler);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetSamplerInfo(long sampler, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetSamplerInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong sampler, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetSamplerInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetSamplerInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetSamplerInfo != NULL);
  _res = (cl_int) (* ptr_clGetSamplerInfo) ((cl_sampler) (intptr_t) sampler, (cl_sampler_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateProgramWithSource(long context, int count, java.lang.String[] strings, com.jogamp.common.nio.PointerBuffer lengths, java.nio.IntBuffer errcode_ret)
 *     C function: cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char *  *  strings, const size_t *  lengths, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateProgramWithSource0__JI_3Ljava_lang_String_2Ljava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint count, jobjectArray /*elements are String*/ strings, jobject lengths, jint lengths_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef cl_program (CL_API_CALL*_local_ARG)(cl_context context, cl_uint count, const char *  *  strings, const size_t *  lengths, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateProgramWithSource;
  const char * * _strings_ptr_copy = NULL; /* copy of data in strings, laid out according to C memory model */
  jobject _tmpObj;
  int _copyIndex;
  jsize _tmpArrayLen;
  size_t * _lengths_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_program _res;
  if ( NULL != strings ) {

    /* Copy contents of strings into _strings_ptr_copy */
    _tmpArrayLen = (*env)->GetArrayLength(env, strings);
    _strings_ptr_copy = (const char * *) malloc(_tmpArrayLen * sizeof(char *));
  if ( NULL == _strings_ptr_copy ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Could not allocate buffer for copying data in argument \"strings\" in native dispatcher for \"clCreateProgramWithSource\"");
      return 0;
    }
    for (_copyIndex = 0; _copyIndex < _tmpArrayLen; ++_copyIndex) {
      /* get each element of the array argument "strings" */
      _tmpObj = (*env)->GetObjectArrayElement(env, strings, _copyIndex);
    if ( NULL != (jstring) _tmpObj ) {
    _strings_ptr_copy[_copyIndex] = (*env)->GetStringUTFChars(env, (jstring) _tmpObj, (jboolean*)NULL);
  if ( NULL == _strings_ptr_copy[_copyIndex] ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Failed to get UTF-8 chars for argument \"(jstring) _tmpObj\" in native dispatcher for \"clCreateProgramWithSource\"");
      return 0;
    }
  } else {      _strings_ptr_copy[_copyIndex] = NULL;
  }
    }

  }
    if ( NULL != lengths ) {
        _lengths_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, lengths)) + lengths_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clCreateProgramWithSource = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateProgramWithSource != NULL);
  _res = (cl_program) (* ptr_clCreateProgramWithSource) ((cl_context) (intptr_t) context, (cl_uint) count, (const char *  * ) _strings_ptr_copy, (const size_t * ) _lengths_ptr, (cl_int * ) _errcode_ret_ptr);
  if ( NULL != strings ) {
    /* Clean up _strings_ptr_copy */
    _tmpArrayLen = (*env)->GetArrayLength(env, strings);
    for (_copyIndex = 0; _copyIndex < _tmpArrayLen; ++_copyIndex) {
      /* free each element of _strings_ptr_copy */
      _tmpObj = (*env)->GetObjectArrayElement(env, strings, _copyIndex);
     (*env)->ReleaseStringUTFChars(env, (jstring) _tmpObj, _strings_ptr_copy[_copyIndex]);
    }
    free((void*) _strings_ptr_copy);
  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateProgramWithBinary(long context, int num_devices, com.jogamp.common.nio.PointerBuffer device_list, com.jogamp.common.nio.PointerBuffer lengths, com.jogamp.common.nio.PointerBuffer binaries, java.nio.IntBuffer binary_status, java.nio.IntBuffer errcode_ret)
 *     C function: cl_program clCreateProgramWithBinary(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const size_t *  lengths, unsigned const char *  *  binaries, cl_int *  binary_status, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateProgramWithBinary0__JILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong context, jint num_devices, jobject device_list, jint device_list_byte_offset, jobject lengths, jint lengths_byte_offset, jobject binaries, jint binaries_byte_offset, jobject binary_status, jint binary_status_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef cl_program (CL_API_CALL*_local_ARG)(cl_context context, cl_uint num_devices, const cl_device_id *  device_list, const size_t *  lengths, unsigned const char *  *  binaries, cl_int *  binary_status, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateProgramWithBinary;
  cl_device_id * _device_list_ptr = NULL;
  size_t * _lengths_ptr = NULL;
  unsigned char * * _binaries_ptr = NULL;
  cl_int * _binary_status_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_program _res;
    if ( NULL != device_list ) {
        _device_list_ptr = (cl_device_id *) (((char*) (*env)->GetDirectBufferAddress(env, device_list)) + device_list_byte_offset);
    }

    if ( NULL != lengths ) {
        _lengths_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, lengths)) + lengths_byte_offset);
    }

    if ( NULL != binaries ) {
        _binaries_ptr = (unsigned char * *) (((char*) (*env)->GetDirectBufferAddress(env, binaries)) + binaries_byte_offset);
    }

    if ( NULL != binary_status ) {
        _binary_status_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, binary_status)) + binary_status_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clCreateProgramWithBinary = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateProgramWithBinary != NULL);
  _res = (cl_program) (* ptr_clCreateProgramWithBinary) ((cl_context) (intptr_t) context, (cl_uint) num_devices, (const cl_device_id * ) _device_list_ptr, (const size_t * ) _lengths_ptr, (unsigned const char *  * ) _binaries_ptr, (cl_int * ) _binary_status_ptr, (cl_int * ) _errcode_ret_ptr);
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainProgram(long program)
 *     C function: cl_int clRetainProgram(cl_program program)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainProgram1__JJ(JNIEnv *env, jobject _unused, jlong program, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program);
  _local_ARG ptr_clRetainProgram;
  cl_int _res;
  ptr_clRetainProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainProgram != NULL);
  _res = (cl_int) (* ptr_clRetainProgram) ((cl_program) (intptr_t) program);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseProgram(long program)
 *     C function: cl_int clReleaseProgram(cl_program program)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseProgram1__JJ(JNIEnv *env, jobject _unused, jlong program, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program);
  _local_ARG ptr_clReleaseProgram;
  cl_int _res;
  ptr_clReleaseProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseProgram != NULL);
  _res = (cl_int) (* ptr_clReleaseProgram) ((cl_program) (intptr_t) program);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clUnloadCompiler()
 *     C function: cl_int clUnloadCompiler(void)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clUnloadCompiler1__J(JNIEnv *env, jobject _unused, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(void);
  _local_ARG ptr_clUnloadCompiler;
  cl_int _res;
  ptr_clUnloadCompiler = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clUnloadCompiler != NULL);
  _res = (cl_int) (* ptr_clUnloadCompiler) ();
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetProgramInfo(long program, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetProgramInfo(cl_program program, cl_program_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetProgramInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_program_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetProgramInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetProgramInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetProgramInfo != NULL);
  _res = (cl_int) (* ptr_clGetProgramInfo) ((cl_program) (intptr_t) program, (cl_program_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetProgramBuildInfo(long program, long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetProgramBuildInfo(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetProgramBuildInfo0__JJIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetProgramBuildInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetProgramBuildInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetProgramBuildInfo != NULL);
  _res = (cl_int) (* ptr_clGetProgramBuildInfo) ((cl_program) (intptr_t) program, (cl_device_id) (intptr_t) device, (cl_program_build_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateKernel(long program, java.lang.String kernel_name, java.nio.IntBuffer errcode_ret)
 *     C function: cl_kernel clCreateKernel(cl_program program, const char *  kernel_name, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateKernel1__JLjava_lang_String_2Ljava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong program, jstring kernel_name, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_kernel (CL_API_CALL*_local_ARG)(cl_program program, const char *  kernel_name, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateKernel;
  const char* _strchars_kernel_name = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  cl_kernel _res;
  if ( NULL != kernel_name ) {
    _strchars_kernel_name = (*env)->GetStringUTFChars(env, kernel_name, (jboolean*)NULL);
  if ( NULL == _strchars_kernel_name ) {
      (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"),
                       "Failed to get UTF-8 chars for argument \"kernel_name\" in native dispatcher for \"clCreateKernel\"");
      return 0;
    }
  }
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateKernel != NULL);
  _res = (cl_kernel) (* ptr_clCreateKernel) ((cl_program) (intptr_t) program, (const char * ) _strchars_kernel_name, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( NULL != kernel_name ) {
    (*env)->ReleaseStringUTFChars(env, kernel_name, _strchars_kernel_name);
  }
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clCreateKernelsInProgram(long program, int num_kernels, com.jogamp.common.nio.PointerBuffer kernels, java.nio.IntBuffer num_kernels_ret)
 *     C function: cl_int clCreateKernelsInProgram(cl_program program, cl_uint num_kernels, cl_kernel *  kernels, cl_uint *  num_kernels_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateKernelsInProgram0__JILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong program, jint num_kernels, jobject kernels, jint kernels_byte_offset, jobject num_kernels_ret, jint num_kernels_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_program program, cl_uint num_kernels, cl_kernel *  kernels, cl_uint *  num_kernels_ret);
  _local_ARG ptr_clCreateKernelsInProgram;
  cl_kernel * _kernels_ptr = NULL;
  cl_uint * _num_kernels_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != kernels ) {
        _kernels_ptr = (cl_kernel *) (((char*) (*env)->GetDirectBufferAddress(env, kernels)) + kernels_byte_offset);
    }

    if ( NULL != num_kernels_ret ) {
        _num_kernels_ret_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, num_kernels_ret)) + num_kernels_ret_byte_offset);
    }

  ptr_clCreateKernelsInProgram = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateKernelsInProgram != NULL);
  _res = (cl_int) (* ptr_clCreateKernelsInProgram) ((cl_program) (intptr_t) program, (cl_uint) num_kernels, (cl_kernel * ) _kernels_ptr, (cl_uint * ) _num_kernels_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainKernel(long kernel)
 *     C function: cl_int clRetainKernel(cl_kernel kernel)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainKernel1__JJ(JNIEnv *env, jobject _unused, jlong kernel, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel);
  _local_ARG ptr_clRetainKernel;
  cl_int _res;
  ptr_clRetainKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainKernel != NULL);
  _res = (cl_int) (* ptr_clRetainKernel) ((cl_kernel) (intptr_t) kernel);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseKernel(long kernel)
 *     C function: cl_int clReleaseKernel(cl_kernel kernel)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseKernel1__JJ(JNIEnv *env, jobject _unused, jlong kernel, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel);
  _local_ARG ptr_clReleaseKernel;
  cl_int _res;
  ptr_clReleaseKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseKernel != NULL);
  _res = (cl_int) (* ptr_clReleaseKernel) ((cl_kernel) (intptr_t) kernel);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clSetKernelArg(long kernel, int arg_index, long arg_size, java.nio.Buffer arg_value)
 *     C function: cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *  arg_value)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clSetKernelArg0__JIJLjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jint arg_index, jlong arg_size, jobject arg_value, jint arg_value_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *  arg_value);
  _local_ARG ptr_clSetKernelArg;
  void * _arg_value_ptr = NULL;
  cl_int _res;
    if ( NULL != arg_value ) {
        _arg_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, arg_value)) + arg_value_byte_offset);
    }

  ptr_clSetKernelArg = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clSetKernelArg != NULL);
  _res = (cl_int) (* ptr_clSetKernelArg) ((cl_kernel) (intptr_t) kernel, (cl_uint) arg_index, (size_t) arg_size, (const void * ) _arg_value_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetKernelInfo(long kernel, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetKernelInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetKernelInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetKernelInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetKernelInfo != NULL);
  _res = (cl_int) (* ptr_clGetKernelInfo) ((cl_kernel) (intptr_t) kernel, (cl_kernel_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetKernelWorkGroupInfo(long kernel, long device, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetKernelWorkGroupInfo0__JJIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong kernel, jlong device, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetKernelWorkGroupInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetKernelWorkGroupInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetKernelWorkGroupInfo != NULL);
  _res = (cl_int) (* ptr_clGetKernelWorkGroupInfo) ((cl_kernel) (intptr_t) kernel, (cl_device_id) (intptr_t) device, (cl_kernel_work_group_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clWaitForEvents(int num_events, com.jogamp.common.nio.PointerBuffer event_list)
 *     C function: cl_int clWaitForEvents(cl_uint num_events, const cl_event *  event_list)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clWaitForEvents0__ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint num_events, jobject event_list, jint event_list_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint num_events, const cl_event *  event_list);
  _local_ARG ptr_clWaitForEvents;
  cl_event * _event_list_ptr = NULL;
  cl_int _res;
    if ( NULL != event_list ) {
        _event_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_list)) + event_list_byte_offset);
    }

  ptr_clWaitForEvents = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clWaitForEvents != NULL);
  _res = (cl_int) (* ptr_clWaitForEvents) ((cl_uint) num_events, (const cl_event * ) _event_list_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetEventInfo(long event, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetEventInfo(cl_event event, cl_event_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetEventInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong event, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_event_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetEventInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetEventInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetEventInfo != NULL);
  _res = (cl_int) (* ptr_clGetEventInfo) ((cl_event) (intptr_t) event, (cl_event_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateUserEvent(long context, java.nio.IntBuffer errcode_ret)
 *     C function: cl_event clCreateUserEvent(cl_context context, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateUserEvent1__JLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_event (CL_API_CALL*_local_ARG)(cl_context context, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateUserEvent;
  cl_int * _errcode_ret_ptr = NULL;
  cl_event _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateUserEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateUserEvent != NULL);
  _res = (cl_event) (* ptr_clCreateUserEvent) ((cl_context) (intptr_t) context, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainEvent(long event)
 *     C function: cl_int clRetainEvent(cl_event event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainEvent1__JJ(JNIEnv *env, jobject _unused, jlong event, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event);
  _local_ARG ptr_clRetainEvent;
  cl_int _res;
  ptr_clRetainEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainEvent != NULL);
  _res = (cl_int) (* ptr_clRetainEvent) ((cl_event) (intptr_t) event);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseEvent(long event)
 *     C function: cl_int clReleaseEvent(cl_event event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseEvent1__JJ(JNIEnv *env, jobject _unused, jlong event, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event);
  _local_ARG ptr_clReleaseEvent;
  cl_int _res;
  ptr_clReleaseEvent = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseEvent != NULL);
  _res = (cl_int) (* ptr_clReleaseEvent) ((cl_event) (intptr_t) event);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clSetUserEventStatus(long event, int execution_status)
 *     C function: cl_int clSetUserEventStatus(cl_event event, cl_int execution_status)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clSetUserEventStatus1__JIJ(JNIEnv *env, jobject _unused, jlong event, jint execution_status, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_int execution_status);
  _local_ARG ptr_clSetUserEventStatus;
  cl_int _res;
  ptr_clSetUserEventStatus = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clSetUserEventStatus != NULL);
  _res = (cl_int) (* ptr_clSetUserEventStatus) ((cl_event) (intptr_t) event, (cl_int) execution_status);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetEventProfilingInfo(long event, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetEventProfilingInfo0__JIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong event, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetEventProfilingInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetEventProfilingInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetEventProfilingInfo != NULL);
  _res = (cl_int) (* ptr_clGetEventProfilingInfo) ((cl_event) (intptr_t) event, (cl_profiling_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clFlush(long command_queue)
 *     C function: cl_int clFlush(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clFlush1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clFlush;
  cl_int _res;
  ptr_clFlush = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clFlush != NULL);
  _res = (cl_int) (* ptr_clFlush) ((cl_command_queue) (intptr_t) command_queue);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clFinish(long command_queue)
 *     C function: cl_int clFinish(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clFinish1__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clFinish;
  cl_int _res;
  ptr_clFinish = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clFinish != NULL);
  _res = (cl_int) (* ptr_clFinish) ((cl_command_queue) (intptr_t) command_queue);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueReadBuffer(long command_queue, long buffer, int blocking_read, long offset, long cb, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t cb, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueReadBuffer0__JJIJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_read, jlong offset, jlong cb, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t cb, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadBuffer;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_read, (size_t) offset, (size_t) cb, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueReadBufferRect(long command_queue, long buffer, int blocking_read, com.jogamp.common.nio.PointerBuffer buffer_origin, com.jogamp.common.nio.PointerBuffer host_origin, com.jogamp.common.nio.PointerBuffer region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *  buffer_origin, const size_t *  host_origin, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueReadBufferRect0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_read, jobject buffer_origin, jint buffer_origin_byte_offset, jobject host_origin, jint host_origin_byte_offset, jobject region, jint region_byte_offset, jlong buffer_row_pitch, jlong buffer_slice_pitch, jlong host_row_pitch, jlong host_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *  buffer_origin, const size_t *  host_origin, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadBufferRect;
  size_t * _buffer_origin_ptr = NULL;
  size_t * _host_origin_ptr = NULL;
  size_t * _region_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != buffer_origin ) {
        _buffer_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, buffer_origin)) + buffer_origin_byte_offset);
    }

    if ( NULL != host_origin ) {
        _host_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, host_origin)) + host_origin_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_read, (const size_t * ) _buffer_origin_ptr, (const size_t * ) _host_origin_ptr, (const size_t * ) _region_ptr, (size_t) buffer_row_pitch, (size_t) buffer_slice_pitch, (size_t) host_row_pitch, (size_t) host_slice_pitch, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueWriteBuffer(long command_queue, long buffer, int blocking_write, long offset, long cb, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t cb, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueWriteBuffer0__JJIJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_write, jlong offset, jlong cb, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t cb, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteBuffer;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_write, (size_t) offset, (size_t) cb, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueWriteBufferRect(long command_queue, long buffer, int blocking_write, com.jogamp.common.nio.PointerBuffer buffer_origin, com.jogamp.common.nio.PointerBuffer host_origin, com.jogamp.common.nio.PointerBuffer region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *  buffer_origin, const size_t *  host_origin, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueWriteBufferRect0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_write, jobject buffer_origin, jint buffer_origin_byte_offset, jobject host_origin, jint host_origin_byte_offset, jobject region, jint region_byte_offset, jlong buffer_row_pitch, jlong buffer_slice_pitch, jlong host_row_pitch, jlong host_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *  buffer_origin, const size_t *  host_origin, const size_t *  region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteBufferRect;
  size_t * _buffer_origin_ptr = NULL;
  size_t * _host_origin_ptr = NULL;
  size_t * _region_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != buffer_origin ) {
        _buffer_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, buffer_origin)) + buffer_origin_byte_offset);
    }

    if ( NULL != host_origin ) {
        _host_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, host_origin)) + host_origin_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_write, (const size_t * ) _buffer_origin_ptr, (const size_t * ) _host_origin_ptr, (const size_t * ) _region_ptr, (size_t) buffer_row_pitch, (size_t) buffer_slice_pitch, (size_t) host_row_pitch, (size_t) host_slice_pitch, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueCopyBuffer(long command_queue, long src_buffer, long dst_buffer, long src_offset, long dst_offset, long cb, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t cb, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueCopyBuffer0__JJJJJJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_buffer, jlong src_offset, jlong dst_offset, jlong cb, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t cb, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBuffer;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_buffer, (size_t) src_offset, (size_t) dst_offset, (size_t) cb, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueCopyBufferRect(long command_queue, long src_buffer, long dst_buffer, com.jogamp.common.nio.PointerBuffer src_origin, com.jogamp.common.nio.PointerBuffer dst_origin, com.jogamp.common.nio.PointerBuffer region, long src_row_pitch, long src_slice_pitch, long dst_row_pitch, long dst_slice_pitch, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *  src_origin, const size_t *  dst_origin, const size_t *  region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueCopyBufferRect0__JJJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJJJJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_buffer, jobject src_origin, jint src_origin_byte_offset, jobject dst_origin, jint dst_origin_byte_offset, jobject region, jint region_byte_offset, jlong src_row_pitch, jlong src_slice_pitch, jlong dst_row_pitch, jlong dst_slice_pitch, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *  src_origin, const size_t *  dst_origin, const size_t *  region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBufferRect;
  size_t * _src_origin_ptr = NULL;
  size_t * _dst_origin_ptr = NULL;
  size_t * _region_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != src_origin ) {
        _src_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, src_origin)) + src_origin_byte_offset);
    }

    if ( NULL != dst_origin ) {
        _dst_origin_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, dst_origin)) + dst_origin_byte_offset);
    }

    if ( NULL != region ) {
        _region_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, region)) + region_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBufferRect = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBufferRect != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBufferRect) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_buffer, (const size_t * ) _src_origin_ptr, (const size_t * ) _dst_origin_ptr, (const size_t * ) _region_ptr, (size_t) src_row_pitch, (size_t) src_slice_pitch, (size_t) dst_row_pitch, (size_t) dst_slice_pitch, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueReadImage(long command_queue, long image, int blocking_read, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long row_pitch, long slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t * , const size_t * , size_t row_pitch, size_t slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueReadImage0__JJILjava_lang_Object_2ILjava_lang_Object_2IJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong image, jint blocking_read, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong row_pitch, jlong slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t * , const size_t * , size_t row_pitch, size_t slice_pitch, void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReadImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReadImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReadImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueReadImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image, (cl_bool) blocking_read, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) row_pitch, (size_t) slice_pitch, (void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueWriteImage(long command_queue, long image, int blocking_write, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long input_row_pitch, long input_slice_pitch, java.nio.Buffer ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueWriteImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t * , const size_t * , size_t input_row_pitch, size_t input_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueWriteImage0__JJILjava_lang_Object_2ILjava_lang_Object_2IJJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong image, jint blocking_write, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong input_row_pitch, jlong input_slice_pitch, jobject ptr, jint ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t * , const size_t * , size_t input_row_pitch, size_t input_slice_pitch, const void *  ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueWriteImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  void * _ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != ptr ) {
        _ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, ptr)) + ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueWriteImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWriteImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueWriteImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) image, (cl_bool) blocking_write, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) input_row_pitch, (size_t) input_slice_pitch, (const void * ) _ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueCopyImage(long command_queue, long src_image, long dst_image, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, com.jogamp.common.nio.PointerBuffer arg5, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t * , const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueCopyImage0__JJJLjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_image, jlong dst_image, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jobject arg5, jint arg5_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t * , const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyImage;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  size_t * _arg5_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != arg5 ) {
        _arg5_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg5)) + arg5_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_image, (cl_mem) (intptr_t) dst_image, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (const size_t * ) _arg5_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueCopyImageToBuffer(long command_queue, long src_image, long dst_buffer, com.jogamp.common.nio.PointerBuffer arg3, com.jogamp.common.nio.PointerBuffer arg4, long dst_offset, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyImageToBuffer(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t * , const size_t * , size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueCopyImageToBuffer0__JJJLjava_lang_Object_2ILjava_lang_Object_2IJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_image, jlong dst_buffer, jobject arg3, jint arg3_byte_offset, jobject arg4, jint arg4_byte_offset, jlong dst_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t * , const size_t * , size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyImageToBuffer;
  size_t * _arg3_ptr = NULL;
  size_t * _arg4_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg3 ) {
        _arg3_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg3)) + arg3_byte_offset);
    }

    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyImageToBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyImageToBuffer != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyImageToBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_image, (cl_mem) (intptr_t) dst_buffer, (const size_t * ) _arg3_ptr, (const size_t * ) _arg4_ptr, (size_t) dst_offset, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueCopyBufferToImage(long command_queue, long src_buffer, long dst_image, long src_offset, com.jogamp.common.nio.PointerBuffer arg4, com.jogamp.common.nio.PointerBuffer arg5, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueCopyBufferToImage(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueCopyBufferToImage0__JJJJLjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong src_buffer, jlong dst_image, jlong src_offset, jobject arg4, jint arg4_byte_offset, jobject arg5, jint arg5_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t * , const size_t * , cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueCopyBufferToImage;
  size_t * _arg4_ptr = NULL;
  size_t * _arg5_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != arg4 ) {
        _arg4_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg4)) + arg4_byte_offset);
    }

    if ( NULL != arg5 ) {
        _arg5_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, arg5)) + arg5_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueCopyBufferToImage = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueCopyBufferToImage != NULL);
  _res = (cl_int) (* ptr_clEnqueueCopyBufferToImage) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) src_buffer, (cl_mem) (intptr_t) dst_image, (size_t) src_offset, (const size_t * ) _arg4_ptr, (const size_t * ) _arg5_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: java.nio.ByteBuffer clEnqueueMapBuffer(long command_queue, long buffer, int blocking_map, long map_flags, long offset, long cb, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event, java.nio.IntBuffer errcode_ret)
 *     C function: void *  clEnqueueMapBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t cb, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event, cl_int *  errcode_ret)
 */
JNIEXPORT jobject JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueMapBuffer0__JJIJJJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong buffer, jint blocking_map, jlong map_flags, jlong offset, jlong cb, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jobject errcode_ret, jint errcode_ret_byte_offset, jlong procAddress) {
  typedef void *  (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t cb, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event, cl_int *  errcode_ret);
  _local_ARG ptr_clEnqueueMapBuffer;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int * _errcode_ret_ptr = NULL;
  void * _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

    if ( NULL != errcode_ret ) {
        _errcode_ret_ptr = (cl_int *) (((char*) (*env)->GetDirectBufferAddress(env, errcode_ret)) + errcode_ret_byte_offset);
    }

  ptr_clEnqueueMapBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMapBuffer != NULL);
  _res = (void *) (* ptr_clEnqueueMapBuffer) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) buffer, (cl_bool) blocking_map, (cl_map_flags) map_flags, (size_t) offset, (size_t) cb, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr, (cl_int * ) _errcode_ret_ptr);
  if (NULL == _res) return NULL;
  return (*env)->NewDirectByteBuffer(env, (void *)_res, cb);
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueUnmapMemObject(long command_queue, long memobj, java.nio.Buffer mapped_ptr, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_mem memobj, void *  mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueUnmapMemObject0__JJLjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong memobj, jobject mapped_ptr, jint mapped_ptr_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_mem memobj, void *  mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueUnmapMemObject;
  void * _mapped_ptr_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mapped_ptr ) {
        _mapped_ptr_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, mapped_ptr)) + mapped_ptr_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueUnmapMemObject = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueUnmapMemObject != NULL);
  _res = (cl_int) (* ptr_clEnqueueUnmapMemObject) ((cl_command_queue) (intptr_t) command_queue, (cl_mem) (intptr_t) memobj, (void * ) _mapped_ptr_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueNDRangeKernel(long command_queue, long kernel, int work_dim, com.jogamp.common.nio.PointerBuffer global_work_offset, com.jogamp.common.nio.PointerBuffer global_work_size, com.jogamp.common.nio.PointerBuffer local_work_size, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *  global_work_offset, const size_t *  global_work_size, const size_t *  local_work_size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueNDRangeKernel0__JJILjava_lang_Object_2ILjava_lang_Object_2ILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong kernel, jint work_dim, jobject global_work_offset, jint global_work_offset_byte_offset, jobject global_work_size, jint global_work_size_byte_offset, jobject local_work_size, jint local_work_size_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *  global_work_offset, const size_t *  global_work_size, const size_t *  local_work_size, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueNDRangeKernel;
  size_t * _global_work_offset_ptr = NULL;
  size_t * _global_work_size_ptr = NULL;
  size_t * _local_work_size_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != global_work_offset ) {
        _global_work_offset_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, global_work_offset)) + global_work_offset_byte_offset);
    }

    if ( NULL != global_work_size ) {
        _global_work_size_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, global_work_size)) + global_work_size_byte_offset);
    }

    if ( NULL != local_work_size ) {
        _local_work_size_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, local_work_size)) + local_work_size_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueNDRangeKernel = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueNDRangeKernel != NULL);
  _res = (cl_int) (* ptr_clEnqueueNDRangeKernel) ((cl_command_queue) (intptr_t) command_queue, (cl_kernel) (intptr_t) kernel, (cl_uint) work_dim, (const size_t * ) _global_work_offset_ptr, (const size_t * ) _global_work_size_ptr, (const size_t * ) _local_work_size_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueTask(long command_queue, long kernel, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueTask0__JJILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong kernel, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueTask;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueTask = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueTask != NULL);
  _res = (cl_int) (* ptr_clEnqueueTask) ((cl_command_queue) (intptr_t) command_queue, (cl_kernel) (intptr_t) kernel, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueMarker(long command_queue, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueMarker0__JLjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_event *  event);
  _local_ARG ptr_clEnqueueMarker;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueMarker = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMarker != NULL);
  _res = (cl_int) (* ptr_clEnqueueMarker) ((cl_command_queue) (intptr_t) command_queue, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueWaitForEvents(long command_queue, int num_events, com.jogamp.common.nio.PointerBuffer event_list)
 *     C function: cl_int clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, const cl_event *  event_list)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueWaitForEvents0__JILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_events, jobject event_list, jint event_list_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_events, const cl_event *  event_list);
  _local_ARG ptr_clEnqueueWaitForEvents;
  cl_event * _event_list_ptr = NULL;
  cl_int _res;
    if ( NULL != event_list ) {
        _event_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_list)) + event_list_byte_offset);
    }

  ptr_clEnqueueWaitForEvents = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueWaitForEvents != NULL);
  _res = (cl_int) (* ptr_clEnqueueWaitForEvents) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_events, (const cl_event * ) _event_list_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueBarrier(long command_queue)
 *     C function: cl_int clEnqueueBarrier(cl_command_queue command_queue)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueBarrier0__JJ(JNIEnv *env, jobject _unused, jlong command_queue, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue);
  _local_ARG ptr_clEnqueueBarrier;
  cl_int _res;
  ptr_clEnqueueBarrier = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueBarrier != NULL);
  _res = (cl_int) (* ptr_clEnqueueBarrier) ((cl_command_queue) (intptr_t) command_queue);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clIcdGetPlatformIDsKHR(int arg0, com.jogamp.common.nio.PointerBuffer arg1, java.nio.IntBuffer arg2)
 *     C function: cl_int clIcdGetPlatformIDsKHR(cl_uint, cl_platform_id * , cl_uint * )
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clIcdGetPlatformIDsKHR0__ILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jint arg0, jobject arg1, jint arg1_byte_offset, jobject arg2, jint arg2_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_uint, cl_platform_id * , cl_uint * );
  _local_ARG ptr_clIcdGetPlatformIDsKHR;
  cl_platform_id * _arg1_ptr = NULL;
  cl_uint * _arg2_ptr = NULL;
  cl_int _res;
    if ( NULL != arg1 ) {
        _arg1_ptr = (cl_platform_id *) (((char*) (*env)->GetDirectBufferAddress(env, arg1)) + arg1_byte_offset);
    }

    if ( NULL != arg2 ) {
        _arg2_ptr = (cl_uint *) (((char*) (*env)->GetDirectBufferAddress(env, arg2)) + arg2_byte_offset);
    }

  ptr_clIcdGetPlatformIDsKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clIcdGetPlatformIDsKHR != NULL);
  _res = (cl_int) (* ptr_clIcdGetPlatformIDsKHR) ((cl_uint) arg0, (cl_platform_id * ) _arg1_ptr, (cl_uint * ) _arg2_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clReleaseDeviceEXT(long arg0)
 *     C function: cl_int clReleaseDeviceEXT(cl_device_id)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clReleaseDeviceEXT1__JJ(JNIEnv *env, jobject _unused, jlong arg0, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id);
  _local_ARG ptr_clReleaseDeviceEXT;
  cl_int _res;
  ptr_clReleaseDeviceEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clReleaseDeviceEXT != NULL);
  _res = (cl_int) (* ptr_clReleaseDeviceEXT) ((cl_device_id) (intptr_t) arg0);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clRetainDeviceEXT(long arg0)
 *     C function: cl_int clRetainDeviceEXT(cl_device_id)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clRetainDeviceEXT1__JJ(JNIEnv *env, jobject _unused, jlong arg0, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id);
  _local_ARG ptr_clRetainDeviceEXT;
  cl_int _res;
  ptr_clRetainDeviceEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clRetainDeviceEXT != NULL);
  _res = (cl_int) (* ptr_clRetainDeviceEXT) ((cl_device_id) (intptr_t) arg0);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clCreateSubDevicesEXT(long arg0, java.nio.LongBuffer arg1, int arg2, com.jogamp.common.nio.PointerBuffer arg3, java.nio.IntBuffer arg4)
 *     C function: cl_int clCreateSubDevicesEXT(cl_device_id, const cl_device_partition_property_ext * , cl_uint, cl_device_id * , cl_uint * )
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateSubDevicesEXT1__JLjava_lang_Object_2IZILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong arg0, jobject arg1, jint arg1_byte_offset, jboolean arg1_is_nio, jint arg2, jobject arg3, jint arg3_byte_offset, jboolean arg3_is_nio, jobject arg4, jint arg4_byte_offset, jboolean arg4_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_device_id, const cl_device_partition_property_ext * , cl_uint, cl_device_id * , cl_uint * );
  _local_ARG ptr_clCreateSubDevicesEXT;
  cl_device_partition_property_ext * _arg1_ptr = NULL;
  cl_device_id * _arg3_ptr = NULL;
  cl_uint * _arg4_ptr = NULL;
  cl_int _res;
  if ( NULL != arg1 ) {
    _arg1_ptr = (cl_device_partition_property_ext *) ( JNI_TRUE == arg1_is_nio ?  (*env)->GetDirectBufferAddress(env, arg1) :  (*env)->GetPrimitiveArrayCritical(env, arg1, NULL) );  }
  if ( NULL != arg3 ) {
    _arg3_ptr = (cl_device_id *) ( JNI_TRUE == arg3_is_nio ?  (*env)->GetDirectBufferAddress(env, arg3) :  (*env)->GetPrimitiveArrayCritical(env, arg3, NULL) );  }
  if ( NULL != arg4 ) {
    _arg4_ptr = (cl_uint *) ( JNI_TRUE == arg4_is_nio ?  (*env)->GetDirectBufferAddress(env, arg4) :  (*env)->GetPrimitiveArrayCritical(env, arg4, NULL) );  }
  ptr_clCreateSubDevicesEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateSubDevicesEXT != NULL);
  _res = (cl_int) (* ptr_clCreateSubDevicesEXT) ((cl_device_id) (intptr_t) arg0, (const cl_device_partition_property_ext * ) (((char *) _arg1_ptr) + arg1_byte_offset), (cl_uint) arg2, (cl_device_id * ) (((char *) _arg3_ptr) + arg3_byte_offset), (cl_uint * ) (((char *) _arg4_ptr) + arg4_byte_offset));
  if ( JNI_FALSE == arg1_is_nio && NULL != arg1 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg1, _arg1_ptr, JNI_ABORT);  }
  if ( JNI_FALSE == arg3_is_nio && NULL != arg3 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg3, _arg3_ptr, 0);  }
  if ( JNI_FALSE == arg4_is_nio && NULL != arg4 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg4, _arg4_ptr, 0);  }
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueMigrateMemObjectEXT(long arg0, int arg1, com.jogamp.common.nio.PointerBuffer arg2, long arg3, int arg4, com.jogamp.common.nio.PointerBuffer arg5, com.jogamp.common.nio.PointerBuffer arg6)
 *     C function: cl_int clEnqueueMigrateMemObjectEXT(cl_command_queue, cl_uint, const cl_mem * , cl_mem_migration_flags_ext, cl_uint, const cl_event * , cl_event * )
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueMigrateMemObjectEXT1__JILjava_lang_Object_2IZJILjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong arg0, jint arg1, jobject arg2, jint arg2_byte_offset, jboolean arg2_is_nio, jlong arg3, jint arg4, jobject arg5, jint arg5_byte_offset, jboolean arg5_is_nio, jobject arg6, jint arg6_byte_offset, jboolean arg6_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue, cl_uint, const cl_mem * , cl_mem_migration_flags_ext, cl_uint, const cl_event * , cl_event * );
  _local_ARG ptr_clEnqueueMigrateMemObjectEXT;
  cl_mem * _arg2_ptr = NULL;
  cl_event * _arg5_ptr = NULL;
  cl_event * _arg6_ptr = NULL;
  cl_int _res;
  if ( NULL != arg2 ) {
    _arg2_ptr = (cl_mem *) ( JNI_TRUE == arg2_is_nio ?  (*env)->GetDirectBufferAddress(env, arg2) :  (*env)->GetPrimitiveArrayCritical(env, arg2, NULL) );  }
  if ( NULL != arg5 ) {
    _arg5_ptr = (cl_event *) ( JNI_TRUE == arg5_is_nio ?  (*env)->GetDirectBufferAddress(env, arg5) :  (*env)->GetPrimitiveArrayCritical(env, arg5, NULL) );  }
  if ( NULL != arg6 ) {
    _arg6_ptr = (cl_event *) ( JNI_TRUE == arg6_is_nio ?  (*env)->GetDirectBufferAddress(env, arg6) :  (*env)->GetPrimitiveArrayCritical(env, arg6, NULL) );  }
  ptr_clEnqueueMigrateMemObjectEXT = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueMigrateMemObjectEXT != NULL);
  _res = (cl_int) (* ptr_clEnqueueMigrateMemObjectEXT) ((cl_command_queue) (intptr_t) arg0, (cl_uint) arg1, (const cl_mem * ) (((char *) _arg2_ptr) + arg2_byte_offset), (cl_mem_migration_flags_ext) arg3, (cl_uint) arg4, (const cl_event * ) (((char *) _arg5_ptr) + arg5_byte_offset), (cl_event * ) (((char *) _arg6_ptr) + arg6_byte_offset));
  if ( JNI_FALSE == arg2_is_nio && NULL != arg2 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg2, _arg2_ptr, 0);  }
  if ( JNI_FALSE == arg5_is_nio && NULL != arg5 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg5, _arg5_ptr, 0);  }
  if ( JNI_FALSE == arg6_is_nio && NULL != arg6 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg6, _arg6_ptr, 0);  }
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateFromGLBuffer(long context, long flags, int bufobj, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLBuffer(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateFromGLBuffer1__JJILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint bufobj, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLBuffer;
  int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLBuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLBuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLBuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLuint) bufobj, (int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateFromGLTexture2D(long context, long flags, int target, int miplevel, int texture, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLTexture2D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateFromGLTexture2D1__JJIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint target, jint miplevel, jint texture, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLTexture2D;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLTexture2D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLTexture2D != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLTexture2D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLenum) target, (cl_GLint) miplevel, (cl_GLuint) texture, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateFromGLTexture3D(long context, long flags, int target, int miplevel, int texture, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLTexture3D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateFromGLTexture3D1__JJIIILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint target, jint miplevel, jint texture, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLTexture3D;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLTexture3D = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLTexture3D != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLTexture3D) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLenum) target, (cl_GLint) miplevel, (cl_GLuint) texture, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateFromGLRenderbuffer(long context, long flags, int renderbuffer, java.nio.IntBuffer errcode_ret)
 *     C function: cl_mem clCreateFromGLRenderbuffer(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *  errcode_ret)
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateFromGLRenderbuffer1__JJILjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong context, jlong flags, jint renderbuffer, jobject errcode_ret, jint errcode_ret_byte_offset, jboolean errcode_ret_is_nio, jlong procAddress) {
  typedef cl_mem (CL_API_CALL*_local_ARG)(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *  errcode_ret);
  _local_ARG ptr_clCreateFromGLRenderbuffer;
  cl_int * _errcode_ret_ptr = NULL;
  cl_mem _res;
  if ( NULL != errcode_ret ) {
    _errcode_ret_ptr = (cl_int *) ( JNI_TRUE == errcode_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, errcode_ret) :  (*env)->GetPrimitiveArrayCritical(env, errcode_ret, NULL) );  }
  ptr_clCreateFromGLRenderbuffer = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateFromGLRenderbuffer != NULL);
  _res = (cl_mem) (* ptr_clCreateFromGLRenderbuffer) ((cl_context) (intptr_t) context, (cl_mem_flags) flags, (cl_GLuint) renderbuffer, (cl_int * ) (((char *) _errcode_ret_ptr) + errcode_ret_byte_offset));
  if ( JNI_FALSE == errcode_ret_is_nio && NULL != errcode_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, errcode_ret, _errcode_ret_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetGLObjectInfo(long memobj, java.nio.IntBuffer gl_object_type, java.nio.IntBuffer gl_object_name)
 *     C function: cl_int clGetGLObjectInfo(cl_mem memobj, cl_gl_object_type *  gl_object_type, cl_GLuint *  gl_object_name)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetGLObjectInfo1__JLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong memobj, jobject gl_object_type, jint gl_object_type_byte_offset, jboolean gl_object_type_is_nio, jobject gl_object_name, jint gl_object_name_byte_offset, jboolean gl_object_name_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_gl_object_type *  gl_object_type, cl_GLuint *  gl_object_name);
  _local_ARG ptr_clGetGLObjectInfo;
  cl_gl_object_type * _gl_object_type_ptr = NULL;
  cl_GLuint * _gl_object_name_ptr = NULL;
  cl_int _res;
  if ( NULL != gl_object_type ) {
    _gl_object_type_ptr = (cl_gl_object_type *) ( JNI_TRUE == gl_object_type_is_nio ?  (*env)->GetDirectBufferAddress(env, gl_object_type) :  (*env)->GetPrimitiveArrayCritical(env, gl_object_type, NULL) );  }
  if ( NULL != gl_object_name ) {
    _gl_object_name_ptr = (cl_GLuint *) ( JNI_TRUE == gl_object_name_is_nio ?  (*env)->GetDirectBufferAddress(env, gl_object_name) :  (*env)->GetPrimitiveArrayCritical(env, gl_object_name, NULL) );  }
  ptr_clGetGLObjectInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLObjectInfo != NULL);
  _res = (cl_int) (* ptr_clGetGLObjectInfo) ((cl_mem) (intptr_t) memobj, (cl_gl_object_type * ) (((char *) _gl_object_type_ptr) + gl_object_type_byte_offset), (cl_GLuint * ) (((char *) _gl_object_name_ptr) + gl_object_name_byte_offset));
  if ( JNI_FALSE == gl_object_type_is_nio && NULL != gl_object_type ) {
    (*env)->ReleasePrimitiveArrayCritical(env, gl_object_type, _gl_object_type_ptr, 0);  }
  if ( JNI_FALSE == gl_object_name_is_nio && NULL != gl_object_name ) {
    (*env)->ReleasePrimitiveArrayCritical(env, gl_object_name, _gl_object_name_ptr, 0);  }
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetGLTextureInfo(long memobj, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetGLTextureInfo(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetGLTextureInfo1__JIJLjava_lang_Object_2IZLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong memobj, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jboolean param_value_is_nio, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jboolean param_value_size_ret_is_nio, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetGLTextureInfo;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
  if ( NULL != param_value ) {
    _param_value_ptr = (void *) ( JNI_TRUE == param_value_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value) :  (*env)->GetPrimitiveArrayCritical(env, param_value, NULL) );  }
  if ( NULL != param_value_size_ret ) {
    _param_value_size_ret_ptr = (size_t *) ( JNI_TRUE == param_value_size_ret_is_nio ?  (*env)->GetDirectBufferAddress(env, param_value_size_ret) :  (*env)->GetPrimitiveArrayCritical(env, param_value_size_ret, NULL) );  }
  ptr_clGetGLTextureInfo = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLTextureInfo != NULL);
  _res = (cl_int) (* ptr_clGetGLTextureInfo) ((cl_mem) (intptr_t) memobj, (cl_gl_texture_info) param_name, (size_t) param_value_size, (void * ) (((char *) _param_value_ptr) + param_value_byte_offset), (size_t * ) (((char *) _param_value_size_ret_ptr) + param_value_size_ret_byte_offset));
  if ( JNI_FALSE == param_value_is_nio && NULL != param_value ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value, _param_value_ptr, 0);  }
  if ( JNI_FALSE == param_value_size_ret_is_nio && NULL != param_value_size_ret ) {
    (*env)->ReleasePrimitiveArrayCritical(env, param_value_size_ret, _param_value_size_ret_ptr, 0);  }
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueAcquireGLObjects(long command_queue, int num_objects, com.jogamp.common.nio.PointerBuffer mem_objects, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueAcquireGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueAcquireGLObjects0__JILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_objects, jobject mem_objects, jint mem_objects_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueAcquireGLObjects;
  cl_mem * _mem_objects_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mem_objects ) {
        _mem_objects_ptr = (cl_mem *) (((char*) (*env)->GetDirectBufferAddress(env, mem_objects)) + mem_objects_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueAcquireGLObjects = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueAcquireGLObjects != NULL);
  _res = (cl_int) (* ptr_clEnqueueAcquireGLObjects) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_objects, (const cl_mem * ) _mem_objects_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clEnqueueReleaseGLObjects(long command_queue, int num_objects, com.jogamp.common.nio.PointerBuffer mem_objects, int num_events_in_wait_list, com.jogamp.common.nio.PointerBuffer event_wait_list, com.jogamp.common.nio.PointerBuffer event)
 *     C function: cl_int clEnqueueReleaseGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clEnqueueReleaseGLObjects0__JILjava_lang_Object_2IILjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jlong command_queue, jint num_objects, jobject mem_objects, jint mem_objects_byte_offset, jint num_events_in_wait_list, jobject event_wait_list, jint event_wait_list_byte_offset, jobject event, jint event_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *  mem_objects, cl_uint num_events_in_wait_list, const cl_event *  event_wait_list, cl_event *  event);
  _local_ARG ptr_clEnqueueReleaseGLObjects;
  cl_mem * _mem_objects_ptr = NULL;
  cl_event * _event_wait_list_ptr = NULL;
  cl_event * _event_ptr = NULL;
  cl_int _res;
    if ( NULL != mem_objects ) {
        _mem_objects_ptr = (cl_mem *) (((char*) (*env)->GetDirectBufferAddress(env, mem_objects)) + mem_objects_byte_offset);
    }

    if ( NULL != event_wait_list ) {
        _event_wait_list_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event_wait_list)) + event_wait_list_byte_offset);
    }

    if ( NULL != event ) {
        _event_ptr = (cl_event *) (((char*) (*env)->GetDirectBufferAddress(env, event)) + event_byte_offset);
    }

  ptr_clEnqueueReleaseGLObjects = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clEnqueueReleaseGLObjects != NULL);
  _res = (cl_int) (* ptr_clEnqueueReleaseGLObjects) ((cl_command_queue) (intptr_t) command_queue, (cl_uint) num_objects, (const cl_mem * ) _mem_objects_ptr, (cl_uint) num_events_in_wait_list, (const cl_event * ) _event_wait_list_ptr, (cl_event * ) _event_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: int clGetGLContextInfoKHR(com.jogamp.common.nio.PointerBuffer properties, int param_name, long param_value_size, java.nio.Buffer param_value, com.jogamp.common.nio.PointerBuffer param_value_size_ret)
 *     C function: cl_int clGetGLContextInfoKHR(const cl_context_properties *  properties, cl_gl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret)
 */
JNIEXPORT jint JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clGetGLContextInfoKHR0__Ljava_lang_Object_2IIJLjava_lang_Object_2ILjava_lang_Object_2IJ(JNIEnv *env, jobject _unused, jobject properties, jint properties_byte_offset, jint param_name, jlong param_value_size, jobject param_value, jint param_value_byte_offset, jobject param_value_size_ret, jint param_value_size_ret_byte_offset, jlong procAddress) {
  typedef cl_int (CL_API_CALL*_local_ARG)(const cl_context_properties *  properties, cl_gl_context_info param_name, size_t param_value_size, void *  param_value, size_t *  param_value_size_ret);
  _local_ARG ptr_clGetGLContextInfoKHR;
  cl_context_properties * _properties_ptr = NULL;
  void * _param_value_ptr = NULL;
  size_t * _param_value_size_ret_ptr = NULL;
  cl_int _res;
    if ( NULL != properties ) {
        _properties_ptr = (cl_context_properties *) (((char*) (*env)->GetDirectBufferAddress(env, properties)) + properties_byte_offset);
    }

    if ( NULL != param_value ) {
        _param_value_ptr = (void *) (((char*) (*env)->GetDirectBufferAddress(env, param_value)) + param_value_byte_offset);
    }

    if ( NULL != param_value_size_ret ) {
        _param_value_size_ret_ptr = (size_t *) (((char*) (*env)->GetDirectBufferAddress(env, param_value_size_ret)) + param_value_size_ret_byte_offset);
    }

  ptr_clGetGLContextInfoKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clGetGLContextInfoKHR != NULL);
  _res = (cl_int) (* ptr_clGetGLContextInfoKHR) ((const cl_context_properties * ) _properties_ptr, (cl_gl_context_info) param_name, (size_t) param_value_size, (void * ) _param_value_ptr, (size_t * ) _param_value_size_ret_ptr);
  return _res;
}


/*   Java->C glue code:
 *   Java package: com.jogamp.opencl.llb.impl.CLAbstractImpl
 *    Java method: long clCreateEventFromGLsyncKHR(long arg0, long arg1, java.nio.IntBuffer arg2)
 *     C function: cl_event clCreateEventFromGLsyncKHR(cl_context, cl_GLsync, cl_int * )
 */
JNIEXPORT jlong JNICALL 
Java_com_jogamp_opencl_llb_impl_CLAbstractImpl_dispatch_1clCreateEventFromGLsyncKHR1__JJLjava_lang_Object_2IZJ(JNIEnv *env, jobject _unused, jlong arg0, jlong arg1, jobject arg2, jint arg2_byte_offset, jboolean arg2_is_nio, jlong procAddress) {
  typedef cl_event (CL_API_CALL*_local_ARG)(cl_context, cl_GLsync, cl_int * );
  _local_ARG ptr_clCreateEventFromGLsyncKHR;
  cl_int * _arg2_ptr = NULL;
  cl_event _res;
  if ( NULL != arg2 ) {
    _arg2_ptr = (cl_int *) ( JNI_TRUE == arg2_is_nio ?  (*env)->GetDirectBufferAddress(env, arg2) :  (*env)->GetPrimitiveArrayCritical(env, arg2, NULL) );  }
  ptr_clCreateEventFromGLsyncKHR = (_local_ARG) (intptr_t) procAddress;
  assert(ptr_clCreateEventFromGLsyncKHR != NULL);
  _res = (cl_event) (* ptr_clCreateEventFromGLsyncKHR) ((cl_context) (intptr_t) arg0, (cl_GLsync) (intptr_t) arg1, (cl_int * ) (((char *) _arg2_ptr) + arg2_byte_offset));
  if ( JNI_FALSE == arg2_is_nio && NULL != arg2 ) {
    (*env)->ReleasePrimitiveArrayCritical(env, arg2, _arg2_ptr, 0);  }
  return (jlong) (intptr_t) _res;
}


